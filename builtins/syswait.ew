--
--  syswait.ew (Phix compatible)
--  ==========
--
--      Phix implementation of system_wait, system_open, system, sysproc, and system_exec.
--DEV document this:
--      system_wait is functionally identical to system_exec but takes only one parameter
--       and exists (as well as system_exec) for compatibility reasons only.
--      system_open can be used to open documents or web pages, equivalent to double-
--       clicking on a file in Explorer. The executable associated with the extension
--       is automatically located (and in fact cannot be specified).
--      system creates a new shell (%COMSPEC% /C) to run the specified command.
--      sysproc invokes an executable in a no-wait fashion, similar to system, but
--       without creating a new shell (seemingly a bad idea for gui apps...).
--      system_exec must be passed an executable (not dir, mkdir, rename, etc).
--      set_system_doevents() is used with system_exec/wait to allow background
--       processing, event handlers etc to continue while waiting.
--
-- Credit: based heavily on system_wait.ew by Juergen Luethje.
--
-- TODO: The mode parameter of system and system_exec is not currently used.
--       These functions probably deserve to be renamed:
--          system() -> system_command(), with an extra wait/shell option
--          sysproc then becomes, say, system_command(,,NOSHELL+NOWAIT).
--          system_exec() -> system_wait(), possibly also with new option.
--          (meaning we are left with 3 main routines, system_command(),
--           system_open(), and system_wait(), plus set_system_doevents()).
--          doing so would of course break alot of legacy code.

--/* Not required for Phix:
include builtins\dll.e
include builtins\machine.e
--*/
--DEV wrong one for newEmit
--!/**/include builtins\pcfunc.e

constant
    FALSE = 0,
--  TRUE = 1,
    SW_NORMAL = 1,
--  INFINITE = #FFFFFFFF,    -- Infinite timeout
    FORTYMS = 40,            -- Forty milliseconds, 1/25th of a second
--  STARTF_USESHOWWINDOW = 1,
--  STARTF_USESTDHANDLES = 256,
--  STD_OUTPUT_HANDLE   = -11,  -- #FFFFFFF5
--  STD_INPUT_HANDLE    = -10,  -- #FFFFFFF6
--  STD_ERROR_HANDLE    = -12,
    STILL_ACTIVE = 259
--  ,
--  PROCESS_QUERY_INFORMATION=#400
--  CREATE_NEW_CONSOLE=#10
--Public Enum ProcessCreationFlags
--   DEBUG_PROCESS            = &H1
--   DEBUG_ONLY_THIS_PROCESS      = &H2
--   CREATE_SUSPENDED         = &H4
--   DETACHED_PROCESS         = &H8
--   CREATE_NEW_CONSOLE       = &H10
--   NORMAL_PRIORITY_CLASS    = &H20
--   IDLE_PRIORITY_CLASS          = &H40
--   HIGH_PRIORITY_CLASS          = &H80
--   REALTIME_PRIORITY_CLASS      = &H100
--   CREATE_NEW_PROCESS_GROUP   = &H200
--   CREATE_UNICODE_ENVIRONMENT = &H400
--   CREATE_SEPARATE_WOW_VDM      = &H800
--   CREATE_SHARED_WOW_VDM    = &H1000
--   CREATE_FORCEDOS              = &H2000
--   CREATE_DEFAULT_ERROR_MODE  = &H4000000
--   CREATE_NO_WINDOW         = &H8000000
--End Enum

constant    -- TYPE STARTUPINFO
--  cb              =  0,   -- DWORD        -- size in bytes
--  lpReserved      =  4,   -- ASCIIZ PTR
--  lpDesktop       =  8,   -- ASCIIZ PTR
--  lpTitle         = 12,   -- ASCIIZ PTR
--  dwX             = 16,   -- DWORD
--  dwY             = 20,   -- DWORD
--  dwXSize         = 24,   -- DWORD
--  dwYSize         = 28,   -- DWORD
--  dwXCountChars   = 32,   -- DWORD
--  dwYCountChars   = 36,   -- DWORD
--  dwFillAttribute = 40,   -- DWORD
--  dwFlags         = 44,   -- DWORD
--  wShowWindow     = 48,   -- WORD
--  cbReserved2     = 50,   -- WORD
--  lpReserved2     = 52,   -- BYTE PTR
--  hStdInput       = 56,   -- DWORD
--  hStdOutput      = 60,   -- DWORD
--  hStdError       = 64,   -- DWORD
SIZEOF_STARTUPINFO = 68


constant    -- TYPE PROCESS_INFORMATION
    hProcess    =  0,   -- DWORD
--  hThread     =  4,   -- DWORD
--  dwProcessId =  8,   -- DWORD
--  dwThreadId  = 12,   -- DWORD
SIZEOF_PROCESS_INFORMATION = 16

integer swinit swinit = 0
atom kernel32,xCreateProcess,xWaitForSingleObject,xGetExitCodeProcess,
--   xGetProcessTimes,lpCreationTime,lpExitTime,lpKernelTime,lpUserTime,
--   xGetStdHandle,xCloseHandle,xGetLastError,
     shell32, xShellExecute
--   user32, xWaitForInputIdle,
--/*
     xOpen,
--*/

procedure initsw()
--DEV locking as per pprntf
    kernel32 = open_dll("kernel32.dll")

--#without reformat
    xCreateProcess = define_c_func(kernel32, "CreateProcessA",
        {C_POINTER, --  LPCTSTR lpApplicationName, // pointer to name of executable module
         C_POINTER, --  LPTSTR lpCommandLine, // pointer to command line string
         C_POINTER, --  LPSECURITY_ATTRIBUTES lpProcessAttributes, // pointer to process security attributes
         C_POINTER, --  LPSECURITY_ATTRIBUTES   lpThreadAttributes, // pointer to thread security attributes
         C_LONG,    --  BOOL  bInheritHandles, // handle inheritance flag 
         C_ULONG,   --  DWORD   dwCreationFlags, // creation flags
         C_POINTER, --  LPVOID lpEnvironment, // pointer to new environment block
         C_POINTER, --  LPCTSTR  lpCurrentDirectory, // pointer to current directory name
         C_POINTER, --  LPSTARTUPINFO   lpStartupInfo, // pointer to STARTUPINFO
         C_POINTER},--  LPPROCESS_INFORMATION lpProcessInformation // pointer to PROCESS_INFORMATION
        C_LONG)     -- BOOL 

    xWaitForSingleObject = define_c_func(kernel32, "WaitForSingleObject",
        {C_ULONG,   --  HANDLE hObject, // handle of object to wait for
         C_ULONG},  --  DWORD   dwTimeout // time-out interval in milliseconds
        C_ULONG)    -- DWORD -- WAIT_ABANDONED, WAIT_OBJECT_0, or WAIT_TIMEOUT

    xGetExitCodeProcess = define_c_func(kernel32, "GetExitCodeProcess",
        {C_ULONG,   --  HANDLE hProcess, // handle to the process
         C_ULONG},  --  LPDWORD  lpExitCode // address to receive termination status
        C_ULONG)    -- BOOL

--  xGetProcessTimes = define_c_func(kernel32,"GetProcessTimes",
--      {C_POINTER, --  HANDLE  hProcess,   // specifies the process of interest
--       C_POINTER, --  LPFILETIME  lpCreationTime, // when the process was created
--       C_POINTER, --  LPFILETIME  lpExitTime, // when the process exited
--       C_POINTER, --  LPFILETIME  lpKernelTime,   // time the process has spent in kernel mode
--       C_POINTER},--  LPFILETIME  lpUserTime  // time the process has spent in user mode
--      C_LONG)     -- BOOL

--  user32 = open_dll("user32.dll")
--
--  xWaitForInputIdle = define_c_func(user32, "WaitForInputIdle",
--      {C_ULONG,   --  HANDLE hObject, // handle of object to wait for
--       C_ULONG},  --  DWORD   dwTimeout // time-out interval in milliseconds
--      C_LONG)     -- DWORD -- 0, WAIT_TIMEOUT, or 0xFFFFFFFF

    shell32 = open_dll("shell32.dll")

    xShellExecute = define_c_func(shell32, "ShellExecuteA",
        {C_LONG,    --  HWND  hwnd, // handle to parent window
         C_POINTER, --  LPCTSTR  lpOperation,   // pointer to string that specifies operation to perform
         C_POINTER, --  LPCTSTR  lpFile,    // pointer to filename string
         C_POINTER, --  LPTSTR  lpParameters,   // pointer to string that specifies executable-file parameters
         C_POINTER, --  LPCTSTR  lpDirectory,   // pointer to string that specifies default directory
         C_LONG},   --  INT  nShowCmd   // whether file is shown when opened
        C_POINTER)  -- HINSTANCE

--  xGetStdHandle = define_c_func(kernel32,"GetStdHandle",
--      {C_UINT},   --  DWORD  nStdHandle   // input, output, or error device
--      C_INT)      -- HANDLE

--  xCloseHandle = define_c_func(kernel32, "CloseHandle",
--      {C_POINTER},--  HANDLE  hObject // handle of object to close
--      C_LONG)     -- BOOL

--  xGetLastError = define_c_func(kernel32, "GetLastError",
--      {},
--      C_INT)      -- DWORD

--#with reformat

--DEV allocate one block and split by hand? (si/pi/ec as well)

--  lpCreationTime = allocate(8)
--  lpExitTime = allocate(8)
--  lpKernelTime = allocate(8)
--  lpUserTime = allocate(8)

--/*
    xOpen = allocate(5)
    poke(xOpen,"open"&0)
--*/

    swinit = 1
end procedure

integer suinit suinit = 0
atom user32,xChangeDisplaySettings,xBeep

procedure initsu()
--DEV locking as per pprntf
    user32 = open_dll("user32.dll")

--#without reformat

    xChangeDisplaySettings = define_c_func(user32, "xChangeDisplaySettingsW",
        {C_POINTER, --  DEVMODE *lpDevMode, // NULL for default
         C_ULONG},  --  DWORD   dwFlags,    // 0 for default
        C_LONG)     -- LONG

    xBeep = define_c_func(kernel32, "Beep",
        {C_ULONG,   --  DWORD dwFreq
         C_ULONG},  --  DWORD dwDuration
        C_LONG)     -- BOOL

--#with reformat

    suinit = 1
end procedure

integer Wait    -- for system()
        Wait = 1

--atom kutime
--
--global function get_ku_time()
---- valid only after a system_wait call.
--  return kutime
--end function

integer doevents
        doevents = -1
object doeventparams

global procedure set_system_doevents(integer rid, object params)
-- typical setup for win32lib/arwen:
--  set_system_doevents(routine_id("doEvents"),{0})
    doevents = rid
    doeventparams = params
end procedure

global function system_wait(sequence child_process)
-- after:
-- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/creating_processes.asp
-- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/createprocess.asp
-- http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/waitforsingleobject.asp
-- or, if you have win32.hlp configured, lookup (press F1 key on):
--  xCreateProcess, xGetExitCodeProcess, xWaitForSingleObject

--/*    -- only needed for RDS Eu
atom child
--*/
atom ret, void, hProc
--atom stdin, stdout, stderr
--, hThr
--integer doevents
atom si, pi, ec

    si = allocate(SIZEOF_STARTUPINFO)
    mem_set(si,0,SIZEOF_STARTUPINFO)
    poke4(si, SIZEOF_STARTUPINFO)       -- cb
--  poke4(si+dwFlags,or_bits(STARTF_USESTDHANDLES,STARTF_USESHOWWINDOW))

    pi = allocate(SIZEOF_PROCESS_INFORMATION)
    mem_set(pi,0,SIZEOF_PROCESS_INFORMATION)

    if not swinit then initsw() end if

--/*
    child = allocate_string(child_process)
--*/
--DEV clutching at straws here...
--  mem_set(si,0,SIZEOF_STARTUPINFO)
--  poke4(si, SIZEOF_STARTUPINFO)       -- cb
--  mem_set(pi,0,SIZEOF_PROCESS_INFORMATION)

--5/3/10:
--         pCmdLine = allocate_string(CommandLine)
--         pPI = allocate(PROCESS_INFORMATION_SIZE)
--         mem_set(pPI,0,PROCESS_INFORMATION_SIZE)
--         pSUI = allocate(STARTUPINFO_SIZE)
--         mem_set(pSUI,0,STARTUPINFO_SIZE)
--         poke4(pSUI,STARTUPINFO_SIZE)
--         poke4(pSUI+SUIdwFlags,or_bits(STARTF_USESTDHANDLES,STARTF_USESHOWWINDOW))
--         poke4(pSUI+SUIhStdInput,StdHandles)
--         fnVal = c_func(iCreateProcess,{0,pCmdLine,0,0,1,0,0,0,pSUI,pPI})

--if 0 then
--  stdin = c_func(xGetStdHandle,{STD_INPUT_HANDLE})
--  stdout = c_func(xGetStdHandle,{STD_OUTPUT_HANDLE})
--  stderr = c_func(xGetStdHandle,{STD_ERROR_HANDLE})
--  poke4(si+hStdInput,stdin)
--  poke4(si+hStdOutput,stdout)
--  poke4(si+hStdError,stderr)
--end if

    -- Start the child process.
    ret = c_func(xCreateProcess,
                 {NULL,     -- No module name (use command line).
--/**/            child_process,                --/*    -- Phix
                  child,    -- Command line.    --*/    -- RDS Eu
                  NULL,     -- Process handle not inheritable.
--instance(),
                  NULL,     -- Thread handle not inheritable.
                  FALSE,    -- Set handle inheritance to FALSE.
--1,--TRUE,
--                PROCESS_QUERY_INFORMATION,        -- No creation flags.
                  NULL,
--#10,
--#4000208,
--#8000210,
--Public Enum ProcessCreationFlags
--   DEBUG_PROCESS            = &H1
--   DEBUG_ONLY_THIS_PROCESS      = &H2
--   CREATE_SUSPENDED         = &H4
--   DETACHED_PROCESS         = &H8
--   CREATE_NEW_CONSOLE       = &H10
--   NORMAL_PRIORITY_CLASS    = &H20
--   IDLE_PRIORITY_CLASS          = &H40
--   HIGH_PRIORITY_CLASS          = &H80
--   REALTIME_PRIORITY_CLASS      = &H100
--   CREATE_NEW_PROCESS_GROUP   = &H200
--   CREATE_UNICODE_ENVIRONMENT = &H400
--   CREATE_SEPARATE_WOW_VDM      = &H800
--   CREATE_SHARED_WOW_VDM    = &H1000
--   CREATE_FORCEDOS              = &H2000
--   CREATE_DEFAULT_ERROR_MODE  = &H4000000
--   CREATE_NO_WINDOW         = &H8000000

                  NULL,     -- Use parent's environment block.
                  NULL,     -- Use parent's starting directory.
                  si,       -- Pointer to STARTUPINFO structure.
                  pi})      -- Pointer to PROCESS_INFORMATION structure.
    if ret=0 then
--      kutime = c_func(xGetLastError,{})
        free(si)
        free(pi)
--/*
        free(child)
--*/
        return -1       -- error
    end if
--printf(1,"system_wait: ret is %d\n",ret)

--/*
    free(child)
--*/
--  if not Wait then return 0 end if
    ret = 0

--  if Wait then
    hProc = peek4u(pi+hProcess)
--      hThr  = peek4u(pi+hThread)

--  void = c_func(xWaitForInputIdle,{hProc,INFINITE})
--  void = c_func(xWaitForInputIdle,{hProc,FORTYMS})

--  if Wait then

        -- Wait until child process exits.
--      ret = c_func(xWaitForSingleObject, {hProc, INFINITE})
--      ec=allocate(4)
--      doevents=routine_id("doEvents") -- if available
    ec = allocate(4)

    while 1 do
        void = c_func(xGetExitCodeProcess, {hProc, ec})
        ret = peek4u(ec)
        if ret!=STILL_ACTIVE then exit end if
        if doevents!=-1 then call_proc(doevents,doeventparams) end if
        void = c_func(xWaitForSingleObject, {hProc, FORTYMS})
        if Wait<0 then Wait += 1 end if
        if Wait=0 then exit end if
    end while
    free(ec)
    free(si)
    free(pi)
--      if not c_func(xGetProcessTimes,{hProc,lpCreationTime,lpExitTime,lpKernelTime,lpUserTime}) then
--          kutime = -c_func(xGetLastError,{})
--      else
--          kutime = peek4s(lpKernelTime+4)*(#100000000/1000000000)+peek4u(lpKernelTime)/1000000000
--                 + peek4s(lpUserTime+4)*(#100000000/1000000000)+peek4u(lpUserTime)/1000000000
--      end if
--  end if

        -- Close process and thread handles.
--      void = c_func(xCloseHandle, {hProc})
--      void = c_func(xCloseHandle, {hThr})
--  end if

--  free(si)
--  free(pi)
--  if not Wait then return 0 end if
    return ret
end function
------------------------------------------------------------------------

global function system_open(sequence filename)
-- as shellExecute(0,"open",file,0,0,SW_NORMAL)
--/**/  if not swinit then initsw() end if                              --\* Phix
--/**/  return c_func(xShellExecute,{0,"open",filename,0,0,SW_NORMAL})  --/* Phix
atom lpFile
integer len, res
        if not swinit then initsw() end if
        len = length(filename)
        lpFile = allocate(len+1)
        poke(lpFile,filename)
        poke(lpFile+len,0)
        res = c_func(xShellExecute,{0,xOpen,lpFile,0,0,SW_NORMAL})
        free( lpFile )
        return res                                                      --  RDS */
end function

procedure restore(integer mode)
    if not suinit then initsu() end if
    if mode=1 then
        if c_func(xBeep,{750,300}) then
            if getc(0) then end if
        end if
    end if
    if c_func(xChangeDisplaySettings,{NULL,0}) then end if
end procedure

--/*
without warning
--*/
--/**/global procedure system(sequence s, integer mode=2)
--/*
global procedure system(sequence s, integer mode)
--*/
--
-- Invoke the specified shell command.
-- Uses %COMSPEC% /C, which means it has the same features (redirection, wildcards, etc) 
--  and is subject to the same limitations (eg it was 126 chars on Win98, but has grown 
--  to 8000 chars on Win7) as manually using an MS-DOS console window.
-- NOTE: Specifying a windows GUI app appears to hang the console, no idea
--  why. If that happens try using sysproc.
-- NOTE2: mode is a bit of a legacy feature and not guaranteed to work exactly as per
--        the documentation. The default value of 2 ("do nothing") should suffice.
--
integer r
    Wait = -10                          -- Max 10 iterations (0.4s)
    s = getenv("COMSPEC")&" /C "&s
    r = system_wait(s)
    Wait = 1
    if mode!=2 then restore(mode) end if
end procedure

global procedure sysproc(sequence s)
--
-- Similar to system(), except that %COMSPEC% /C is NOT used (which means no
--  redirection, etc). Strongly recommended for running windows GUI apps.
--
integer r
    Wait = -10
    r = system_wait(s)
    Wait = 1
end procedure

--/**/global function system_exec(sequence s, integer mode=2)
--/*
global function system_exec(sequence s, integer mode)
--*/
integer res -- exit code or -1 on failure
    res = system_wait(s)
    if mode!=2 then restore(mode) end if
    return res
end function

global function sysexec(sequence s)
--
-- Similar to system_exec(), except that %COMSPEC% /C is used.
--
integer res -- exit code or -1 on failure
    s = getenv("COMSPEC")&" /C "&s
    res = system_wait(s)
    return res
end function

