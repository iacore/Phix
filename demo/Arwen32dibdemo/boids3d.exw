DEAD (never got going, see ..\arwendemo)
--
-- boids3d.exw
-- ===========
--
-- IN PROGRESS.
--  Needs:  upDown controls/setScrollRange [done]
--          get StaticBitmaps working [erm, see polydib.exw]    [erm, see scroller.exw]
--          drawLines [done]
--          setTimer/copyBlt/drawPolygon
--          getNumber [see getInteger]
--          setPenColor? [done?]
--          display_proc/on_timer/values_change/win_paint
--
with trace
--without warning
--include win32lib.ew
include arwen.ew
include axtra.ew
include boids3d.e as boids
--include boids3d.e

include a32dcore.ew  -- only the core-library is necessary

constant wstyle = or_all({WS_BORDER,
                          WS_DLGFRAME,
                          WS_SYSMENU,
                          WS_MINIMIZEBOX,
                          WS_MAXIMIZEBOX}),
        win = create(Window, "Boids 3D", 0, 0, 20, 20, 625, 690, wstyle),
--DEV:
--blank_pix = create( Pixmap, "", win, 0, 0, 600, 600, 0 ),
--pix = create( Pixmap, "", win, 0, 0, 600, 600, 0 ),
--bmp = create( Bitmap, "", win, 10, 10, 600, 600, 0 ),                 -- screen_dib
blank_pix = create(StaticBitmap, "", 0, win, 0, 0, 60, 600, 0),
pix = create(StaticBitmap, "", 0, win, 0, 0, 60, 600, 0),
bmp = create(StaticBitmap, "", 0, win, 10, 10, 60, 600, 0),
        restart = create(Button, "Restart", 0, win, 10, 625, 70, 25, 0),
        spd = create(Label, "Max Speed", 0, win, 90, 610, 70, 15, 0),
        max_speed = create(EditText, "15", 0, win, 90, 625, 60, 25, ES_NUMBER),
        ud_style = or_all({UDS_AUTOBUDDY,UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS}),
        max_ud = create(UpDown, "", 0, win, 0, 0, 0, 0, ud_style),

        dist_label = create(Label, "Separation", 0, win, 155, 610, 60, 15, 0),
        dist_edit = create(EditText, "30", 0, win, 155, 625, 60, 25, ES_NUMBER),
        dist_ud = create(UpDown, "", 0, win, 0, 0, 0, 0, ud_style),

        nd_label = create(Label, "Neighbor Radius", 0, win, 220, 610, 80, 15, 0),
        n_dist = create(EditText, "100", 0, win, 220, 625, 80, 25, ES_NUMBER),
        n_ud = create(UpDown, "", 0, win, 0, 0, 0, 0, ud_style),

        boids_label = create(Label, "Boids", 0, win, 305, 610, 60, 15, 0),
        nboids = create(EditText, "100", 0, win, 305, 625, 60, 25, ES_NUMBER),
        boids_ud = create(UpDown, "", 0, win, 0, 0, 0, 0, ud_style),

        shadow_check = create(CheckBox, "Draw Shadows", 0, win, 493, 625, 90, 25, 0)


--constant
--observer = {300, 300, 1200}
sequence observer
procedure set_observer()
    observer = {floor(X_MAX/2),floor(Y_MAX/2),Z_MAX*2}
end procedure
set_observer()


sequence colors, world_points
colors = {}
world_points = {{0,0,0}, {600,0,0}, {0,600,0}, {0,0,600}}

integer draw_shadows

function project_point(sequence pt)
atom d

        if pt[3]=observer[3] then
            d = 0.0001
        else

            d =  1-pt[3]/(pt[3]-observer[3])
        end if

        pt[1] = observer[1]+(observer[1]-pt[1])/d
        pt[2] = observer[2]+(observer[2]-pt[2])/d

        pt = sq_floor(pt[1..2])

        return pt[1..2]

end function

--DEV 
--without warning
--procedure drawLines(integer id, sequence s)
--  if id or sequence(s) then end if
--end procedure
procedure setTimer(integer win, integer id, integer dt)
    if win or id or dt then end if
end procedure
procedure copyBlt(integer src, integer x, integer y, integer dest)
    if src or x or y or dest then end if
end procedure
procedure drawPolygon(integer id, integer filled, sequence points)
    if id or filled or sequence(points) then end if
end procedure
--function getNumber(integer id)
--  return id
--end function
--with warning

--procedure project_world()
----sequence pt
--atom x1, x2, z1, z2, y1, y2
---- draw a blank rectangle on the pixmap
----    setPenColor( blank_pix, White )
--  setPenColor(White)
--  drawRectangle(blank_pix, True, 0, 0, 600, 600)
--
----    setPenColor( blank_pix, #909090 )
--  setPenColor(#909090)
--  drawRectangle(blank_pix, False, 0, 0, 600, 600)
--
--
----    setPenColor( blank_pix, Black )
--  setPenColor(Black)
--  x1 = X_MIN -- 100
--  x2 = X_MAX --+ 100
--  z1 = Z_MIN -- 100
--  z2 = Z_MAX --+ 100
--  y1 = 0.0
--  y2 = Y_MAX
--
--
--  for z=z1+100 to z2-100 by 100 do
--      drawLines(blank_pix, {
--                            #808080,
--                            project_point({x2, y2, z}) &
--                            project_point({x2, y1, z}),
--                            project_point({x1, y1, z}),
--                            project_point({x1, y2, z}),
--                            #FFFFFF,
--                            project_point({x1, y2, z}) &
--                            project_point({x2, y2, z})
--
--                           })
--
--  end for
--
--  for y=y1+100 to y2-100 by 100 do
--      drawLines(blank_pix, {
--                            #808080,
--                            project_point({x1,y,z1}) &
--                            project_point({x1,y,z2}),
--                            project_point({x2,y,z2}),
--                            project_point({x2,y,z1})})
--  end for
--
--  for x=x1+100 to x2-100 by 100 do
--      drawLines(blank_pix, {
--                            #808080,
--                            project_point({x,y2,z2}) &
--                            project_point({x,y1,z2}),
--                            project_point({x,y1,z1}),
--                            #FFFFFF,
--                            project_point({x,y2,z1}) &
--                            project_point({x,y2,z2})
--                           })
--  end for
--
--  drawLines(blank_pix, {
--                        Black,
--                        project_point({x1, y1, z2}) &
--                        project_point({x2, y1, z2}),
--                        project_point({x2, y2, z2}),
--                        project_point({x1, y2, z2}),
--                        project_point({x1, y1, z2}),
--
--                        project_point({x1, y1, z1}) &
--                        project_point({x1, y1, z2}),
--
--                        project_point({x2, y1, z1}) &
--                        project_point({x2, y1, z2}),
--
--                        project_point({x2, y2, z1}) &
--                        project_point({x2, y2, z2}),
--
--                        project_point({x1, y2, z1}) &
--                        project_point({x1, y2, z2})
--
--                       })
--
--end procedure

object world_dib = 0

procedure project_world2(integer w, integer h)
atom hDC, hBitMap
--sequence pt
atom x1, x2, z1, z2, y1, y2

    hDC = c_func(xCreateCompatibleDC, {NULL})
    hBitMap = createCompatibleBitmap(win, w, h)
    void = selectObject(hDC,hBitMap)

    -- clear the background
--  setPenColor(BrightWhite)    -- dunno why this does not work...
--?{BrightWhite,White}
--  setPenColor(White)      --- .. yet thisis fine
    setPenColor(Parchment)  -- also fine...
--  setPenColor(Green)
    drawRectangleh(hDC, True, 0, 0, w, h)

    -- draw an outer box
    setPenColor(#909090)
    drawRectangleh(hDC, False, 0, 0, w, h)


--  setPenColor( blank_pix, Black )
--  setPenColor(Black)
--setText(win,sprintf("XMIN=%d,XMAX=%d,YMIN=%d,YMAX=%d,ZMIN=%d,ZMAX=%d",{X_MIN,X_MAX,Y_MIN,Y_MAX,Z_MIN,Z_MAX}))
    x1 = X_MIN -- 100
    x2 = X_MAX --+ 100
    z1 = Z_MIN -- 100
    z2 = Z_MAX --+ 100
    y1 = 0.0
    y2 = Y_MAX

--DEV this is good enough for now, but could be improved (either fixed N or N=floor((?-?)/100), then 1/Nth, 2/Nths, etc)
--  - would be good for middle line to /always/ be perfectly vertical/horizontal (or equally aside), which may well
--    occur naturally from the above suggested approach anyway.

    -- draw the verticals on the sides and horizontals on the floor and ceiling
    for z=z1+100 to z2-100 by 100 do
        drawLinesh(hDC, {#808080,
                         project_point({x2, y2, z}) & project_point({x2, y1, z}),
                         project_point({x1, y1, z}),
                         project_point({x1, y2, z}),
                         #FFFFFF,
                         project_point({x1, y2, z}) & project_point({x2, y2, z})
                        })

    end for

    -- draw the horizontals on the back and the not-quite horizontals on the sides
    for y=y1+100 to y2-100 by 100 do
        drawLinesh(hDC, {#808080,
                         project_point({x1,y,z1}) & project_point({x1,y,z2}),
                         project_point({x2,y,z2}),
                         project_point({x2,y,z1})
                        })
    end for

    -- draw the verticals on the back and the not-quite-verticals on floor/ceiling
    for x=x1+100 to x2-100 by 100 do
        drawLinesh(hDC, {#808080,
                         project_point({x,y2,z2}) & project_point({x,y1,z2}),
                         project_point({x,y1,z1}),
                         #FFFFFF,
                         project_point({x,y2,z1}) & project_point({x,y2,z2})
                        })
    end for

    -- draw the minimal room outline (DEV easier above??)
    drawLinesh(hDC, {Black,
                     project_point({x1, y1, z2}) & project_point({x2, y1, z2}),
                     project_point({x2, y2, z2}),
                     project_point({x1, y2, z2}),
                     project_point({x1, y1, z2}),
                     project_point({x1, y1, z1}) & project_point({x1, y1, z2}),
                     project_point({x2, y1, z1}) & project_point({x2, y1, z2}),
                     project_point({x2, y2, z1}) & project_point({x2, y2, z2}),
                     project_point({x1, y2, z1}) & project_point({x1, y2, z2})
                    })

    copyToDib2(world_dib, hDC, 0, 0, 0, 0, w, h)
    void = c_func(xDeleteObject,{hBitMap})
    void = c_func(xDeleteObject,{hDC})
end procedure

--procedure display_proc(integer self, atom event, sequence params)
--integer dt
--if self or event or sequence(params) then end if
--  boids:setup()
----    project_world()
--
--  dt = floor(1000.0/30.0)
--
--  colors = {}
--  setTimer(win, 1, dt)
--end procedure
--setHandler( win, w32HActivate, routine_id("display_proc"))
--setHandler( restart, w32HClick, routine_id("display_proc"))

constant null_u = {0,0}
function get_ortho(sequence v)
sequence y, yhat, z, u

    u = v[1..2]
    if equal(u, null_u) then
        return {1,1,0}
    end if
    y = {1,1}
    yhat = sq_div(dot(u,y),sq_mul(dot(u,u),u))
    z = sq_sub(y,yhat)
    if equal(z, null_u) then
        return {1,1,0}
    end if
    return z & 0
end function

procedure on_timer()--integer self, atom event, sequence params)
sequence in,boid, pt, v, verts, v1, v2, v3, sv
--atom d
--integer r, x, y
--if self or event or sequence(params) then end if

    move_boids()

    in = boidsnp1

    -- draw a blank rectangle on the pixmap
    copyBlt(pix, 0, 0, blank_pix)

    if not length(colors) then
        colors = repeat(0, BOIDS)
        for i=1 to BOIDS do
            colors[i] = rand(#FFFFFF)
        end for

    end if


    -- convert boid location and velocities into
    -- triangles in 3D and project them onto
    -- the screen
    verts = repeat("", BOIDS)
    for i=1 to BOIDS do

        boid = in[i]

        pt = boid[B_X..B_Z]
        v = boid[B_XV..B_ZV]

        if equal(v,{0,0,0}) then
            v = {1,0,1}
        end if

        -- the 'nose' of the boid
        v1 = sq_add(pt,make_length(v, 20))

        -- make the base of the triangle
        sv = make_length(get_ortho(v), 4)
        v2 = sq_add(pt,sv)
        v3 = sq_sub(pt,sv)

        verts[i] = {distance3(pt, observer), v1, v2, v3, i, v1, v2, v3}

        -- project the 3D points onto a 2D viewing surface
        for j=2 to 4 do
            verts[i][j] = project_point(verts[i][j])
        end for
        if draw_shadows then
            for j=6 to 8 do
                pt = verts[i][j]
                pt[2] = 0.0
                verts[i][j] = project_point(pt)
            end for
        end if

    end for

    -- this sorts by distance, so nearer boids will
    -- clip boids that are more distant     
    verts = sort(verts)

    if draw_shadows then
--      setPenColor( pix, #A0A0A0 )
        setPenColor(#A0A0A0)
        for i=1 to BOIDS do
            drawPolygon(pix, True, verts[i][6..8])
        end for
    end if

    -- draw the boids as polygons, starting with the 
    -- farthest from the POV
    for i=BOIDS to 1 by -1 do
        v = verts[i]
--      setPenColor( pix, colors[v[5]] )
        setPenColor(colors[v[5]])
        drawPolygon(pix, True, v[2..4])
    end for

    copyBlt(bmp, 0, 0, pix)

end procedure
--setHandler( win, w32HTimer, routine_id("on_timer"))

--          c = getInteger(getText(twid))
function getInteger(sequence numstr)
--
-- Return the (positive) integer value of a string.
-- "" is treated as 0. {} is returned on error.
--
atom n
integer ch
    n=0
    for i=1 to length(numstr) do
        ch=numstr[i]-'0'
        if ch<0 or ch>9 then return {} end if
        n=n*10+ch
        if not integer(n) then return {} end if
    end for
    return n
end function


-- the user interface 
--procedure values_change(integer self, atom event, sequence params)
--integer num
--sequence boid
--if sequence(params) or event then end if
--  num = getNumber(self)*1.0
--  if self=max_speed then
--      -- let the boids go faster
--      V_MAX = num
--
--  elsif self=n_dist then
--      -- this alters how far out the boids look 
--      -- for other boids to change velocities
--      N_DIST = num
--
--  elsif self=nboids then
--      -- change the number of boids
--      boid = repeat(0, B_ELEMENTS)
--      if num>BOIDS then
--          for i=BOIDS+1 to num do
--              boid[B_X] = rand(X_MAX)
--              boid[B_Y] = rand(Y_MAX)
--              boid[B_Z] = rand(Z_MAX)
--
--              boid[B_XV] = floor(V_MAX/2)-rand(V_MAX)
--              boid[B_YV] = floor(V_MAX/2)-rand(V_MAX)
--              boid[B_ZV] = floor(V_MAX/2)-rand(V_MAX)
--              boidsnp1 = append(boidsnp1, boid)
--              colors &= rand(#FFFFFF)
--          end for
--          boidsn = boidsnp1
--      end if
--      BOIDS = num
--  elsif self=shadow_check then
--      draw_shadows = isChecked(shadow_check)
--
--  end if
--end procedure
--setHandler( {max_speed,n_dist, nboids}, w32HChange, routine_id("values_change"))
--setHandler( shadow_check, w32HClick, routine_id("values_change"))

--procedure win_paint(integer self, atom event, sequence params)
--  copyBlt(bmp, 0, 0, pix)
--end procedure
--setHandler( win, w32HPaint, routine_id("win_paint"))

include a32dpoly.ew  -- only the polygon- and core-library are necessary

--object screen_dib = 0, world_dib = 0
object screen_dib = 0
integer dx, dy, dw, dh, frames
atom t

dx = 0  dy = 0  dw = 0  dh = 0

--constant win = create(Window, "Arwen32Dib bitmap shaded polygon demo", 0, 0, Default, Default, 480, 300, 0)

constant trans_color = {255, 255, 255}

procedure IdleHandler()
integer w, h
--integer x1, y1, x2, y2, x3, y3, x4, y4
--  x1 = rand(dx)           y1 = rand(dy)
--  x2 = dw-rand(dx)        y2 = rand(dy)
--  x3 = dw-rand(dx)        y3 = dh-rand(dy)
--  x4 = rand(dx)           y4 = dh-rand(dy)
    if sequence(screen_dib) then
--      clearDib(screen_dib, {255, 255, 0})
        w = screen_dib[DibWidth]-1
        h = screen_dib[DibHeight]-1
        drawDibToDib(screen_dib, world_dib, 0, 0, 0, 0, w, h, trans_color, 255)

--      drawShadedPolygonToDib(screen_dib, {{x1, y1}, {x2, y2}, {x3, y3}, {x4, y4}}, {{0, 0, 255}, {0, 255, 0}, {255, 0, 0}, {255, 255, 255}})
--      drawShadedPolygonToDib(screen_dib, {{x1, y1}, {x2, y2}, {x3, y3}}, {{0, 0, 255}, {0, 255, 0}, {255, 0, 0}})
--      drawShadedPolygonToDib(screen_dib, {{x1, y1}, {x2, y2}, {(x3+x4)/2, (y3+y4)/2}}, {{0, 0, 255}, {0, 255, 0}, {255, 0, 0}})
--      drawShadedPolygonToDib(screen_dib, {{(x1+x2)/2, (y1+y2)/2}, {(x2+x3)/2, (y2+y3)/2}, {(x3+x4)/2, (y3+y4)/2}, {(x4+x1)/2, (y4+y1)/2}}, {{0, 0, 255}, {0, 255, 0}, {255, 0, 0}, {255, 255, 255}})
--      sleep(1)
    end if
--  frames += 1
--  if time()-t>2 then
--      setText(win, sprintf("%g FPS", frames/2))
--      frames = 0
--      t = time()
--  end if
    repaintWindow(win,False)
end procedure
--setHandler(IDLE, routine_id("IdleHandler"))

integer firsttime = 1
integer eraseRqd = 1

function winHandler(integer id, integer msg, atom wParam, object lParam)
integer w, h, num
integer dt
--sequence rect
--sequence boid
    if object(lParam) then end if -- suppress warnings
    if id=win then
        if msg=WM_PAINT then
            if sequence(screen_dib) then
                w = screen_dib[DibWidth]-1
                h = screen_dib[DibHeight]-1
                drawDib(win, screen_dib, 0, 0, 0, 0, w, h)
            end if
        elsif msg=WM_SIZE then
            {{},{},dw,dh} = getClientRect(win)
--          rect = getClientRect(win)
--          {{},{},dw,dh} = rect
            dh -= 45
            dx = floor(dw/4)+1
            dy = floor(dh/4)+1
            X_MAX = dw
            Y_MAX = dh
            Z_MAX = floor((dw+dh)/2)
            set_observer()
            if sequence(world_dib) then killDib(world_dib) end if
            world_dib = newDib(dw, dh)
            project_world2(dw,dh)
            if sequence(screen_dib) then killDib(screen_dib) end if
            screen_dib = newDib(dw, dh)
            IdleHandler()
--DEV for WM_ERASEBKGND:
--          firsttime = 1
            eraseRqd = 10
        elsif msg=WM_ERASEBKGND then -- suppress the erasing of the background: eliminates flickering
--if not firsttime and not eraseRqd then
--if not firsttime then
if eraseRqd=0 then
            return {1}
end if
--firsttime = 0 -- nope!
eraseRqd -=1
        elsif msg=WM_TIMER then
            --DEV
--          IdleHandler()
            on_timer()
        elsif firsttime
          and msg=WM_SHOWWINDOW then
            firsttime = 0
            boids:setup()
            dt = floor(1000.0/30.0)
            colors = {}
--DEV
            setTimer(win, 1, dt)
            t = time()
            frames = 0
--          startIdle(40)
        end if
    end if
    if msg=WM_CHAR 
    and wParam=VK_ESCAPE then
        closeWindow(win)
    elsif msg = WM_COMMAND then

        if id=max_speed then
            -- let the boids go faster
            V_MAX = getInteger(getText(max_speed))

        elsif id=n_dist then
            -- this alters how far out the boids look 
            -- for other boids to change velocities
            N_DIST = getInteger(getText(n_dist))

        elsif id=nboids then
            -- change the number of boids
            num = getInteger(getText(nboids))
            sequence boid = repeat(0, B_ELEMENTS)
            if num>BOIDS then
                for i=BOIDS+1 to num do
                    boid[B_X] = rand(X_MAX)
                    boid[B_Y] = rand(Y_MAX)
                    boid[B_Z] = rand(Z_MAX)

                    boid[B_XV] = floor(V_MAX/2)-rand(V_MAX)
                    boid[B_YV] = floor(V_MAX/2)-rand(V_MAX)
                    boid[B_ZV] = floor(V_MAX/2)-rand(V_MAX)
                    boidsnp1 = append(boidsnp1, boid)
                    colors &= rand(#FFFFFF)
                end for
                boidsn = boidsnp1
            end if
            BOIDS = num

        elsif id=shadow_check then
            draw_shadows = isChecked(shadow_check)
        end if

    end if
    return 0
end function
setHandler({win,restart,
            spd,        max_speed,  max_ud,
            dist_label, dist_edit,  dist_ud,
            nd_label,   n_dist,     n_ud,
            boids_label,nboids,     boids_ud,
            shadow_check}, routine_id("winHandler"))

procedure main()

    setScrollInfo(max_ud,{1,100},1)
    setText(max_speed, sprint(V_MAX))

    setScrollInfo(n_ud,{10,600},1)
    setText(n_dist, sprint(N_DIST))

    setScrollInfo(boids_ud,{0,200},1)
    setText(nboids, sprint(BOIDS))

    setScrollInfo(dist_ud,{0,200},1)
    setText(dist_edit, sprint(DIST))

    draw_shadows = 1
    setCheck(shadow_check, draw_shadows)

    WinMain(win, SW_NORMAL)
end procedure
main()

