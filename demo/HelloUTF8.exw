--
-- HelloUTF8.exw
--
--  Demonstrates Phix compiling a UTF8 source (for this be such a beast) and 
--  invoking WideString Windows API routines instead of the AnsiString ones.
--
--  At the moment, libraries such as arwen and win32lib are ansi-only, but this
--  shows it ought not necessarily be particularly difficult to craft a fully
--  Unicode (UTF8) compliant version of them (which would work seamlessly even
--  if all your project sources were still ansi text files). Which is not the
--  same as claiming it would be a quick, short, interesting, or trivial task.
--
--  Edita (0.3.6+) now lets you edit and create UTF8 files, look on the open
--  and save file dialog for the "Encoding" dropdown. Mind you, I say arwen 
--  is ansi-only, but Edita manages fairly well, at least where it matters,
--  though not necessarily on the menus, config files, etc.
--

integer xMessageBoxW, 
        xGetActiveWindow,
        xMultiByteToWideChar

integer initX = 0

constant CP_UTF8 = 65001

procedure Xinit()
atom user32, kernel32
    user32 = open_dll("user32.dll")
    kernel32 = open_dll("kernel32.dll")
--#without reformat
    xMessageBoxW = define_c_func(user32, "MessageBoxW",
        {C_POINTER, --  HWND     hWnd,      // handle of owner window
         C_POINTER, --  LPCTSTR  lpText,    // address of text in message box
         C_POINTER, --  LPCTSTR  lpCaption, // address of title of message box
         C_INT},    --  UINT     uType      // style of message box
        C_INT)      -- int 
    if xMessageBoxW=-1 then ?9/0 end if
    xGetActiveWindow = define_c_func(user32, "GetActiveWindow",
        {},
        C_LONG)     -- HWND
    if xGetActiveWindow=-1 then ?9/0 end if
    xMultiByteToWideChar = define_c_func(kernel32,"MultiByteToWideChar",
        {C_INT,     --  UINT    CodePage,       // code page 
         C_INT,     --  DWORD   dwFlags,        // character-type options 
         C_POINTER, --  LPCSTR  lpMultiByteStr, // address of string to map 
         C_INT,     --  int     cchMultiByte,   // number of characters in string 
         C_POINTER, --  LPWSTR  lpWideCharStr,  // address of wide-character buffer 
         C_INT},    --  int     cchWideChar     // size of buffer 
        C_INT)      -- int
    if xMultiByteToWideChar=-1 then ?9/0 end if 
--#with reformat
    initX = 1
end procedure

function WideString(string s)
--
-- Convert the input UTF8 string to WideChar. 
-- The calling routine must free() the result.
--
integer nLen    -- length of UTF8 input, in bytes, plus 1 for the trailing null byte
integer wLen    -- length of WideChar output, in WideChars, plus 1 for a trailing null word
atom pRes
    nLen = length(s)+1
    wLen = c_func(xMultiByteToWideChar,{CP_UTF8,0,s,nLen,NULL,0})+1
    pRes = allocate(wLen*2)
    wLen = c_func(xMultiByteToWideChar,{CP_UTF8,0,s,nLen,pRes,wLen})
    return pRes
end function

function MessageBoxW(string text, string title, integer style)
atom hWnd
atom pText, pTitle
integer res
    if not initX then Xinit() end if
    hWnd = c_func(xGetActiveWindow, {})
    pText = WideString(text)
    pTitle = WideString(title)
    res = c_func(xMessageBoxW, {hWnd,pText,pTitle,style})
    free(pText)
    free(pTitle)
    return res
end function

--DEV all this should have "if platform()=WINDOWS then" around it...
include builtins\cffi.e
constant 
tCOORD = """
typedef struct _COORD {
  SHORT X;
  SHORT Y;
} COORD, *PCOORD;
""",
tCFI="""
typedef struct _CONSOLE_FONT_INFOEX {
  ULONG cbSize;
  DWORD nFont;
  COORD dwFontSize;
  UINT  FontFamily;
  UINT  FontWeight;
  WCHAR FaceName[LF_FACESIZE];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
""",
tSCOCP = """
BOOL WINAPI SetConsoleOutputCP(
  _In_  UINT wCodePageID
);
""",		   
tSCCFX = """
BOOL WINAPI SetCurrentConsoleFontEx(
  _In_  HANDLE hConsoleOutput,
  _In_  BOOL bMaximumWindow,
  _In_  PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx
);
""",
tGSH = """
HANDLE WINAPI GetStdHandle(
  _In_  DWORD nStdHandle
);
""",
STD_OUTPUT_HANDLE = -11,
idCOORD = define_struct(tCOORD),
idCFI = define_struct(tCFI),
k32 = open_dll("kernel32.dll"),
xSetConsoleOutputCP = define_cffi_func(k32,tSCOCP),
xSetCurrentConsoleFontEx = define_cffi_func(k32,tSCCFX),
xGetStdHandle = define_cffi_func(k32,tGSH),
pCFI = allocate_struct(idCFI),
$
set_struct_field(idCFI,pCFI,"cbSize",get_struct_size(idCFI))
set_struct_field(idCFI,pCFI,"nFont",12)
set_struct_field(idCFI,pCFI,"dwFontSize.X",11)
set_struct_field(idCFI,pCFI,"dwFontSize.Y",18)
set_struct_field(idCFI,pCFI,"FontFamily",54)
set_struct_field(idCFI,pCFI,"FontWeight",400)
--set_struct_field(idCFI,pCFI,"FaceName","Lucida Console")
constant {name_offset} = get_field_details(idCFI,"FaceName")
--poke2(pCFI+name_offset,"Lucida Console\0")
poke2(pCFI+name_offset,"Consolas\0")

puts(1,"")  -- force console to exist
atom hConsole = c_func(xGetStdHandle,{STD_OUTPUT_HANDLE})
{} = c_func(xSetCurrentConsoleFontEx,{hConsole,FALSE,pCFI})
-- the following is equivalent to running "chcp 65001":
{} = c_func(xSetConsoleOutputCP,{CP_UTF8})

puts(1,"├─│└ ─│ ┄ ┆ ┌ ┐ └ ┘ ├ ┤ ┬ ┴ ┼ \n")

--puts(1,"日本語") -- not covered...

--note these required hacks to ptok.e and ptree.e to get working (search for rosettacode/unicode)
constant π = 3.14
printf(1,"π=%g\n",{π})
constant √ = "root"
printf(1,"√=%s\n",{√})
constant λ = "lambda"
printf(1,"λ=%s\n",{λ})
constant Σ = "sum"
printf(1,"Σ=%s\n",{Σ})
--printf(1,"\u221B")
--∛
--?"\u2502 "
--? "\u2514\u2500" 
--? "\u251c\u2500"

puts(1,"\u2502\u2514\u2500\u251c\u2500\n")
puts(1,"£\n")

--"as⃝df̅" becomes "f̅ds⃝a", not "̅fd⃝sa". 
--"as\u203Ddf\u0305"
string ctest = "as\u203Ddf\u0305"
puts(1,ctest)

-- this might have a place in builtins/unicode.e, or perhaps not...
function unicode_reverse(string utf8)
sequence utf32 = utf8_to_utf32(utf8)
integer ch
    --
    -- The assumption is made that <char><comb1><comb2>
    -- and <char><comb2><comb1> would work the same.
    -- Of course <char> must be first, so this loop
    -- converts <ch><c1..cN> to <c1..cN><ch>, and the
    -- following reverse() makes that <ch><cN..c1>.
    -- (where c1..cN are >=1 combining characters)
    --
    for i=1 to length(utf32) do
        ch = utf32[i]
        if (ch>=0x300 and ch<=0x36f)
        or (ch>=0x1dc0 and ch<=0x1dff)
        or (ch>=0x20d0 and ch<=0x20ff)
        or (ch>=0xfe20 and ch<=0xfe2f) then
            utf32[i] = utf32[i-1]
            utf32[i-1] = ch
        end if
    end for
    utf32 = reverse(utf32)
    utf8 = utf32_to_utf8(utf32)
    return utf8
end function
--ctest = reverse(ctest)
string rtest = unicode_reverse(ctest)
puts(1,rtest)


    {} = MessageBoxW("Hello 水 test of MessageBoxW\n"&ctest&" <==> "&rtest, "Unicode 水 test", MB_OK)
--str := "日本語"
-- (I have no idea what 水 might mean, just t'first thing I found on t'internet)

--constant s="ア"
--?s --DEV
--for i=1 to length(s) do
--  puts(1,s[i])
--  ?s[i]
--end for

--?'π' --DEV (doc)
--?"π" --DEV
--  λ
