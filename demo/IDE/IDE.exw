--IDE for Win32Lib -- core originally developed by David Cuny
--                                                                      ?-1999

--                     with modifications by Judith Evans
--                              and contributors
--                                                                      1999-2008

--About this release:
--this version is specifically for use with win32lib v0.70.4a or later.

--Problem Notes related to IDE code:
--1. If there are more than 1 popup and you want to test them within IDE, when you right click
--   a window pops up for you to select which one to test and when you make a selection the
--       popup appears. In XP if you click the popup, it disappears. In Win98 you get an machine-level 
--   exception in w32dll.ew line 212 in function w32Func().
--2. If you add an icon to a button in FlatToolBar you can not double click to open Code Editor.



without type_check
include win32lib.ew
without warning
setWarning(0)

-- CW add
global integer autosave_time, autosave_OnOff
autosave_time = 300000
autosave_OnOff = w32False
--

global constant
    Application  = "Win32Lib IDE",
    Version      = "1.0.4",
    Version_Date = "07-2008",
    Build_date   = "July-06-2008"

-------------------------------------------------------------------------------
--      splash screen which will disappear when IDE activates
-------------------------------------------------------------------------------
include includes\\IDE_splash.ew
openWindow(splash, Normal)

--------------------------------------------------------------------------------
--                declaratives and routines for instance control of IDE
-------------------------------------------------------------------------------
--Euman
constant ERROR_ALREADY_EXISTS = 183

global atom hMutex
integer arg
constant
    xSetLastError = registerw32Procedure(kernel32, "SetLastError",{C_INT}),
    xCreateMutex = registerw32Function(kernel32, "CreateMutexA",
                                       {C_POINTER,C_INT,C_POINTER},C_LONG),
    xReleaseMutex  = registerw32Procedure(kernel32, "ReleaseMutex",{C_LONG}),

xScrollWindow = registerw32Procedure(user32, "ScrollWindow", {C_LONG,C_LONG,C_LONG,C_POINTER,C_POINTER})

arg = allocate_string("JudithIDE")
hMutex = w32Func(xCreateMutex,{0, 0, arg})
    if w32Func(GetLastError,{})=ERROR_ALREADY_EXISTS then
        w32VOID = message_box("Only 1 instance of IDE is allowed","",0)--suggested by Mark Young
        w32Proc(xReleaseMutex,{hMutex})
        free(arg)
        free_console()
        abort(0)
    end if

    -------------------------------------------------------------------------------
    --       messages and display routine for all messages in IDE
    -------------------------------------------------------------------------------
global sequence MsgNos          MsgNos = {}
global sequence IDEText         IDEText = {}
global sequence TheLanguages    TheLanguages = {}

global function displayErrorMessage(integer number, object param)
integer ok

    if number>length(MsgNos) then
        ok = message_box("Your message file is not current."
                         & " Can not display message " & sprint(number),"",MB_ICONERROR)
        return 0
    end if
    ok = message_box(sprintf(MsgNos[number][1],param),MsgNos[number][2],MsgNos[number][3])

    return ok
end function

global sequence
    the_current_dir,            --if user switches folders on open or save dialogs then the curent directory
                                --is modified. So save the current dir at startup for the documentation routines.
    projectDir                  --folder of saved project

    the_current_dir             = {}
    projectDir                  = {}

sequence params, testParam, subparams
global object d
integer at

params = command_line()
the_current_dir = current_dir()

--set the projectDir temporaryily to IDE's dir
projectDir = current_dir()

    --if user started IDE from an .prj file association, then current_dir is
    --the directory of the .prj file not IDE.
    --path={}
    if length(params)>1 then
        --check the directory of IDE.exw
        subparams = params[2]
        --if start IDE without extension (e.g. from Start/run)
        subparams = reverse(subparams)
        at = find('.',subparams)
        subparams = reverse(subparams)
        if not at then
            subparams &= ".exw"
        end if
        --get the long name if there is one
        d = dir(subparams)
        if not atom(d) then
            --find the path
            for i=length(subparams) to 1 by -1 do
                if subparams[i]='\\' then
                    subparams = subparams[1..i] & d[1][D_NAME]
                    exit
                end if
            end for
        end if

        testParam = reverse(subparams)
        at = find('\\', testParam)
        if at then
            testParam = testParam[at+1..length(testParam)]
            --establish project directory
            projectDir = reverse(testParam)
            the_current_dir = reverse(testParam)
        end if
    end if

constant cfgLangPref = 45,
cfgRegisterStyle = 46,
maxSlots = 66
---------------------------------------------------------------------------------
--      establish error messages and Window translations in requested language
---------------------------------------------------------------------------------

global procedure loadLanguagePreference(sequence lang)
sequence fileName, thedata--,buffer
integer handle, ok
    setText(splashLoadInfo, "Loading Language File: " & lang & "...")
    fileName = the_current_dir & "\\Languages\\" & lang & ".lng"
    handle = open(fileName, "r")
    if handle= -1 then
        ok = displayErrorMessage(215,{fileName})
        return
    end if
    thedata = get(handle)
    if thedata[1]!=GET_SUCCESS then
        ok = displayErrorMessage(216,{fileName})
        close(handle)   --Josef
        return
    end if
    MsgNos = thedata[2][1]
    IDEText = thedata[2][2]
    close(handle)
end procedure

sequence ConfigFile, FirstConfigFile
integer fn, ignore, haveEnglish
object line
global integer translateNow      translateNow = w32False

    setText(splashLoadInfo, "Loading Languages...")
    --find any languages in IDE\Languages folder
    haveEnglish = w32False
    d = dir(the_current_dir & "\\Languages")
    if atom(d) then
        --there are no languages;should have English.lng!
        ignore = message_box("You have removed English.lng from IDE\\Languages and not "
                             & "replaced with any others. IDE may not continue.","",0)
        closeWindow(splash)
        abort(1)
    else
        for i=1 to length(d) do
            at = match(".lng",lower(d[i][D_NAME]))
            if at then
                TheLanguages &= {d[i][D_NAME][1..at-1]}
                if equal(TheLanguages[length(TheLanguages)], "English") then
                    --in case error in opening/reading cfg file
                    haveEnglish = w32True
                    loadLanguagePreference("English")
                end if
            end if
        end for
    end if
    setText(splashLoadInfo, "Loading Configuration...")
    ConfigFile = the_current_dir & "\\Files\\IDE.cfg"
    -- open the file and find language user prefers
    fn = open(ConfigFile, "r")
    if fn= -1 then
        --pick up IDEFirstTime.cfg
        FirstConfigFile = the_current_dir & "\\Files\\IDEFirstTime.cfg"
        fn = open(FirstConfigFile, "r")
        if fn= -1 then
            if haveEnglish then
                ignore = displayErrorMessage(149,{ConfigFile,FirstConfigFile})
            else
                ignore = message_box("Unable to read the file IDE\\Files\\IDE.cfg or IDE\\Files\\FirstTimeIDE.cfg."
                                     & " You must have one of these to continue with IDE.","Msg 149",8208)
            end if
            closeWindow(splash)
            abort(1)
        end if
    end if
    if fn!= -1 then
        line = get(fn)
        if line[1]=GET_FAIL then
            if haveEnglish then
                ignore = displayErrorMessage(49,{})
            else
                ignore = message_box("can not read " & ConfigFile
                                     & " and you do not have English.lng. "
                                     & "IDE can not continue","",16)
                closeWindow(splash)
                abort(1)
            end if
        end if
        line = line[2]
        close(fn)
        if length(line)!=maxSlots then
            if haveEnglish then
                loadLanguagePreference("English")
            else
                ignore = message_box("you have removed English.lng. IDE can not continue","",16)
                closeWindow(splash)
                abort(1)
            end if
        else
            if equal(line[cfgLangPref][1], "LanguagePref") then
                at = find(line[cfgLangPref][2],TheLanguages)
                if at then
                    loadLanguagePreference(TheLanguages[at])
                    if not equal(lower(TheLanguages[at]), "english") then
                        translateNow = w32True
                    end if
                else
                    ignore = displayErrorMessage(223,{the_current_dir & "\\Languages"})
                    if haveEnglish then
                        line[cfgLangPref][2] = "English"
                        loadLanguagePreference("English")
                    else
                        ignore = message_box("your prefered language is not found in IDE\\Languages "
                                             & "and you have removed English.lng. IDE can not continue","",16)
                        closeWindow(splash)
                        abort(1)
                    end if
                end if
            end if
        end if
    end if

---------------------------------------------------------------------------------
--      some included files. Others are below
---------------------------------------------------------------------------------
include resources\xpm_icon.e
include resources\ide_xpm.ew
include includes\ruler.ew    --Travis Beaty
--------------------------------------------------------------------------------
--
global sequence
    statusBar,                  --system size of status bar; determined in Code.ew
    CursorPos                   --last cursor position in Code Editor

sequence
    size, sizeS

    sizeS                       = getRect(Screen)

global integer
    ok,
    DesignCX, DesignCY,         --fixed size of new design window
    cX, cY, cCX, cCY,           --base size of IDE
    dX, dY, dCX, dCY,           --size of Design Window as user changes the size
    borderX,                    --system size of a window border
    borderY,                    --system size of window border
    scrollWide, toolBar,        --system size of tool bar and scrollbar thumb
    titleBar, menuBar           --system size of window title bar and menu bar

    cX                          = 0
    cY                          = 0
    cCX                         = 640
    cCY                         = 480
    DesignCX                    = 400
    DesignCY                    = 300

integer
    sX, sY, sCX, sCY,           --base size of Show Window
    propertyTitleBar            --height of PropertyTitleBar

    ok = setLVInsert(1)         --ListView inserts in order added
    borderX                     = getSystemMetrics(SM_CXFRAME)
    borderY                     = getSystemMetrics(SM_CYFRAME)
    scrollWide                  = getSystemMetrics(SM_CXHTHUMB)
    toolBar                     = 34
    titleBar                    = getSystemMetrics(SM_CYCAPTION)
    menuBar                     = getSystemMetrics(SM_CYMENU)

-------------------------------------------------------------------------------
--                          Major IDE Windows
-------------------------------------------------------------------------------
setText(splashLoadInfo, "Creating Controls: Menus...")
global constant
    Controls            = createEx(Window, Application, 0, cX, cY, cCX, cCY, w32or_all({WS_CLIPCHILDREN,WS_CLIPSIBLINGS}),0)
--include a module that keeps the windows in Controls, as well as Controls itself, titlebars lit
include includes\IDE_docking.ew

constant
    FileMenu            = createEx(Menu, "P&roject", Controls, 0, 0, 0, 0, 0, 0),
    MenuNew             = createEx(MenuItem, "&New",      FileMenu, 0, 0, 0, 0, 0, 0),
    MenuOpen            = createEx(MenuItem, "&Open \t Ctrl+O", FileMenu, 0, 0, 0, 0, 0, 0)
global constant
    MenuSave            = createEx(MenuItem, "&Save \t Ctrl+S", FileMenu, 0, 0, 0, 0, 0, 0),
    MenuSaveAs          = createEx(MenuItem, "Save &As \t F12", FileMenu, 0, 0, 0, 0, 0, 0)
constant
    MenuSep1            = createEx(MenuItem, "-",        FileMenu, 0, 0, 0, 0, 0, 0),
    MenuClose           = createEx(MenuItem, "&Exit",    FileMenu, 0, 0, 0, 0, 0, 0),
    MenuSep1a           = createEx(MenuItem, "-",        FileMenu, 0, 0, 0, 0, 0, 0)
global constant
    MenuClearRecent     = createEx(MenuItem, "&Clear Recent Projects List", FileMenu, 0, 0, 0, 0, 0, 0)
constant
    MenuComponents      = createEx(Menu, "&View", Controls, 0, 0, 0, 0, 0, 0),
    MenuProjectViewOpen = createEx(MenuItem, "Project &View \t Ctrl+J",MenuComponents, 0, 0, 0, 0, 0, 0),
    MenuPropertyOpen    = createEx(MenuItem, "&Properties \t Ctrl+P", MenuComponents, 0, 0, 0, 0, 0, 0),
    MenuIconBarOpen     = createEx(MenuItem, "&Tool Box \t Ctrl+T", MenuComponents, 0, 0, 0, 0, 0, 0),
    MenuEditors         = createEx(Menu, "&Editors", Controls, 0, 0, 0, 0, 0, 0),
    MenuCodeEditor      = createEx(MenuItem, "&Code Editor \t Ctrl+E", MenuEditors, 0, 0, 0, 0, 0, 0)
global constant
    MenuMenuEditor      = createEx(MenuItem, "&Menu Editor \t Ctrl+M", MenuEditors, 0, 0, 0, 0, 0, 0),
    MenuPopupEditor     = createEx(MenuItem, "&Popup Editor \t Ctrl+U", MenuEditors, 0, 0, 0, 0, 0, 0),
    MenuTimerEditor     = createEx(MenuItem, "&Timer Editor \t Ctrl+W", MenuEditors, 0, 0, 0, 0, 0, 0),
    MenuXPMmer          = createEx(MenuItem, "&XPM Icon Editor", MenuEditors, 0, 0, 0, 0, 0, 0)
constant
    MenuListValues      = createEx(CheckBox, "List values", Controls, -100, 0, 50, 50, 0, 0),
    EditMenu            = createEx(Menu, "E&dit", Controls, 0, 0, 0, 0, 0, 0)
global constant
    MenuControlUndo     = createEx(MenuItem, "Control Action &Undo \t Ctrl+Z", EditMenu, 0, 0, 0, 0, 0, 0)
constant
    MenuSep2            = createEx(MenuItem, "-", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuWindow          = createEx(MenuItem, "&New Window", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuSep2a           = createEx(MenuItem, "-",             EditMenu, 0, 0, 0, 0, 0, 0),
    MenuWinDel          = createEx(MenuItem, "&Delete Active Window", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuSep2b           = createEx(MenuItem, "-", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuLayer           = createEx(MenuItem, "New Controls La&yer", EditMenu, 0, 0, 0, 0, 0, 0)
global constant
    MenuTabAllUseLayer  = createEx(MenuItem, "All c&ontrols in active layer may use setLayer", EditMenu, 0, 0, 0, 0, 0, 0)
constant
    MenuLayerRename     = createEx(MenuItem, "R&ename Layers", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuLayerDel        = createEx(MenuItem, "Delete &Active Layer", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuSep2c           = createEx(MenuItem, "-", EditMenu, 0, 0, 0, 0, 0, 0)
global constant
    MenuFormLock        = createEx(MenuItem, "&Form Lock: No Control Move", EditMenu, 0, 0, 0, 0, 0, 0)
constant
    MenuSep2d           = createEx(MenuItem, "-", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuInitValueEditor = createEx(MenuItem, "&Initial Value for List, Combo \t Ctrl+L", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuMsgboxes        = createEx(MenuItem, "&Create Message Box", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuSystray         = createEx(MenuItem, "&Setup Systray for current Window", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuWinStyles       = createEx(MenuItem, "&Visual Window Styles Explorer", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuListViewStyles  = createEx(MenuItem, "Visual &List View Styles Explorer", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuSep2e           = createEx(MenuItem, "-", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuRegisterStyles  = createEx(MenuItem, "&Manage Property Templates", EditMenu, 0, 0, 0, 0, 0, 0),
    MenuSelectStyles    = createEx(MenuItem, "Select From &Property Templates", EditMenu, 0, 0, 0, 0, 0, 0),

    MenuOptions         = createEx(Menu, "&Options", Controls, 0, 0, 0, 0, 0, 0),
    MenuClicks          = createEx(Menu, "&Icon Behavior", MenuOptions, 0, 0, 0, 0, 0, 0)
global constant
    MenuClick           = createEx(MenuItem, "&Off", MenuClicks, 0, 0, 0, 0, 0,0)
constant
    MenuInst            = createEx(MenuItem, "&Instructions", MenuClicks, 0, 0, 0, 0, 0, 0),
    MenuMeasure         = createEx(Menu, "&Ruler Tool", MenuOptions, 0, 0, 0, 0, 0, 0),
    MenuMeasureOpen     = createEx(MenuItem, "&Open Ruler Tool", MenuMeasure, 0, 0, 0, 0, 0, 0),
    MenuMeasureHelp     = createEx(MenuItem, "&Information - Ruler Tool", MenuMeasure,
                                   0, 0, 0, 0, 0, 0),
    MenuOptionsS1               = createEx(MenuItem, "-", MenuOptions, 0, 0, 0, 0, 0, 0),
    MenuHide            = createEx(MenuItem, "Grid &Hide", MenuOptions, 0, 0, 0, 0, 0, 0),
    MenuDisable         = createEx(MenuItem, "&Grid Disable", MenuOptions, 0, 0, 0, 0, 0, 0),
    MenuOptionsS2               = createEx(MenuItem, "-", MenuOptions, 0, 0, 0, 0, 0, 0)
global constant
    MenuUndockForm      = createEx(MenuItem, "&Undock Form", MenuOptions, 0, 0, 0, 0, 0, 0),
MenuUndockProperty  = createEx(MenuItem, "Undock &Properties", MenuOptions, 0, 0, 0, 0, 0, 0)
constant MenuClosedProperty = createEx(CheckBox, "     closed", Controls, 0, 0, -1, -1, 0, 0)
setEnable(MenuClosedProperty, w32False)
global constant MenuUndockProject   = createEx(MenuItem, "Undock Project &View", MenuOptions, 0, 0, 0, 0, 0, 0)
constant MenuClosedProject = createEx(CheckBox, "      closed", Controls, 0, 0, -1, -1, 0, 0)
setEnable(MenuClosedProject, w32False)
constant
        MenuUndockToolKit   = createEx(MenuItem, "Undock &Tool Kit", MenuOptions, 0, 0, 0, 0, 0, 0),
        MenuClosedToolKit = createEx(CheckBox, "      closed", Controls, 0, 0, -1, -1, 0, 0),
        MenuOptionsS3           = createEx(MenuItem, "-", MenuOptions, 0, 0, 0, 0, 0, 0)
setEnable(MenuClosedToolKit, w32False)
global constant
    MenuColorNoSuppress = createEx(MenuItem, "&Draw window and controls with color", MenuOptions, 0, 0, 0, 0, 0, 0),
    MenuFontNoSuppress  = createEx(MenuItem, "Draw controls with &Font", MenuOptions, 0, 0, 0, 0, 0, 0),
    MenuBitmapNoSuppress = createEx(MenuItem, "Draw controls with &Bitmap, Ico, XPM", MenuOptions, 0, 0, 0, 0, 0, 0)
constant
    MenuConfigurations  = createEx(MenuItem, "&Configure IDE",MenuOptions, 0, 0, 0, 0, 0, 0),
    MenuGenerating      = createEx(Menu, "&Generate Tools", Controls, 0, 0, 0, 0, 0, 0),
    MenuRunOption       = createEx(MenuItem, "&Program Information", MenuGenerating, 0, 0, 0, 0, 0, 0),
    MenuRunOrder        = createEx(MenuItem, "&Change Control Order For Program", MenuGenerating, 0, 0, 0, 0, 0, 0),
    MenuIncludeOrder    = createEx(MenuItem, "&Manage Include Statements \t Ctrl+A", MenuGenerating, 0, 0, 0, 0, 0, 0),
    RunMenu             = createEx(Menu, "Generate &Program", Controls, 0, 0, 0, 0, 0, 0),
    MenuTempRun         = createEx(Menu, "Temporary Run &Project/Include", RunMenu, 0, 0, 0, 0, 0, 0),
    MenuRulesTemp       = createEx(MenuItem, "&Rules",MenuTempRun, 0, 0, 0, 0, 0, 0)
global constant
    MenuRunTemp         = createEx(MenuItem, "&Temp Run \t F6", MenuTempRun, 0, 0, 0, 0, 0, 0),
    MenuRun             = createEx(MenuItem, "&Run Project/Include \t F5", RunMenu, 0, 0, 0, 0, 0, 0),

    MenuBind            = createEx(MenuItem, "&Bind Project/Include", RunMenu, 0, 0, 0, 0, 0, 0)
constant
--    OtherSep            = createEx( MenuItem, "-", RunMenu, 0, 0, 0, 0, 0, 0 ),
    LaunchMenu          = createEx(Menu, "&Launch", Controls, 0, 0, 0, 0, 0, 0)
global constant
    MenuPass                    = createEx(MenuItem, "Instead of using Code Editor &Pass controls and routines to editor of your choice", LaunchMenu, 0, 0, 0, 0, 0, 0)
constant
        LaunchSep3          = createEx(MenuItem, "-", LaunchMenu, 0, 0, 0, 0, 0, 0),
RunItem             = createEx(MenuItem, "&Run ...", LaunchMenu, 0, 0, 0, 0, 0, 0),
LaunchSep1          = createEx(MenuItem, "-", LaunchMenu, 0, 0, 0, 0, 0, 0),
EditLaunchItem      = createEx(MenuItem, "&Edit Launcher", LaunchMenu, 0, 0, 0, 0, 0, 0),
--possibly eliminate this separator and add back if there are entries in Launcher    
LaunchSep2          = createEx(MenuItem, "-", LaunchMenu, 0, 0, 0, 0, 0, 0),
HelpMenu            = createEx(Menu, "&Help", Controls, 0, 0, 0, 0, 0, 0),
MenuConts           = createEx(MenuItem, "&Contents", HelpMenu, 0, 0, 0, 0, 0, 0),
MenuSep3            = createEx(MenuItem, "-", HelpMenu, 0, 0, 0, 0, 0, 0),
MenuKeys            = createEx(MenuItem, "&Keys", HelpMenu, 0, 0, 0, 0, 0, 0),
MenuSep4            = createEx(MenuItem, "-", HelpMenu, 0, 0, 0, 0, 0, 0),
MenuAbout           = createEx(MenuItem, "&About...", HelpMenu, 0, 0, 0, 0, 0, 0),
Tools               = createEx(ToolBar, "", Controls, 0, 0, 0, 34, 0, 0)
size        = getClientRect(Controls)
global constant
    IconOff             = createEx(PushButton, "Off", Tools, 275,0, 28, 28, 0, 0),
    WinList             = createEx(Combo, "", Tools, 308, 2, 160, size[4]-2, 0, 0),
    TheTabItemCombo     = createEx(Combo, "", Tools, 470, 2, 160, size[4]-2, 0, 0)

setText(splashLoadInfo, "Creating Controls: Design Form...")
constant HiddenWindow = createEx(Window,"", Controls, 180, 2, 448, 332,
                                 {WS_CHILD,WS_DLGFRAME,WS_CLIPCHILDREN,WS_CLIPSIBLINGS}, 0)
size = getClientRect(HiddenWindow)
global constant Form = createDockBar("Form Design", HiddenWindow, 0,0,size[3],size[4],
                                     {WS_CHILD,WS_THICKFRAME,WS_MAXIMIZEBOX,WS_CAPTION,WS_SYSMENU,WS_HSCROLL,WS_VSCROLL,WS_CLIPCHILDREN},0)
global constant LayersTC = createEx(TabControl,"",Form,0,0,400,20,0,0)
global integer LayersTI --LayersTI will be built on the fly in proj.ew routine pickWindow
                                                                                                --"Form Design"
global constant FormUndockWindow = createDockBar(IDEText[1032][1], Controls, 1000, -20, -1, -1,
                                                 or_all({WS_HSCROLL,WS_VSCROLL,WS_CLIPCHILDREN,WS_CLIPSIBLINGS}),0)

setText(splashLoadInfo, "Creating Controls: Design...")
global constant Design = createDockBar("Design", Form, 0, 20, 400, 300,
                                       {WS_CHILD,WS_CAPTION,WS_THICKFRAME,WS_DLGFRAME,WS_CLIPCHILDREN,WS_CLIPSIBLINGS},0)

setText(splashLoadInfo, "Creating Controls: Popup Design...")
global constant
    PopUpDesign             = createEx(Popup, "", Design, 0, 0, 0, 0, 0, 0),
                                                 --"Code Editor"
    PopUpDesign_CodeEditor  = createEx(MenuItem, IDEText[711][1], PopUpDesign,
                                       0, 0, 0, 0, 0, 0)
constant
                                                 --"Menu Editor"
    PopUpDesign_MenuEditor  = createEx(MenuItem, IDEText[712][1], PopUpDesign,
                                       0, 0, 0, 0, 0, 0),
                                                --"Popup Editor"
    PopUpDesign_PopupEditor = createEx(MenuItem, IDEText[713][1], PopUpDesign,
                                       0, 0, 0, 0, 0, 0),
                                                 --"Properties"
    PopUpDesign_PropertyOpen = createEx(MenuItem, IDEText[714][1],PopUpDesign, 0, 0, 0, 0, 0, 0),
    --additions by Roland Stowasser
                                                    --"Project View"
    PopUpDesign_ProjectTreeOpen = createEx(MenuItem, IDEText[715][1],PopUpDesign,
                                           0, 0, 0, 0, 0, 0),
                                                 --"Tool Box"
    PopUpDesign_IconBarOpen = createEx(MenuItem, IDEText[716][1],PopUpDesign, 0, 0, 0, 0, 0, 0)
    --end Roland
global constant
                                                --"Window Styles Explorer"
    PopUpDesign_Styles      = createEx(MenuItem, IDEText[717][1],PopUpDesign, 0, 0, 0, 0, 0, 0)
constant
    PopUpSep1               = createEx(MenuItem, "-", PopUpDesign, 0, 0, 0, 0, 0, 0)
global constant
                                                 --"Delete control"
    PopUpDesign_DeleteCtrl  = createEx(MenuItem, IDEText[718][1], PopUpDesign,
                                       0, 0, 0, 0, 0, 0),
                                                     --"Delete TabControl"
    PopUpDesign_DeleteTabControl = createEx(MenuItem, IDEText[719][1], PopUpDesign,
                                            0, 0, 0, 0, 0, 0),
                                                   --"Delete TabItem"
    PopUpDesign_DeleteTabItem = createEx(MenuItem, IDEText[720][1], PopUpDesign,
                                         0, 0, 0, 0, 0, 0),
    PopUpDesign_Move = createEx(MenuItem, IDEText[1141][1], PopUpDesign,
                                0, 0, 0, 0, 0, 0),
PopUpDesign_Copy = createEx(MenuItem, IDEText[1142][1], PopUpDesign,
                            0, 0, 0, 0, 0, 0),
PopUpDesign_Paste = createEx(MenuItem, IDEText[1143][1], PopUpDesign,
                             0, 0, 0, 0, 0, 0),
                                                --"Undo"
    PopUpDesign_Undo        = createEx(MenuItem, IDEText[721][1],PopUpDesign, 0, 0, 0, 0, 0, 0)
constant
    PopUpSep2               = createEx(MenuItem, "-", PopUpDesign, 0, 0, 0, 0, 0, 0)
global constant
                                                --"Show Popup"
    PopUpDesign_PopUp       = createEx(MenuItem, IDEText[722][1], PopUpDesign, 0, 0, 0, 0, 0, 0),
                                                 --"Table Specs"
    PopUpDesign_Table       = createEx(MenuItem, IDEText[723][1], PopUpDesign, 0, 0, 0, 0, 0, 0),
                                                 --"Show Full Size"
    PopUpDesign_FullSize    = createEx(MenuItem, IDEText[724][1], PopUpDesign, 0, 0, 0, 0, 0, 0),
                                                 --"Show Off Screen"
    PopUpDesign_OffScreen   = createEx(MenuItem, IDEText[725][1], PopUpDesign, 0, 0, 0, 0, 0, 0),
                                                 --"Show Multiple Layers"
    PopUpDesign_Layers      = createEx(MenuItem, IDEText[986][1], PopUpDesign, 0, 0, 0, 0, 0, 0)
constant                                                 --"Undock Form"
    PopUpDesign_UndockForm  = createEx(MenuItem, IDEText[726][1], PopUpDesign, 0, 0, 0, 0, 0, 0)
                                                 --"Pick Background Layers"
constant MultipleLayersSelect = createEx(Window, IDEText[988][1], Controls, Default, Default, 174, 243, {WS_DLGFRAME}, 0)
constant List3 = createEx(List, "", MultipleLayersSelect, 4, 32, 148, 120, w32or_all({LBS_MULTIPLESEL,LBS_EXTENDEDSEL}), 0)
                                  --"Select background layers"
constant LText4 = createEx(LText, IDEText[989][1], MultipleLayersSelect, 4, 12, 160, 20, 0, 0)
                                            --"Ok"
constant PushButton7 = createEx(PushButton, IDEText[385][1], MultipleLayersSelect, 4, 162, 68, 28, 0, 0)
constant PushButton8 = createEx(PushButton, IDEText[386][1], MultipleLayersSelect, 80, 162, 68, 28, 0, 0)

setEnable(PopUpDesign_Paste, w32False)

setText(splashLoadInfo, "Creating Controls: Properties...")
global constant PropertySheet = createDockBar("Properties", Controls, 0, 2, 180, 170, or_all({WS_CHILD}), 0)
global constant PropertyTitleBar = createEx(Combo, "", PropertySheet, 0, 0, 164, 20*6, 0, 0)
constant UndockPropertyButton = createEx(PushButton, "", PropertySheet, 164, 0, 8, 8, 0, 0)
sequence propertySize
propertySize = getClientRect(PropertySheet)
sequence IDEsize
IDEsize = getClientRect(Controls)
setRect(PropertyTitleBar,0, 0, propertySize[3]-scrollWide-borderX, IDEsize[4],True)
setRect(UndockPropertyButton,propertySize[3]-scrollWide, 0, 10, 10, True)
                                                                                        --"Properties"
global constant PropertyUndockWindow = createDockBar(IDEText[714][1], Controls, -1000, -2, -1, -1, or_all({WS_CLIPCHILDREN,WS_CLIPSIBLINGS}), 0)
constant PropertyUndockButton = createEx(PushButton, "", PropertyUndockWindow, 164, 0, 8, 8, 0, 0)

setText(splashLoadInfo, "Creating Controls: ProjectView...")
global constant ProjectWindow = createDockBar("ProjectView", Controls, 0, 170, 180, 220, or_all({WS_CHILD}), 0)
constant UndockButton = createEx(PushButton, "", ProjectWindow, 164, 0, 10, 10, 0, 0)
global constant ProjectUndockWindow = createDockBar("ProjectView", Controls, -4000, -4, -1, -1, or_all({WS_CLIPCHILDREN,WS_CLIPSIBLINGS}), 0)
constant ProjectUndockButton = createEx(PushButton, "", ProjectUndockWindow, 164, 0, 8, 8, 0, 0)

setText(splashLoadInfo, "Creating Controls: ToolKit...")
constant IconBar = createDockBar("ToolKit", Controls, 264, 334, 364, 60, or_all({WS_CHILD}), 0)
constant
    ToolboxHelp         = createEx(PushButton, "?", IconBar, 325, 0, 15, 15, 0, 0),
    ToolboxUndockButton = createEx(PushButton, "", IconBar, 345, 0, 10, 10, 0, 0)
sequence toolkitSize
toolkitSize = getClientRect(IconBar)
setRect(ToolboxUndockButton,toolkitSize[3]-10, 0, 10, 10, True)
global constant
    ToolboxTabControl   = createEx(TabControl, "", IconBar, 0, 0, 325, 55, 0, 0),
    ToolboxTabItem      = createEx(TabItem, "Controls", ToolboxTabControl, 0, 0, 0, 0, 0, 0),
    ToolboxTabItem2     = createEx(TabItem, "Additional", ToolboxTabControl, 0, 0, 0, 0, 0, 0),
    ToolboxTabItem3     = createEx(TabItem, "Input", ToolboxTabControl, 0, 0, 0, 0, 0, 0),
    ToolboxTabItem4     = createEx(TabItem, "Selection", ToolboxTabControl, 0, 0, 0, 0, 0, 0),
    ToolboxTabItem5     = createEx(TabItem, "Extras", ToolboxTabControl, 0, 0, 0, 0, 0, 0)
--    ToolboxTabItem6     = createEx( TabItem, "Customized", ToolboxTabControl, 0, 0, 0, 0, 0, 0 )
constant IconBarUndockWindow = createDockBar("ToolKit", Controls, -800, -8, 364, 60, or_all({WS_CLIPCHILDREN,WS_CLIPSIBLINGS}), 0)
constant IconBarUndockButton = createEx(PushButton, "", IconBarUndockWindow, 350, 0, 10, 10, 0, 0)
constant IconBarToolboxHelp  = createEx(PushButton, "?", IconBarUndockWindow, 325, 0, 15, 15, 0, 0)
toolkitSize = getClientRect(IconBarUndockWindow)
setRect(IconBarUndockButton,toolkitSize[3]-10, 0, 10, 10, True)

addItem(PropertyTitleBar,"Window1")
setIndex(PropertyTitleBar,1)

--adjust button in ProjectWindow
sequence projectSize
projectSize = getClientRect(ProjectWindow)
setRect(UndockButton,projectSize[3]-scrollWide, 0, 10, 10, True)
                                              --IDEText[965][1]
constant PropertyTabControl      = createEx(TabControl, "", PropertySheet, 0, 20, 1,1,0,0)
constant PropertyTabItem         = createEx(TabItem, "PropertyList", PropertyTabControl, 0, 0, 0, 0, 0, 0)
                                              --IDEText[966][1]
constant PropertyTabItem2        = createEx(TabItem, "Events", PropertyTabControl, 0, 0, 0, 0, 0, 0)
constant EventListView           = createEx(ListView, {" "}, PropertyTabItem2, 0, 20, 188, 204,w32or_all({LVS_REPORT,LVS_SHOWSELALWAYS,LVS_NOSORTHEADER}),0)
constant LVIcon1                = addIcon(extractIcon(the_current_dir & "\\resources\\forward.ico"))
propertySize  = getCtlSize(PropertySheet)
size = getRect(PropertyTitleBar)
propertyTitleBar  = size[4]-size[2]
    setCtlSize(PropertyTabControl, propertySize[1], propertySize[2]-propertyTitleBar)
    setCtlSize(EventListView, propertySize[1]-5,propertySize[2]-40)
atom lvMask
    lvMask  = w32or_all({LVS_EX_GRIDLINES,LVS_EX_FULLROWSELECT})
    ok      = sendMessage(EventListView,LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)
    ok      = sendMessage(EventListView,LVM_SETCOLUMNWIDTH,0,size[1]-28)
--------------------------------------------------------------------------------
--remove and add style for Design causes PropertySheet, PV and ToolKit to remain on top
--BUT allows Design to scroll over Layer Tab!
--removeStyle(Design, {(WS_MINIMIZEBOX+WS_SYSMENU),(0)})
--addStyle(Design, {(WS_DLGFRAME+WS_POPUP+WS_CLIPSIBLINGS+WS_CLIPCHILDREN),(0) })

removeStyle(PropertyUndockWindow, {
                 -- normal styles
                                   (WS_MAXIMIZEBOX),
                 -- extended styles
                                   (0)
                                  })
removeStyle(ProjectUndockWindow, {(WS_MAXIMIZEBOX), (0)})
removeStyle(IconBarUndockWindow, {(WS_MAXIMIZEBOX), (0)})
removeStyle(PropertySheet, {(WS_THICKFRAME+WS_CAPTION+WS_MINIMIZEBOX+WS_SYSMENU), (0)})
addStyle(PropertySheet, {(WS_DLGFRAME+WS_POPUP+WS_THICKFRAME+WS_CLIPSIBLINGS+WS_CLIPCHILDREN),(0)})
removeStyle(ProjectWindow, {(WS_THICKFRAME+WS_CAPTION+WS_MINIMIZEBOX+WS_SYSMENU), (0)})
addStyle(ProjectWindow, {(WS_DLGFRAME+WS_POPUP+WS_THICKFRAME+WS_CLIPSIBLINGS+WS_CLIPCHILDREN),(0)})
removeStyle(IconBar, {(WS_THICKFRAME+WS_CAPTION+WS_MINIMIZEBOX+WS_SYSMENU), (0)})
addStyle(IconBar, {(WS_DLGFRAME+WS_POPUP+WS_THICKFRAME+WS_CLIPSIBLINGS+WS_CLIPCHILDREN), (0)})
-------------------------------------------------------------------------------
--initial size of design window
dX          = 0
dY          = 20 --height of Layer Tab
dCX         = 400 --starting size of window1
dCY         = 300 --starting size of window1
--------------------------------------------------------------------------------
--CalendarWin is used as a hidden window to test monthcalendar font changes for resize
--once have changed font then getCtlSize for setting in Properties.
constant CalendarWin    = createEx(Window, "",Controls,-5, -5, sizeS[3], sizeS[4], 0, 0)
constant testCalendar   = createEx(MonthCalendar,"",CalendarWin,0, 0, 0, 0, 0, 0)
--testControl and testControlRe are for getFontDialogEx
constant testControl    = createEx(PushButton, "", CalendarWin, 100,100,100,28,0,0)
constant testControlRE    = createEx(RichEdit, "", CalendarWin, 100,100,100,28,0,0)
putStream(testControlRE, StreamText, "some data")
--------------------------------------------------------------------------------
--adding this window allowed Undocked windows to stick on top of Controls with Win98SE
--plus fixed problems with CodeWin, WinExpl and ListViewExpl opening behind Controls
--with Win98SE. 
--I don't have a clue why but hey!!!!!!
constant DummyWindow = createDockBar("", 0, -800, -1, 630, 344, WS_CLIPCHILDREN, 0)
showWindow(DummyWindow, SW_HIDE)
-------------------------------------------------------------------------------
--            Pixmaps to draw grid and controls
-------------------------------------------------------------------------------
global integer GridBlit, ControlBlit, OffScreenBlit, BackBlit
GridBlit        = createEx(Pixmap, "", Controls, -1, -1, sizeS[3], sizeS[4], 0, 0)
ControlBlit     = createEx(Pixmap, "", Controls, -2, -2, sizeS[3], sizeS[4], 0, 0)
OffScreenBlit   = createEx(Pixmap, "", Controls, -3, -3, sizeS[3], sizeS[4], 0, 0)
BackBlit        = createEx(Pixmap, "", Controls, -4, -4, sizeS[3], sizeS[4], 0, 0)

    --initialize pixmap for drawing grid
    setPenColor(GridBlit, getSysColor(COLOR_BTNFACE))
    drawRectangle(GridBlit, w32True, 0, 0, sizeS[3], sizeS[4])
    setPenColor(BackBlit, getSysColor(COLOR_BTNFACE))
    drawRectangle(BackBlit, w32True, 0, 0, sizeS[3], sizeS[4])

integer LayerRenameWindow, LayerRenameTitle1,LayerRenameWinCombo,LayerRenameTitle2,
        LayerRenameLayerCombo,LayerRenameTitle3,LayerRenameEdit,LayerRenameOk,
        LayerRenameDone,LayerRenameCancel
        LayerRenameWindow = -1
------------------------------------------------------------------------------
--               populate Toolbar
------------------------------------------------------------------------------
setText(splashLoadInfo, "Initializing Toolbar XPM's...")
--disabled Undo button (from Roland Stawasser)
setTransparentColor(getSysColor(COLOR_BTNFACE))
global constant
undodisabled_xpm = xpmToEuBmp({
"24 24 6 1",
".        c #040204",
"@        c #989898",
"         c None",
"&        c #FCFEFC",
"$        c #5C5E5C",
"+        c #D4D2D4",
"&&&&&&&&&&&&&&&&&&&&&&&&",
"&+++++++++++++++++++++++",
"&+                      ",
"&+                      ",
"&+                      ",
"&+                      ",
"&+                      ",
"&+                      ",
"&+       @              ",
"&+      @@              ",
"&+     @@@@@@           ",
"&+    @@@@@@@@@         ",
"&+     @@@@@@@@@        ",
"&+      @@    @@        ",
"&+       @     @@       ",
"&+             @@       ",
"&+             @@       ",
"&+             @        ",
"&+            $         ",
"&+                      ",
"&+                      ",
"&+                      ",
"&+                      ",
"&+                      "})
constant
indexedCopydisabled_xpm = xpmToEuBmp({
"24 24 4 1",
"   c None",
".  c #989898",
"&  c #FCFEFC",
"+  c #D4D2D4",
"&&&&&&&&&&&&&&&&&&&&&&&&",
"&+++++++++++++++++++++++",
"&+                      ",
"&+                      ",
"&+                      ",
"&+      .      ....     ",
"&+     ...    ......    ",
"&+    .....  .   ...    ",
"&+   .......      ...   ",
"&+  .........     ...   ",
"&+ ...........  ....... ",
"&+ ..........    .....  ",
"&+  ........      ...   ",
"&+    .....        .    ",
"&+      ..              ",
"&+                ...   ",
"&+              ....... ",
"&+              ....... ",
"&+             .........",
"&+             .........",
"&+             .........",
"&+              ....... ",
"&+              ....... ",
"&+                ...   "})
-------------------------------------------------------------------------------
integer lastButtonX, ButtonY, which
    lastButtonX = 0
    ButtonY = 0
    which = 0

--slight mod of this routine allows IDE to always show icons
function toolbarButton(integer toolbar, sequence tooltip, object xpm,
             integer which)
     -- create a button in the toolbar
     -- if xpm is 0, creates a separation instead

integer button,result
atom dib

     -- request for separator?
    if atom(xpm) then
         -- increment space
        lastButtonX += 4
        return 0
    end if

     -- convert the xpm to a dib
     -- transparent colors are converted to the button color
    setTransparentColor(getSysColor(COLOR_BTNFACE))

     -- create to dib
    dib = createDIB(xpmToEuBmp(xpm))

     -- create a 28x28 button in the toolbar
     --Roland removed dib from createEx and used sendMessage
    if which then
        button = createEx(TogglePicture, "", toolbar, lastButtonX,
                          ButtonY, 28, 28, 0, 0)
    else
        button = createEx(PictureButton, "", toolbar, lastButtonX,
                          ButtonY, 28, 28, 0, 0)
    end if

    result = sendMessage(button, BM_SETIMAGE, IMAGE_BITMAP, dib)
     --end Roland

     -- add the tooltip hint
    setHint(button, tooltip)

     -- increment
    lastButtonX += 28

     -- restore the transparent color to the default
    setTransparentColor({255,0,255})

    return button

end function
--------------------------------------------------------------------------------
constant
    ToolNew     = toolbarButton(Tools, "New Project",      new_xpm, 0),
    ToolOpen    = toolbarButton(Tools, "Open Project",    open_xpm, 0),
    ToolSave    = toolbarButton(Tools, "Save.. Project",     save_xpm, 0),
    ToolSaveAs  = toolbarButton(Tools, "Save As.. Project", save_as_xpm, 0),
    ToolSep5    = toolbarButton(Tools, "",     0, 0)
global constant
    ToolUndo    = toolbarButton(Tools, "Control Undo", undo_xpm, 0),
    ToolUndoD  = createEx(Bitmap, "Control Undo", Tools, 116, 0, 28,28, 0, 0)
constant
    ToolSep1    = toolbarButton(Tools, "",    0, 0),
    ToolConfiguration = toolbarButton(Tools, "Configure IDE", preferences_xpm, 0),
    ToolSep2    = toolbarButton(Tools, "",    0, 0),
    ToolDelete  = toolbarButton(Tools, "Delete Active Window", trash_xpm, 0),
    ToolSep3    = toolbarButton(Tools, "",     0, 0),
    ToolRun     = toolbarButton(Tools, "Run",              clock_run_xpm, 0),
    ToolSep4    = toolbarButton(Tools, "",     0, 0)
global constant
    ToolCopyIndex = toolbarButton(Tools, "Indexed Copy Active", XPM_IndexedCopy, 0),
    ToolCopyIndexD = createEx(Bitmap, "Control Undo", Tools, 244, 0, 28, 28, 0, 0)

    --build toolbox buttons
    lastButtonX = 2
    ButtonY = 23
global constant
    ThePushButton = toolbarButton(ToolboxTabItem,"PushButton",XPM_control_button, 1),
    TheColoredButton = toolbarButton(ToolboxTabItem, "Colored Button", XPM_control_cbutton, 1),
    TheCheckBox = toolbarButton(ToolboxTabItem,"Check Box",XPM_control_check, 1),
    TheRadio = toolbarButton(ToolboxTabItem,"Radio",XPM_control_radio, 1),
    TheTabControl = toolbarButton(ToolboxTabItem,"Tab Control",XPM_control_tabcontrol, 1),
    TheTabItem = toolbarButton(ToolboxTabItem,"Tab Item",XPM_control_tabs, 1),
    TheGroup = toolbarButton(ToolboxTabItem,"Group",XPM_control_group, 1),
    TheToolBar = toolbarButton(ToolboxTabItem,"Tool Bar",XPM_control_tools, 1),
    TheNone = toolbarButton(ToolboxTabItem,"Tool Bar Spacer",XPM_control_toolbarspacer, 1)

    lastButtonX = 2
global constant
    TheLText = toolbarButton(ToolboxTabItem2,"Label",XPM_additional_label, 1),
    TheStatusBar = toolbarButton(ToolboxTabItem2,"Status Bar",XPM_additional_status, 1),
    TheMenu = toolbarButton(ToolboxTabItem2,"Menu",XPM_control_menu, 1),
    ThePopup = toolbarButton(ToolboxTabItem2,"Popup",XPM_control_popup, 1),
    TheBitmap = toolbarButton(ToolboxTabItem2,"Bitmap",XPM_additional_bitmap, 1),
    TheIcon = toolbarButton(ToolboxTabItem2,"Icon",XPM_additional_image, 1),
    TheProgress = toolbarButton(ToolboxTabItem2,"Progress Bar",XPM_additional_progress, 1),
    TheHScroll = toolbarButton(ToolboxTabItem2,"H Scroll",XPM_additional_scrollbar, 1),
    TheVScroll = toolbarButton(ToolboxTabItem2,"V Scroll",XPM_additional_vscrollbar, 1),
    TheCalendar = toolbarButton(ToolboxTabItem2,"Calendar",XPM_input_date, 1)

    lastButtonX = 2
global constant
    TheRichEdit = toolbarButton(ToolboxTabItem3,"Rich Edit",XPM_rtb, 1),
    TheMle = toolbarButton(ToolboxTabItem3,"Mle Text",XPM_input_mle, 1),
    TheEditText = toolbarButton(ToolboxTabItem3,"Edit Text",XPM_input_text, 1),
    TheLabelEdit = toolbarButton(ToolboxTabItem3,"Label Edit",XPM_input_labeltext, 1)

    lastButtonX = 2
global constant
    TheCombo = toolbarButton(ToolboxTabItem4,"Combo",XPM_selection_combo, 1),
    TheList = toolbarButton(ToolboxTabItem4,"List",XPM_selection_list, 1),
    TheUpDown = toolbarButton(ToolboxTabItem4,"Up/Down",XPM_selection_spin, 1),
    TheTreeView = toolbarButton(ToolboxTabItem4,"Tree View",XPM_selection_tree, 1),
    TheListView = toolbarButton(ToolboxTabItem4,"List View",XPM_lvc, 1),
    TheTable = toolbarButton(ToolboxTabItem4,"Table",XPM_control_array, 1),
    TheEuGrid = toolbarButton(ToolboxTabItem4,"EuGrid",XPM_selection_grid, 1)

    lastButtonX = 2

global constant
    TheFlatBar = toolbarButton(ToolboxTabItem5, "FlatToolBar",XPM_control_flatTools, 1),
    TheSepButton = toolbarButton(ToolboxTabItem5,"Separator",XPM_control_Sep, 1),
    TheReBar = toolbarButton(ToolboxTabItem5,"ReBar",XPM_control_ReBar, 1),
    TheReBarBand = toolbarButton(ToolboxTabItem5,"ReBarBand",XPM_control_ReBarBand, 1),
    TheTimer = toolbarButton(ToolboxTabItem5,"Timer",XPM_input_time, 1),
    TheChildWindow = toolbarButton(ToolboxTabItem5,"Child Window",XPM_windows_child, 1)

--create the disabled Undo button:
atom hToolUndoD
    hToolUndoD = createDIB({undodisabled_xpm[1],undodisabled_xpm[2]})
    setBitmap(ToolUndoD, hToolUndoD)

    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)
--create the disabled indexCopy button:
atom hToolCopyIndexD
    hToolCopyIndexD = createDIB({indexedCopydisabled_xpm[1],indexedCopydisabled_xpm[2]})
    setBitmap(ToolCopyIndexD, hToolCopyIndexD)

    setVisible(ToolCopyIndex, w32True)
    setVisible(ToolCopyIndexD, w32False)

setHint(PropertyTitleBar, "All controls in Window except Menu, PopUp and Timer")
setHint(UndockButton,"Click to undock and redock")
setHint(UndockPropertyButton,"Click to undock and redock")
setHint(ProjectUndockButton,"Click to undock and redock")
setHint(PropertyUndockButton,"Click to undock and redock")
setHint(ToolboxUndockButton,"Click to undock and redock")
setHint(TheTabItemCombo, "Active TabItem Name")
setHint(WinList, "Active Window Name")
setHint(IconOff, "Drop Icon Multiple Times")
setHint(LayersTC, "Left click to select layer, ctrl+right click to select background layer(s)")
-----------------------------------------------------------------------------
integer checkOtherWindows_id
integer translateLayerRename_id
global sequence layerTabItemSeq             --list of layer tabitem ids
layerTabItemSeq                             = {}
global sequence layerCaptionSeq             --sequence of layer tab titles for project; structure similar to windows
layerCaptionSeq                             = {}
global integer selectedWindow               --currently selected window
selectedWindow                              = 1
-----------------------------------------------------------------------------
procedure translateControlWindow()
integer formLockChecked, iconOffChecked, gridHideChecked, gridEnableChecked,
        undockFormChecked, drawColorChecked, drawFontChecked, drawBitmapChecked,
        setLayerChecked,undockPropertyChecked,undockProjectChecked,undockToolkitChecked
sequence lValues
integer lastTabItem, layernumber

    setText(splashLoadInfo, "Configurating...")
    --since setText will remove any checkmarks, need to see what state they are in now
    formLockChecked = isChecked(MenuFormLock)
    iconOffChecked = isChecked(MenuClick)
    gridHideChecked = isChecked(MenuHide)
    gridEnableChecked = isChecked(MenuDisable)
    undockFormChecked = isChecked(MenuUndockForm)
    drawColorChecked = isChecked(MenuColorNoSuppress)
    drawFontChecked = isChecked(MenuFontNoSuppress)
    drawBitmapChecked = isChecked(MenuBitmapNoSuppress)
    setLayerChecked = isChecked(MenuTabAllUseLayer)
    undockPropertyChecked = isChecked(MenuUndockProperty)
    undockProjectChecked = isChecked(MenuUndockProject)
    undockToolkitChecked = isChecked(MenuUndockToolKit)

    setText(FileMenu, IDEText[149][1])
    setText(MenuNew, IDEText[150][1])
    setText(MenuOpen, IDEText[151][1])
    setText(MenuSave, IDEText[152][1])
    setText(MenuSaveAs, IDEText[153][1])
    setText(MenuClose, IDEText[154][1])
    setText(MenuClearRecent, IDEText[155][1])
    setText(MenuComponents, IDEText[156][1])
    setText(MenuProjectViewOpen, IDEText[157][1])
    setText(MenuPropertyOpen, IDEText[158][1])
    setText(MenuIconBarOpen, IDEText[159][1])
    setText(MenuEditors, IDEText[160][1])
    setText(MenuCodeEditor, IDEText[161][1])
    setText(MenuMenuEditor, IDEText[162][1])
    setText(MenuPopupEditor, IDEText[163][1])
    setText(MenuTimerEditor, IDEText[164][1])
    setText(MenuListValues, IDEText[165][1])
    setText(EditMenu, IDEText[166][1])
    setText(MenuControlUndo, IDEText[167][1])
    setText(MenuWindow, IDEText[168][1])
    setText(MenuWinDel, IDEText[169][1])
    setText(MenuFormLock, IDEText[170][1])
    setText(MenuInitValueEditor, IDEText[171][1])
    setText(MenuMsgboxes, IDEText[172][1])
    setText(MenuSystray, IDEText[173][1])
    setText(MenuWinStyles, IDEText[174][1])
    setText(MenuListViewStyles, IDEText[175][1])
    setText(MenuSelectStyles, IDEText[176][1])
    setText(MenuRegisterStyles, IDEText[1036][1])
    setText(MenuOptions, IDEText[177][1])
    setText(MenuClicks, IDEText[178][1])
    setText(MenuClick, IDEText[179][1])
    setText(MenuInst, IDEText[180][1])
    setText(MenuMeasure, IDEText[181][1])
    setText(MenuMeasureOpen, IDEText[182][1])
    setText(MenuMeasureHelp, IDEText[183][1])
    setText(MenuHide, IDEText[184][1])
    setText(MenuDisable, IDEText[185][1])
    setText(MenuUndockForm, IDEText[186][1])
    setText(MenuColorNoSuppress, IDEText[187][1])
    setText(MenuFontNoSuppress, IDEText[188][1])
    setText(MenuBitmapNoSuppress, IDEText[189][1])
    setText(MenuConfigurations, IDEText[190][1])
    setText(MenuGenerating, IDEText[191][1])
    setText(MenuRunOption, IDEText[192][1])
    setText(MenuRunOrder, IDEText[193][1])
    setText(MenuIncludeOrder, IDEText[194][1])
    setText(RunMenu, IDEText[195][1])
    setText(MenuTempRun, IDEText[196][1])
    setText(MenuRulesTemp, IDEText[197][1])
    setText(MenuRunTemp, IDEText[198][1])
    setText(MenuRun, IDEText[199][1])
    setText(MenuBind, IDEText[200][1])
    setText(LaunchMenu, IDEText[201][1])
    setText(RunItem, IDEText[202][1])
    setText(EditLaunchItem, IDEText[203][1])
    setText(HelpMenu, IDEText[204][1])
    setText(MenuConts, IDEText[205][1])
    setText(MenuKeys, IDEText[206][1])
    setText(MenuAbout, IDEText[207][1])
    setText(MenuLayer, IDEText[982][1])
    setText(MenuLayerDel, IDEText[983][1])
    setText(IconOff, IDEText[208][1])
    setText(MenuTabAllUseLayer, IDEText[1018][1])
    setText(FormUndockWindow, IDEText[1032][1])
    setText(PropertyUndockWindow, IDEText[714][1])
    setText(ProjectUndockWindow, IDEText[715][1])
    setText(IconBarUndockWindow, IDEText[716][1])
    setText(MenuUndockProperty, IDEText[1041][1])
    setText(MenuUndockProject, IDEText[1042][1])
    setText(MenuUndockToolKit, IDEText[1043][1])
    setText(MenuXPMmer, IDEText[1090][1])
    setText(MenuPass, IDEText[1126][1])

    for i=1 to length(layerTabItemSeq) do
        lastTabItem = layerTabItemSeq[i]
        --get active layer number
        lValues = getUserProperty(lastTabItem, "layer")
        if length(lValues) then
            layernumber = lValues[1][1]
        else
            layernumber = 0
        end if
        --if user has not renamed the layer then assign Layer plus number as caption,
        --otherwise use his choice.
        if not layerCaptionSeq[selectedWindow][i][2] then
            setText(lastTabItem, IDEText[984][1] & " " & sprint(layernumber))
            layerCaptionSeq[selectedWindow][i][1] = IDEText[984][1] & " " & sprint(layernumber)
        end if
    end for

    setHint(ToolNew, IDEText[209][1])
    setHint(ToolOpen, IDEText[210][1])
    setHint(ToolSave, IDEText[211][1])
    setHint(ToolSaveAs, IDEText[212][1])
    setHint(ToolUndo, IDEText[213][1])
    setHint(ToolConfiguration, IDEText[214][1])
    setHint(ToolDelete, IDEText[215][1])
    setHint(ToolRun, IDEText[216][1])
    setHint(ToolCopyIndex, IDEText[217][1])
    setHint(TheTabItemCombo, IDEText[218][1])
    setHint(WinList, IDEText[219][1])
    setHint(IconOff, IDEText[220][1])
    setHint(LayersTC, IDEText[990][1])

    setCheck(MenuFormLock,formLockChecked)
    setCheck(IconOff,iconOffChecked)
    setCheck(MenuClick, iconOffChecked)
    setCheck(MenuHide,gridHideChecked)
    setCheck(MenuDisable,gridEnableChecked)
    setCheck(MenuUndockForm,undockFormChecked)
    setCheck(MenuColorNoSuppress,drawColorChecked)
    setCheck(MenuFontNoSuppress,drawFontChecked)
    setCheck(MenuBitmapNoSuppress,drawBitmapChecked)
    setCheck(MenuTabAllUseLayer,setLayerChecked)
    setCheck(MenuUndockProperty,undockPropertyChecked)
    setCheck(MenuUndockProject,undockProjectChecked)
    setCheck(MenuUndockToolKit,undockToolkitChecked)

    setText(PopUpDesign_CodeEditor, IDEText[711][1])
    setText(PopUpDesign_MenuEditor, IDEText[712][1])
    setText(PopUpDesign_PopupEditor, IDEText[713][1])
    setText(PopUpDesign_PropertyOpen, IDEText[714][1])
    setText(PopUpDesign_ProjectTreeOpen, IDEText[715][1])
    setText(PopUpDesign_IconBarOpen, IDEText[716][1])
    setText(PopUpDesign_Styles, IDEText[717][1])
    setText(PopUpDesign_DeleteCtrl, IDEText[718][1])
    setText(PopUpDesign_DeleteTabControl, IDEText[719][1])
    setText(PopUpDesign_DeleteTabItem, IDEText[720][1])
    setText(PopUpDesign_Undo, IDEText[721][1])
    setText(PopUpDesign_PopUp, IDEText[722][1])
    setText(PopUpDesign_Table, IDEText[723][1])
    setText(PopUpDesign_FullSize, IDEText[724][1])
    setText(PopUpDesign_OffScreen, IDEText[725][1])
    setText(PopUpDesign_UndockForm, IDEText[726][1])
    setText(PopUpDesign_Layers, IDEText[986][1])
    setText(MultipleLayersSelect, IDEText[988][1])
    setText(LText4, IDEText[989][1])
    setText(PushButton7, IDEText[385][1])
    setText(PushButton8, IDEText[386][1])
    setText(PopUpDesign_Move,IDEText[1141][1])
    setText(PopUpDesign_Copy,IDEText[1142][1])
    setText(PopUpDesign_Paste,IDEText[1143][1])
    if isChecked(MenuUndockForm) then
        setText(PopUpDesign_UndockForm, IDEText[811][1])
    end if
end procedure
------------------------------------------------------------------------------
global procedure translateControls()

    --this routine is called from ide_config.ew when user changes language
    --change all the window verbage for those windows that may open when IDE
    --initiates. Other windows will translate when they open.
    --if they are already open when language is changed in config.ew, need to
    --translate now.
    translateControlWindow()

    --check to see if Properties, Code Editor is open and needs translating
    call_proc(checkOtherWindows_id,{})
    call_proc(translateLayerRename_id,{})
end procedure
-------------------------------------------------------------------------------
--   support windows created on demand
-------------------------------------------------------------------------------
---- initial values for Show Window when created
sX          = 0
sY          = 0
sCX         = 800
sCY         = 600

setText(splashLoadInfo, "Initializing Variables...")
global integer
    Show,
    OffScreen

    Show                        = -1
    OffScreen                   = -1

integer SelectPopUp,
    PopupBox,
    cancelPopupButton,
    ConfigInclude

    SelectPopUp                 = -1
    PopupBox                    = -1
    cancelPopupButton           = -1
    ConfigInclude               = -1

integer Config_Group1,Config_Ew,Config_Exw,Config_has_Winlib,Config_Winlib_Name,
     Config_save_Options,SavePrj,SaveCfg,SaveNo,ButClose2
integer ConfigText1,ConfigText3,ConfigText4,ConfigText2,ConfigText5,ConfigText6,EditTitle,EditVersion,EditAuthor,
     EditDate,Win32libVer,MleDesc,MleComment,ConfigText7,Config_Text1,
     CommandLineLabel, RunCommandLine, AddCrashFile

--variables saved for other modules:
global integer config_Ew            config_Ew = w32False
global integer config_Exw           config_Exw = w32True
global integer addCrashFile         addCrashFile = w32False
global integer config_has_Winlib    config_has_Winlib = w32True
global integer saveCfg              saveCfg = w32False
global integer savePrj              savePrj = w32False
global sequence config_Winlib_Name  config_Winlib_Name = {}
global sequence config_Title        config_Title = {}
global sequence config_Author       config_Author = {}
global sequence config_Date         config_Date = {}
global sequence config_Version      config_Version = {}
global sequence config_WinLibVer    config_WinLibVer = {}
global sequence config_Desc         config_Desc = {}
global sequence config_Comment      config_Comment = {}
global sequence commandLineRun      commandLineRun = {}
global integer canUseTransparency
global integer notifyNewControl         notifyNewControl = w32False

include includes\alphablend.ew           -- transparency routines (Thomas Parslow)
canUseTransparency = alphablend_Supported()
-------------------------------------------------------------------------------
integer Binding        Binding = -1
integer RunBindButton,TextBindingClose,TextBindingFind,
                TextBind,BindDebug,BindList,BindQuiet,BindOut,BindCon,BindIcon,BindingOptions,
                BindOutName,BindingIconName

--variables saved for other modules:
global integer checkDebug,checkQuiet,checkCon,checkList,bindingIcon
    checkDebug = w32False
    checkQuiet = w32False
    checkCon = w32False
    checkList = w32False
    bindingIcon = w32False
global sequence bindingIconName,bindingOptions,bindingOutName
    bindingIconName = {}
    bindingOptions  = {}
    bindingOutName  = {}
-------------------------------------------------------------------------------
constant
MeasureScale = createEx(Window, "Scale Ruler", Form, Default, Default,
                        100, 200, {WS_DLGFRAME, WS_CAPTION}, 0),
cbPlayScale = createEx(SimpleCombo, "", MeasureScale, 4, 4, 72, 6*32, 0, 0)
-------------------------------------------------------------------------------
integer KeysWindow     KeysWindow = -1
integer LText2,LText3
-------------------------------------------------------------------------------
integer TableSpecs     TableSpecs  = -1
integer TSEditText1,TSLText1,TSLText2,TSEditText2,TSUpDown2,TSEditText3,TSUpDown1
integer TSUpDown3,TSEditText4,TSUpDown4,TSLText4,TSCheckBox1,TSCheckBox2,TSLText5
integer TSPushButton1,TSPushButton2,TSLText3
integer TSGroup1,TSGroup2,TS_FitYes,TS_FitNo,TS_VScroll,TS_HScroll,TS_Note1--,TS_Note2,TS_Note3
integer TS_Resizable,TSCheckBox3, TSCheckBox4, TSSetHandler,TSRow,TSCol,TSNone,TSAll
integer TSGroupColor,TSCheckAll, TSTextAll,TSCheckCopy,TSTextCopy
--------------------------------------------------------------------------------
integer TempWindow     TempWindow = -1
integer TempMenu,TempRunMenu,TempRunSave,TempRulesSave,TempText1,TempCloseBut
integer TempGroup1,TempRadioReplace,TempRadioStop,TempRadioAsk,TempGroup2
integer TempRadioKeepBad,TempRadioKeepAlways,TempRadioKeepGood,TempRadioKeepNever

--variables save for other modules:
global integer tempRadioReplace,tempRadioStop,tempRadioAsk,tempRadioKeepBad,
        tempRadioKeepGood,tempRadioKeepAlways,tempRadioKeepNever

    tempRadioReplace    = 0
    tempRadioStop       = 0
    tempRadioAsk        = 0
    tempRadioKeepBad    = 0
    tempRadioKeepGood   = 0
    tempRadioKeepAlways = 0
    tempRadioKeepNever  = 0
-------------------------------------------------------------------------------
setFocus(PropertyTabItem)

setIcon(Controls, the_current_dir & "\\resources\\IDE_design.ico")
setIcon(Form, the_current_dir & "\\resources\\IDE_design.ico")
setIcon(ProjectUndockWindow, the_current_dir & "\\resources\\IDE_tree.ico")
setIcon(IconBarUndockWindow, the_current_dir & "\\resources\\IDE_Hammer.ico")
setIcon(PropertyUndockWindow, the_current_dir & "\\resources\\IDE_spy.ico")

setCheck(MenuClick, w32True)
setCheck(MenuFormLock, w32False)
setCheck(MenuColorNoSuppress, w32True)
setCheck(MenuFontNoSuppress, w32True)
setCheck(MenuBitmapNoSuppress, w32True)
setCheck(MenuUndockProperty, w32False)
setCheck(MenuUndockProject,w32False)
setCheck(MenuUndockToolKit,w32False)

setEnable(MenuControlUndo, w32False)
setEnable(PopUpDesign_Undo, w32False)
setEnable(PopUpDesign_PopUp, w32False)
setEnable(PopUpDesign_DeleteTabControl, w32False)
-------------------------------------------------------------------------------
----        declaratives
-------------------------------------------------------------------------------
global object
    whereEu                     --location of Euphoria folder
    whereEu                     = {}

global sequence
        euIncFiles,                                     --list of EuInc files
        euDir,                                          --path of Euphoria
    FileTypes,                                  --for open, saveAs dialogs
    IcoFileTypes,
    OpenFileModules,
    validEuGridChild,           --a sequence of allowed child Class
    projectFileType,            --file type for project file. User defined in IDE.cfg
    IcoFileName,                --hold browse for name in Property
    BitmapFileName,             --ditto
    XPMFileName,                --ditto
    controlResource,            --control and the resource handle for draw and deleteObject
    controlResourceBack,        --backup to controlResource, used in Undo

    --initial values from configuration Project Control for start at last position
    controlsPosition,
    formPosition,
    codePosition,
    projectPosition,
    propertyPosition,

    openFileName,               --name of file currently open
    CB_StartFileName,           --default open or saved project file path
    selectedTabItem,            --currently selected TabItem
    windows,                    --holds all windows in the project
    controls,                   --holds all the controls in the currently selected window
    backupControls,             --holds last action on controls sequence for Undo or restore from error
    backupLayerCaptionSeq,      --  ditto for layer information
    backupLayerTabItemSeq,      --  ditto for the layer tab ids
    FileBuffer,                 --holds list of recent files opened
    settingsBuffer,             --temporary slots for holding user configuration items
    cfgWin32lib, prjWin32lib,   --"Win32lib.ew" name is in config or project file?
    MultiPropertySelect,        --there are several controls updated with same Property value
    eventNode,                  --ProjectView node for events
    includeModules,             --list of modules included into project
    toolBarInfo,                --holds data about toolbars
    toolBarInfoBack,            --backup to toolBarInfo, used in Undo
    toolBarName,                --Name of toolbar
    GridColorName,              --default grid color
    waitForKeys,                --properties to wait for enter key loaded from config
    origName,                   --original control Name; used in Property change
    textOrigName,               --original control Name; used in Property change thru code events
    showBackLayer,                              --show Form Design layer behind current layer
    iconStrings,                --contains control name and iconId
    iconData,
    crashfile,                  --users crash_file
    codeLastSize,                               --Code Editor size when closing Editor
    parentList,                                 --list of a controls possible parents
    controlNameKeywords,                --list of control names for colorization
        commonTableArray,                       --cells in table with CommonSetHandler
        theDefaultFont                          --array holding Win32lib's default font

    projectFileType             = "prj"  --default
    FileTypes                   = {"Project File","*." & projectFileType}
    IcoFileTypes                = {"Icon File", "*.ICO"}
    OpenFileModules             = {"Include File","*.E;*.EW"}
    validEuGridChild            = {"LText","CText","RText","EditText","CheckBox","Combo","Radio","DropDownList","Bitmap","PushButton"}
    IcoFileName                 = ""
    BitmapFileName              = ""
    XPMFileName                 = ""
    controlsPosition            = {}
    formPosition                = {}
    codePosition                = {}
    projectPosition             = {}
    propertyPosition            = {}
    windows                     = {}
    controls                    = {}
    backupControls              = {}
    backupLayerTabItemSeq       = {}
    backupLayerCaptionSeq       = {}
    FileBuffer                  = {}
    settingsBuffer              = {}
    cfgWin32lib                 = "Win32lib.ew"
    prjWin32lib                 = {}
    MultiPropertySelect         = {}
    eventNode                   = ""
    includeModules              = {}
    toolBarInfo                 = {}
    toolBarName                 = {}
    GridColorName               = "Blue"
    waitForKeys                 = {}
    origName                    = {}
    textOrigName                = {}
    controlResource             = {}
    controlResourceBack         = {}
    toolBarInfoBack             = {}
    showBackLayer               = {}
    iconStrings                 = {}
    iconData                    = {"",0}
    CursorPos                   = {0,1}
    crashfile                   = {}
    codeLastSize                                = {0,0,0}
    parentList                                  = {}
    controlNameKeywords                 = {}
    commonTableArray                    = {}
    openFileName                                = {}
    theDefaultFont                              = {"MS Sans Serif",8,0}

sequence
    theControlWindowSize,       --initial size of IDE. Cannot resize smaller.
    priorFont,                  --Property Font change
    priorHintFont,              --Property Hint Font change
    bindName,                   --name of file to bind
    realPopupIds,               --list of popup Ids
    selectedProp                                --selected Property caption (in English)

    theControlWindowSize        = getRect(Controls)
    priorFont                   = "Edit or Choose..."
    priorHintFont               = "Edit or Choose..."
    bindName                    = {}
    realPopupIds                = {}
    selectedProp                                = {}

sequence
    winMainList,                --open Window verbs in Properties
    winPosList,                 --Positioning of Window in Properties
    defaultList,                --Style Type list
    tempFileName,               --temporary run file name
    tabItemList,
    childrenList

    winMainList                 = {"Normal","Maximize","Minimize"}
    winPosList                  = {"None","Top Left","Top Center","Top Right","Middle Left","Middle Center",
                                   "Middle Right","Bottom Left","Bottom Center","Bottom Right"}
    defaultList                 = {"w32or_all({...})","{...}","..."}
    tempFileName                = ""
    tabItemList                 = {}
    childrenList                = {}

global constant
    WindowColor         = getSysColor(COLOR_WINDOW),
    ButtonColor         = getSysColor(COLOR_BTNFACE),
    TextColor           = getSysColor(COLOR_WINDOWTEXT),
    ButtonTextColor     = getSysColor(COLOR_BTNTEXT),
    TitleBarColor       = getSysColor(COLOR_ACTIVECAPTION),
    HighlightColor      = getSysColor(COLOR_HIGHLIGHT),
    HighlightTextColor  = getSysColor(COLOR_HIGHLIGHTTEXT),
    ButtonHighlightColor = getSysColor(COLOR_BTNHIGHLIGHT),
    ShadowColor         = getSysColor(COLOR_BTNSHADOW),
    ScrollColor         = getSysColor(COLOR_SCROLLBAR),
    TitleColor          = getSysColor(COLOR_CAPTIONTEXT),
    MenuColor           = getSysColor(COLOR_MENU),
    TitleY              = 0,        -- size of titlebar
    -- emulated toolbar metrics
    MenuSpacing         = 12,       -- x spacing between menu bar items

    -- state of mouse in Design window
    -- Normal       = 0
    MoveDrag        = 1,        -- drag move in process
    ResizeDrag      = 2,        -- resize drag in process
    MenuPick        = 3,        -- emulated menu dropped down

    -- rendering flags
    -- Normal       = 0
    Selected        = 1,        -- control is selected
    Dragging        = 2,        -- control is being dragged
    Borders         = 3,        -- control is LText and needs borders shown
    RedSelected     = 4,        -- controls hidden behind another control
    -- cr is system dependant
    cr              = "\n",

    -- design window constants
    TheWindow       = 1,        -- the design window is control #1
    General         = 1,        -- the first event, "(General)"
    Pointer         = 1,        -- no Tool Box icon selected

    -- scroll bar icon direction
    None            = 0,
    Up              = 1,
    Down            = 2,
    Left            = 3,
    Right           = 4
global integer CWindows
    CWindows = -1

global integer
    gridCellCX,                 --EuGrid Row Header CellCX
    gridCellCY,                 --EuGrid Col Header and Cell CellCY
    haveReBar,                  --user added a reBar control
    haveToolBar,                --user add a toolbar or flat toolbar;this is a count of them
    haveStatusBar,              --user added a status bar
    haveEuGrid,                 --user added a grid; this is a count of them
    haveEuGridControl,
    repaintWinResize,           --in drawIt redraw ReBar and ToolBar
    doProperties,               --if show properties after a routine
    focusDesign,
    gridX, gridY,               --grid CX and CY

    --information to locate windows when IDE opens
    controlsWasMaxed,
    formWasMaxed,
    formWasUndocked,
    codeWasMaxed,
    codeWasMined,
    propWasUnDocked,
    pvWasUnDocked,
    copyIndexSw,                --if CopyIndex disabled or not

    IDE_Changed,                --something in IDE changed since last save
    userReorderControls,                --during project, user reordered controls for tabbing
    showActive,                 --if show window is currently open
    offsetActive,               --if Offset window is currently open
    saveLocal,                  --user wants local createEx in exw
    WinX,                       --x offset for drawing window in scrolled screen
    WinY,                       --y offset
    MenuY,                      -- size of menu; if nonzero, there's a menu
    hasPopup,                   -- there is a popup window open
    selectedControl,            -- the control that's currently selected
    state,                      -- current state
    mouseDown,                  -- if w32True, mouse is down
    dragX,                      -- x at start of drag
    dragY,                      -- y at start of drag
    dragCX,                     -- cx at start of drag
    dragCY,                     -- cy at start of drag
    backupSelectedWindow,       -- holds value of selectedWindow when Undo a new or delete Window
    closedUp,                   --closed IDE
    damagedFlag,                                --TableSpecs did not have enough room to generate cells

    --forward reference rids
    updateProperties_id,
    updateProperty_id,
    ToolBarStuff_id,
    TabItemStuff_id,
    GroupStuff_id,
    StatusBarStuff_id,
    MiscStuff_id,
    check_ResizeDrag_id,
    check_MoveDrag_id,
    moveTabSubControls_id,
    CopyGroupStuff_id,
    CopyMiscStuff_id,
    drawIt_id,
    PickWindowId,
    onChangeCodeFromProject_id,
    saveDefaultSettingsId,
    buildCols_id,
    buildRows_id,
    buildNewTable_Id,
    savetheReorder_id,
    openReorder_id,
    drawControl_id,
    CodeWinState,
    fontColor_id,
    resetMultiDrop_id,
    findCodeForEventList_id,
    deleteTheControl_id,
    writeCode_id,
    drawHiddenControls_id,
    jump_rid,
    ProcessXPMFile_id,
    MakeXPM_id,

    stopMouse,                  --prevents mouse_design() firing when modal window open
    counter,                    --for unique ids of controls
    tabCounter,                 --for unique ids of TabControls when multiple windows
    event,                      --event being edited in Code Editor
    winCounter,                 --unique window number for name/title
    counterInWindow,            --taborder counter by window
    delayDraw,                  --don't do drawIt yet
    picked,                     --what icon selected from Tool Box
    CodeWinOpen,                --Code Editor window is opened
    CodeWinWasOpened,                   --Code Editor was opened in current session
    CodeWinWasMaxed,                    --Code Editor was closed while in Maximized position
    haveOffscreen,              --there are offscreen controls in Design
    editorChanged,              --changes made to code in Editor
    zeroEvent,                  --when w32False prevents editor from resetting event to 0
    showEvent,                  --force editor to a particular event
    showScroll,                 --force editor to a particular row
    showCol,                    --force editor to a particular column
    toolBarCY,                  --the current CY of the ToolBar control
    toolBarRowCY,               --the row CY
    toolBarSubCY,               --the current CY for controls in the ToolBar
    toolBarOrigX,               --first position of toolBar
    toolBarOrigY,               --first position of toolBar
    toolBarX,                   --the next x position
    toolBarY,                   --the row number
    forceRedraw,                --force DrawIt to redraw toolbars
    treatAsInclude,             --module is Include file
    autoLoad,                   --prj was loaded from command line
    GridColor,                  --things for the snap to grid
    GridHide,
    GridDisable,
    GridDots,                   --when w32False is lines
    SnapSize,
    StopRun,                    --prevents onMouse activating when Modal window open
    tempRules1,                 --rules about temp run file
    tempRules2,
    doingFind,                  --when w32True tells IDE not to do drawIt when F3 pressed
    MenuEditDoubleClick,        --Martin, for Menu Editor to keep focus when transfer to Code Editor
    dropMultipleTimes,                  --user has selected multiple use of toolbox icon

    -- Variables for holding scroll info
    OldVPos,
    MinScroll,
    MaxScroll,
    ScrollPage,
    launchparent,               --allows both IDE and editor.exw to use IDE_launch.ew
    launchIDEdir,               --allows both IDE and editor.exw to use IDE_launch.ew
    layerNum,                   --counter of layers used in project
    layerNumber,                --current selected layer
    backgroundlayer,            --when showing multiple layers this is the one in back
    thelayerNumber,             --when DrawIt which layer is being drawn
    hatchBackground,
    formDiff,
    xpmCell                                             --tells XPmmer which type of icon is active

    gridCellCY                  = 20
    gridCellCX                  = 23
    haveReBar                   = w32False
    haveStatusBar               = w32False
    haveToolBar                 = 0             --gets incremented with number of toolbars
    haveEuGrid                  = 0             -- ditto
    haveEuGridControl           = 0             -- ditto
    repaintWinResize            = w32False
    doProperties                = w32False
    focusDesign                 = w32True
    size                        = getClientRect(Design)
    gridX                       = size[3]
    gridY                       = size[4]
    controlsWasMaxed            = w32False
    formWasMaxed                = w32False
    formWasUndocked                             = w32False
    codeWasMaxed                = w32False
    codeWasMined                = w32False
    propWasUnDocked             = w32False
    pvWasUnDocked               = w32False
    IDE_Changed                 = w32False
    userReorderControls                 = w32False
    showActive                  = w32False
    offsetActive                = w32False
    saveLocal                   = w32False
    WinX                        = 0
    WinY                        = 0
    stopMouse                   = w32False
    MenuY                       = 0         -- no menu in window
    selectedControl             = TheWindow -- no control selected
    state                       = Normal    -- mouse not in a mode
    mouseDown                   = 0         -- mouse button not held down
    selectedTabItem             = {}
    hasPopup                    = w32False
    backupSelectedWindow        = 1
    counter                     = 0
    tabCounter                  = 0
    winCounter                  = 1
    event                       = 0
    delayDraw                   = w32False
    picked                      = Pointer
    CodeWinOpen                 = w32False
    CodeWinWasOpened                    = w32False
    CodeWinWasMaxed                             = w32False
    haveOffscreen               = w32False
    editorChanged               = w32False
    zeroEvent                   = w32True
    showEvent                   = 0
    showCol                     = 0
    showScroll                  = 0
    toolBarCY                   = 0
    toolBarRowCY                = 0
    toolBarSubCY                = 0
    toolBarOrigX                = 0
    toolBarOrigY                = 0
    toolBarX                    = 0
    toolBarY                    = 0
    forceRedraw                 = w32False
    treatAsInclude              = w32False
    autoLoad                    = w32False
    GridColor                   = Blue
    GridHide                    = w32False
    GridDisable                 = w32False
    GridDots                    = w32True
    SnapSize                    = 4
    StopRun                     = w32False
    tempRules1                  = 0
    tempRules2                  = 0
    doingFind                   = w32False
    MenuEditDoubleClick         = w32False
    dropMultipleTimes                   = w32False
    OldVPos                     = 0
    MinScroll                   = 1
    MaxScroll                   = 100
    ScrollPage                  = 10
    copyIndexSw                 = w32True
    launchparent                = Controls
    launchIDEdir                = w32True
    closedUp                    = w32False
    layerNum                    = 0
    layerNumber                 = 0
    backgroundlayer             = 0
    hatchBackground             = w32False
    formDiff                                    = 0
    damagedFlag                                 = w32False
    xpmCell                                             = 0

integer
    skipValidations,           --bypass validations of Properties when loading with different control
    inScrolling,               --bypass scroll changes
    buildProjectView,          --update Project View due to Property change
    projectRunning,            --when w32True do not close IDE while output exw open
    cameFromProperty,          --came from property change
    whichCellIcon,             --which cell looking up in Icon Name in Property
    fromTitleBarChange,            --tells Design that Properties changed cx or cy so not to do it again                
    reOpenCodeWin,             --tells should reopen Code Editor when IDE forced it closed
    holdSep,                   --id for menu separator in recent files
    temporaryRun,
    havePropertySheet,
    okToMovePT,
    dontCountMove,
    firstOne,                  --finding correct parent for tabitem
    lastParent,
    canChangeIt,               --when w32True can change Name changes thru events

    --when resizing IDE:
    makeCodeWinMin,
    makeCodeWinMax,
    makeProjectMin,
    makeFormMax,
    makePropertyMin,
    makeToolMin,
    makeToolMax,
    gridBuildYet,
    createShowHandlers_id,     --forward reference rid
--  createLayersHandlers_id,
--  cameFromResizeControls,
    haveMaxed,                 --IDE was maximized
    openingIDE,
    fromShow,
    first,
--  createSelectStyleWindow_id,
    moduleX,
    moduleY,
    moduleTop,
    cancelledSaveAs,
    propertyPopupCell

    skipValidations             = w32False
    inScrolling                 = w32False
    buildProjectView            = w32False
    projectRunning              = w32False
    cameFromProperty            = w32False
    whichCellIcon               = 0
    fromTitleBarChange          = w32False
    reOpenCodeWin               = w32False
    holdSep                     = 0
    temporaryRun                = w32False
    havePropertySheet           = w32False
    okToMovePT                  = w32False
    dontCountMove               = w32False
    firstOne                    = w32False
    lastParent                  = 0
    makeCodeWinMin              = w32False
    makeCodeWinMax              = w32False
    makePropertyMin             = w32False
    makeProjectMin              = w32False
    makeToolMin                 = w32False
    makeToolMax                 = w32False
    makeFormMax                 = w32False
    gridBuildYet                = w32False
    haveMaxed                   = w32False
    openingIDE                  = w32True
    fromShow                    = w32False
    first                       = w32True
    canChangeIt                 = w32False
    moduleX                     = 0
    moduleY                     = 0
    moduleTop                   = 0
    cancelledSaveAs             = w32False
        propertyPopupCell                       = 0

--object
--  numbacklayer
--
--  numbacklayer                = 0
-------------------------------------------------------------------------------
-- master control sequence attributes (indexes)
-- these indexes for control sequence tell everything needed about a control to
-- manipulate it, createEx in exw file, output and reload from project file
---------------------------------------------------------------------------------
global constant
    AWindow     = 1,        -- 0 for Window class, menu=1, popup=2, timer=3, CWindow=4,
                                                -- ReBar=5, ReBarBand=6, ToolBar,FlatToolBar,StatusBar=7, 
                                                -- direct Child of ReBarBand (except ToolBar/FlatToolBar)=10, 
                                                -- TabControl,TabItem=25, rest=30
    Y           = 2,        -- y position (holds menu and popup order since not normally have x,y,cx,cy)
    X           = 3,        -- x position
    SubClass    = 4,        -- class of TabControl, TabItem; else blank
    ControlParent = 5,      -- highest parent of any control, except Window, and TabControl within TabItem
    ParentClass   = 6,          --  
    Id          = 7,        -- unique id
    Parent      = 8,        -- parent Table Name for cell controls
    CX          = 9,        -- width    also EGW_COL_WIDTH
    CY          = 10,       -- height
    Class       = 11,       --          also EGW_COL_TYPE
    Title       = 12,       -- title
    Name        = 13,       -- name
    Code        = 14,       -- Code Editor statements by event
    Checked     = 15,       -- Menu is checked
    Enabled     = 16,       -- Menu is enabled
    Active       = 17,      -- 1 if the selected TabItem for the TabControl
    Style        = 18,      -- window or control style param in create
    StyleType    = 19,      -- formating for Style
    Visible      = 20,
    Upper        = 21,
    Lower        = 22,
    ReadOnly     = 23,      --          also EGW_COL_EDITABLE
    Pswd         = 24,
    Limit        = 25,      --          also EGQ_COL_MAXCHARS
    BkColor      = 26,      -- setWindowBackColor also EGW_NULL_GRID_COLOR and EGW_COL_BACKGROUND_COLOR
    EnableC      = 27,
    Numeric      = 28,
    Multiline    = 29,      --          also EGW_COL_MULTILINE
    Hscrolls     = 30,
    Vscrolls     = 31,
    Buddy        = 32,
    IcoFile     = 33,      --file name for ?.ico; icofile 'default' for FlatToolBar
    BitmapFile  = 34,      --file name for ?.bmp
    TableCols   = 35,
    TableRows   = 36,
    TableColsSpace = 37,
    TableRowsSpace = 38,
    TableCell = 39,
    TableArray  = 40,
    HintFontName = 41,
    HintFontPts = 42,
    HintFontAttrib = 43,
    HintFontBold = 44,
    HintFontUnderline = 45,
    HintFontStrikeout = 46,
    FontName = 47,
    FontPts = 48,
    FontAttrib = 49,
    FontBold = 50,
    FontUnderline = 51,
    FontStrikeout = 52,
    HintText = 53,
    CreateEx = 54,
    ExStyle = 55,
    TabOrder = 56,
    DefaultXY = 57,
    XPM = 58,
    XPMmember = 59,
    Showcap = 60,
    InitialVal = 61,
    Local = 62,
    MultiSel = 63,
    ExtendSel = 64,
    MinValue = 65,
    MaxValue = 66,
    RBBSBREAK = 67,
    TwoIcoFile = 68,      --IcoFile 'hot' for FlatToolBar; close folder for TreeView
    TriIcoFile = 69,      --IcoFile 'disable' for FlatToolbar;open folder for TreeView
    TimerInt = 70,
    SetEvent = 71,
    SetControl = 72,
    KillEvent = 73,
    KillControl = 74,
    Clickable = 75,
    WinMainOpen = 76,
    WinPos = 77,
    Integers = 78,
    CCWinStyle = 79,
    WidthTitle = 80,    --specified title lengths for ListView
    ExtExStyle = 81,    --sendMessage list from ListView Explorer
    SelectWidth = 82,
    FontColor = 83,     --for RichEdit control only
    ToolRowCY = 84,     --the actual height of a 'row' in toolbar
    SystemBkColor = 85,
    WinPosTaskBar = 86,
    OutX = 87,
    OutY = 88,
    OutCX = 89,
    OutCY = 90,
    ControlComment = 91,
    MCS_multiselect = 92,
    PBS_smooth = 93,
    BS_flat = 94,
    DEFIndex = 95,
    SysTrayIcon = 96,
    SysTrayHint = 97,
    SysTrayText = 98,
    SuppressCell = 99,
    PreserveName = 100, --keep existing names in Table cells when add/remove
    FitToTable = 101,   --resize Table Control to contain all cells
    TableHScroll = 102, --add HScroll to Table Control
    TableVScroll = 103, --add VScroll to Table Control
    DontDraw = 104,     --when control is beyond fitting in Table control
    TableResizable = 105, --scrollable table control is resizable in exw
    SETLVInsert = 106,  --List View is built in order loaded
    LineChg = 107,              --small scroll change
    PageChg = 108,              --large scroll change
    Indexed = 109,      --this control when copied produces indexed controls
    IndexParent = 110,  --copyFrom control Name which created this index control
    SeqParentName = 111,    --this control's direct Parent Name
    SeqParentClass = 112, --this control's direct parent class
    SeqChildName = 113, --list of child controls for tis Parent
    GridRowHeaderCX = 114,--EuGrid width of row header EGW_ROW_HEADER_WIDTH
    GridColHeaderCY = 115,--EuGrid depth of column header  EGW_COL_HEADER_HEIGHT
    GridHeaderColor = 116,--EuGrid background color of headers EGW_HEADER_BACKGROUND_COLOR
    GridHeaderType = 117, --if header text is in a data column, 0, or -1 EGW_ROW_HEADER_DATACOL
    GridHeaderInCol = 118,--when GridHeaderType=1
    GridLineColor = 119,    --the color of lines between cells - EGW_LINE_COLOR
    GridBkColorRows = 120,--the color of columns in Grid, may be overridden by BkColor per column. EGW_BACKGROUND_COLOR
    GridRowCY = 121,        --default row size
    GridTextAlign = 122,    --left, center, right values
    GridFormat = 123,   --sequence printf format for numeric data
    GridTextColor = 124,
    GridColTextColor = 125,
    GridDataArrayName = 126,    --name under which grid array is created in Intro Event in Editor
    GridColListDataCol = 127, --column holding combo entries
    GridColListValues = 128,    --name of array holding combo entries
    GridRowSelect = 129,        --EGW_NONE or EGW_SINGLE
    GridActiveHeaders = 130,    --default=w32True
    GridAllowColResize = 131, --default=w32True
    GridAllowColSort = 132, --default=w32True
    GridCellBorder = 133,   --default=w32True
    GridHighlightText = 134,    --default=w32False
    GridCellBorderColor = 135,--color of border in columns
    GridTextColorSelect = 136,--color of selected text
    GridBkSelectColor = 137,    --color of background color select
    WinOpenAtCtrl = 138,        --name of control to open window with cursor at
    WinTransparency = 139,  --alphablend transparency of window (not of Win95/98)
    NoIntegralHeight = 140, --for List, ListView
    SysTrayHide = 141,      --user supplies sysTrayHide statement in window close procedure
    AdjCenter = 142,            --center text in edit controls
    AdjRight = 143,         --right adjust text in edit controls
    ControlLayer = 144,     --"layer" number
    ClassDefaults = 145,        --class defaults usually assigned by Window Style Explorer
    LastEditorEvent = 146,  --last event with code for a control
    SetLayerAll = 147,      --for Window control, check all control layer 0 setLayer checkbox
                            --now obsolete; may reuse this slot for something else later
    SetLayerOK = 148,       --for non Window control and layer 0 if can use setlayer routines
    TxtColor = 149,         --text color for EditText, labels and List controls
    UseInWinMain = 150,     --when checked, this window is used in WinMain() statement
LastListHeight = 151,           --used when switching DropDownList back to List or SortedList
                                                        --where IDE remembers the height of List before switching to DropDownList
LabelExtent = 152,              --specific to LabeledEdit control. width of auto generated label of control
ValueEdit = 153,                    --specific to labeledEdit control. Data for editbox portion of control
    TableGenInExw = 154,            --do not generate createEx in Proj.ew but instead generate in exw
    TableGenBorder = 155,       --use Group instead of LText in order for "border" around Table
    LabelSide = 156,                        --left or right side for LabelEdit "label"   
    OrigTitle = 157,                        --original caption for a control; used in Table generated in exw
    ParentIsFrozen = 158,       --user has altered parent cell in Properties. Ignore changes in Design for this control.
    ControlPartners = 159,      --list of controls than move in tandum with this control
    BkBarColor = 160,                   --tick bar color for ProgressBar
    PB_Caption_Pos = 161,       --position PushButton caption left, center or right (1,0,2)
    XpmObject = 162,                        --data for XPMmer
    ShowFontVar = 163,          --opens Font and HintFont cells for 'variable' data
    FontVarName = 164,          --the following are cells for 'variable' data
    FontVarPts = 165,
    FontVarItalic = 166,
    FontVarBold = 167,
    FontVarUnderline = 168,
    FontVarStrikeout = 169,
    FontVarColor = 170,
    ShowHintFontVar = 171,
    HintFontVarName = 172,
    HintFontVarPts = 173,
    HintFontVarItalic = 174,
    HintFontVarBold = 175,
    HintFontVarUnderline = 176,
    HintFontVarStrikeout = 177,
    HintVarText = 178,
    XpmDisableObject = 179,     --holds data from XPMmer for disabled icon. IDE will createEx a button for it.
    UpDownLeft = 180,                   --UpDown is Left of Buddy
    UpDownHorz = 181,                   --show UpDown horizontal
    TabsBottom = 182,                   --show TabControl tabs at bottom
CommonSetHandler = 183, --propagate setHandler from common control 1=row, 2=col, 0=none
CommonRow = 184,
CommonCol = 185,
GenFromName = 186,              --when creating cells in Table, save the cell1 name in each new coll. 
                                                        --This is for using CommonSetHandler expecially when multiple controls in cell1.
cbColor = 187,                  --Up color for colored button
cbCaptionColor = 188,   --Up Caption color
cbThickness = 189,              --Border Thickness
cbPressColor = 190,             --Down Color
cbPressCaptionColor = 191,--Down Caption Color
cbCaptionPos = 192,             --Caption Pos
cbGraphicPos = 193,             --Left, Center, Right placement of graphic on button
TableButtonAllColor = 194,--when checked user wants all Table buttons color of cell 1 Button                                                        
TableButtonAllCopy = 195, --when checked user wants all colored button data passed to all Table buttons
TreatAsColorButton = 196, --make this a colored button even if no color
cbMultiline = 197,
cbFlat = 198,
cbCentVert = 199,
setCreatefont = 200,                --when True use Window font in setCreateFont statement. For Window class only.
                                                        --ChildWindow?
MC_background = 201,
MC_text = 202,
    MC_titleBK = 203,
    MC_titleText = 204,
    MC_monthBK = 205,
    MC_trailingText = 206,

    ControlSize = 206

--------------------------------------------------------------------------------
--classes of controls
--first entry is the one that first shows in Property; others may be selected from dropdown
global constant ClassName = {
                             {"Bitmap","Pixmap"},
                             {"Icon"},
                             {"Group"},
                             {"LText","RText","CText"},
                             {"EditText"},
                             {"MleText"},
                             {"RichEdit"},
                             {"PushButton","PictureButton","ToggleButton","TogglePicture","DefPushButton","CancelButton"},
                             {"CheckBox","TriCheckBox"},
                             {"Combo","SortedCombo","SimpleCombo","ComboBoxEx"},
                             {"List","SortedList","DropDownList"},
                             {"HScroll","HTrackBar"},
                             {"ProgressBar"},
                             {"VScroll","VTrackBar"},
                             {"UpDown"},
                             {"TreeView"},
                             {"ListView"},
                             {"MonthCalendar"},
                             {"TabItem"},
                             {"ToolBar"},
                             {"StatusBar"},
                             {"Radio"},
                             {"Table"},
                             {"FlatToolBar"},
                             {"SepButton"},
                             {"ReBar"},
                             {"ReBarBand"},
                             {"EuGrid"},
                             {"LabelEdit"}
                            }

global constant WinlibClassName = {
                                   {Bitmap,Pixmap},
                                   {Icon},
                                   {LText,RText,CText},
                                   {EditText},
                                   {MleText},
                                   {RichEdit},
                                   {PushButton,PictureButton,ToggleButton,TogglePicture,DefPushButton},
                                   {CheckBox,TriCheckBox},
                                   {Combo,SortedCombo,SimpleCombo,ComboBoxEx},
                                   {List,SortedList,DropDownList},
                                   {HScroll,HTrackBar},
                                   {ProgressBar},
                                   {VScroll,VTrackBar},
                                   {UpDown},
                                   {TreeView},
                                   {ListView},
                                   {MonthCalendar},
                                   {TabItem},
                                   {ToolBar},
                                   {StatusBar},
                                   {Radio},
                                   {LText},
                                   {FlatToolBar},
                                   {SepButton},
                                   {ReBar},
                                   {ReBarBand},
                                   {PushButton},
                                   {EditText}
                                  }
--------------------------------------------------------------------------------
-- list of all the events, and their args, followed by SetHandler event name
global constant Events = {
                          {"(General)",     "", "(General)"},
                          {"onChange",      "()", "w32HChange"},
                          {"onClick",       "()", "w32HClick"},
                          {"onClose",       "()", "w32HClose"},
                          {"onDestroy",     "()", "w32HDestroy"},
                          {"onEvent",       "( integer iMsg, atom wParm, atom lParm )", "w32HEvent"},
                          {"onGotFocus",    "()", "w32HGotFocus"},
                          {"onKeyDown",     "( atom scanCode, atom shift )", "w32HKeyDown"},
                          {"onKeyPress",    "( integer keyCode, integer shift,integer released )", "w32HKeyPress"},
                          {"onKeyUp",       "( integer scanCode, integer shift )", "w32HKeyUp"},
                          {"onLostFocus",   "()", "w32HLostFocus"},
                          {"onMouse",       "( integer event, integer x, integer y, integer shift, integer wheelmove )", "w32HMouse"},
                          {"onOpen",        "()", "w32HOpen"},
                          {"onPaint",       "( integer x1, integer y1, integer x2, integer y2 )", "w32HPaint"},
                          {"onScroll",      "( integer pos )", "w32HScroll"},
                          {"onResize",      "( integer style, integer cx, integer cy )", "w32HResize"},
                          {"onTimer",       "( integer timerId )", "w32HTimer"},
                          {"onActivate",    "()", "w32HActivate"},
                          {"onDragAndDrop", "( integer id, sequence FileName )", "w32HDragAndDrop"},
                          {"(Intro)",       "", "(Intro)"},
                          {"(Final)",       "", "Final"},
                          {"(Begin)",       "", "Begin/Version"},
                          {"onAfterEvent",  "( atom winmsg, atom wParam, atom lParam, atom lWinReturn )", "w32HAfterEvent"},
                          {"onDropDown",    "()", "w32HDropDown"},
                          {"onCloseUp",     "()", "w32HCloseUp"},
                          {"onMouseTrap",   "( integer event, integer x, integer y, integer z, sequence traps, integer id, integer shift )", "w32HMouseTrap"},
                          {"onKeyboard",    "( sequence virtual_codes,sequence extended_flags,sequence scan_codes,sequence repeat_count,sequence shifts )", "w32HKeyboard"}
--It is very IMPORTANT when a new event is added that IDE_orderEvents.ew has enough slots.
--Do not rearrange the entries in the table as there is a file read in if user had unchecked any Event.

--Also you need to add the new event to IDE_Code.ew controlEventPairing. Read the paragraph before this
--sequence to understand how you can rearrange the events showing in Code Editor event dropdown. The
--event order in the project file does not change -- it is the same order as the above events.
                         }
--------------------------------------------------------------------------------
global integer
    Intro, Final, Begin             --occurance in table above
    Intro = 20
    Final = 21
    Begin = 22

-- the indexes to MasterList/Control List below
global constant
    ControlId           = 1,    -- the id of the control
    ControlX            = 2,    -- x position of control
    ControlY            = 3,    -- y position of control
    ControlClass        = 4,    -- Win32 name of control
    ControlCX           = 5,    -- default cx size
    ControlCY           = 6,    -- default cy size
    ControlName         = 7,    -- in configurations user may change defualt Name
    ControlTitle        = 8,    -- ditto but Title (Caption)
    ControlButton       = 9             -- associated button name from ToolKit

-- the controls
global sequence MasterList          --creates emulated control when selected and dropped on Design

MasterList = {
--    button id           x       y       class        x       y
              {"Pointer",         33,     03,     "Edit",     100,    100,"","",TheWindow},
              {"Bitmap",          33,     03,     "Bitmap",   100,    150,"","",TheBitmap},
              {"Icon",            33,     03,     "Icon",     100,    150,"","",TheIcon},
              {"Label",           63,     03,     "LText",    150,    20,"","",TheLText},
              {"Edit Text",       93,     03,     "EditText", 150,    20,"","",TheEditText},
              {"Mle Text",        93,     03,     "MleText",  150,    150,"","",TheMle},
              {"Rich Edit",       93,     03,     "RichEdit", 150,    150,"","",TheRichEdit},
              {"Group",           123,    03,     "Group",    150,    60,"","",TheGroup},
              {"Pushbutton",      153,    03,     "PushButton",90,    30,"","",ThePushButton},
              {"Check Box",       183,    03,     "CheckBox", 150,    20,"","",TheCheckBox},
              {"Radio",           213,    03,     "Radio",    150,    20,"","",TheRadio},
              {"Combo",           243,    03,     "Combo",    150,    20,"","",TheCombo},
              {"List",            273,    03,     "List",     150,   120,"","",TheList},
              {"H Scroll",        303,    03,     "HScroll",  150,    20,"","",TheHScroll},
              {"Progress",        303,    03,     "ProgressBar",  150,    20,"","",TheProgress},
              {"V Scroll",        333,    03,     "VScroll",   20,    150,"","",TheVScroll},
              {"Calendar",        03,     03,     "MonthCalendar", 250, 200,"","",TheCalendar},
              {"Tool Bar",        03,     03,     "ToolBar",   500,    34,"","",TheToolBar},
              {"Tool Bar Spacer",  03,    03,     "None",        5,    34,"","",TheNone},
              {"Status Bar",      03,     03,     "StatusBar", 388,    23,"","",TheStatusBar},
              {"Tab Control",     03,     03,     "TabControl", 150,   60,"","",TheTabControl},
              {"Tab Item",        03,     03,     "TabItem",    150,   60,"","",TheTabItem},
              {"Tree View",       03,     03,     "TreeView",   150,   200,"","",TheTreeView},
              {"List View",       03,     03,     "ListView",   203,   200,"","",TheListView},
              {"Up/Down",         03,     03,     "UpDown",     28,     30,"","",TheUpDown},
              {"Table",           03,     03,     "Table",      200,    50,"","",TheTable},
              {"Flat Bar",        03,     03,     "FlatToolBar",500,    48, "","",TheFlatBar},
              {"Sep Button",      03,     03,     "SepButton",  08,     32, "","",TheSepButton},
              {"ReBar",           03,     03,     "ReBar",      500,    21, "","",TheReBar},
              {"ReBar Band" ,     03,     03,     "ReBarBand",  500,    14, "","",TheReBarBand},
              {"CWindow",         03,     03,     "CWindow",    200,   100,"","",TheChildWindow},
              {"EuGrid",          03,     03,     "EuGrid",     200,   150,"","",TheEuGrid},
              {"LabelEdit",       03,     03,     "LabelEdit",  48,     20,"","",TheLabelEdit},
              {"ColorButton",     03,     03,     "ColorButton", 90,     30,"","",TheColoredButton}
             }
    --use user's system to determine scrollbar thumb width:
    MasterList[14][ControlCX] = scrollWide
    MasterList[16][ControlCY] = scrollWide

    --initialize Name and Title (Caption) from Class 
    for i=1 to length(MasterList) do
        MasterList[i][ControlName] = MasterList[i][ControlClass]
        MasterList[i][ControlTitle] = MasterList[i][ControlClass]
    end for

global sequence ControlList
    ControlList = {}
--------------------------------------------------------------------------------
global sequence validColors
validColors = {
               "User Color",
               "BTNFACE",
               "WINDOW",
               "SCROLLBAR",
               "BACKGROUND",
               "DESKTOP",
               "ACTIVECAPTION",
               "INACTIVECAPTION",
               "MENU",
               "WINDOWFRAME",
               "MENUTEXT",
               "WINDOWTEXT",
               "CAPTIONTEXT",
               "ACTIVEBORDER",
               "INACTIVEBORDER",
               "APPWORKSPACE",
               "HIGHLIGHT",
               "HIGHLIGHTTEXT",
               "3DFACE",
               "BTNSHADOW",
               "3DSHADOW",
               "GRAYTEXT",
               "BTNTEXT",
               "INACTIVECAPTIONTEXT",
               "BTNHIGHLIGHT",
               "3DHILIGHT",
               "3DDKSHADOW",
               "3DLIGHT",
               "INFOTEXT",
               "INFOBK",
               "TOOLTIPBK"
              }

global sequence numColors
numColors = {
             0,
             COLOR_BTNFACE,
             COLOR_WINDOW,
             COLOR_SCROLLBAR,
             COLOR_BACKGROUND,
             COLOR_DESKTOP,
             COLOR_ACTIVECAPTION,
             COLOR_INACTIVECAPTION,
             COLOR_MENU,
             COLOR_WINDOWFRAME,
             COLOR_MENUTEXT,
             COLOR_WINDOWTEXT,
             COLOR_CAPTIONTEXT,
             COLOR_ACTIVEBORDER,
             COLOR_INACTIVEBORDER,
             COLOR_APPWORKSPACE,
             COLOR_HIGHLIGHT,
             COLOR_HIGHLIGHTTEXT,
             COLOR_3DFACE,
             COLOR_BTNSHADOW,
             COLOR_3DSHADOW,
             COLOR_GRAYTEXT,
             COLOR_BTNTEXT,
             COLOR_INACTIVECAPTIONTEXT,
             COLOR_BTNHIGHLIGHT,
             COLOR_3DHILIGHT,
             COLOR_3DDKSHADOW,
             COLOR_3DLIGHT,
             COLOR_INFOTEXT,
             COLOR_INFOBK,
             COLOR_TOOLTIPBK
            }
--procedure GetDefaults()
--object lDefaults
--
--  -- Hardcoded defaults.
--  theDefaultFont = setCreateFont("Times New Roman", 10, Normal, 0)
--  lDefaults = setCreateFont(theDefaultFont[1],theDefaultFont[2],theDefaultFont[3],theDefaultFont[4])
--end procedure

global sequence controlsWithOutColor
controlsWithOutColor = {"ToolBar","PushButton","ToggleButton","DefPushButton",
                "TogglePicture","PictureButton","CancelButton",
                "MonthCalendar","TabControl","TabItem",
                "FlatToolBar","SepButton","ReBar","ReBarBand","None",
                "Bitmap","UpDown","Combo","SimpleCombo",
                "SortedCombo","ComboBoxEx","ListView"}
----------------------------------------------------------------------------------
--                                Launcher declarations                        
----------------------------------------------------------------------------------
setText(splashLoadInfo, "Initializing Launcher...")
global integer LaunchItemId

-- fieldnames of AppFiles, partly IDElvItems
global constant
L_AppItem            = 1,
L_AppItemId          = 2,
L_AppTitle           = 3,
L_AppFileName        = 4,
L_AppHotkey          = 5,
L_AppStartDir        = 6,
L_AppArgs            = 7

global constant AppFields = 7

global object AppFiles
AppFiles = repeat({{},{},{},{},{},{},{}},10)
--------------------------------------------------
procedure LaunchItemId_onClick(integer self, integer event, sequence params)
integer Id, item, what_happens, pos, msg
sequence argument, text, directory, application, temp

    Id = getSelf()

    for x=1 to 10 do
        if atom(AppFiles[x][L_AppItemId]) and AppFiles[x][L_AppItemId]=Id then
            item = x
            exit
        end if
    end for
    if match("&appd",AppFiles[item][L_AppStartDir]) then
        directory = reverse(AppFiles[item][L_AppFileName])
        pos = find('\\', directory)
        directory = reverse(directory[pos+1..length(directory)])
    elsif match("&pd",AppFiles[item][L_AppStartDir]) then
        directory = projectDir
    elsif match("&ide",AppFiles[item][L_AppStartDir]) then
        directory = the_current_dir
    else
        directory = AppFiles[item][L_AppStartDir]
    end if

    argument = " "
    application = AppFiles[item][L_AppFileName]
    if equal(".exw", lower(application[length(application)-3..length(application)])) or
       equal(".ex",  lower(application[length(application)-2..length(application)])) then
        argument = application & " "
        application = "exw.exe"
    end if
    if length(AppFiles[item][L_AppArgs]) then
        if match("&p", AppFiles[item][L_AppArgs]) then
            -- project file
            if length(openFileName) then
                argument &= openFileName
            else
                ok = displayErrorMessage(214,{})
                return
            end if
        elsif match("&e", AppFiles[item][L_AppArgs]) then
            -- created exw / ew file
            if length(openFileName) then
                temp = reverse(openFileName)
                -- remove project type
                pos = find('.', temp)
                temp = reverse(temp[pos..length(temp)])
                if not treatAsInclude then
                    argument &= temp & "exw"
                else
                    argument &= temp & "ew"
                end if
            else
                ok = displayErrorMessage(214,{})
                return
            end if
        else
          -- selected file
            argument &= AppFiles[item][L_AppArgs]
        end if
    end if

    what_happens = shellExecuteEx("open",
    -- with the program to call:
                                  application,
    -- the parameter to pass to application to run:
                                  argument ,
    -- in this directory:
                                  directory ,
    -- and last, the 'show' parameter:
                                  SW_SHOW, 0)

    if what_happens<33 then
        if what_happens=2 then
            text = " Application not found!"
        elsif what_happens=31 then
            text = " Application / Document not associated!"
        else
            text = "Strange error!"
        end if
        msg = displayErrorMessage(207,{sprint(what_happens),text})
        return
    end if

end procedure
--------------------------------------------------
global procedure addLauncherMenu()
integer nr

    --add menu
    nr = 7
    for x=1 to 10 do
        if length(AppFiles[x][L_AppItem]) then
            nr += 1
            LaunchItemId = createEx(MenuItem, AppFiles[x][L_AppTitle] &
                                    '\t' &  AppFiles[x][L_AppHotkey] , LaunchMenu, 0, nr , 0, 0, 0, 0)
            setHandler(LaunchItemId, w32HClick, routine_id("LaunchItemId_onClick"))
            AppFiles[x][L_AppItemId] = LaunchItemId
        end if
    end for
end procedure
-----------------------------------------------------------------------------
--   set Font and color for emulated controls
----------------------------------------------------------------------------
global procedure setMenuFont()
    setTextColor(ControlBlit, TextColor)
    setFont(ControlBlit, "Arial", 9, Normal)
end procedure

global procedure setControlFont()
    setTextColor(ControlBlit, TextColor)
    setDefaultFont(ControlBlit)
    setTextColor(OffScreenBlit, TextColor)
    setDefaultFont(OffScreenBlit)
end procedure
------------------------------------------------------------------------------
global function getRelRect(integer id , integer id2)

     -- Martin Stachon: getRelRect
     -- same as getRect but return relative to id2
     -- returns { left, top, bottom, right }

atom struct, mset
sequence retval,xy

    if not validId(id) then
      -- bad id
        return {0,0,0,0}
    end if

    retval = {0, 0, 0, 0}
    mset = w32new_memset()

    -- Allocate a buffer to hold the rectangle information
    struct  = w32acquire_mem(mset, SIZEOF_RECT)

    -- load rectangle information into the buffer
    if not w32Func(xGetWindowRect, {getHandle(id), struct}) then
        -- ERROR
        abortErr("getRelRect Failed !")
    end if

    -- get points
    retval[1] = w32fetch(struct, rectLeft)
    retval[2] = w32fetch(struct, rectTop)
    retval[3] = w32fetch(struct, rectRight)
    retval[4] = w32fetch(struct, rectBottom)

    -- add id2
    if validId(id2) then

        xy = ClientToScreen(id2, 0, 0)

        -- adjust points
--/**/  retval = sq_sub(retval,(xy & xy))               --/* -- Phix
        retval -= (xy & xy)                             --*/ -- RDS

    end if

    -- Return any memory blocks used.
    w32release_mem(mset)

    -- return values
    return retval -- { left, top, right+1, bottom+1 }

end function
-------------------------------------------------------------------------------
global function Replace(sequence s, sequence old, sequence new)
        -- from David Cuny
-- replace substring in sequence

integer at
sequence s1

    s1 = ""

    while 1 do

        -- look for target
        at = match(old, s)
        if at=0 then
            -- no more replacements
            exit
        end if

        -- accumulate in s1
        s1 &= s[1..at-1] & new

        -- remove from s
        s = s[at+length(old)..length(s)]

    end while

    return s1 & s

end function
------------------------------------------------------------------------------
global function w32findKeyAny(object key,sequence list, integer occurance)
    for i=1 to length(list)do
        if equal(list[i][occurance],key)then
            return i
        end if
    end for
    return 0
end function
----------------------------------------------------------------------------
procedure buildChildrenList(integer index)
integer cnt

    cnt = 0
    for i=index to length(controls) do
        if find(controls[i][Name],controls[index][SeqChildName]) then
            cnt += 1
            childrenList &= {controls[i][Name]}
            if length(controls[i][SeqChildName]) then
                buildChildrenList(i)
            end if
            if cnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end if
    end for
end procedure
-----------------------------------------------------------------------------
function inside2(sequence control, integer x, integer y)
    -- return w32True if point is inside the control

    -- hit test
    if x>control[X]
    and y>control[Y] then
        if x<control[X]+control[CX]-1
        and y<control[Y]+control[CY]-1 then
            return 1
        end if
    end if
    return 0

end function
------------------------------------------------------------------------------
global function inControl(integer x, integer y)

-- return the index of the control the point is in
integer flag

    -- default is design window
    flag = TheWindow

    -- scan all controls
    for i=1 to length(controls) do
        if  not equal(controls[i][Class], "Window")
        and not controls[i][DontDraw]
        and inside2(controls[i], x, y)
        and controls[i][ControlLayer]=layerNumber then

            --if clicked in a tabitem check for the right one
            --remember they all occupy the same 'space' and only the
            --TabItemCombo designates the currectly active one.

            if length(controls[i][ControlParent]) then
                --had a parent. If that parent is TabItem, check to be sure
                --it is the correct one.
                if equal(controls[i][ParentClass], "TabItem") then
                    --make sure it matches the selectedTabItem
                    if equal(controls[i][ControlParent], selectedTabItem)
                    and controls[i][Active] then
                        flag = i
                    else

                        --if the selectedTabItem is, for ex, a member of
                        --tabContol1 and the one we try
                        --to select is a member of tabControl2, then this
                        --routine will think we are
                        --selecting the tabControl1. So find the parent of the
                        --selectedTabItem and if
                        --it is different from the tabItem we selected, use
                        --this one. Then we need to
                        --look at the tabItems for the tabcontrol to see which
                        --one is active.

                        --is this tabItem the active one
                        for j=1 to length(controls) do
                            if equal(controls[j][Name],
                                     controls[i][ControlParent])
                            and controls[j][Active]then
                                flag = i
                            end if
                        end for

                    end if
                elsif equal(controls[i][ParentClass], "TabControl") then
                    --make sure it matches the selectedTabItem
                    if equal(controls[i][Name], selectedTabItem)
                    and controls[i][Active] then
                        flag = i
                    else
                        --is this tabitem an active one?
                        if controls[i][Active] then
                            flag = i
                        end if
                    end if
                else
                    flag = i
                end if

            else
                --a control without a parent
                flag = i
            end if
        end if
    end for

    return flag

end function
-------------------------------------------------------------
global function findDirectParent(integer x, integer y, sequence testparent,
        sequence name, integer index)

integer theControlParentIs--,flag
sequence theParentClassIs

    childrenList = {}

    if index   --will be 0 for a new control
    and length(controls[index][SeqChildName]) then
        --build a list of children of this control & the childrens's children
        buildChildrenList(index)
    end if

    --find the direct parent (excluding the window and TabControl) of the control
    --return the index of the parent the control is in

    theControlParentIs = 0
    theParentClassIs = {}

    x += 1
    y += 1

    -- scan all controls
    for i=1 to length(controls) do
        if  not find(controls[i][Class], {"Window","TabControl"})
        and not equal(controls[i][Name], name) --it is itself
        and not find(controls[i][Name], childrenList)   --it is one of its children
        and inside2(controls[i], x, y)
        and (not controls[i][ControlLayer]
             or controls[i][ControlLayer]=controls[selectedControl][ControlLayer]) then--layerNumber) then                                              
            if find(controls[i][Class], {"Group","Table",
                                         "LText","CText","RText","EuGrid"}) then
                if equal(controls[i][ParentClass], "TabItem") then
                    if equal(controls[i][ControlParent], testparent) then
                        --must be in the same tabitem
                        theControlParentIs = i
                        theParentClassIs = controls[i][Class]
                    end if
                else
                    theControlParentIs = i
                    theParentClassIs = controls[i][Class]
                end if
            elsif equal(controls[i][Class], "StatusBar")
               or equal(controls[i][Class], "ToolBar")
               or equal(controls[i][Class], "FlatToolBar")
               or equal(controls[i][Class], "ReBar")
               or equal(controls[i][Class], "ReBarBand")
               or equal(controls[i][Class], "CWindow")
               or ( equal(controls[i][Class], "TabItem")
                   and equal(controls[i][Name], selectedTabItem) )
              then
                theControlParentIs = i
                theParentClassIs = controls[i][Class]
            end if
        end if
    end for

    return {theControlParentIs,theParentClassIs}
end function
-------------------------------------------------------------------------------
global function findSeqParentName(integer index)
integer flag

    flag = 0
    if length(controls[index][SeqParentName]) then
        for j=index to 1 by -1 do
            if equal(controls[j][Name], controls[index][SeqParentName]) then
                flag = j
                exit
            end if
        end for
    end if
    return flag
end function
--------------------------------------------------------------------------------
global function testLabelEditCaption(integer index)
integer answer,flag, x1, y1, cx, cy, x2, y2, nx1
sequence textLen
    x1 = controls[index][X]-WinX
    y1 = controls[index][Y]-WinY+(MenuY+TitleY)
    cx = controls[index][CX]
    cy = controls[index][CY]
    x2 = x1+cx-1
    y2 = y1+cy-1

    answer = w32False
    flag = findSeqParentName(index)
    textLen = getTextExtent(ControlBlit, controls[index][Title])

    --figure placement of text to left or right
    if controls[index][LabelSide]=0 then
        nx1 = x1-textLen[1]
        if flag then
            --if caption width expands past edge of parent, give warning                                    
            if nx1<controls[flag][X] then
                answer = w32True
            end if
        end if
    else
        nx1 = x2
        if flag then
            --if caption width expands past edge of parent, give warning                                            
            if nx1+textLen[1]>controls[flag][X]+controls[flag][CX] then
                answer = w32True
            end if
        end if
    end if

    return answer
end function
-----------------------------------------------------------------------------
include includes\ide_projectview.ew
------------------------------------------------------------------------------
global procedure newWindow(sequence name, sequence title,
                                integer cx, integer cy)
sequence control,layerTabInfo,slot

-- initial values
    MenuY               = 0         -- no menu in window
    selectedControl     = TheWindow -- no control selected
    state               = Normal    -- mouse not in a mode
    mouseDown           = 0         -- mouse button not held down
    selectedTabItem     = {}        -- no TabControl/TabItems yet
    hasPopup            = w32False

    -- create a new window, always the first item in the list

    -- allocate space for a control
    control = repeat(0, ControlSize)
    counter += 1
    counterInWindow = 0     --reset tab order counter
    -- turn it into a window
    control[Id]     = counter
    control[Class]  = "Window"
    control[SubClass] = ""
    control[CX]     = cx
    control[CY]     = cy
    control[Title]  = title
    control[Name]   = name

    --add to sequence for colorization
    controlNameKeywords &= {control[Name]}

    control[ControlParent] = ""
    control[ParentClass] = ""
    control[Parent] = ""
    control[StyleType] = {}
    control[Visible] = w32True
    control[EnableC] = w32True
    control[Buddy] = ""
    control[IcoFile] = ""
    control[TwoIcoFile] = ""
    control[TriIcoFile] = ""
    control[BitmapFile] = ""
    control[FontName] = theDefaultFont[1]--""
    control[HintFontName] = theDefaultFont[1]--""
    control[FontPts] = theDefaultFont[2]
    control[HintFontPts] = theDefaultFont[2]
    control[HintText] = ""
    control[ExStyle] = "0"
    control[XPM] = ""
    control[XPMmember] = ""
    control[InitialVal] = {}
    control[SetEvent] = ""
    control[SetControl] = ""
    control[KillEvent] = ""
    control[KillControl] = ""
    control[CCWinStyle] = ""
    control[WidthTitle] = {}
    control[ExtExStyle] = {}
    control[SelectWidth] = {}
    control[SystemBkColor] = {}
    control[OutX] = {}
    control[OutY] = {}
    control[OutCX] = {}
    control[OutCY] = {}
    control[ControlComment] = {}
    control[DEFIndex] = {}
    control[SysTrayIcon] = {}
    control[SysTrayHint] = {}
    control[SysTrayText] = {}
    control[IndexParent] = {}
    control[SeqParentName] = {}
    control[SeqParentClass] = {}
    control[SeqChildName] = {}
    control[GridFormat] = {}
    control[GridDataArrayName] = {}
    control[GridColListValues] = {}
    control[WinOpenAtCtrl] = {}
    control[ClassDefaults] = {}
    control[ValueEdit] = {}
    control[OrigTitle] = {}
    control[ControlPartners] = {}
    control[XpmObject] = {}
    control[FontVarName] = {}
    control[FontVarPts] = {}
    control[FontVarItalic] = {}
    control[FontVarBold] = {}
    control[FontVarUnderline] = {}
    control[FontVarStrikeout] = {}
    control[HintFontVarName] = {}
    control[HintFontVarPts] = {}
    control[HintFontVarItalic] = {}
    control[HintFontVarBold] = {}
    control[HintFontVarUnderline] = {}
    control[HintFontVarStrikeout] = {}
    control[FontVarColor] = {}
    control[HintVarText] = {}
    control[XpmDisableObject] = {}
    control[GenFromName] = {}

    if saveLocal then
        control[Local] = w32True
    end if

    if equal(control[Class], "Window") then
        control[BkColor] = getSysColor(COLOR_BTNFACE)
        control[SystemBkColor] = "BTNFACE"
    end if

    control[Code]   = repeat({}, length(Events))

    -- set as control list
    controls = {control}

    --resize the Design window
    setRect(Design, dX, dY, cx, cy, w32True)
    dCX = cx
    dCY = cy

    --add layer information for this window
    slot = {"",0,0,0}
    slot[1] = IDEText[984][1] & " 0"
    layerTabInfo = {slot}
    layerCaptionSeq &= {layerTabInfo}

    --flag that had updates
    if winCounter>1 then
        IDE_Changed = w32True
    end if

    --show the window properties
    delayDraw = w32True
    selectedControl = TheWindow
    windows &= {controls}
    selectedWindow = length(windows)
--
    call_proc(updateProperties_id,{})
    delayDraw = w32False

end procedure
-----------------------------------------------------------------------------
global function val(sequence s)
        --from David Cuny
    -- converts s into a number
    s = value(s)
    return s[2]
end function
-------------------------------------------------------------------------------
global procedure addToParentChildSeq(integer parentindex, sequence name)
    if not parentindex
    or parentindex=1 then
        --Window does not carry children
        return
    end if
    if length(controls[parentindex][SeqChildName]) then
        if find(name, controls[parentindex][SeqChildName]) then
            --already there don't duplicate
            return
        end if
        controls[parentindex][SeqChildName] &= {name}
    else
        controls[parentindex][SeqChildName] &= {name}
    end if
end procedure
-------------------------------------------------------------------------------
function trims(sequence text)
integer start, finish

    start = 1
    finish = length(text)
    --now trim text at right
    for i=length(text) to 1 by -1 do
        if text[i]!=' ' then
            finish = i
            exit
        end if
    end for

    --now trim text from left
    for i=1 to finish do
        if text[i]!=' ' then
            start = i
            exit
        end if
    end for

    return text[start..finish]
end function
-------------------------------------------------------------------------------
function clean_the_text(sequence text)
integer at
    --clean up the names list
    text = trims(text)
    if match("global", text)
    or match("export", text) then
        at = match("global", text)
        if at then
            text = text[1..at-1] & text[at+6..length(text)]
        end if
        at = match("export", text)
        if at then
            text = text[1..at-1] & text[at+6..length(text)]
        end if
    end if
    if match("constant", text) then
        at = match("constant", text)
        if at then
            text = text[1..at-1] & text[at+8..length(text)]
        end if
    end if
    if match("{", text) then
        text = text[1..length(text)-1]
        text = trims(text)
        if match("=", text) then
            text = text[1..length(text)-1]
            text = trims(text)
        end if
    end if

    return {text}
end function
-------------------------------------------------------------------------------
function betweenQuotes(sequence text)
integer at, at2, at3

    at = find('"', text)
    if at then
        text = text[1..at-1] & " " & text[at+1..length(text)]
        at2 = find('"', text)
        if at2 then
            --check special case }
            at3 = find('}', text)
            if at3 then
                if at3<at2 then
                    return 1
                else
                    return 2
                end if
            else
                return 1
            end if
        else
            return 0
        end if
    else
        return 0
    end if

end function
-------------------------------------------------------------------------------
function getXpmMembers(sequence XPMfName)
--thanks to Derek Parnell for helping me with this routine
integer handle, at, answer
object text
integer eof, XPMI, Continue
sequence XPMs
sequence XPMNames

    XPMs = {}
    XPMNames = {}

    eof = w32False

    handle = open(XPMfName, "r")
    if handle= -1 then
        -- give message and exit
        return {"",""}
    end if

    -- parse the file
    while not eof do

        -- get a line of text
        text = gets(handle)
        if atom(text) then
            exit   --EOF
        end if

        -- remove line feed
        if text[length(text)]='\n' then
            text = text[1..length(text)-1]
        end if
        text = trims(text)

        if length(text) then
            at = find('{', text)
            if at then
                answer = betweenQuotes(text)
                if answer then
                    Continue = w32False
                elsif answer=2 then
                    Continue = w32False
                else
                    Continue = w32True
                end if
            else
                Continue = w32False
            end if
        else
            --Virtual B.
            Continue = w32True
        end if

        if Continue=w32True then
            text = clean_the_text(text)
            XPMNames &= text
            XPMs = append(XPMs, {})
            XPMI = length(XPMs)

        -- If ONLY we had a "continue" statement, this would look a lot cleaner.
        elsif length(XPMs)!=0 then
            text = trims(text)
            at = find('{', text)
            if at then
                answer = betweenQuotes(text)
                if not answer then
                    text = text[at+1..length(text)]
                end if
            end if
            text = trims(text)
            if length(text)>0 then
                if text[1]='"' then
                    text = text[2..length(text)]
                    at = find('"',text)
                    if at then
                        text = text[1..at-1]
                    end if
                end if
                if length(text)>0 then
                    XPMs[XPMI] = append(XPMs[XPMI], text)
                end if
            end if
        end if
    end while
    close(handle)

    return {XPMNames,XPMs}
end function
--------------------------------------------------------------------------
global procedure deleteResource(sequence control, sequence resource)
    if not length(controlResource) then
        return
    end if

    --find control-handle in controlResource and remove
    for i=1 to length(controlResource) do
        if equal(control, controlResource[i][1])
        and equal(resource, controlResource[i][2]) then
            deleteObject(controlResource[i][3])
            controlResource = controlResource[1..i-1]
                              & controlResource[i+1..length(controlResource)]
            exit
        end if
    end for
end procedure
----------------------------------------------------------------------------------------
procedure deleteAllResources()
    if length(controlResource) then
        for i=1 to length(controlResource) do
            if length(controlResource[i][1]) then
                deleteObject(controlResource[i][3])
            end if
        end for
        controlResource = {}
    end if
end procedure
---------------------------------------------------------------------------------------
procedure deleteSelectedWindowResource(integer selectedWindow)
    if length(controlResource) then
        for i=1 to length(windows[selectedWindow]) do
            for j=1 to length(controlResource) do
                if equal(windows[selectedWindow][i][Name], controlResource[j][1]) then
                    deleteObject(controlResource[j][3])
                    controlResource[j][1] = {}
                end if
            end for
        end for
    end if
end procedure
----------------------------------------------------------------------------------------
global procedure addResource(sequence control, sequence resource, sequence class, sequence member)
object whereIs, theBmp
integer at
atom hBitmap, hXpm
sequence theresource, findXpmMembers
object res
sequence xpm
integer fh, ch

    if equal(class, "Bitmap") then
        if length(resource) then
            whereIs = dir(resource)
            if sequence(whereIs) then
                --don't try to use until have full name
                at = match(".bmp",lower(resource))
                if at then
                    hBitmap = loadBitmapFromFile(resource)
                    theresource = {0,"",0}
                    theresource[1] = control
                    theresource[2] = resource
                    theresource[3] = hBitmap
                    controlResource &= {theresource}
                end if
            end if
        end if

    elsif equal(class, "XpmObject")
      and length(resource) then
        -- transparent colors are converted to the button color
        setTransparentColor(getSysColor(COLOR_BTNFACE))
        theBmp = xpmToEuBmp(resource)
        if atom(theBmp) then
                --can't draw it                                                  
        else
            -- create to dib
            hXpm = createDIB({theBmp[1],theBmp[2]})
            theresource = {0,"",0}
            theresource[1] = control
            theresource[2] = resource
            theresource[3] = hXpm
            controlResource &= {theresource}
        end if

    elsif equal(class, "XpmDisableObject")
      and length(resource) then
        -- transparent colors are converted to the button color
        setTransparentColor(getSysColor(COLOR_BTNFACE))
        theBmp = xpmToEuBmp(resource)
        if atom(theBmp) then
                --can't draw it                                                  
        else
            -- create to dib
            hXpm = createDIB({theBmp[1],theBmp[2]})
            theresource = {0,"",0}
            theresource[1] = control
            theresource[2] = resource
            theresource[3] = hXpm
            controlResource &= {theresource}
        end if

    elsif equal(class, "XPM")
      and length(resource)
      and match(".xpm", lower(resource)) then
        -- transparent colors are converted to the button color
        setTransparentColor(getSysColor(COLOR_BTNFACE))
        whereIs = dir(resource)
        if sequence(whereIs) then
            --don't try to use until have full name
            theBmp = readXpm(resource)
            if atom(theBmp) then
                    --can't draw it
                    --this may be an Andy Drummond style xpm                    
                --try alternate read from IDE_xpmmer
                fh = open(resource, "r")
                res = ""
                ch = getc(fh)
                while ch!='{' do
                    res &= ch
                    ch = getc(fh)
                    if ch= -1 then
                        return
                    end if
                end while
                if match("XPM", res)=0 then
                    return
                end if
                res = ""
                while True do
                    if ch>=' ' then
                        res &= ch
                    end if
                    ch = getc(fh)
                    if ch= -1 then
                        close(fh)
                        exit
                    end if
                end while
                res = value(res)
                if res[1]!=GET_SUCCESS then
                    return
                end if
                close(fh)
                xpm = res[2]
                --see if get resource now
                theBmp = xpmToEuBmp(xpm)
                if atom(theBmp) then
                                                --still can't draw                                                                      
                else
                    -- create to dib
                    hXpm = createDIB({theBmp[1],theBmp[2]})
                    theresource = {0,"",0}
                    theresource[1] = control
                    theresource[2] = resource
                    theresource[3] = hXpm
                    controlResource &= {theresource}
                end if
            else
                --this is a David Cuny style xpm
                -- create to dib
                hXpm = createDIB(theBmp)
                theresource = {0,"",0}
                theresource[1] = control
                theresource[2] = resource
                theresource[3] = hXpm
                controlResource &= {theresource}
            end if
        end if

    elsif equal(class, "XPM")
      and not match(".xpm", lower(resource))
      and length(member)
      and length(resource) then
        findXpmMembers = getXpmMembers(resource)
        if not length(findXpmMembers[1]) then
            --do nothing error or not found
        else
            for i=1 to length(findXpmMembers[1]) do
                if equal(member, findXpmMembers[1][i]) then
                    hXpm = xpmToPixmap(findXpmMembers[2][i])
                    theresource = {0,"",0}
                    theresource[1] = control
                    theresource[2] = resource
                    theresource[3] = hXpm
                    controlResource &= {theresource}
                    exit
                end if
            end for
        end if
    end if
end procedure
--------------------------------------------------------------------------------
global procedure change_LayerTI(integer Self, integer Event, sequence Params)
atom lastTabItem
sequence lValues, text, textback

--get active tabitem
    lastTabItem = getTabItem(LayersTC)

    --get number
    lValues = getUserProperty(lastTabItem, "layer")
    if length(lValues) then
        layerNumber = lValues[1][1]
    end if

    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        if layerNumber=layerCaptionSeq[selectedWindow][i][3] then
            setCheck(MenuTabAllUseLayer,layerCaptionSeq[selectedWindow][i][4])
            exit
        end if
    end for

    if layerNumber=0 then
        setText(Form, "Form Design")
        setEnable(PopUpDesign_Layers, w32False)
    else
        setEnable(PopUpDesign_Layers, w32True)
        if length(showBackLayer) then
            text = "Form Design: Background Layers = "
            for i=1 to length(showBackLayer) do
                if i>1 then
                    text &= ", "
                end if
                --use tab's caption
                textback = {}
                for j=1 to length(layerCaptionSeq[selectedWindow]) do
                    if showBackLayer[i]=layerCaptionSeq[selectedWindow][j][3] then
                        textback = layerCaptionSeq[selectedWindow][j][1]
                        exit
                    end if
                end for
                if length(textback) then
                    text &= textback
                else
                    text &= sprint(showBackLayer[i])
                end if
            end for
            setText(Form, text)
        else
            setText(Form, "Form Design")
        end if
    end if

    --clear window of any .ico and .bmp showing
    for i=1 to length(iconStrings) do
        iconData = iconStrings[i]
        if validId(iconData[2]) then
            destroy(iconData[2])
        end if
    end for
    iconStrings = {}

    --now build design with controls matching this layer
    selectedControl = TheWindow
    call_proc(updateProperties_id,{})
    setIndex(PropertyTitleBar, 1)
    call_proc(drawIt_id,{})

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)

        --draw all controls now

end procedure
---------------------------------------------------------------------------
-- Derek Parnell supplied this:
constant
    IDE_TCHITTESTINFO_ptX       = w32allot(Long),
    IDE_TCHITTESTINFO_ptY       = w32allot(Long),
    IDE_TCHITTESTINFO_flags     = w32allot(UInt),
    IDE_SIZEOF_TCHITTESTINFO    = w32allotted_size()

function rtClickedTab(atom Tab, integer x, integer y)
--submitted by Dan Moyer
atom lHT
atom lTab
atom lRC

    lHT = w32acquire_mem(0, IDE_SIZEOF_TCHITTESTINFO)
    w32store(lHT, IDE_TCHITTESTINFO_ptX, x)
    w32store(lHT, IDE_TCHITTESTINFO_ptY, y)

    lTab = sendMessage(Tab, TCM_HITTEST, 0, lHT)
    lRC = w32fetch(lHT, IDE_TCHITTESTINFO_flags)

    w32release_mem(lHT)
    -- Return both the tab index and where inside the tab the mouse is.
    --lTab is 0 based
    return {lTab+1,lRC}
end function
------------------------------------------------------------------------------
global procedure mouse_LayerTC(integer Self, integer Event, sequence Params)
sequence aTabItem, text,lValues, textback
integer backlayerNumber,tabName

    if equal(Params[1], RIGHT_DOWN) then
        aTabItem = rtClickedTab(LayersTC, Params[2], Params[3])

        if layerNumber=0 then
            --can not make backgrounds to layer 0
            showBackLayer = {}
            setText(Form, "Form Design")
            setText(PopUpDesign_Layers,IDEText[986][1])
            return
        end if

        --from tab index, find the tab name for finding userProperty and thus tab's layer number
        backlayerNumber = 0
        tabName = layerTabItemSeq[aTabItem[1]]
        lValues = getUserProperty(tabName, "layer")
        if length(lValues) then
            backlayerNumber = lValues[1][1]
        end if

        if equal(backlayerNumber, layerNumber) then
            --if right click on active layer tab, make NO backgrounds
            --clear window of any .ico and .bmp showing
            for i=1 to length(iconStrings) do
                iconData = iconStrings[i]
                if validId(iconData[2]) then
                    destroy(iconData[2])
                end if
            end for
            iconStrings = {}
            showBackLayer = {}
            backgroundlayer = -1
            setText(PopUpDesign_Layers,IDEText[986][1])
            call_proc(drawIt_id,{})
            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        else
            -- NOT right clicked on active layer tab, make one or more background:
            if and_bits(Params[4], ControlMask) then
                -- control key held down, make multiple bkgnds:
                --find layer number for clicked tab (if tabs have been removed then
                --the tab occurance is NOT the layer number
                if not find(backlayerNumber, showBackLayer) then
                    showBackLayer &= {backlayerNumber}
                end if
            else
                -- normal, control key NOT held down, just make ONE layer as a background
                showBackLayer = {backlayerNumber}
            end if
            setText(PopUpDesign_Layers,IDEText[987][1])
        end if

        if length(showBackLayer) then
            text = "Form Design: Background Layers = "
            for i=1 to length(showBackLayer) do
                if i>1 then
                    text &= ", "
                end if
                textback = {}
                for j=1 to length(layerCaptionSeq[selectedWindow]) do
                    if showBackLayer[i]=layerCaptionSeq[selectedWindow][j][3] then
                        textback = layerCaptionSeq[selectedWindow][j][1]
                        exit
                    end if
                end for
                --show tab caption
                if length(textback) then
                    text &= textback
                else
                    text &= sprint(showBackLayer[i])
                end if
            end for
            setText(Form, text) -- backgroundTabs
        else
            setText(Form, "Form Design")
            setText(PopUpDesign_Layers,IDEText[986][1])
        end if

        if length(showBackLayer) then
            call_proc(drawIt_id,{})
            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        end if
    end if

end procedure
--------------------------------------------------------------------------------
global function textInQuotes(sequence text,integer at,integer matchLength)
integer cnt,back,backpos,s,r,f
    if matchLength then end if
    cnt = 0
    back = 0
    backpos = 0
    for i=1 to at do
        if text[i]='\\' then
            back += 1
            backpos = i
        end if
        if text[i]='\"' then
            if back then
                if backpos=i-1 then
                else
                    cnt += 1
                    f = i
                end if
                back = 0
                backpos = 0
            else
                cnt += 1
                f = i
            end if
        end if
    end for
    if cnt then
        s = remainder(cnt,2)
        if s then
            r = match("routine_id",text)
            if r
            and r<f then
                return w32False
            end if
            return w32True
        else
            return w32False
        end if
    else
        return w32False
    end if
end function
----------------------------------------------------------------------------
--              the other modules
-------------------------------------------------------------------------------
setText(splashLoadInfo, "Loading Modules...")
include includes\IDE_about.ew            -- new about box (Mario Steele)
include includes\ide_config.ew           -- all the basic configuration stuff
--------------------------------------------------------------------------------
global function HowOpenCodeWin()
    --this routine is used when CodeWin is opened the first time after IDE loads up
    --Code Editor in closed format.
    --this routine is also used after closing CodeWin and reopening

    -- CW add
    -- so it seems like a good time to set the autosave timer, as there is code to (potentially) save
    -- timer is set in *milliseconds*, so 1000 = 1 second, 60000 = 1 minute, etc.
    --autosave_time = 300000 -- this would be set from a preference, set to 5 minutes for testing

    if autosave_OnOff then
        setTimer(Controls, 1, autosave_time)
    else
        killTimer(Controls, 1)
    end if
    --

    if CodeWinOpen
    or CodeWinWasOpened then
        if CodeWinWasOpened
        and CodeWinWasMaxed then
            if not isChecked(Code_R1)               --if not always maximize
            and not isChecked(Code_R2) then --and not closed IDE when maximized             
                CodeWinWasMaxed = w32False      --disable maximize for next open        
            end if
            return 1
        end if
        return 0
    end if

    if isChecked(Code_R1) then
        return 1        --Maximized
    end if
    if isChecked(Code_R2)
    and codeWasMaxed then
        return 1        --Maximized
    end if
    if isChecked(Code_R3)
    and length(codePosition) then
        --position editor
        if codeWasMaxed then
            return 1    --Maximized
        elsif codePosition[4]=titleBar+(2*borderX)
           or codeWasMined then
                --probably was minimized                        
            return 0
        else
            return 3    --restore
        end if
    end if
    return 0
end function
--------------------------------------------------------------------------------
global procedure selectIconMouse(integer Self, integer Event, sequence Params)
--w32HMouse setHandler setup in IDE_draw.ew
sequence selectedId, mouse

        --if Icon on top of FlatToolBar button got hit instead translate to button id
    if Params[1]=LeftDoubleClick then
--                      does not work with IDE and XP. I can not explain why it works
--                      with IDE and Win98SE.           
        for i=1 to length(iconStrings) do
            if Self=iconStrings[i][2] then
                selectedId = iconStrings[i][1]
                for x=1 to length(controls) do
                    if equal(selectedId, controls[x][Name]) then
                        selectedControl = x
                        ok = invokeHandler(MenuCodeEditor, w32HClick,{})
                        return
                    end if
                end for
            end if
        end for
    elsif Params[1]=LeftDown then
        --find which control is hit and switch to it
        for i=1 to length(iconStrings) do
            if Self=iconStrings[i][2] then
                selectedId = iconStrings[i][1]
                for j=1 to getCount(PropertyTitleBar) do
                    if equal(selectedId, getItem(PropertyTitleBar,j)) then
                        setIndex(PropertyTitleBar, j)
                        ok = invokeHandler(PropertyTitleBar, w32HChange,{})
                        exit
                    end if
                end for
                exit
            end if
        end for
    elsif Params[1]=RightDown then
        mouse = getPointerRelPos(Design)
        setText(PopUpDesign_Styles, "Unavailable")
        setEnable(PopUpDesign_Styles, w32False)
        setEnable(PopUpDesign_DeleteCtrl, w32True)
        setEnable(PopUpDesign_DeleteTabControl, w32False)
        setEnable(PopUpDesign_DeleteTabItem, w32False)
        setEnable(PopUpDesign_FullSize, w32False)
        setEnable(PopUpDesign_Table, w32False)
        setEnable(PopUpDesign_Layers, w32False)
        popup(PopUpDesign, mouse[1], mouse[2])
    end if
end procedure
--------------------------------------------------------------------------------
global function isInCWindowTitleBar(sequence controls, integer selectedControl)
integer header
integer giveMessage, flag
object styleCheck

    giveMessage = w32False

    if equal(controls[selectedControl][SeqParentClass], "CWindow") then
        header = w32False
        flag = findSeqParentName(selectedControl)
        if flag then
            styleCheck = controls[flag][Style]
            if integer(styleCheck) then
            --what to do here?
            else
                if length(controls[flag][Style])
                and length(controls[flag][StyleType]) then
                    if match("WS_CHILD",controls[flag][Style]) then
                        header = w32True
                        if equal(controls[flag][StyleType],"{...}") then
                            header = w32False
                        end if
                        if equal(controls[flag][StyleType],"...") then
                            header = w32True
                        end if
                    end if
                    if match("WS_POPUP",controls[flag][Style]) then
                        header = w32False
                        if equal(controls[flag][StyleType],"w32or_all({...})")
                        or equal(controls[flag][StyleType],"...") then
                            header = w32True
                        end if
                    end if
                    if match("WS_POPUP",controls[flag][Style])
                    and match("WS_CHILD",controls[flag][Style]) then
                        header = w32False
                        if equal(controls[flag][StyleType],"w32or_all({...})")
                        or equal(controls[flag][StyleType],"...") then
                            header = w32True
                        end if
                    end if
                    if match("WS_CAPTION",controls[flag][Style]) then
                        header = w32True
                    end if
                end if
            end if
        end if
        if header then
            if ( controls[selectedControl][X]>=controls[flag][X]
                and controls[selectedControl][X]<(controls[flag][X]+borderX) )
            or ( controls[selectedControl][Y]>=controls[flag][Y]
                and controls[selectedControl][Y]<(controls[flag][Y]+titleBar+borderY) ) then
                if not equal(controls[selectedControl][Class], "StatusBar") then
                    giveMessage = w32True
                end if
            end if
        end if
    end if
    return giveMessage
end function
--------------------------------------------------------------------------------
global function isCWindowTitleBar(integer flag)
object styleCheck
integer header

    header = w32False

    if not equal(controls[flag][Class], "CWindow") then
        return header
    end if

    styleCheck = controls[flag][Style]
    if integer(styleCheck) then
        --what to do here?
    else
        if length(controls[flag][Style])
        and length(controls[flag][StyleType]) then
            if match("WS_CHILD",controls[flag][Style]) then
                header = w32True
                if equal(controls[flag][StyleType],"{...}") then
                    header = w32False
                end if
                if equal(controls[flag][StyleType],"...") then
                    header = w32True
                end if
            end if
            if match("WS_POPUP",controls[flag][Style]) then
                header = w32False
                if equal(controls[flag][StyleType],"w32or_all({...})")
                or equal(controls[flag][StyleType],"...") then
                    header = w32True
                end if
            end if
            if match("WS_POPUP",controls[flag][Style])
            and match("WS_CHILD",controls[flag][Style]) then
                header = w32False
                if equal(controls[flag][StyleType],"w32or_all({...})")
                or equal(controls[flag][StyleType],"...") then
                    header = w32True
                end if
            end if
            if match("WS_CAPTION",controls[flag][Style]) then
                header = w32True
            end if
        end if
    end if

    return header
end function
--------------------------------------------------------------------------------
global integer startSave, endSave
startSave = 0   endSave = 0

include includes\ide_draw.ew             -- control rendering
include includes\ide_findwin.ew                  -- find match in all controls-events                                     
include includes\ide_code.ew             -- code editor
include includes\ide_findwin.ew          -- find match in all controls-events
include includes\ide_exErr.ew            -- interpret exw error file
include includes\ide_proj.ew             -- read/write project and config file
include includes\ide_menu.ew             -- menu editor
include includes\ide_popup.ew            -- popup editor
include includes\ide_timer.ew                    -- Timer control editor
include includes\ide_design.ew           -- controls design on Form
include includes\ide_reorder.ew          -- control order menu; more or less obsolete now
include includes\ide_include.ew          -- included files add/reorder
include includes\ide_initlist.ew         -- initial values for List and Combo
include includes\ide_mbox.ew             -- Design a message box in IDE (Roland Stowasser)
include includes\ide_launch.ew           -- Launcher (Roland Stowasser)
include includes\ide_systray.ew          -- designs data for (Thomas Parslov) systray.ew
include includes\ide_ListViewStyles.ew   -- various ListView styles
include includes\IDE_scrollingTable.ew   -- routines for IDE and user exw to scroll tables
include includes\ide_xpmmer.ew                   -- XPMmer (Andy Drummond) to design control graphics
        --use user's system to determine:
    MasterList[20][ControlCY]   = statusBar --from code.ew
-------------------------------------------------------------------------------
--          variables needed for property sheet
-------------------------------------------------------------------------------
-- will be created after we get handle to properties (via prop.ew below)
integer StylePopup,Explore1,Explore2,Explore3,Explore4,Explore5,Explore6,Explore7,
                Explore8,Explore9,Explore10,Explorea,Exploreb,Explore11, Explore12

--these are all the property control names
integer sheetId,name,caption,showCap,titleWidth,propclass,row,col,width,height,toolHeight,controlOrder,
        list,local,createWith,exStyle,extExStyle,style,styletype,ccWin,ccWinMain,winPos,enable,visible,
        alimitText,controlStyle,
        readOnly,upperCase,lowerCase,numeric,password,hScroll,vScroll,multiline,clickable,minValue,maxValue,buddy,
        multSel,extSel,rbbsBreak,otherFlags,controlStyletype,parent,color,iconFile,defFile,hotFile,disFile,closeFile,openFile,
        bitmap,XPMFile,XPMMember,font,fontBold,fontItalic,fontUnderline,fontStrike,fontPts,
        fontName,fontAttrib,fontColor,hintFont,hintFontBold,hintFontItalic,hintFontUnderline,hintFontStrike,
        hintFontPts,hintFontName,hintFontAttrib,defaultColor,hintText,windowParent,
        iconFileLV, winPosTaskBar, outX, outY, outCX, outCY,
    alternatePos,controlComment,mcs_multiselect,pbs_smooth,bs_flat,defindex,insystray,
    suppressCell,LvAddBottom,checked,lineChg,pageChg,indexTo,controllayer,classdef,
    winOpenAtCtrl,transparency,noIntegralHeight,adjCenter,adjRight,setLayerOK, txtColor,
    useInWinMain,proptableSpecs,valueEdit,labelSide,parentFrozen,partners,barColor,
    pbCapPos, xpmmer, xpmmerObject, showHintFontVar, varhintFontName, varhintFontPts,
    varhintFontBold, varhintFontItalic, varhintFontUnderline, varhintFontStrike, varhintText,
    showFontVar, varfontName, varfontPts, varfontBold, varfontItalic, varfontUnderline,
    varfontStrike, varfontColor, xpmmerDisableObject,xpmmerDisable, upDownHorz, upDownLeft,
    tabsBottom, removeCopyIndex, setcreatefont, treatAsColorButton, mc_background, mc_text,
    mc_titleBK, mc_titleText, mc_monthBK, mc_trailingText,

    --EuGrid specific
    gridHeaderInfo,gridHeaderColor,gridHeaderColHeight,gridHeaderRowWidth,gridHeaderDataCol,
    gridHeaderDataColVal,gridRowHeight,gridTextAlign,gridCellBkColor,gridLineColor,
    gridColAlign,gridColors,gridFormat,gridCellFormat,gridTextColor,gridColTextColor,
    gridDataArrayName,gridRowSelect,gridColListDataCol,gridColListValues,
    gridActiveHeaders,gridAllowColResize,gridAllowColSort,gridCellBorder,gridHighlightText,
    gridTextColorSelect,gridCellBorderColor,gridBkColorSelect,

        --ColoredButton specific
        cbcolor,cbpresscolor,cbcaptioncolor,cbpresscaptioncolor,cbthickness,cbcaptionpos,
        cbgraphicpos,cbmultiline,cbflat,cbcentvert

include includes\prop.ew                 -- the property contents of PropertySheet Window (Martin Stachon)
--------------------------------------------------------------------------------
constant
RECT_left   = w32allot(Long),
RECT_top    = w32allot(Long),
RECT_right = w32allot(Long),
RECT_bottom = w32allot(Long),
SIZEOF_RECT = w32allotted_size(),
RECT_STRUCT = allocate(SIZEOF_RECT)
procedure findCalendarSize(integer index)
integer width, height

--when font name/points change for monthcalendar control, the control's size
--might be altered. To obtain the cx, cy a dummy calendar is altered in a
--hidden window then the cx,cy altered in Properties.

    if not length(controls[index][FontName]) then
        --use default size
        width = 248
        height = 200
    else
        setFont(testCalendar, controls[index][FontName],controls[index][FontPts],
                Normal)
        if sendMessage(testCalendar, MCM_GETMINREQRECT, 0, RECT_STRUCT)=0 then
            ok = message_box("Error using MonthCal_GetMinReqRect!","",0)
            return
        end if

        width = w32fetch(RECT_STRUCT, RECT_right)-w32fetch(RECT_STRUCT, RECT_left)
        height = w32fetch(RECT_STRUCT, RECT_bottom)-w32fetch(RECT_STRUCT, RECT_top)
    end if

    setCtlSize(testCalendar, width, height)

    controls[index][CX] = width
    controls[index][CY] = height

    call_proc(updateProperty_id,{"Height"})

end procedure
--------------------------------------------------------------------------------
--              validation routines for PropertySheet
---------------------------------------------------------------------------------
procedure drawChildren(sequence control, integer thisOne)
integer childCnt, withHatching

    withHatching = w32False
    if hatchBackground
    and not GridHide then
        --hatch the menu bar
        withHatching = w32True
    end if

    childCnt = 0
    for j=thisOne to length(controls) do
        if find(controls[j][Name], control[SeqChildName]) then
            childCnt += 1
            drawControl(ControlBlit, controls[j], Normal, j, withHatching)
            --draw its children also
            if length(controls[j][SeqChildName]) then
                drawChildren(controls[j], j)
            end if
        end if
        if childCnt>=length(control[SeqChildName]) then
            exit
        end if
    end for

end procedure
--------------------------------------------------------------------------------
procedure drawChildOffscreen(integer index)
integer childCnt, diff
sequence OSControls

    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],
                    controls[index][SeqChildName]) then
                childCnt += 1
                OSControls = controls[i]
                diff = controls[index][X]-controls[i][X]
                OSControls[X] = dCX+controls[index][X]+diff
                drawControl(OffScreenBlit, OSControls, Normal, i, 0)
                if length(controls[i][SeqChildName]) then
                    drawChildOffscreen(i)
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if
end procedure
-------------------------------------------------------------------------------
global procedure changeCodeEditorCode()
--also used when changing Name in Menu, Popup and Timer editors
sequence text, comparetext
integer changedText, changedEvent, at, onX, inGeneral

    canChangeIt = w32False
    if not length(textOrigName) then
        return
    end if

    if CodeWinOpen then
        setIndex(CodeControls, editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
        flushControls()
    end if

    --change any event coding for changed name
    for i=1 to length(windows) do
        for j=1 to length(windows[i]) do
            if length(windows[i][j][Code]) then
                for k=1 to length(windows[i][j][Code]) do
                    for m=1 to length(windows[i][j][Code][k]) do
                        text = windows[i][j][Code][k][m]
                        comparetext = text
                        changedEvent = event
                        at = w32True
                        while at do
                            --find old name somewhere in line of code
                            changedText = w32False
                            onX = w32False
                            for n=1 to length(Events) do
                                if match(Events[n][1], comparetext) then
                                    onX = w32True
                                    exit
                                end if
                            end for
                            inGeneral = w32False
                            if event=General
                            or event=Final
                            or event=Begin
                            or event=Intro then
                                inGeneral = w32True
                            end if

                            if (match("procedure", comparetext)
                                and not inGeneral)
                            or match("setHandler", comparetext)
                            or onX then

                                at = match(textOrigName, comparetext)
                                if at then
                                    --look at prior and next character for uniqueness of name
                                    if at>1 then
                                        if not((text[at-1]>='a' and text[at-1]<='z') or
                                               (text[at-1]>='A' and text[at-1]<='Z') or
                                               (text[at-1]>='0' and text[at-1]<='9')) then
                                            if at+length(textOrigName)-1<length(text) then
                                                if not((text[at+length(textOrigName)]>='a' and text[at+length(textOrigName)]<='z') or
                                                       (text[at+length(textOrigName)]>='A' and text[at+length(textOrigName)]<='Z') or
                                                       (text[at+length(textOrigName)]>='0' and text[at+length(textOrigName)]<='9')) then
                                                    if textInQuotes(text,at,length(textOrigName)) then
                                                    else
                                                        --ok to convert
                                                        text = text[1..at-1] & controls[selectedControl][Name]
                                                               & text[at+length(textOrigName)..length(text)]
                                                        windows[i][j][Code][k][m] = text
                                                        changedText = w32True
                                                    end if
                                                end if
                                            else
                                         --ok to convert
                                                text = text[1..at-1] & controls[selectedControl][Name]
                                                       & text[at+length(textOrigName)..length(text)]
                                                windows[i][j][Code][k][m] = text
                                                changedText = w32True
                                            end if
                                        end if
                                    else
                                        if at+length(textOrigName)-1<length(text) then
                                            if not((text[at+length(textOrigName)]>='a' and text[at+length(textOrigName)]<='z') or
                                                   (text[at+length(textOrigName)]>='A' and text[at+length(textOrigName)]<='Z') or
                                                   (text[at+length(textOrigName)]>='0' and text[at+length(textOrigName)]<='9')) then
                                                --ok to convert
                                                text = text[1..at-1] & controls[selectedControl][Name]
                                                       & text[at+length(textOrigName)..length(text)]
                                                windows[i][j][Code][k][m] = text
                                                changedText = w32True
                                            end if
                                        else
                                            --ok to convert
                                            text = text[1..at-1] & controls[selectedControl][Name]
                                                   & text[at+length(textOrigName)..length(text)]
                                            windows[i][j][Code][k][m] = text
                                            changedText = w32True
                                        end if
                                    end if
                                    --remove matches from comparetext so don't keep hitting them in while loop
                                    if changedText then
                                        comparetext = comparetext[1..at-1] & repeat(' ',length(controls[selectedControl][Name]))
                                                      & comparetext[at+length(textOrigName)..length(comparetext)]
                                        changedEvent = 0
                                    else
                                        comparetext = comparetext[1..at-1] & repeat(' ',length(textOrigName))
                                                      & comparetext[at+length(textOrigName)..length(comparetext)]
                                    end if
                                end if
                            else
                                at = match(textOrigName, comparetext)
                                if at then
                                    --look at prior and next character for uniqueness of name
                                    if at>1 then
                                        if not((text[at-1]>='a' and text[at-1]<='z') or
                                               (text[at-1]>='A' and text[at-1]<='Z') or
                                               (text[at-1]>='0' and text[at-1]<='9') or
                                               (text[at-1]='_'))
                                        and not textInQuotes(text,at,length(textOrigName)) then
                                            if at+length(textOrigName)-1<length(text) then
                                                if not((text[at+length(textOrigName)]>='a' and text[at+length(textOrigName)]<='z') or
                                                       (text[at+length(textOrigName)]>='A' and text[at+length(textOrigName)]<='Z') or
                                                       (text[at+length(textOrigName)]>='0' and text[at+length(textOrigName)]<='9') or
                                                       (text[at+length(textOrigName)]='_'))
                                                and not textInQuotes(text,at,length(textOrigName)) then
                                                    --ok to convert
                                                    text = text[1..at-1] & controls[selectedControl][Name]
                                                           & text[at+length(textOrigName)..length(text)]
                                                    windows[i][j][Code][k][m] = text
                                                    changedText = w32True
                                                end if
                                            else
                                                --ok to convert
                                                text = text[1..at-1] & controls[selectedControl][Name]
                                                       & text[at+length(textOrigName)..length(text)]
                                                windows[i][j][Code][k][m] = text
                                                changedText = w32True
                                            end if
                                        end if
                                    else
                                        if at+length(textOrigName)-1<length(text) then
                                            if not((text[at+length(textOrigName)]>='a' and text[at+length(textOrigName)]<='z') or
                                                   (text[at+length(textOrigName)]>='A' and text[at+length(textOrigName)]<='Z') or
                                                   (text[at+length(textOrigName)]>='0' and text[at+length(textOrigName)]<='9') or
                                                   (text[at+length(textOrigName)]='_'))
                                            and not textInQuotes(text,at,length(textOrigName)) then
                                                --ok to convert
                                                text = text[1..at-1] & controls[selectedControl][Name]
                                                       & text[at+length(textOrigName)..length(text)]
                                                windows[i][j][Code][k][m] = text
                                                changedText = w32True
                                            end if
                                        else
                                            --ok to convert
                                            text = text[1..at-1] & controls[selectedControl][Name]
                                                   & text[at+length(textOrigName)..length(text)]
                                            windows[i][j][Code][k][m] = text
                                            changedText = w32True
                                        end if
                                    end if
                                    --remove matches from comparetext so don't keep hitting them in while loop
                                    if changedText then
                                        comparetext = comparetext[1..at-1] & repeat(' ',length(controls[selectedControl][Name]))
                                                      & comparetext[at+length(textOrigName)..length(comparetext)]
                                        changedEvent = 0
                                    else
                                        comparetext = comparetext[1..at-1] & repeat(' ',length(textOrigName))
                                                      & comparetext[at+length(textOrigName)..length(comparetext)]
                                    end if
                                end if
                            end if
                        end while
                    end for
                end for
            end if

            if i=selectedWindow then
                controls = windows[i]
            end if
        end for
    end for
    textOrigName = ""

    if CodeWinOpen then
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if
end procedure
--------------------------------------------------------------------------------
sequence prevTitle,prevFont
integer prevSide, prevPts, prevBold, prevUnderline, prevStrikeout, prevAttrib
        prevTitle = {} prevSide = 0 prevFont = {} prevPts = 0 prevAttrib = 0 prevBold = 0
        prevUnderline = 0 prevStrikeout = 0
--------------------------------------------------------------------------------                                
procedure endChanges(integer cell)
object whereIs
integer haveName, at, holdSelectedControl, childCnt, diff,
        lastIndex, controlnamelength, inTitleBar
sequence OSControls, extent, oldName, newName

    haveName = w32False

        -- update changes to current window
    flushControls()

    if buildProjectView then
        buildProjectView = w32False

        for i=1 to length(iconStrings) do
            if equal(origName, iconStrings[i][1]) then
                iconStrings[i][1] = controls[selectedControl][Name]
                --could be multiples?
            end if
        end for

        changeTreeViewText(origName, controls[selectedControl][Name])
        if equal(controls[selectedControl][Class], "Window") then
            --if previously had Menus then need to change the Menu:WindowName entry in ProjectView
            oldName = origName
            oldName = "The Menus:" & oldName
            newName = controls[selectedControl][Name]
            newName = "The Menus:" & newName
            changeTreeViewText(oldName, newName)
            -- Popups
            oldName = origName
            oldName = "The Popups:" & oldName
            newName = controls[selectedControl][Name]
            newName = "The Popups:" & newName
            changeTreeViewText(oldName, newName)
            -- Timers
            oldName = origName
            oldName = "The Timers:" & oldName
            newName = controls[selectedControl][Name]
            newName = "The Timers:" & newName
            changeTreeViewText(oldName, newName)
        end if

        for i=1 to length(windowsList) do
            if equal(windowsList[i],origName) then
                windowsList[i] = controls[selectedControl][Name]
                exit
            end if
        end for
    end if

--dev (a and b) or (c and not d)???: [I added the ()]
    if (cell=name
        and length(textOrigName))
    or (canChangeIt
        and not equal(textOrigName, controls[selectedControl][Name])) then

        for i=1 to length(controlNameKeywords) do
            if equal(textOrigName,controlNameKeywords[i]) then
                controlNameKeywords[i] = controls[selectedControl][Name]
                exit
            end if
        end for

        changeCodeEditorCode()

        lastIndex = getIndex(CodeControls)
        --rebuild codeControls list
        eraseItems(CodeControls)
        --set up for control and event
        controlnamelength = 0
        for i=1 to length(controls) do
            -- get the event name
            -- add the control name to the list
            if not length(controls[i][Name]) then
                controls[i][Name] = " "
            end if

            addItem(CodeControls, controls[i][Name])
            if length(controls[i][Name])>controlnamelength then
                controlnamelength = length(controls[i][Name])
            end if
        end for
        extent = getTextExtent(CodeControls, "M")
        controlnamelength *= extent[1]
        ok = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
        setIndex(CodeControls,lastIndex)
    else
        canChangeIt = w32False
    end if

    if not length(controls[selectedControl][XPM]) then
        controls[selectedControl][XPMmember] = {}
    end if

    --skip the rest if change doesn't affect the drawn control
    if not find(cell,{col,row,width,height,toolHeight,caption,parent,propclass,color,
                      defaultColor,fontName,fontPts,fontItalic,fontBold,cbcolor,cbcaptioncolor,
                      fontUnderline,fontStrike,fontColor,visible,bitmap,XPMFile,XPMMember,cbgraphicpos,
                      disFile,defFile,hotFile,iconFile,openFile,closeFile,rbbsBreak,styletype,cbcaptionpos,
                      style,controlStyletype,gridHeaderColHeight,gridHeaderRowWidth,gridHeaderColor,gridLineColor,
                      controllayer,txtColor,labelSide,xpmmerObject, showHintFontVar, showFontVar,xpmmerDisableObject}) then
        cell = 0
    end if

    --to speed up Property do not add IcoFile, TwoIcoFile and TriIcoFile
    --to this list until the complete name has been input
    haveName = 0
    if length(controls[selectedControl][IcoFile])
    and not equal(controls[selectedControl][Class], "ListView") then
        whereIs = dir(controls[selectedControl][IcoFile])
        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][IcoFile]))
            if at then
                haveName = w32True
            end if
        end if
    end if

    if length(controls[selectedControl][TwoIcoFile]) then
        whereIs = dir(controls[selectedControl][TwoIcoFile])
        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][TwoIcoFile]))
            if at then
                haveName = w32True
            end if
        end if
    end if

    if length(controls[selectedControl][TriIcoFile]) then
        whereIs = dir(controls[selectedControl][TriIcoFile])
        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][TriIcoFile]))
            if at then
                haveName = w32True
            end if
        end if
    end if

    if length(controls[selectedControl][BitmapFile]) then
        whereIs = dir(controls[selectedControl][BitmapFile])
        if sequence(whereIs) then
            at = match(".bmp",lower(controls[selectedControl][BitmapFile]))
            if at then
                haveName = w32True
            end if
        end if
    end if

    if length(controls[selectedControl][XPM]) then
        whereIs = dir(controls[selectedControl][XPM])
        if sequence(whereIs) then
            at = match(".xpm",lower(controls[selectedControl][XPM]))
            if at then
                haveName = w32True
                controls[selectedControl][XPMmember] = {}
                setProperty(XPMMember,"")
            elsif length(controls[selectedControl][XPMmember]) then
                haveName = w32True
            end if
        else
            controls[selectedControl][XPMmember] = {}
            setProperty(XPMMember,"")
        end if
    end if

    if not isChecked(MenuBitmapNoSuppress) then
        haveName = w32False
    end if

    if length(controls[selectedControl][XpmObject]) then
        haveName = w32True
    end if

    if length(controls[selectedControl][XpmDisableObject]) then
        haveName = w32True
    end if

    --when coming from changing tabItemcombo dont do drawit yet because that routine
    --will draw.
    if delayDraw then
        return
    end if

    if cell=col
    or cell=row
    or cell=width
    or cell=height
    or cell=toolHeight
    or cell=rbbsBreak
    or cell=caption
    or parent
    or (cell=propclass and equal(controls[selectedControl][Class], "DropDownList") )
    or (cell=propclass and find(controls[selectedControl][Class], {"PushButton",
                                                                   "PictureButton","ToggleButton","TogglePicture","CancelButton","DefPushButton"}) )
    or ( cell=fontName and isChecked(MenuFontNoSuppress) )
    or ( cell=fontPts and isChecked(MenuFontNoSuppress) )
    or ( cell=fontItalic and isChecked(MenuFontNoSuppress) )
    or ( cell=fontBold and isChecked(MenuFontNoSuppress) )
    or ( cell=fontUnderline and isChecked(MenuFontNoSuppress) )
    or ( cell=fontStrike and isChecked(MenuFontNoSuppress) )
    or cell=color
    or cell=defaultColor
    or cell=fontColor
    or haveName
    or (cell=styletype and equal(controls[selectedControl][Class], "CWindow"))
    or (cell=style and equal(controls[selectedControl][Class], "CWindow"))
    or cell=gridHeaderColHeight
    or cell=gridHeaderRowWidth
    or cell=gridHeaderColor
    or cell=gridLineColor
    or cell=controllayer
    or cell=txtColor
    or cell=labelSide
    or cell=cbcolor
    or cell=cbpresscolor
         then
        holdSelectedControl = selectedControl
        selectedControl = TheWindow
        --if control moved location or appearance changed, need to change it in the drawn area
        if find(controls[holdSelectedControl][Class], {"ReBar","ReBarBand","ToolBar",
                                                       "FlatToolBar","StatusBar","EuGrid"})
        or find(controls[holdSelectedControl][SeqParentClass], {"ReBar","ReBarBand","ToolBar",
                                                                "FlatToolBar","StatusBar","EuGrid"}) then
            repaintWinResize = w32True
        end if

        if (cell=styletype or cell=style)
        and equal(controls[holdSelectedControl][Class], "CWindow") then
            repaintWinResize = w32True
        end if

        call_proc(drawIt_id,{})
        selectedControl = holdSelectedControl
    end if

    if selectedControl!=TheWindow
    and cell!=controllayer then
        -- draw selected control        
        drawControl(ControlBlit, controls[selectedControl], Normal, selectedControl, 0)
        drawControl(ControlBlit, controls[selectedControl], Selected, selectedControl, 0)
        haveOffscreen = w32False

        OSControls = controls[selectedControl]

        if OSControls[X]<0
        or OSControls[Y]<0 then
            haveOffscreen = w32True
            if OSControls[X]<0 then
                OSControls[X] = dCX+controls[selectedControl][X]
            end if
            if OSControls[Y]<0 then
                OSControls[Y] *= -1  --can't draw negative Y yet
            end if
            copyBlt(OffScreenBlit, 0, 0, GridBlit)

            drawControl(OffScreenBlit, OSControls, Normal, selectedControl, 0)

            --did it have children?
            childCnt = 0
            if length(controls[selectedControl][SeqChildName]) then
                for i=selectedControl to length(controls) do
                    if find(controls[i][Name],
                            controls[selectedControl][SeqChildName]) then
                        childCnt += 1
                        OSControls = controls[i]
                        diff = controls[selectedControl][X]-controls[i][X]
                        OSControls[X] = dCX+controls[selectedControl][X]+diff
                        drawControl(OffScreenBlit, OSControls, Normal,i, 0)
                        if length(controls[i][SeqChildName]) then
                            drawChildOffscreen(i)
                        end if
                    end if
                    if childCnt>=length(controls[selectedControl][SeqChildName]) then
                        exit
                    end if
                end for
            end if
        else
            --draw any controls within the selected control
            if length(controls[selectedControl][SeqChildName]) then
                --find subs
                childCnt = 0
                for j=selectedControl to length(controls) do
                    if find(controls[j][Name], controls[selectedControl][SeqChildName]) then
                        childCnt += 1
                        drawControl(ControlBlit, controls[j], Normal,j, 0)
                        --draw its children also
                        if length(controls[j][SeqChildName]) then
                            drawChildren(controls[j],j)
                        end if
                    end if
                    if childCnt>=length(controls[selectedControl][SeqChildName]) then
                        exit
                    end if
                end for
            end if
        end if

        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            call_proc(drawHiddenControls_id,{selectedControl})
        end if
    end if

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if offsetActive then
        copyBlt(OffScreen, 0, 0, OffScreenBlit)
    end if

    if not haveOffscreen then
        closeWindow(OffScreen)
    end if

    if (cell=style and equal(controls[selectedControl][Class],"CWindow"))
    or (cell=styletype and equal(controls[selectedControl][Class],"CWindow")) then
        if length(controls[selectedControl][SeqChildName]) then
            childCnt = 0
            for j=selectedControl to length(controls) do
                if find(controls[j][Name],controls[selectedControl][SeqChildName]) then
                    childCnt += 1
                    inTitleBar = isInCWindowTitleBar(controls, j)
                    if inTitleBar then
                        ok = displayErrorMessage(251,{})
                        exit
                    end if
                end if
                if childCnt=length(controls[selectedControl][SeqChildName]) then
                    exit
                end if
            end for
        end if
    end if

    if equal(controls[selectedControl][Class], "LabelEdit") then
        if cell=caption
        or cell=labelSide
        or cell=fontName
        or cell=fontPts
        or cell=fontBold
        or cell=fontItalic
        or cell=fontUnderline
        or cell=fontStrike then
            if equal(controls[selectedControl][Title], prevTitle)
            and controls[selectedControl][LabelSide]=prevSide
            and equal(controls[selectedControl][FontName], prevFont)
            and controls[selectedControl][FontPts]=prevPts
            and controls[selectedControl][FontAttrib]=prevAttrib
            and controls[selectedControl][FontBold]=prevBold
            and controls[selectedControl][FontUnderline]=prevUnderline
            and controls[selectedControl][FontStrikeout]=prevStrikeout then
                                --same so do not show message
            else
                if testLabelEditCaption(selectedControl) then
                    ok = displayErrorMessage(252,{})
                end if
                --set for next text
                prevTitle = controls[selectedControl][Title]
                prevSide = controls[selectedControl][LabelSide]
                prevFont = controls[selectedControl][FontName]
                prevPts = controls[selectedControl][FontPts]
                prevAttrib = controls[selectedControl][FontAttrib]
                prevBold = controls[selectedControl][FontBold]
                prevUnderline = controls[selectedControl][FontUnderline]
                prevStrikeout = controls[selectedControl][FontStrikeout]
            end if
        end if
    end if

    --if property cells list has changed due to a different class, show properties again
    --so user may make additional modifications     
    if cell=propclass and find(controls[selectedControl][Class], {"PushButton",
                                                                  "PictureButton","ToggleButton","TogglePicture","DefPushButton","CancelButton"}) then
        if sequence(controls[selectedControl][BS_flat]) then
            --somehow this field gets spaced out and I can't find where!!!!!
            controls[selectedControl][BS_flat] = w32False
        end if
        call_proc(updateProperties_id,{})
    end if

    if cell=color
    and equal(controls[selectedControl][Class], "Window") then
        --force system color to "User Color"
        setPropertyCombo(defaultColor,1,validColors)
    end if

    if cell=showHintFontVar or cell=showFontVar then
        call_proc(updateProperties_id,{})
    end if

end procedure
--------------------------------------------------------------------------------
procedure addChildToNode(integer index)
integer childCnt

    if length(controls[index][SeqChildName]) then
        childCnt = 0
        for i=index to length(controls) do
            if find(controls[i][Name], controls[index][SeqChildName]) then
                childCnt += 1
                addTreeViewNode(controls[index][Name], controls[i][Name])
                if length(controls[i][SeqChildName]) then
                    addChildToNode(i)
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if
end procedure
--------------------------------------------------------------------------------
function checkBoxOnOff(integer cell, integer event, sequence params)
integer onOff, flag
sequence whoIs

    onOff = params[1]

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    --update file accordingly
    if cell=showCap then
        if onOff then
            controls[selectedControl][Showcap] = w32False
        else
            controls[selectedControl][Showcap] = w32True
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Showcap] = w32False
                        else
                            controls[j][Showcap] = w32True
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=local then
        if onOff then
            controls[selectedControl][Local] = w32True
        else
            controls[selectedControl][Local] = w32False
        end if

        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Local] = w32True
                        else
                            controls[j][Local] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=multSel then
        if onOff then
            controls[selectedControl][MultiSel] = w32True
        else
            controls[selectedControl][MultiSel] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][MultiSel] = w32True
                        else
                            controls[j][MultiSel] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=clickable then
        if onOff then
            controls[selectedControl][Clickable] = w32True
        else
            controls[selectedControl][Clickable] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Clickable] = w32True
                        else
                            controls[j][Clickable] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=extSel then
        if onOff then
            controls[selectedControl][ExtendSel] = w32True
        else
            controls[selectedControl][ExtendSel] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][ExtendSel] = w32True
                        else
                            controls[j][ExtendSel] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=enable then
        if onOff then
            controls[selectedControl][EnableC] = w32True
        else
            controls[selectedControl][EnableC] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][EnableC] = w32True
                        else
                            controls[j][EnableC] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=visible then
        if onOff then
            controls[selectedControl][Visible] = w32True
        else
            controls[selectedControl][Visible] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Visible] = w32True
                        else
                            controls[j][Visible] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=upperCase then
        if onOff then
            controls[selectedControl][Upper] = w32True
        else
            controls[selectedControl][Upper] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Upper] = w32True
                        else
                            controls[j][Upper] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=lowerCase then
        if onOff then
            controls[selectedControl][Lower] = w32True
        else
            controls[selectedControl][Lower] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Lower] = w32True
                        else
                            controls[j][Lower] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=readOnly then
        if onOff then
            controls[selectedControl][ReadOnly] = w32True
        else
            controls[selectedControl][ReadOnly] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][ReadOnly] = w32True
                        else
                            controls[j][ReadOnly] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=password then
        if onOff then
            controls[selectedControl][Pswd] = w32True
        else
            controls[selectedControl][Pswd] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Pswd] = w32True
                        else
                            controls[j][Pswd] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=rbbsBreak then
        if onOff then
            controls[selectedControl][RBBSBREAK] = w32True
        else
            controls[selectedControl][RBBSBREAK] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][RBBSBREAK] = w32True
                        else
                            controls[j][RBBSBREAK] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=numeric then
        if onOff then
            controls[selectedControl][Numeric] = w32True
            if equal(controls[selectedControl][SeqParentClass], "EuGrid") then
                setPropEnabled(gridCellFormat, w32True)
                setProperty(gridCellFormat, controls[selectedControl][GridFormat])
            end if
        else
            controls[selectedControl][Numeric] = w32False
            if equal(controls[selectedControl][SeqParentClass], "EuGrid") then
                controls[selectedControl][GridFormat] = {}
                setProperty(gridCellFormat,"")
                setPropEnabled(gridCellFormat, w32False)
            end if
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            if equal(controls[j][SeqParentClass], "EuGrid") then
                                setPropEnabled(gridCellFormat, w32True)
                                setProperty(gridCellFormat, controls[j][GridFormat])
                            end if
                            controls[j][Numeric] = w32True
                        else
                            if equal(controls[j][SeqParentClass], "EuGrid") then
                                controls[j][GridFormat] = {}
                                setPropEnabled(gridCellFormat, w32False)
                            end if
                            controls[j][Numeric] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=multiline then
        if onOff then
            controls[selectedControl][Multiline] = w32True
            controls[selectedControl][cbMultiline] = w32True
        else
            controls[selectedControl][Multiline] = w32False
            controls[selectedControl][cbMultiline] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Multiline] = w32True
                            controls[j][cbMultiline] = w32True
                        else
                            controls[j][Multiline] = w32False
                            controls[j][cbMultiline] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=hScroll then
        if onOff then
            controls[selectedControl][Hscrolls] = w32True
        else
            controls[selectedControl][Hscrolls] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Hscrolls] = w32True
                        else
                            controls[j][Hscrolls] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=vScroll then
        if onOff then
            controls[selectedControl][Vscrolls] = w32True
        else
            controls[selectedControl][Vscrolls] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Vscrolls] = w32True
                        else
                            controls[j][Vscrolls] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=hintFontItalic then
        if onOff then
            controls[selectedControl][HintFontAttrib] = w32True
        else
            controls[selectedControl][HintFontAttrib] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][HintFontAttrib] = w32True
                        else
                            controls[j][HintFontAttrib] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=hintFontBold then
        if onOff then
            controls[selectedControl][HintFontBold] = w32True
        else
            controls[selectedControl][HintFontBold] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][HintFontBold] = w32True
                        else
                            controls[j][HintFontBold] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=hintFontStrike then
        if onOff then
            controls[selectedControl][HintFontStrikeout] = w32True
        else
            controls[selectedControl][HintFontStrikeout] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][HintFontStrikeout] = w32True
                        else
                            controls[j][HintFontStrikeout] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=hintFontUnderline then
        if onOff then
            controls[selectedControl][HintFontUnderline] = w32True
        else
            controls[selectedControl][HintFontUnderline] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][HintFontUnderline] = w32True
                        else
                            controls[j][HintFontUnderline] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=fontItalic then
        if onOff then
            controls[selectedControl][FontAttrib] = w32True
        else
            controls[selectedControl][FontAttrib] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][FontAttrib] = w32True
                        else
                            controls[j][FontAttrib] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=fontBold then
        if onOff then
            controls[selectedControl][FontBold] = w32True
        else
            controls[selectedControl][FontBold] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][FontBold] = w32True
                        else
                            controls[j][FontBold] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=fontStrike then
        if onOff then
            controls[selectedControl][FontStrikeout] = w32True
        else
            controls[selectedControl][FontStrikeout] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][FontStrikeout] = w32True
                        else
                            controls[j][FontStrikeout] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=fontUnderline then
        if onOff then
            controls[selectedControl][FontUnderline] = w32True
        else
            controls[selectedControl][FontUnderline] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][FontUnderline] = w32True
                        else
                            controls[j][FontUnderline] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=winPosTaskBar then
        if onOff then
            controls[selectedControl][WinPosTaskBar] = w32True
        else
            controls[selectedControl][WinPosTaskBar] = w32False
        end if
    end if

    if cell=mcs_multiselect then
        if onOff then
            controls[selectedControl][MCS_multiselect] = w32True
        else
            controls[selectedControl][MCS_multiselect] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][MCS_multiselect] = w32True
                        else
                            controls[j][MCS_multiselect] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=pbs_smooth then
        if onOff then
            controls[selectedControl][PBS_smooth] = w32True
        else
            controls[selectedControl][PBS_smooth] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][PBS_smooth] = w32True
                        else
                            controls[j][PBS_smooth] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=bs_flat then
        if onOff then
            controls[selectedControl][BS_flat] = w32True
            controls[selectedControl][cbFlat] = w32True
        else
            controls[selectedControl][BS_flat] = w32False
            controls[selectedControl][cbFlat] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][BS_flat] = w32True
                            controls[j][cbFlat] = w32True
                        else
                            controls[j][BS_flat] = w32False
                            controls[j][cbFlat] = w32True
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=insystray then
        if onOff then
            createSystrayWin()
            openWindow(SystrayWin, Normal)
        else
            controls[selectedControl][SysTrayIcon] = {}
            controls[selectedControl][SysTrayHint] = {}
            controls[selectedControl][SysTrayText] = {}
        end if
    end if

    if cell=suppressCell then
        if onOff then
            controls[selectedControl][SuppressCell] = w32True
        else
            controls[selectedControl][SuppressCell] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][SuppressCell] = w32True
                        else
                            controls[j][SuppressCell] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=LvAddBottom then
        if onOff then
            controls[selectedControl][SETLVInsert] = w32True
        else
            controls[selectedControl][SETLVInsert] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][SETLVInsert] = w32True
                        else
                            controls[j][SETLVInsert] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridActiveHeaders then
        if onOff then
            controls[selectedControl][GridActiveHeaders] = w32True
        else
            controls[selectedControl][GridActiveHeaders] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][GridActiveHeaders] = w32True
                        else
                            controls[j][GridActiveHeaders] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridAllowColResize then
        if onOff then
            controls[selectedControl][GridAllowColResize] = w32True
        else
            controls[selectedControl][GridAllowColResize] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][GridAllowColResize] = w32True
                        else
                            controls[j][GridAllowColResize] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridAllowColSort then
        if onOff then
            controls[selectedControl][GridAllowColSort] = w32True
        else
            controls[selectedControl][GridAllowColSort] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][GridAllowColSort] = w32True
                        else
                            controls[j][GridAllowColSort] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridCellBorder then
        if onOff then
            controls[selectedControl][GridCellBorder] = w32True
        else
            controls[selectedControl][GridCellBorder] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][GridCellBorder] = w32True
                        else
                            controls[j][GridCellBorder] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridHighlightText then
        if onOff then
            controls[selectedControl][GridHighlightText] = w32True
        else
            controls[selectedControl][GridHighlightText] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][GridHighlightText] = w32True
                        else
                            controls[j][GridHighlightText] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=checked then
        if onOff then
            controls[selectedControl][Checked] = w32True
        else
            controls[selectedControl][Checked] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][Checked] = w32True
                        else
                            controls[j][Checked] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=noIntegralHeight then
        if onOff then
            controls[selectedControl][NoIntegralHeight] = w32True
        else
            controls[selectedControl][NoIntegralHeight] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][NoIntegralHeight] = w32True
                        else
                            controls[j][NoIntegralHeight] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=adjCenter then
        if onOff then
            controls[selectedControl][AdjCenter] = w32True
        else
            controls[selectedControl][AdjCenter] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][AdjCenter] = w32True
                        else
                            controls[j][AdjCenter] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=adjRight then
        if onOff then
            controls[selectedControl][AdjRight] = w32True
        else
            controls[selectedControl][AdjRight] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][AdjRight] = w32True
                        else
                            controls[j][AdjRight] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=setLayerOK then
        if onOff then
            controls[selectedControl][SetLayerOK] = w32True
        else
            controls[selectedControl][SetLayerOK] = w32False
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if not equal("Window",controls[j][Class])
                    and equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][SetLayerOK] = w32True
                        else
                            controls[j][SetLayerOK] = w32False
                        end if
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=useInWinMain then
        if onOff then
            controls[selectedControl][UseInWinMain] = w32True
            --turn off in other windows
            if length(windows) then
                for i=1 to length(windows) do
                    if not equal(windows[i][1][Name],controls[selectedControl][Name]) then
                        windows[i][1][UseInWinMain] = w32False
                    end if
                end for
            end if
        end if
    end if

    if cell=showHintFontVar then
        if onOff then
            controls[selectedControl][ShowHintFontVar] = w32True
        else
            controls[selectedControl][ShowHintFontVar] = w32False
        end if
    end if

    if cell=showFontVar then
        if onOff then
            controls[selectedControl][ShowFontVar] = w32True
        else
            controls[selectedControl][ShowFontVar] = w32False
        end if
    end if

    if cell=upDownLeft then
        if onOff then
            controls[selectedControl][UpDownLeft] = w32True
        else
            controls[selectedControl][UpDownLeft] = w32False
        end if
        call_proc(updateProperty_id,{"UpDownLeft"})
    end if

    if cell=tabsBottom then
        if onOff then
            controls[selectedControl][TabsBottom] = w32True
        else
            controls[selectedControl][TabsBottom] = w32False
        end if
    end if

    if cell=upDownHorz then
        if onOff then
            controls[selectedControl][UpDownHorz] = w32True
        else
            controls[selectedControl][UpDownHorz] = w32False
        end if
        call_proc(updateProperty_id,{"UpDownHorz"})
    end if

    if cell=treatAsColorButton then
        if onOff then
            controls[selectedControl][TreatAsColorButton] = w32True
        else
            controls[selectedControl][TreatAsColorButton] = w32False
        end if
        call_proc(updateProperties_id,{})
    end if

    if cell=cbmultiline then
        if onOff then
            controls[selectedControl][cbMultiline] = w32True
            controls[selectedControl][Multiline] = w32True
        else
            controls[selectedControl][cbMultiline] = w32False
            controls[selectedControl][Multiline] = w32False
        end if
    end if

    if cell=cbflat then
        if onOff then
            controls[selectedControl][cbFlat] = w32True
            controls[selectedControl][BS_flat] = w32True
        else
            controls[selectedControl][cbFlat] = w32False
            controls[selectedControl][BS_flat] = w32False
        end if
    end if

    if cell=cbcentvert then
        if onOff then
            controls[selectedControl][cbCentVert] = w32True
        else
            controls[selectedControl][cbCentVert] = w32False
        end if
    end if

    if cell=parentFrozen then
        if onOff then
                        --user may turn frozen back on via Properties frozen checkbox   
            controls[selectedControl][ParentIsFrozen] = w32True
        else
            controls[selectedControl][ParentIsFrozen] = w32False
        end if
        --find the direct parent of this control
        whoIs = findDirectParent(controls[selectedControl][X], controls[selectedControl][Y],
                                 controls[selectedControl][ControlParent], controls[selectedControl][Name],
                                 selectedControl)
        flag = findSeqParentName(selectedControl)
        removeFromParentChildSeq(flag,controls[selectedControl][Name])
        if whoIs[1] then
            controls[selectedControl][ControlParent] = controls[whoIs[1]][Name]
            controls[selectedControl][SeqParentName] = controls[whoIs[1]][Name]
            controls[selectedControl][SeqParentClass] = whoIs[2]
            controls[selectedControl][Parent] = controls[whoIs[1]][Name]
            addToParentChildSeq(whoIs[1],controls[selectedControl][Name])
            deleteTreeViewNode("", controls[selectedControl][Name])
            addTreeViewNode(controls[whoIs[1]][Name],controls[selectedControl][Name])
            if equal(whoIs[2],"TabItem") then
                controls[selectedControl][ControlParent] = controls[selectedControl][SeqParentName]
                controls[selectedControl][ParentClass] = whoIs[2]
            elsif equal(whoIs[2],"Table") then
                controls[selectedControl][Parent] = controls[whoIs[1]][Name]
                controls[selectedControl][ControlParent] = controls[selectedControl][SeqParentName]
                controls[selectedControl][ParentClass] = whoIs[2]
            end if
            --add children of unfrozen control to treeview
            if length(controls[selectedControl][SeqChildName]) then
                addChildToNode(selectedControl)
            end if
        else
            --parent is Window1                             
            --move control to window1 in treeview
            deleteTreeViewNode("", controls[selectedControl][Name])
            addTreeViewNode(controls[TheWindow][Name],controls[selectedControl][Name])
            --add children of unfrozen control to treeview                  
            if length(controls[selectedControl][SeqChildName]) then
                addChildToNode(selectedControl)
            end if
            --now remove parenting
            controls[selectedControl][SeqParentName] = {}
            controls[selectedControl][SeqParentClass] = {}
            controls[selectedControl][ControlParent] = {}
            controls[selectedControl][ParentClass] = {}
            controls[selectedControl][Parent] = {}
        end if
        call_proc(updateProperty_id,{"Parent"})

        for i=1 to length(MultiPropertySelect) do
            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                for j=1 to length(controls) do
                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                        if onOff then
                            controls[j][ParentIsFrozen] = w32True
                        else
                            controls[j][ParentIsFrozen] = w32False
                            if whoIs[1] then
                                flag = findSeqParentName(selectedControl)
                                removeFromParentChildSeq(flag,controls[selectedControl][Name])
                                controls[j][SeqParentName] = controls[whoIs[1]][Name]
                                controls[j][SeqParentClass] = whoIs[2]
                                deleteTreeViewNode("", controls[j][Name])
                                addTreeViewNode(controls[whoIs[1]][Name],controls[j][Name])
                                if equal(whoIs[2],"TabItem") then
                                    controls[j][ControlParent] = controls[selectedControl][SeqParentName]
                                    controls[j][ParentClass] = whoIs[2]
                                elsif equal(whoIs[2],"Table") then
                                    controls[j][Parent] = controls[whoIs[1]][Name]
                                    controls[j][ControlParent] = controls[j][SeqParentName]
                                    controls[j][ParentClass] = whoIs[2]
                                end if
                            end if
                            call_proc(updateProperty_id,{"Parent"})
                        end if
                        exit
                    end if
                end for
            end if
        end for
        call_proc(updateProperty_id,{"Frozen"})
    end if

    if cell=removeCopyIndex then
        if onOff then
            for i=1 to length(controls) do
                if equal(controls[i][Name],controls[selectedControl][IndexParent]) then
                    controls[i][Indexed] = 0
                    exit
                end if
            end for
            controls[selectedControl][IndexParent] = {}
            call_proc(updateProperties_id,{})
        end if
    end if

    if cell=setcreatefont then
        if onOff then
            controls[selectedControl][setCreatefont] = w32True
        else
            controls[selectedControl][setCreatefont] = w32False
        end if
    end if

    endChanges(cell)

    return w32True
end function
integer checkBoxes_rid
checkBoxes_rid = routine_id("checkBoxOnOff")
--------------------------------------------------------------------------------
procedure moveNegChild(integer index)
integer childCnt

    childCnt = 0
    --take any children of this control and take off screen also
    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],
                    controls[index][SeqParentName]) then
                controls[i][X] *= -1
                childCnt += 1
                if length(controls[i][SeqChildName]) then
                    moveNegChild(i)
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if
end procedure
--------------------------------------------------------------------------------
procedure addToNegChild(integer index, integer diff)
integer childCnt

    childCnt = 0
    --take any children of this control and take off screen also
    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],
                    controls[index][SeqParentName]) then
                controls[i][X] += diff
                childCnt += 1
                if length(controls[i][SeqChildName]) then
                    addToNegChild(i, diff)
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if
end procedure
--------------------------------------------------------------------------------
function checkXY(integer cell, integer event, sequence params)
integer ok
object attrib
sequence the, multiThe
integer tempDisable, childCnt, diff, calcDiff, holdControl
sequence size, aattrib

    if skipValidations then
        --when a control has a negative value and is moved offscreen and then
        --TheWindow is clicked, the negative value from the offscreen control was
        --kicking in before the Window column values were moved into Properties.
        return w32True
    end if

    attrib = params[1]

    if not length(attrib) then
        return w32True
    end if

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    the = controls[selectedControl]
    if integer(attrib)
    and cell=col
    and attrib=the[X] then
        return w32True
    end if
    if integer(attrib)
    and cell=row
    and attrib=the[Y] then
        return w32True
    end if
    if integer(attrib)
    and cell=width
    and attrib=the[CX] then
        return w32True
    end if
    if integer(attrib)
    and cell=height
    and attrib=the[CY] then
        return w32True
    end if

    aattrib = attrib

    if cell=col
    or cell=row then
        --when in Property Sheet temporarily disable grid snap
        tempDisable = GridDisable
        GridDisable = w32True
        focusDesign = w32False   --keeps Design from getting focus between keystrokes
        if selectedControl=TheWindow then
            if equal(upper(attrib), "DEFAULT") then
                -- w32False/w32True is backwards so do not have to convert all existing
                -- PRj files
                controls[selectedControl][DefaultXY] = w32False
                attrib = 0
            else
                attrib = floor(val(attrib))
                controls[selectedControl][DefaultXY] = w32True
                if attrib<0 then
                    GridDisable = tempDisable
                    ok = displayErrorMessage(201,{})
                    if cell=col then
                        if controls[selectedControl][DefaultXY] then
                            setProperty(col, "Default")
                        else
                            setProperty(col, sprintf("%d",controls[selectedControl][X]))
                        end if
                    else
                        if controls[selectedControl][DefaultXY] then
                            setProperty(row, "Default")
                        else
                            setProperty(row, sprintf("%d",controls[selectedControl][Y]))
                        end if
                    end if
                    return prInvalidDontChange
                end if
            end if
            if cell=col then
                if length(aattrib)>8 then
                    ok = displayErrorMessage(160,{})
                    setProperty(col, sprintf("%d",controls[selectedControl][X]))
                    return prInvalidDontChange
                end if
                controls[selectedControl][X] = attrib
            else
                if length(aattrib)>8 then
                    ok = displayErrorMessage(160,{})
                    setProperty(row, sprintf("%d",controls[selectedControl][Y]))
                    return prInvalidDontChange
                end if
                controls[selectedControl][Y] = attrib
            end if
        else
            if equal(upper(attrib), "DEFAULT") then
                --error; only window may use default
                ok = displayErrorMessage(1,{})
                return prInvalidDontChange
            else
                attrib = floor(val(attrib))
                if cell=row
                and attrib<0 then
                    ok = displayErrorMessage(206,{})
                    setProperty(row, sprintf("%d",controls[selectedControl][Y]))
                    return prInvalidDontChange
                end if
            end if
            if cell=col then
                if length(aattrib)>8 then
                    ok = displayErrorMessage(160,{})
                    setProperty(col, sprintf("%d",controls[selectedControl][X]))
                    return prInvalidDontChange
                end if
                controls[selectedControl][X] = attrib
            else
                if length(aattrib)>8 then
                    ok = displayErrorMessage(160,{})
                    setProperty(row, sprintf("%d",controls[selectedControl][Y]))
                    return prInvalidDontChange
                end if
                controls[selectedControl][Y] = attrib
            end if

            if cell=col then
                if controls[selectedControl][X]<0
                or controls[selectedControl][Y]<0 then

                    if the[X]<0 then
                        --need to add to the negative amount of children
                        diff = controls[selectedControl][X]-the[X]
                        childCnt = 0
                        if length(controls[selectedControl][SeqChildName]) then
                            for i=selectedControl to length(controls) do
                                if find(controls[i][Name],
                                        controls[selectedControl][SeqChildName]) then
                                    controls[i][X] += diff
                                    childCnt += 1
                                    if length(controls[i][SeqChildName]) then
                                        addToNegChild(i,diff)
                                    end if
                                end if
                                if childCnt>=length(controls[selectedControl][SeqChildName]) then
                                    exit
                                end if
                            end for
                        end if
                    else
                        --find any children of this control and take off screen also
                        childCnt = 0
                        if length(controls[selectedControl][SeqChildName]) then
                            for i=selectedControl to length(controls) do
                                if find(controls[i][Name],
                                        controls[selectedControl][SeqChildName]) then
                                    controls[i][X] *= -1
                                    childCnt += 1
                                    if length(controls[i][SeqChildName]) then
                                        moveNegChild(i)
                                    end if
                                end if
                                if childCnt>=length(controls[selectedControl][SeqChildName]) then
                                    exit
                                end if
                            end for
                        end if
                    end if
                elsif the[X]<0 then
                    --bring onscreen again any children of this control
                    childCnt = 0
                    if length(controls[selectedControl][SeqChildName]) then
                        for i=selectedControl to length(controls) do
                            if find(controls[i][Name],
                                    controls[selectedControl][SeqChildName]) then
                                controls[i][X] *= -1
                                childCnt += 1
                                if length(controls[i][SeqChildName]) then
                                    moveNegChild(i)
                                end if
                            end if
                            if childCnt>=length(controls[selectedControl][SeqChildName]) then
                                exit
                            end if
                        end for
                    end if

                    call_proc(check_MoveDrag_id,{the[X]*-1,the[Y], the[X]*-1, the[Y],
                                                 the[CX], the[CY], w32False, w32False})
                else
                    if selectedControl!=TheWindow then
                        if length(MultiPropertySelect) then
                            calcDiff = controls[selectedControl][X]-the[X]
                        end if
                        for i=1 to length(MultiPropertySelect) do
                            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                                for j=1 to length(controls) do
                                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                                        controls[j][X] += calcDiff
                                        exit
                                    end if
                                end for
                            end if
                        end for
                        call_proc(check_MoveDrag_id,{the[X],the[Y], the[X], the[Y],
                                                     the[CX], the[CY], w32False, w32False})
                        for i=1 to length(MultiPropertySelect) do
                            if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                                for j=1 to length(controls) do
                                    if equal(MultiPropertySelect[i], controls[j][Name]) then
                                        multiThe = controls[j]
                                        holdControl = selectedControl
                                        selectedControl = j
                                        multiThe[X] -= calcDiff --put back to original value
                                        call_proc(check_MoveDrag_id,{multiThe[X], multiThe[Y],
                                                                     multiThe[X], multiThe[Y],
                                                                     multiThe[CX],multiThe[CY], w32False, w32False})
                                        selectedControl = holdControl
                                        exit
                                    end if
                                end for
                            end if
                        end for
                    end if
                end if
            elsif cell=row then
                if selectedControl!=TheWindow then
                    if length(MultiPropertySelect) then
                        calcDiff = controls[selectedControl][Y]-the[Y]
                    end if
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][Y] += calcDiff
                                    exit
                                end if
                            end for
                        end if
                    end for
                    call_proc(check_MoveDrag_id,{the[X],the[Y], the[X], the[Y],
                                                 the[CX], the[CY], w32False, w32False})
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    multiThe = controls[j]
                                    holdControl = selectedControl
                                    selectedControl = j
                                    multiThe[Y] -= calcDiff --put back to original value
                                    call_proc(check_MoveDrag_id,{multiThe[X], multiThe[Y],
                                                                 multiThe[X], multiThe[Y],
                                                                 multiThe[CX],multiThe[CY], w32False, w32False})
                                    selectedControl = holdControl
                                    exit
                                end if
                            end for
                        end if
                    end for
                end if
            end if
        end if
        GridDisable = tempDisable
    end if

    if cell=width
    or cell=height then
        aattrib = attrib
        attrib = floor(val(attrib))
        --when in Property Sheet temporarily disable grid snap
        tempDisable = GridDisable
        GridDisable = w32True

        if attrib<0 then
            GridDisable = tempDisable
            ok = displayErrorMessage(201,{})
            MultiPropertySelect = {}
            if cell=width then
                setProperty(width, sprintf("%d",controls[selectedControl][CX]))
            else
                setProperty(height, sprintf("%d",controls[selectedControl][CY]))
            end if
            return prInvalidDontChange
        end if

                -- save change
        if cell=width then
            if length(aattrib)>8 then
                ok = displayErrorMessage(160,{})
                setProperty(width, sprintf("%d",controls[selectedControl][CX]))
                return prInvalidDontChange
            end if
            controls[selectedControl][CX] = attrib
        else
            if length(aattrib)>8 then
                ok = displayErrorMessage(160,{})
                setProperty(height, sprintf("%d",controls[selectedControl][CY]))
                return prInvalidDontChange
            end if
            controls[selectedControl][CY] = attrib
        end if

        if selectedControl!=TheWindow then
            call_proc(check_ResizeDrag_id,{the[CX], the[CY]})
        end if

        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        --save change
                        multiThe = controls[j]
                        if cell=width then
                            controls[j][CX] = attrib
                        else
                            controls[j][CY] = attrib
                        end if

                        if not equal(controls[j][Class], "Window") then
                            call_proc(check_ResizeDrag_id,{multiThe[CX], multiThe[CY]})
                        end if
                        exit
                    end if
                end for
            end if
        end for

        GridDisable = tempDisable

        if selectedControl=TheWindow then
            dCX = controls[selectedControl][CX]
            dCY = controls[selectedControl][CY]

            cameFromProperty = w32True
            size = getCtlSize(LayersTC)
            setRect(LayersTC, 0, 0, dCX, size[2], w32True)
            setRect(Design, dX, dY, dCX, dCY, w32True)
            if showActive then
                setRect(Show, dX, dY, dCX, dCY, w32True)
            end if

            cameFromProperty = w32False

            gridX = dCX
            gridY = dCY

            --change the scrollbar ranges
            size = getClientRect(Form)

            if dCX<=size[3] then
                setWindowScrollRange(Form, SB_HORZ, 0, 0, 1)
            else
                setWindowScrollRange(Form, SB_HORZ, 1, dCX, size[3])
            end if
            if dCY<=size[4] then
                setWindowScrollRange(Form, SB_VERT, 0, 0, 1)
            else
                setWindowScrollRange(Form,SB_VERT, 1, dCY, size[4])
            end if

            --reset scroll position
            setHScrollPos(Form, 1)
            setVScrollPos(Form, 1)

        end if

    end if

    endChanges(cell)

    return w32True

end function
integer XY_rid
XY_rid = routine_id("checkXY")
--------------------------------------------------------------------------------
function checkNumber(integer cell, integer event, sequence params)
object text
atom num
integer ok
sequence the, multiThe, testFontName
integer testFontAttrib, testFontPts
integer tempDisable

    text = params[1]

    for i=1 to length(text) do
        if text[i]<'0' or text[i]>'9' then
            ok = displayErrorMessage(202,{})
            return w32False
        end if
    end for

--DEV???
--      if (cell = fontPts and length(getProperty(fontName)))
--      or (cell = hintFontPts and length(getProperty(hintFontName)))
--      and not length(text) then
    if ((cell=fontPts and length(getProperty(fontName)))
        or (cell=hintFontPts and length(getProperty(hintFontName))))
    and not length(text) then
        if cell=fontPts then
            ok = displayErrorMessage(203,{})
            return prInvalidDontChange
        end if
        if cell=hintFontPts then
            ok = displayErrorMessage(203,{})
            return prInvalidDontChange
        end if
    end if


    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    --if good update file
    num = floor(val(text))
    the = controls[selectedControl]
    if cell=toolHeight then
        tempDisable = GridDisable
        GridDisable = w32True

        controls[selectedControl][ToolRowCY] = num
        if controls[selectedControl][ToolRowCY]>controls[selectedControl][CY] then
            controls[selectedControl][CY] = controls[selectedControl][ToolRowCY]
        end if

        if controls[selectedControl][ToolRowCY] then
            --force recalculation of toolbar and its controls
            call_proc(check_ResizeDrag_id,{the[CX], the[CY]})
        end if

        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        multiThe = controls[j]
                        controls[j][ToolRowCY] = num
                        if controls[j][ToolRowCY]>
                                                  controls[j][CY] then
                            controls[j][CY] =
                                controls[j][ToolRowCY]
                        end if

                        if controls[j][ToolRowCY] then
                            --force recalculation of toolbar and its controls
                            call_proc(check_ResizeDrag_id,{multiThe[CX], multiThe[CY]})
                        end if
                        exit
                    end if
                end for
            end if
        end for

        GridDisable = tempDisable
    end if

    if cell=fontPts then
        controls[selectedControl][FontPts] = num
        if equal(controls[selectedControl][Class], "ReBar") then

        --need to adjust the ReBarBand contents
            testFontAttrib = 0
            if controls[selectedControl][FontAttrib] then
                testFontAttrib = Italic
            end if
            if controls[selectedControl][FontBold] then
                testFontAttrib += controls[selectedControl][FontBold]
            end if
            if controls[selectedControl][FontUnderline] then
                testFontAttrib += 4
            end if
            if controls[selectedControl][FontStrikeout] then
                testFontAttrib += 8
            end if

            if length(controls[selectedControl][FontName]) then
                testFontName = controls[selectedControl][FontName]
                testFontPts = controls[selectedControl][FontPts]
            else
                testFontName = ""
            end if

            if length(testFontName) then
                setFont(ControlBlit, controls[selectedControl][FontName],
                        controls[selectedControl][FontPts], testFontAttrib)
            else
                setDefaultFont(ControlBlit)
            end if
        elsif equal(controls[selectedControl][Class], "MonthCalendar") then
            findCalendarSize(selectedControl)
        end if
    end if

    if cell=hintFontPts then
        controls[selectedControl][HintFontPts] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][HintFontPts] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=alimitText then
        controls[selectedControl][Limit] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][Limit] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=minValue then
        controls[selectedControl][MinValue] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MinValue] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=maxValue then
        controls[selectedControl][MaxValue] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MaxValue] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=lineChg then
        controls[selectedControl][LineChg] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][LineChg] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=pageChg then
        controls[selectedControl][PageChg] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][PageChg] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridHeaderDataColVal then
        controls[selectedControl][GridHeaderInCol] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridHeaderInCol] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridHeaderColHeight then
        controls[selectedControl][GridColHeaderCY] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridColHeaderCY] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridHeaderRowWidth then
        controls[selectedControl][GridRowHeaderCX] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridRowHeaderCX] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridRowHeight then
        controls[selectedControl][GridRowCY] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridRowCY] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=gridColListDataCol then
        controls[selectedControl][GridColListDataCol] = num
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i],controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridColListDataCol] = num
                        exit
                    end if
                end for
            end if
        end for
    end if

    if cell=transparency then
        controls[selectedControl][WinTransparency] = num
    end if

    if cell=cbthickness then
        controls[selectedControl][cbThickness] = num
    end if

    endChanges(cell)

    return w32True
end function
integer number_rid
number_rid = routine_id("checkNumber")
--------------------------------------------------------------------------------
function checkValidName(sequence theName)
integer ok

    if not ((theName[1]>='a' and theName[1]<='z') or
            (theName[1]>='A' and theName[1]<='Z')) then
        ok = displayErrorMessage(204,sprintf("%s",theName[1]))
        return w32False
    end if
    for i=2 to length(theName) do
        if not (theName[i]='_' or (theName[i]>='a' and theName[i]<='z') or
                (theName[i]>='A' and theName[i]<='Z') or
                (theName[i]>='0' and theName[i]<='9')) then
            ok = displayErrorMessage(205,sprintf("%s",theName[i]))
            return w32False
        end if
    end for

    return w32True
end function
--------------------------------------------------------------------------------
procedure checkChildNameChange(sequence control, sequence tempName, sequence newName,
                integer index)
integer childCnt

    childCnt = 0
    if length(control[SeqChildName]) then
        for j=index to length(controls) do
            if find(controls[j][Name], control[SeqChildName]) then
                childCnt += 1
                if equal(controls[j][ControlParent], tempName) then
                    controls[j][ControlParent] = newName
                end if
                if equal(controls[j][SeqParentName], tempName) then
                    controls[j][SeqParentName] = newName
                end if
                checkChildNameChange(controls[j], tempName, newName, j)

                if childCnt>=length(control[SeqChildName]) then
                    exit
                end if
            end if
        end for
    end if
end procedure
--------------------------------------------------------------------------------
function snap(integer i)
    -- position to closest nth pixel
    if GridDisable then
        return i
    else
        return floor(i/SnapSize)*SnapSize
    end if
end function
--------------------------------------------------------------------------------
integer namewait        namewait = w32False
function checkName(integer cell, integer event, sequence params)
sequence ctrls, tempName, testFontName,theName, info
sequence origLen, textLen, the
integer indexWin, testFontPts, testFontAttrib, chgLen, thisOne, hit, childCnt,
            nextChildCnt

    --press Enter Key or Tab in property, params2=1
    theName = params[1]
    the = controls[selectedControl]

    if cell=name
    and not equal(theName, the[Name]) then
    --turn off multiple selection
        MultiPropertySelect = {}
        if length(theName) then
            ok = checkValidName(theName)
            if not ok then
                return w32False
            end if
        else
            ok = displayErrorMessage(203,{})
            return prInvalidDontChange
        end if

        --Name may not be same as the Class when Bind
        if equal(theName, controls[selectedControl][Class]) then
            --issue warning
            ok = displayErrorMessage(195,{})
        end if

                --find if already used
        for i=1 to length(windows) do
            ctrls = windows[i]
            for j=1 to length(ctrls) do
                if i=selectedWindow
                and j=selectedControl then
                        --ignore it
                elsif equal(theName, ctrls[j][Name]) then
                    --change it back
                    ok = displayErrorMessage(2,{})
                    setProperty(name, controls[selectedControl][Name])
                    return w32False
                end if
            end for
        end for

        if namewait then        --set from Properties test find("Name",waitForKeys)                     
            textOrigName = controls[selectedControl][Name]
            origName = controls[selectedControl][Name]
            canChangeIt = w32True
        else
            if not params[2] then
                if not length(textOrigName) then
                    textOrigName = controls[selectedControl][Name]
                end if
                origName = the[Name]
            end if
            if params[2] then
                if length(textOrigName) then
                    canChangeIt = w32True
                end if
            end if
        end if

        IDE_Changed = w32True
        --backup
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)

                --update file,properties dropdown, Project View
        --and also window dropdown if class = window      
        if equal(getProperty(name), theName) then
                    --nothing to change
        else
            indexWin = getIndex(PropertyTitleBar)
            ok = deleteItem(PropertyTitleBar, indexWin)
            ok = insertItem(PropertyTitleBar,theName, indexWin)
            setIndex(PropertyTitleBar, indexWin)

                                -- force tabitemcombo to select the new name in rebuildwindowlist
            --routine.
            tabNewTitle = theName

            --save the original name for checking to tabitem controls
            tempName = controls[selectedControl][Name]

            for i=1 to getCount(TheTabItemCombo) do
                if equal(getItem(TheTabItemCombo, i), tempName) then
                    ok = deleteItem(TheTabItemCombo, i)
                    ok = insertItem(TheTabItemCombo, theName, i)
                    setIndex(TheTabItemCombo, i)
                    exit
                end if
            end for

            --then save the new name
            controls[selectedControl][Name]    = theName

            --check for name change on bars
            if find(controls[selectedControl][Class], {"ToolBar","FlatToolBar"}) then
                for i=1 to length(toolBarInfo) do
                    if equal(tempName, toolBarInfo[i][8]) then
                        toolBarInfo[i][8] = theName
                        exit
                    end if
                end for
            end if

            --check for name change on tabs
            if equal(controls[selectedControl][Class], "TabItem")
            and equal(selectedTabItem, controls[selectedControl][Name]) then
                selectedTabItem = theName
            end if

            --change name in tab coordinates
            for i=1 to length(tabItemCoordinates) do
                if equal(theName,tabItemCoordinates[i][5]) then
                    tabItemCoordinates[i][5] = theName
                end if
            end for

            --check for name change in resources
            if length(controlResource) then
                for i=1 to length(controlResource) do
                    if equal(tempName, controlResource[i][1]) then
                        controlResource[i][1] = theName
                        exit
                    end if
                end for
            end if

            --change name in any ControlPartners list
            for i=1 to length(controls) do
                at = find(tempName,controls[i][ControlPartners])
                if at then
                    controls[i][ControlPartners][at] = theName
                end if
            end for

                --find all occurances of the old name in the ControlParent, Parent and Children and
                    --change to the new name.
            if length(controls[selectedControl][SeqChildName]) then
                childCnt = 0
                for j=selectedControl to length(controls) do
                    if find(controls[j][Name],controls[selectedControl][SeqChildName]) then
                        childCnt += 1
                        if equal(controls[j][ControlParent], origName) then
                            controls[j][ControlParent] = theName
                        end if
                        if equal(controls[j][SeqParentName], origName) then
                            controls[j][SeqParentName] = theName
                        end if
                        checkChildNameChange(controls[j], origName, theName, j)
                    end if
                    if childCnt>=length(controls[selectedControl][SeqChildName]) then
                        exit
                    end if
                end for
            end if
            --maybe this container has another container as parent, if so need to change the child recorded is that parent
            if length(controls[selectedControl][SeqParentName]) then
                for i=selectedControl to 1 by -1 do
                    if equal(controls[i][Name], controls[selectedControl][SeqParentName]) then
                        for j=1 to length(controls[i][SeqChildName]) do
                            if equal(controls[i][SeqChildName][j], origName) then
                                controls[i][SeqChildName][j] = theName
                                exit    --should only be in parent once
                            end if
                        end for
                        exit        --should be in only one parent
                    end if
                end for
            end if

            info = getControlInfo(ProjectWindow, {CONTROLINFO_closed})
            if not info[1] then
            -- is open 
                buildProjectView = w32True
            end if
        end if

        if selectedControl=TheWindow then
        --change name in WinList
            indexWin = getIndex(WinList)
            ok = deleteItem(WinList, indexWin)
            ok = insertItem(WinList, theName, indexWin)
            setIndex(WinList, indexWin)
        end if

    elsif cell=caption
      and not equal(theName,the[Title]) then
        IDE_Changed = w32True
        --backup
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)
        if equal(controls[selectedControl][Class], "LabelEdit") then
            --turn off multiple property select
            MultiPropertySelect = {}
            controls[selectedControl][Title] = theName
            textLen = getTextExtent(selectedControl, theName)
            controls[selectedControl][LabelExtent] = snap(textLen[1])
        elsif equal(controls[selectedControl][Class], "TabItem") then
            --turn off multiple property select
            MultiPropertySelect = {}
            controls[selectedControl][Title]   = theName
        else
            controls[selectedControl][Title]   = theName
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][Title] = theName
                            exit
                        end if
                    end for
                end if
            end for
        end if

        if equal(controls[selectedControl][Class], "ReBarBand") then
        --need to adjust the ReBarBand subcontrols
        --find the font of Rebar            
            for j=selectedControl to 1 by -1 do
                if equal(controls[j][Name],controls[selectedControl][SeqParentName]) then
                    thisOne = j
                    exit
                end if
            end for
            testFontAttrib = 0
            if controls[thisOne][FontAttrib] then
                testFontAttrib = Italic
            end if
            if controls[thisOne][FontBold] then
                testFontAttrib += controls[thisOne][FontBold]
            end if
            if controls[thisOne][FontUnderline] then
                testFontAttrib += 4
            end if
            if controls[thisOne][FontStrikeout] then
                testFontAttrib += 8
            end if

            if length(controls[thisOne][FontName]) then
                testFontName = controls[thisOne][FontName]
                testFontPts = controls[thisOne][FontPts]
            else
                testFontName = ""
            end if

            if length(testFontName) then
                setFont(ControlBlit, testFontName, testFontPts, testFontAttrib)
            else
                setDefaultFont(ControlBlit)
            end if

            --adjust its X
            origLen = getTextExtent(ControlBlit, the[Title])
            textLen = getTextExtent(ControlBlit, controls[selectedControl][Title])
            chgLen = textLen[1]-origLen[1]
            controls[selectedControl][CX] += chgLen
            --adjust X of children of rebarband
            if length(controls[selectedControl][SeqChildName]) then
                childCnt = 0
                for i=selectedControl to length(controls) do
                    if find(controls[i][Name], controls[selectedControl][SeqChildName]) then
                        childCnt += 1
                        controls[i][X] += chgLen
                        controls[i][CX] = controls[selectedControl][CX]-10-controls[i][X]
                    end if
                    if childCnt>=length(controls[selectedControl][SeqChildName]) then
                        exit
                    end if
                end for
            end if

                --are there other rebarband on the same Y?
            if length(controls[thisOne][SeqChildName]) then
                childCnt = 0
                for i=thisOne to length(controls) do
                    if find(controls[i][Name], controls[thisOne][SeqChildName]) then
                        childCnt += 1
                        hit = i
                        if controls[hit][X]>controls[selectedControl][X]
                        and controls[hit][Y]=controls[selectedControl][Y]
                        and hit!=selectedControl then
                            --does it have controls?
                            if length(controls[hit][SeqChildName]) then
                                nextChildCnt = 0
                                for j=hit to length(controls) do
                                    if find(controls[j][Name], controls[hit][SeqChildName]) then
                                        nextChildCnt += 1
                                        controls[j][X] += chgLen
                                    end if
                                    if nextChildCnt>=length(controls[hit][SeqChildName]) then
                                        exit
                                    end if
                                end for
                            end if
                        end if

                        --adjust rebarband also
                        if not controls[hit][RBBSBREAK]
                        and hit!=selectedControl then
                            controls[hit][X] += chgLen
                        end if
                        if childCnt>=length(controls[thisOne][SeqChildName]) then
                            exit
                        end if
                    end if
                end for
            end if
        end if

        if selectedControl=TheWindow then
            setText(Design, theName)
            if showActive then
                setText(Show, theName)
            end if
        end if
    end if

    if length(params)>1
    and params[2]=1 then--tab or enter key used
        setFocus(Design)
    end if

    endChanges(cell)

    return w32True
end function
integer name_rid
name_rid = routine_id("checkName")
--------------------------------------------------------------------------------
function keyedFont(integer cell, integer event, sequence params)
object kfont

    kfont = params[1]

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    if find(lower(kfont),theDefaultFont[1])--{"default","<default>"})
    or not length(kfont) then
        if cell=fontName then
            setProperty(fontPts,sprint(theDefaultFont[2]))--"")
            setProperty(fontBold, w32False)
            setProperty(fontItalic, w32False)
            setProperty(fontUnderline, w32False)
            setProperty(fontStrike, w32False)
            if not length(kfont) then
                setProperty(fontName,theDefaultFont[1])--"")                                    
            end if
            controls[selectedControl][FontName] = theDefaultFont[1]--{}
            controls[selectedControl][FontPts] = theDefaultFont[2]
            if equal(controls[selectedControl][Class], "MonthCalendar") then
                findCalendarSize(selectedControl)
            end if
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontName] = {}
                            if equal(controls[j][Class], "MonthCalendar") then
                                findCalendarSize(j)
                            end if
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(hintFontPts,sprint(theDefaultFont[2]))--"")
            setProperty(hintFontBold, w32False)
            setProperty(hintFontItalic, w32False)
            setProperty(hintFontUnderline, w32False)
            setProperty(hintFontStrike, w32False)
            if not length(kfont) then
                setProperty(hintFontName,theDefaultFont[1])--"")        
            end if
            controls[selectedControl][HintFontName] = theDefaultFont[1]--{}
            controls[selectedControl][HintFontPts] = theDefaultFont[2]
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontName] = theDefaultFont[1]--{}
                            exit
                        end if
                    end for
                end if
            end for
        end if
    else
        if cell=fontName then
            controls[selectedControl][FontName] = kfont
            if equal(controls[selectedControl][Class], "MonthCalendar") then
                findCalendarSize(selectedControl)
            end if
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontName] = kfont
                            if equal(controls[j][Class], "MonthCalendar") then
                                findCalendarSize(j)
                            end if
                            exit
                        end if
                    end for
                end if
            end for
        else
            controls[selectedControl][HintFontName] = kfont
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontName] = kfont
                            exit
                        end if
                    end for
                end if
            end for
        end if
    end if

    endChanges(cell)

    return w32True
end function
integer font2_rid
font2_rid = routine_id("keyedFont")
--------------------------------------------------------------------------------
function chooseTheFont(integer cell, integer event, sequence params)

integer points, attribBold,attribItalic,attribUnderline,attribStrike, pickColor
sequence edittext, testFontName, chooseFont
integer testFontAttrib, testFontPts

--for getfontdialogEx
object fontdata, lf,hf
integer lFontHeight
integer attrib
sequence facename

    edittext = params[1]

    if cell=fontName then
        if not length(edittext) then
            chooseFont = controls[selectedControl][FontName]
        else
            chooseFont = edittext
        end if

    elsif cell=hintFontName then
        if not length(edittext) then
            chooseFont = controls[selectedControl][HintFontName]
        else
            chooseFont = edittext
        end if
    end if

    -- This returns height values for the user selected font size
    if equal(controls[selectedControl][Class],"RichEdit") then
        lFontHeight = convPointsToLogical(testControlRE, controls[selectedControl][FontPts], w32True)
    else
        lFontHeight = convPointsToLogical(testControl, controls[selectedControl][FontPts], w32True)
    end if

    --these are the attributes the user selected
    attrib = 0 --No attributes, or some combination such as attrib=Bold+Underline+Italic+Strikeout
    if controls[selectedControl][FontAttrib] then
        attrib = Italic
    end if
    if controls[selectedControl][FontBold] then
        attrib += Bold
    end if
    if controls[selectedControl][FontUnderline] then
        attrib += Underline
    end if
    if controls[selectedControl][FontStrikeout] then
        attrib += Strikeout
    end if

    --thanks to Chris Cuvier for working with me on preping the LOGFONT structure
    --this the font name user selected
    facename = chooseFont--controls[selectedControl][FontName]
    if equal(controls[selectedControl][Class],"RichEdit") then
        hf = sendMessage(testControlRE,WM_GETFONT,0,0) -- get a handle on control font  
    else
        hf = sendMessage(testControl,WM_GETFONT,0,0) -- get a handle on control font
    end if
    lf = w32acquire_mem(0,SIZEOF_LOGFONT)
    w32VOID = w32Func(xGetObject,{hf,SIZEOF_LOGFONT,lf}) -- get copy of associated LOGFONT structure
    w32store(lf,lfHeight,lFontHeight) -- change the size
    w32store(lf, lfFaceName,facename)-- change the font name
    -- store styles
    w32store(lf, lfItalic,         (and_bits(attrib, Italic)    )!=0)
    w32store(lf, lfUnderline,      (and_bits(attrib, Underline))!=0)
    w32store(lf, lfStrikeOut,      (and_bits(attrib, Strikeout))!=0)
    if and_bits(attrib, 1) then
        w32store(lf, lfWeight, ((and_bits(attrib, Bold)  )!=0)*setFontWeight(w32GetValue))
    end if

    -- clear attributes
    testFontName = {}
    points = 0
    attribBold = 0
    attribItalic = 0
    attribUnderline = 0
    attribStrike = 0
    pickColor = 0

    if equal(controls[selectedControl][Class], "RichEdit") then
        fontdata = getFontDialogEx(testControlRE,CF_SCREENFONTS+CF_EFFECTS+CF_INITTOLOGFONTSTRUCT,{{CF_INITTOLOGFONTSTRUCT,lf}})
    else
        fontdata = getFontDialogEx(testControl,CF_SCREENFONTS+CF_EFFECTS+CF_INITTOLOGFONTSTRUCT,{{CF_INITTOLOGFONTSTRUCT,lf}})
    end if

    if sequence(fontdata) then
        testFontName = fontdata[1]

        -- bold?
        if w32fetch(lf, lfWeight)>=FW_BOLD then
            attribBold = Bold
        end if

        -- italic?
        if w32fetch(lf, lfItalic) then
            attribItalic = Italic
        end if

        -- underline?
        if w32fetch(lf, lfUnderline) then
            attribUnderline = Underline
        end if

        -- strikeout?
        if w32fetch(lf, lfStrikeOut) then
            attribStrike = Strikeout
        end if

        -- points
        points = fontdata[2]

        --get font color        
        pickColor = fontdata[4]
    end if
    w32release_mem(lf)

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    if cell=fontName
    and sequence(fontdata) then
        controls[selectedControl][FontName] = testFontName
        setProperty(fontName, testFontName)
        setProperty(fontPts, sprintf("%d",points))
        controls[selectedControl][FontPts] = points
        if equal(controls[selectedControl][Class], "MonthCalendar") then
            findCalendarSize(selectedControl)
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][FontName] = testFontName
                        controls[j][FontPts] = points
                        if equal(controls[j][Class], "MonthCalendar") then
                            findCalendarSize(j)
                        end if
                        exit
                    end if
                end for
            end if
        end for
        if attribBold then
            setProperty(fontBold, w32True)
            controls[selectedControl][FontBold] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontBold] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(fontBold, w32False)
            controls[selectedControl][FontBold] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontBold] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if
        if attribItalic then
            setProperty(fontItalic, w32True)
            controls[selectedControl][FontAttrib] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontAttrib] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(fontItalic, w32False)
            controls[selectedControl][FontAttrib] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontAttrib] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if
        if attribUnderline then
            setProperty(fontUnderline, w32True)
            controls[selectedControl][FontUnderline] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][Underline] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(fontUnderline, w32False)
            controls[selectedControl][FontUnderline] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontUnderline] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if

        if attribStrike then
            setProperty(fontStrike, w32True)
            controls[selectedControl][FontStrikeout] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontStrikeout] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(fontStrike, w32False)
            controls[selectedControl][FontStrikeout] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontStrikeout] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if

        if equal(controls[selectedControl][Class], "RichEdit") then
            controls[selectedControl][FontColor] = pickColor
            setProperty(fontColor, sprintf("%d",pickColor))
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontColor] = pickColor
                            exit
                        end if
                    end for
                end if
            end for
        else
            controls[selectedControl][FontColor] = 0
            setProperty(fontColor, "")
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontColor] = 0
                            exit
                        end if
                    end for
                end if
            end for
        end if

    elsif cell=hintFontName
      and sequence(fontdata) then
        controls[selectedControl][HintFontName] = testFontName
        setProperty(hintFontName, testFontName)
        setProperty(hintFontPts, sprintf("%d",points))
        controls[selectedControl][HintFontPts] = points
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][HintFontName] = testFontName
                        controls[j][HintFontPts] = points
                        exit
                    end if
                end for
            end if
        end for

        if attribBold then
            setProperty(hintFontBold, w32True)
            controls[selectedControl][HintFontBold] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontBold] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(hintFontBold, w32False)
            controls[selectedControl][HintFontBold] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontBold] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if
        if attribItalic then
            setProperty(hintFontItalic, w32True)
            controls[selectedControl][HintFontAttrib] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontAttrib] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(hintFontItalic, w32False)
            controls[selectedControl][HintFontAttrib] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontAttrib] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if
        if attribUnderline then
            setProperty(hintFontUnderline, w32True)
            controls[selectedControl][HintFontUnderline] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontUnderline] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(hintFontUnderline, w32False)
            controls[selectedControl][HintFontUnderline] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontUnderline] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if
        if attribStrike then
            setProperty(hintFontStrike, w32True)
            controls[selectedControl][HintFontStrikeout] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontStrikeout] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            setProperty(hintFontStrike, w32False)
            controls[selectedControl][HintFontStrikeout] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][HintFontStrikeout] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if
    end if
    if not pickColor then
        setProperty(fontColor, "")
        controls[selectedControl][FontColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][FontColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    end if

    if equal(controls[selectedControl][Class], "ReBar") then
    --need to adjust the ReBarBand contents
        testFontAttrib = 0
        if controls[selectedControl][FontAttrib] then
            testFontAttrib = Italic
        end if
        if controls[selectedControl][FontBold] then
            testFontAttrib += controls[selectedControl][FontBold]
        end if
        if controls[selectedControl][FontUnderline] then
            testFontAttrib += 4
        end if
        if controls[selectedControl][FontStrikeout] then
            testFontAttrib += 8
        end if

        if length(controls[selectedControl][FontName]) then
            testFontName = controls[selectedControl][FontName]
            testFontPts = controls[selectedControl][FontPts]
        else
            testFontName = ""
        end if

        if length(testFontName) then
            setFont(ControlBlit, controls[selectedControl][FontName],
                    controls[selectedControl][FontPts], testFontAttrib)
        else
            setDefaultFont(ControlBlit)
        end if
    end if

    endChanges(cell)

    return w32True
end function
integer font_rid
font_rid = routine_id("chooseTheFont")
--------------------------------------------------------------------------------
function popupStyle(integer cell, integer event, sequence params)
    setEnable(Explore1, w32False)
    setEnable(Explore2, w32False)
    setEnable(Explore3, w32False)
    setEnable(Explore4, w32False)
    setEnable(Explore5, w32False)
    setEnable(Explore6, w32False)
    setEnable(Explore7, w32True)
    setEnable(Explore8, w32True)
    setEnable(Explore9, w32True)
    setEnable(Explore10, w32True)
    setEnable(Explore11, w32False)
    setEnable(Explore12, w32False)

    propertyPopupCell = cell

    if cell=style then
        setEnable(Explore1, w32True)
        selectedProp = "Style"
        setEnable(Explore6, w32True)
    elsif cell=list then
        if equal(getProperty(propclass), "ListView") then
            setEnable(Explore2, w32True)
        else
            setEnable(Explore4, w32True)
        end if
    elsif cell=controlOrder then
        setEnable(Explore3, w32True)
    elsif cell=iconFileLV then
        setEnable(Explore2, w32True)
    elsif cell=transparency then
        setEnable(Explore5, w32True)
    elsif cell=exStyle then
        selectedProp = "ExStyle"
        setEnable(Explore6, w32True)
    elsif cell=classdef then
        selectedProp = "ClassDef"
        setEnable(Explore6, w32True)
    elsif cell=ccWin then
        selectedProp = "CCWin"
        setEnable(Explore6, w32True)
    elsif cell=xpmmerObject then
        setEnable(Explore7, w32False)
        setEnable(Explore8, w32False)
        setEnable(Explore9, w32False)
        setEnable(Explore10, w32False)
        setEnable(Explore11, w32True)
        setEnable(Explore12, w32False)
    elsif cell=xpmmerDisableObject then
        setEnable(Explore7, w32False)
        setEnable(Explore8, w32False)
        setEnable(Explore9, w32False)
        setEnable(Explore10, w32False)
        setEnable(Explore11, w32False)
        setEnable(Explore12, w32True)
    end if

    popup(StylePopup, params[1], params[2])
    return w32False
end function
integer popup_rid
popup_rid = routine_id("popupStyle")
--------------------------------------------------------------------------------
integer transWin,transOpt,sampleTrans,okButton, transButton
        transWin = -1
procedure changeTransValues(integer self, integer event, sequence params)
    if getNumber(transOpt)= -1
    or getNumber(transOpt)=0 then
        alphablend_SetWinAlpha(getHandle(sampleTrans),-1)
    else
        alphablend_SetWinAlpha(getHandle(sampleTrans),getNumber(transOpt))
    end if
end procedure
--------------------------------------------------------------------------------
procedure close_TransWin(integer self, integer event, sequence params)
    if validId(sampleTrans) then
        closeWindow(sampleTrans)
    end if
end procedure
--------------------------------------------------------------------------------
procedure event_TransWin(integer self, integer event, sequence params)
sequence Pos, size
    if params[1]=WM_MOVE then
        Pos = ClientToScreen(transWin, 0, 0)
        size = getClientRect(transWin)
        setRect(sampleTrans, Pos[1], Pos[2]+40, size[3], size[4]-40, w32True)
    end if
end procedure
--------------------------------------------------------------------------------
procedure click_BackToProperties(integer self, integer event, sequence params)
    controls[selectedControl][WinTransparency] = getNumber(transOpt)
    call_proc(updateProperty_id,{"Trans"})
    if getNumber(transOpt)= -1 then
        controls[selectedControl][WinTransparency] = 0
        call_proc(updateProperty_id,{"Trans"})
    end if

    closeWindow(transWin)

end procedure
--------------------------------------------------------------------------------
procedure createTransparencyWin()
sequence size

    if transWin= -1 then
        transWin = createEx(Window,"Test Transparency Values",0,Default,Default,400,300,0,0)
        transOpt = createEx(EditText,"",transWin,0,0,90,30,0,0)
        okButton = createEx(PushButton,"Transfer Value to Properties",transWin,100,0,200,30,0,0)
        transButton = createEx(CheckBox,"",transWin,100,100,90,30,0,0)

        size = getClientRect(transWin)
        sampleTrans = createEx(Window,"",transWin,0,40,size[3],size[4]-40,0,0)

        setHandler(transOpt,w32HChange,routine_id("changeTransValues"))
        setHandler(transWin,w32HClose,routine_id("close_TransWin"))
        setHandler(transWin,w32HEvent,routine_id("event_TransWin"))
        setHandler(okButton,w32HClick,routine_id("click_BackToProperties"))

        setCheck(transButton, w32True)
        setWindowBackColor(transButton,Blue)
    end if

    setText(transOpt,controls[selectedControl][WinTransparency])

    openWindow({transWin,transOpt},Normal)
    openWindow(sampleTrans,Normal)
end procedure
--------------------------------------------------------------------------------
procedure popupClicked(integer self, integer event, sequence params)

    if self=Explore1 then
        ok = invokeHandler(MenuWinStyles, w32HClick,{})
    elsif self=Explore2 then
        ok = invokeHandler(MenuListViewStyles, w32HClick, {})
    elsif self=Explore3 then
        ok = invokeHandler(MenuRunOrder, w32HClick,{})
        call_proc(updateProperty_id,{"Control Order"})
    elsif self=Explore4 then
        ok = invokeHandler(MenuListValues, w32HClick,{})
    elsif self=Explore5 then
        createTransparencyWin()
    elsif self=Explore6 then
        ok = invokeHandler(MenuSelectStyles, w32HClick, {})
    elsif self=Explore7 then
        cutProp()
    elsif self=Explore8 then
        copyProp()
    elsif self=Explore9 then
        pasteProp()
    elsif self=Explore10 then
        undoProp()
    elsif self=Explore11 then
        controls[selectedControl][XpmDisableObject] = controls[selectedControl][XpmObject]
        call_proc(updateProperty_id,{"XpmDisableObject"})
    elsif self=Explore12 then
        controls[selectedControl][XpmObject] = controls[selectedControl][XpmDisableObject]
        call_proc(updateProperty_id,{"XpmObject"})
    else return
    end if

    endChanges(whichCellIcon)

end procedure
--------------------------------------------------------------------------------
function pickFileName(integer cell, integer event, sequence params)
sequence edittext, fileName, name,currentdirectory
integer ok

    currentdirectory = current_dir()

    edittext = params[1]
    if cell=iconFile
    or cell=defFile
    or cell=hotFile
    or cell=closeFile
    or cell=disFile
    or cell=openFile then

        if not length(edittext) then
            IcoFileName = controls[selectedControl][IcoFile]
            if cell=hotFile
            or cell=closeFile then
                IcoFileName = controls[selectedControl][TwoIcoFile]
            end if
            if cell=disFile
            or cell=openFile then
                IcoFileName = controls[selectedControl][TriIcoFile]
            end if
        else
            IcoFileName = edittext
        end if

        fileName = getOpenFileName(Form, current_dir() & "\\*.ico", {IDEText[1105][1],"*.ico"})
        IDE_Changed = w32True
        --backup
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)

        if length(fileName) then
            IcoFileName = fileName
        else
            fileName = IcoFileName
        end if
        setProperty(cell, fileName)
        if cell=iconFile
        or cell=defFile then
            controls[selectedControl][IcoFile] = fileName
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][IcoFile] = fileName
                            exit
                        end if
                    end for
                end if
            end for
        elsif cell=hotFile
           or cell=closeFile then
            controls[selectedControl][TwoIcoFile] = fileName
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][TwoIcoFile] = fileName
                            exit
                        end if
                    end for
                end if
            end for
        elsif cell=disFile
           or cell=openFile then
            controls[selectedControl][TriIcoFile] = fileName
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][TriIcoFile] = fileName
                            exit
                        end if
                    end for
                end if
            end for
        end if
        endChanges(cell)
        ok = chdir(currentdirectory)

        return fileName

    elsif cell=bitmap then
        if not length(edittext) then
            BitmapFileName = controls[selectedControl][BitmapFile]
        else
            BitmapFileName = edittext
        end if

        fileName = getOpenFileName(Form, current_dir() & "\\*.bmp", {IDEText[1106][1],"*.bmp"})

        IDE_Changed = w32True
        --backup
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)
        if length(fileName) then
            BitmapFileName = fileName
        else
            fileName = BitmapFileName
        end if
        if length(fileName) then
            setPropEnabled(XPMFile, w32False)
        else
            setPropEnabled(XPMFile, w32True)
        end if
        setProperty(bitmap, fileName)
        --remove any existing resource for control
        deleteResource(controls[selectedControl][Name],controls[selectedControl][BitmapFile])
        controls[selectedControl][BitmapFile] = fileName
        --add new resource for control
        addResource(controls[selectedControl][Name],controls[selectedControl][BitmapFile],"Bitmap","")
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        deleteResource(controls[j][Name],controls[j][BitmapFile])
                        controls[j][BitmapFile] = fileName
                        addResource(controls[j][Name],controls[j][BitmapFile],"Bitmap","")
                        exit
                    end if
                end for
            end if
        end for

        endChanges(cell)
        ok = chdir(currentdirectory)

        return fileName

    elsif cell=XPMFile then
        if not length(edittext) then
            XPMFileName = controls[selectedControl][XPM]
        else
            XPMFileName = edittext
        end if

        fileName = getOpenFileName(Form, current_dir() & "\\*.xpm",
                                   {IDEText[1109][1],"*.XPM",IDEText[1110][1],"*.e;*.ew",IDEText[1103][1],"*.*"})

        IDE_Changed = w32True
        --backup
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)
        if length(fileName) then
            XPMFileName = fileName
        else
            fileName = XPMFileName
        end if
        if length(fileName) then
            setPropEnabled(bitmap, w32False)
        else
            setPropEnabled(bitmap, w32True)
        end if
        setProperty(XPMFile, fileName)
        --remove any existing resource for control
        deleteResource(controls[selectedControl][Name],controls[selectedControl][XPM])
        controls[selectedControl][XPM] = fileName
        --add new resource for control
        addResource(controls[selectedControl][Name],controls[selectedControl][XPM],"XPM",controls[selectedControl][XPMmember])
        controls[selectedControl][XPM] = fileName
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        deleteResource(controls[j][Name],controls[j][XPM])
                        controls[j][XPM] = fileName
                        addResource(controls[j][Name],controls[j][XPM],"XPM",controls[j][XPMmember])
                        exit
                    end if
                end for
            end if
        end for

        name = fileName
        for i=length(name) to 1 by -1 do
            if name[i]='.' then
                name = name[i..length(name)]
                exit
            end if
        end for

        if length(name) then
            if not equal(lower(name),".xpm") then
                setPropEnabled(XPMMember, w32True)
            end if
        end if

        if not length(name) then
            setProperty(XPMMember,"")
            setPropEnabled(XPMMember, w32False)
        end if

        endChanges(cell)
        ok = chdir(currentdirectory)

        return fileName

    end if

end function
integer pickFileName_rid
pickFileName_rid = routine_id("pickFileName")
--------------------------------------------------------------------------------
function RegisterStylesExplorer(integer cell, integer event, sequence params)
sequence theParams

    propertyPopupCell = style
    selectedProp = "Style"
    ok = invokeHandler(MenuSelectStyles, w32HClick,{})

    if sequence(controls[selectedControl][Style]) then
        theParams = controls[selectedControl][Style]
        return theParams
    else
        return {}       --fixes bug when rightclick in style for Window control then click away
    end if
end function
integer styles_rid
styles_rid = routine_id("RegisterStylesExplorer")
--------------------------------------------------------------------------------
integer PartnersWin, PartnersList, PartnersText, PartnersEdit, PartnersSave, PartnersCancel
PartnersWin = -1 PartnersList = -1 PartnersText = -1 PartnersEdit = -1 PartnersSave = -1
PartnersCancel = -1
--------------------------------------------------------------------------------
procedure PartnersList_onChange(integer Self, integer Event, sequence Parmas)
    if length(getText(PartnersEdit)) then
        setText(PartnersEdit,getText(PartnersEdit) & ",")
    end if
    setText(PartnersEdit,getText(PartnersEdit) & getItem(PartnersList,getIndex(PartnersList)))
end procedure
--------------------------------------------------------------------------------
procedure PartnersSave_onClick(integer Self, integer Event, sequence Params)
sequence partnerList,holdPartners
integer it

    partnerList = {}
    if length(getText(PartnersEdit)) then
        --build partner list            
        holdPartners = getText(PartnersEdit)
        while True do
            it = match(",",holdPartners)
            if it then
                partnerList &= {holdPartners[1..it-1]}
                holdPartners = holdPartners[it+1..length(holdPartners)]
            else
                partnerList &= {holdPartners}
                exit
            end if
        end while
    end if
    controls[selectedControl][ControlPartners] = partnerList
    call_proc(updateProperties_id,{})
    closeWindow(PartnersWin)
end procedure
--------------------------------------------------------------------------------
procedure PartnersCancel_onClick(integer Self, integer Event, sequence Params)
    call_proc(updateProperties_id,{})
    closeWindow(PartnersWin)
end procedure
--------------------------------------------------------------------------------
procedure SelectPartners_onOpen(integer Self, integer Event, sequence Params)
    if Self or Event or sequence(Params) then end if
    if PartnersWin= -1 then
        PartnersWin = createEx(Window,"",0,Default,Default,367,305,0,0)
                                                                --      "Pick Partners for selected control"            
        PartnersText = createEx(CText, IDEText[1052][1], PartnersWin, 4,4,
                                352,32,0,0)
        PartnersList = createEx(List, "", PartnersWin, 24,40,312,128,0,0)
        PartnersEdit = createEx(EditText,"",PartnersWin, 4,180, 348,28,0,0)
                                                                                --      "Save"
        PartnersSave = createEx(PushButton, IDEText[58][1],PartnersWin,48,212,88,28,0,0)
                                                                                --      "Close"
        PartnersCancel = createEx(PushButton, IDEText[59][1],PartnersWin,188,212,88,28,0,0)
        setHandler(PartnersList, w32HClick, routine_id("PartnersList_onChange"))
        setHandler(PartnersSave, w32HClick, routine_id("PartnersSave_onClick"))
        setHandler(PartnersCancel, w32HClick, routine_id("PartnersCancel_onClick"))
    end if
    --build a list of possible controls for the selectedControl     
    eraseItems(PartnersList)
    for i=1 to length(controls) do
        if not find(controls[i][Class],{"Window","ReBar","ReBarBand","ToolBar","FlatToolBar",
                                        "StatusBar","TabItem"})
        and (controls[i][ControlLayer]=controls[selectedControl][ControlLayer]
             or not controls[i][ControlLayer])
        and not equal(controls[i][Name], controls[selectedControl][Name])
        and not find(controls[i][Name],controls[selectedControl][SeqChildName])
        and not equal(controls[i][SeqParentClass], "Table")
        and not equal(controls[i][Name],controls[selectedControl][SeqParentName]) then
            addItem(PartnersList,controls[i][Name])
        end if
    end for
    --if have some partners already stuff into edittext
    setText(PartnersEdit,"")
    for i=1 to length(controls[selectedControl][ControlPartners]) do
        if i=1 then
            setText(PartnersEdit,controls[selectedControl][ControlPartners][1])
        else
            setText(PartnersEdit,getText(PartnersEdit) & "," & controls[selectedControl][ControlPartners][i])
        end if
    end for

    openWindow(PartnersWin, Normal)
end procedure
--------------------------------------------------------------------------------
function PickPartnerControls(integer cell, integer event, sequence params)
sequence theParams

    SelectPartners_onOpen(0,0,{})

    if sequence(controls[selectedControl][ControlPartners]) then
        theParams = getText(PartnersEdit)
        return theParams
    else
        return {}
    end if

end function
integer partners_rid
partners_rid = routine_id("PickPartnerControls")
--------------------------------------------------------------------------------
function chooseColor(integer cell, integer event, sequence params)
atom oldcolor
sequence editedcolor

    editedcolor = params[1]

    if length(editedcolor) then
        if length(editedcolor)>10 then
            editedcolor = editedcolor[1..10]
        end if
    end if

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    if find(lower(editedcolor),{"default","<default>"}) then -- this can only happen when waitforenterkey is set  
        if equal(getProperty(propclass), "Window") then
            oldcolor = getSysColor(COLOR_BTNFACE)
        else
            oldcolor = 0
        end if
        return sprintf("%d",oldcolor)
    else
        if not length(editedcolor) then
            if cell=color then
                editedcolor = value(getProperty(color))
            elsif cell=barColor then
                editedcolor = value(getProperty(barColor))
            elsif cell=fontColor then
                editedcolor = value(getProperty(fontColor))
            elsif cell=gridCellBkColor then
                editedcolor = value(getProperty(gridCellBkColor))
            elsif cell=gridLineColor then
                editedcolor = value(getProperty(gridLineColor))
            elsif cell=gridTextColor then
                editedcolor = value(getProperty(gridTextColor))
            elsif cell=gridColTextColor then
                editedcolor = value(getProperty(gridColTextColor))
            elsif cell=gridHeaderColor then
                editedcolor = value(getProperty(gridHeaderColor))
            elsif cell=gridBkColorSelect then
                editedcolor = value(getProperty(gridBkColorSelect))
            elsif cell=gridCellBorderColor then
                editedcolor = value(getProperty(gridCellBorderColor))
            elsif cell=gridTextColorSelect then
                editedcolor = value(getProperty(gridTextColorSelect))
            elsif cell=cbcolor then
                editedcolor = value(getProperty(cbcolor))
            elsif cell=cbcaptioncolor then
                editedcolor = value(getProperty(cbcaptioncolor))
            elsif cell=cbpresscolor then
                editedcolor = value(getProperty(cbpresscolor))
            elsif cell=cbpresscaptioncolor then
                editedcolor = value(getProperty(cbpresscaptioncolor))
            elsif cell=mc_background then
                editedcolor = value(getProperty(mc_background))
            elsif cell=mc_text then
                editedcolor = value(getProperty(mc_text))
            elsif cell=mc_titleBK then
                editedcolor = value(getProperty(mc_titleBK))
            elsif cell=mc_titleText then
                editedcolor = value(getProperty(mc_titleText))
            elsif cell=mc_monthBK then
                editedcolor = value(getProperty(mc_monthBK))
            elsif cell=mc_trailingText then
                editedcolor = value(getProperty(mc_trailingText))
            end if
            oldcolor = editedcolor[2]
        else
            editedcolor = value(editedcolor)
            oldcolor = editedcolor[2]
        end if
    end if

    oldcolor = getColorDialog(Form, oldcolor)

    if oldcolor=0 then
        if equal(controls[selectedControl][Class], "Window") then
            oldcolor = -2
        end if
--I don't know how to know for control other than Window. 
--0 in Color means default color (BTNFACE)
--dialog returns the sending color if cancel is pressed, in this case 0
--but if user selects Black color, it returns 0 as well         
    end if

    if oldcolor!=editedcolor[2] then
        if cell!=fontColor then
        --when use color dialog, system color is removed       
            controls[selectedControl][SystemBkColor] = {}
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][SystemBkColor] = {}
                            exit
                        end if
                    end for
                end if
            end for
        end if
    end if

    if cell=fontColor then
        controls[selectedControl][FontColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][FontColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridCellBkColor then
        controls[selectedControl][GridBkColorRows] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridBkColorRows] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridHeaderColor then
        controls[selectedControl][GridHeaderColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridHeaderColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridLineColor then
        controls[selectedControl][GridLineColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridLineColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridTextColor then
        controls[selectedControl][GridTextColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridTextColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridColTextColor then
        controls[selectedControl][GridColTextColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridColTextColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridBkColorSelect then
        controls[selectedControl][GridBkSelectColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridBkSelectColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridCellBorderColor then
        controls[selectedControl][GridCellBorderColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridCellBorderColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridTextColorSelect then
        controls[selectedControl][GridTextColorSelect] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridTextColorSelect] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=txtColor then
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][TxtColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=barColor then
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][BkBarColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbcolor then
        controls[selectedControl][cbColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbcaptioncolor then
        controls[selectedControl][cbCaptionColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbCaptionColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbpresscolor then
        controls[selectedControl][cbPressColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbPressColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbpresscaptioncolor then
        controls[selectedControl][cbPressCaptionColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbPressCaptionColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_background then
        controls[selectedControl][MC_background] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_background] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_text then
        controls[selectedControl][MC_text] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_text] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_titleBK then
        controls[selectedControl][MC_titleBK] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_titleBK] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_titleText then
        controls[selectedControl][MC_titleText] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_titleText] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_monthBK then
        controls[selectedControl][MC_monthBK] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_monthBK] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_trailingText then
        controls[selectedControl][MC_trailingText] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_trailingText] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    else
        controls[selectedControl][BkColor] = oldcolor
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][BkColor] = oldcolor
                        exit
                    end if
                end for
            end if
        end for
    end if

    if equal(controls[selectedControl][Class], "Window")
    and cell=color then
        if isChecked(MenuColorNoSuppress) then
            if controls[selectedControl][BkColor]<0 then
                setPenColor(tile, Black)
            else
                setPenColor(tile, controls[selectedControl][BkColor])
            end if
            drawRectangle(tile, w32True, 0, 0, sizeS[3], sizeS[4])
            drawGrid(GridBlit)
            copyBlt(ControlBlit, 0, 0, OffScreenBlit)
            if offsetActive then
                copyBlt(OffScreen, 0, 0, OffScreenBlit)
            end if
        end if
    end if

    endChanges(cell)

    return sprintf("%d", oldcolor)
end function
integer color_rid
color_rid = routine_id("chooseColor")
--------------------------------------------------------------------------------
function returnToDefault(integer cell, integer event, sequence params)
object what

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)
    what = params[1]

    if length(what) then
        if length(what)>10 then
            what = what[1..10]
        end if
    end if

    for i=1 to length(what) do
        if not find(what[i],{'-','0','1','2','3','4','5','6','7','8','9'}) then
            ok = displayErrorMessage(202,{})
            return w32False
        end if
    end for

    if length(what) then
        if cell=color then
            if equal(controls[selectedControl][Class], "Window") then
                controls[selectedControl][BkColor] = floor(val(what))
                --set system color dropdown to 'User Color', #1
                setPropertyCombo(defaultColor, 1, validColors)
                controls[selectedControl][SystemBkColor] = {}
                if isChecked(MenuColorNoSuppress) then
                    setPenColor(tile, controls[selectedControl][BkColor])
                    drawRectangle(tile, w32True, 0, 0, sizeS[3], sizeS[4])
                    drawGrid(GridBlit)
                    copyBlt(ControlBlit, 0, 0, OffScreenBlit)
                    if offsetActive then
                        copyBlt(OffScreen, 0, 0, OffScreenBlit)
                    end if
                end if
            else
                controls[selectedControl][BkColor] = floor(val(what))
                for i=1 to length(MultiPropertySelect) do
                    if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                        for j=1 to length(controls) do
                            if equal(controls[j][Name], MultiPropertySelect[i]) then
                                controls[j][BkColor] = floor(val(what))
                                exit
                            end if
                        end for
                    end if
                end for
            end if
        elsif cell=fontColor then
            controls[selectedControl][FontColor] = floor(val(what))
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][FontColor] = floor(val(what))
                            exit
                        end if
                    end for
                end if
            end for
        elsif cell=barColor then
            controls[selectedControl][BkBarColor] = floor(val(what))
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][BkBarColor] = floor(val(what))
                            exit
                        end if
                    end for
                end if
            end for
        elsif cell=cbcolor then
            controls[selectedControl][cbColor] = floor(val(what))
        elsif cell=cbcaptioncolor then
            controls[selectedControl][cbCaptionColor] = floor(val(what))
        elsif cell=cbpresscolor then
            controls[selectedControl][cbPressColor] = floor(val(what))
        elsif cell=cbpresscaptioncolor then
            controls[selectedControl][cbPressCaptionColor] = floor(val(what))
        elsif cell=mc_background then
            controls[selectedControl][MC_background] = floor(val(what))
        elsif cell=mc_text then
            controls[selectedControl][MC_text] = floor(val(what))
        elsif cell=mc_titleBK then
            controls[selectedControl][MC_titleBK] = floor(val(what))
        elsif cell=mc_titleText then
            controls[selectedControl][MC_titleText] = floor(val(what))
        elsif cell=mc_monthBK then
            controls[selectedControl][MC_monthBK] = floor(val(what))
        elsif cell=mc_trailingText then
            controls[selectedControl][MC_trailingText] = floor(val(what))
        else
            if cell=gridCellBkColor
            or cell=gridHeaderColor
            or cell=gridLineColor
            or cell=gridTextColor
            or cell=gridColTextColor
            or cell=gridBkColorSelect
            or cell=gridCellBorderColor
            or cell=gridTextColorSelect
            or cell=txtColor then
                if cell=txtColor then
                    controls[selectedControl][TxtColor] = floor(val(what))
                elsif cell=gridCellBkColor then
                    controls[selectedControl][GridBkColorRows] = floor(val(what))
                elsif cell=gridHeaderColor then
                    controls[selectedControl][GridHeaderColor] = floor(val(what))
                elsif  cell=gridLineColor then
                    controls[selectedControl][GridLineColor] = floor(val(what))
                elsif cell=gridTextColor then
                    controls[selectedControl][GridTextColor] = floor(val(what))
                elsif cell=gridBkColorSelect then
                    controls[selectedControl][GridBkSelectColor] = floor(val(what))
                elsif cell=gridCellBorderColor then
                    controls[selectedControl][GridCellBorderColor] = floor(val(what))
                elsif cell=gridTextColorSelect then
                    controls[selectedControl][GridTextColorSelect] = floor(val(what))
                else
                    controls[selectedControl][GridColTextColor] = floor(val(what))
                end if
                for i=1 to length(MultiPropertySelect) do
                    if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                        for j=1 to length(controls) do
                            if equal(controls[j][Name], MultiPropertySelect[i]) then
                                if cell=txtColor then
                                    controls[j][TxtColor] = floor(val(what))
                                elsif cell=gridCellBkColor then
                                    controls[j][GridBkColorRows] = floor(val(what))
                                elsif cell=gridHeaderColor then
                                    controls[j][GridHeaderColor] = floor(val(what))
                                elsif cell=gridLineColor then
                                    controls[j][GridLineColor] = floor(val(what))
                                elsif cell=gridTextColor then
                                    controls[j][GridTextColor] = floor(val(what))
                                elsif cell=gridBkColorSelect then
                                    controls[j][GridBkSelectColor] = floor(val(what))
                                elsif cell=gridCellBorderColor then
                                    controls[j][GridCellBorderColor] = floor(val(what))
                                elsif cell=gridTextColorSelect then
                                    controls[j][GridTextColorSelect] = floor(val(what))
                                else
                                    controls[j][GridColTextColor] = floor(val(what))
                                end if
                                exit
                            end if
                        end for
                    end if
                end for
            end if

        end if
        endChanges(cell)

        return w32True
    end if

    --color removed so go to default case           
    if cell=color then
        if equal(controls[selectedControl][Class], "Window") then
            --return to default state
            controls[selectedControl][BkColor] = getSysColor(COLOR_BTNFACE)
            --set system color dropdown to 'User Color', #1
            setPropertyCombo(defaultColor, 1, validColors)
            controls[selectedControl][SystemBkColor] = {}
            setProperty(color, sprint(controls[selectedControl][BkColor]))
            if isChecked(MenuColorNoSuppress) then
                setPenColor(tile, controls[selectedControl][BkColor])
                drawRectangle(tile, w32True, 0, 0, sizeS[3], sizeS[4])
                drawGrid(GridBlit)
                copyBlt(ControlBlit, 0, 0, OffScreenBlit)
                if offsetActive then
                    copyBlt(OffScreen, 0, 0, OffScreenBlit)
                end if
            end if
        elsif equal(controls[selectedControl][Class],"EuGrid") then
            --return to default state
            controls[selectedControl][BkColor] = getSysColor(COLOR_BTNFACE)
            setProperty(color, sprint(controls[selectedControl][BkColor]))
        else
            setProperty(color,"0")
            controls[selectedControl][BkColor] = 0
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][BkColor] = 0
                            exit
                        end if
                    end for
                end if
            end for
        end if
    elsif cell=barColor then
        setProperty(barColor, "0")
        controls[selectedControl][BkBarColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][BkBarColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=fontColor then
        setProperty(fontColor, "0")
        controls[selectedControl][FontColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][FontColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=txtColor then
        setProperty(txtColor, "0")
        controls[selectedControl][TxtColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][TxtColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridCellBkColor then
        controls[selectedControl][GridBkColorRows] = BrightWhite
        setProperty(gridCellBkColor,sprint(controls[selectedControl][GridBkColorRows]))
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridBkColorRows] = BrightWhite
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridHeaderColor then
        controls[selectedControl][GridHeaderColor] = getSysColor(COLOR_BTNFACE)
        setProperty(gridHeaderColor, sprint(controls[selectedControl][GridHeaderColor]))
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridHeaderColor] = getSysColor(COLOR_BTNFACE)
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridLineColor then
        setProperty(gridLineColor, "0")
        controls[selectedControl][GridLineColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridLineColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridTextColor then
        setProperty(gridTextColor, "0")
        controls[selectedControl][GridTextColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridTextColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=gridColTextColor then
        setProperty(gridColTextColor, "0")
        controls[selectedControl][GridColTextColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][GridColTextColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbcolor then
        setProperty(cbcolor, "0")
        controls[selectedControl][cbColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbcaptioncolor then
        setProperty(cbcaptioncolor, "0")
        controls[selectedControl][cbCaptionColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbCaptionColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbpresscolor then
        setProperty(cbpresscolor, "0")
        controls[selectedControl][cbPressColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbPressColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=cbpresscaptioncolor then
        setProperty(cbpresscaptioncolor, "0")
        controls[selectedControl][cbPressCaptionColor] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][cbPressCaptionColor] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_background then
        setProperty(mc_background, "0")
        controls[selectedControl][MC_background] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_background] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_text then
        setProperty(mc_text, "0")
        controls[selectedControl][MC_text] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_text] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_titleBK then
        setProperty(mc_titleBK, "0")
        controls[selectedControl][MC_titleBK] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_titleBK] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_titleText then
        setProperty(mc_titleText, "0")
        controls[selectedControl][MC_titleText] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_titleText] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_monthBK then
        setProperty(mc_monthBK, "0")
        controls[selectedControl][MC_monthBK] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_monthBK] = 0
                        exit
                    end if
                end for
            end if
        end for
    elsif cell=mc_trailingText then
        setProperty(mc_trailingText, "0")
        controls[selectedControl][MC_trailingText] = 0
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][MC_trailingText] = 0
                        exit
                    end if
                end for
            end if
        end for
    end if

    endChanges(cell)

    return w32True
end function
integer defaultColor_rid
defaultColor_rid = routine_id("returnToDefault")
--------------------------------------------------------------------------------
function useSystemColors(integer cell, integer event, sequence params)
sequence systemcolor

    systemcolor = params[1]

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    for i=1 to length(validColors) do
        if equal(systemcolor, validColors[i]) then
            if i=1 then
                call_proc(updateProperties_id,{})
            else
                if getSysColor(numColors[i])=0 then --here 0 means Black
                    --but 0 assumes BTNFACE when generate the exw
                    setProperty(color, sprintf("%d", Black))
                    controls[selectedControl][BkColor] = Black
                else
                    setProperty(color, sprintf("%d",getSysColor(numColors[i])))
                    controls[selectedControl][BkColor] = getSysColor(numColors[i])
                end if
                controls[selectedControl][SystemBkColor] = validColors[i]
                for j=1 to length(MultiPropertySelect) do
                    if not equal(MultiPropertySelect[j], controls[selectedControl][Name]) then
                        for m=1 to length(controls) do
                            if equal(controls[m][Name], MultiPropertySelect[j]) then
                                controls[m][BkColor] = getSysColor(numColors[i])
                                controls[m][SystemBkColor] = validColors[i]
                                exit
                            end if
                        end for
                    end if
                end for
            end if
            if isChecked(MenuColorNoSuppress) then
                setPenColor(tile, controls[selectedControl][BkColor])
                if controls[selectedControl][BkColor]<0 then
                    setPenColor(tile, Black)
                end if
                drawRectangle(tile, w32True, 0, 0, sizeS[3], sizeS[4])
                drawGrid(GridBlit)
                copyBlt(ControlBlit, 0, 0, OffScreenBlit)
                if offsetActive then
                    copyBlt(OffScreen, 0, 0, OffScreenBlit)
                end if
            end if
            exit
        end if
    end for

    endChanges(cell)

    return w32True
end function
integer systemColors_rid
systemColors_rid = routine_id("useSystemColors")
--------------------------------------------------------------------------------
--function validateToValidControlName(sequence what)
--  for i=1 to length(windows) do
--      for j=1 to length(windows[i]) do
--          if equal(what, windows[i][j][Name])     then
--              return w32True
--          end if
--      end for
--  end for
--  return w32False
--end function
--------------------------------------------------------------------------------
procedure autoPositionBars(integer flag)
integer toolBarSlot, cntr

    --place control at next available x. Increment toolBarX with the width
    --of the control. Be sure in moveDrag and moveResize routines to adjust
    --toolBarX.
    --find the next available x and y positions
    toolBarX = 0
    toolBarY = 1
    toolBarSlot = 0

    if find(controls[selectedControl][SeqParentClass], {"ToolBar","FlatToolBar"}) then
        for i=1 to length(toolBarInfo) do
            --find current data on this bar
            if equal(toolBarInfo[i][8], controls[flag][Name]) then
                toolBarX = toolBarInfo[i][6]
                toolBarY = toolBarInfo[i][7]
                toolBarCY = toolBarInfo[i][2]
                toolBarSubCY = toolBarInfo[i][3]
                toolBarOrigX = toolBarInfo[i][4]
                toolBarOrigY = toolBarInfo[i][5]
                toolBarSlot = i
                exit
            end if
        end for
    else
        --rebar
        for i=1 to length(toolBarInfo) do
            --find all current data on this bar
            if equal(toolBarInfo[i][8], controls[selectedControl][ControlParent]) then
                toolBarX = toolBarInfo[i][6]
                toolBarY = toolBarInfo[i][7]
                toolBarCY = toolBarInfo[i][2]
                toolBarSubCY = toolBarInfo[i][3]
                toolBarOrigX = toolBarInfo[i][4]
                toolBarOrigY = toolBarInfo[i][5]
                toolBarSlot = i
                exit
            end if
        end for
    end if

    if toolBarSlot=0
    and flag!=TheWindow then
        ok = displayErrorMessage(196,{})
        return
    end if

    toolBarX = 0
    cntr = 0
    --now reposition X by looking at all controls on the bar now
    if length(controls[flag][SeqChildName]) then
        for i=flag to length(controls) do
            if find(controls[i][Name],controls[flag][SeqChildName]) then
                cntr += 1
                controls[i][X] = toolBarX
                toolBarX += controls[i][CX]
                if cntr>=length(controls[flag][SeqChildName]) then
                    exit
                end if
            end if
        end for
    end if

    if equal(controls[selectedControl][Class], "PushButton") then
        if equal(controls[flag][Class], "FlatToolBar") then
            if toolBarCY=48 then
                controls[selectedControl][CX] = toolBarCY-10
                controls[selectedControl][CY] = toolBarCY-10
            else
                controls[selectedControl][CX] = toolBarCY-4
                controls[selectedControl][CY] = toolBarCY-4
            end if
            controls[selectedControl][Class] = "PictureButton"   --change to PushButton in Proj.
        else
            if toolBarCY<34 then
                controls[selectedControl][CX] = toolBarCY-2
                controls[selectedControl][CY] = toolBarCY-2
            else
                controls[selectedControl][CX] = toolBarCY-4
                controls[selectedControl][CY] = toolBarCY-4
            end if
            controls[selectedControl][Class] = "TogglePicture"
        end if
        --update Property with new values
        call_proc(updateProperty_id,{"Row"})
        call_proc(updateProperty_id,{"Column"})
        call_proc(updateProperty_id,{"Height"})
        call_proc(updateProperty_id,{"Width"})
        call_proc(updateProperty_id,{"Class"})
    end if

    --how many rows are there in the ToolBar?
    toolBarSize = floor(controls[flag][CY]/toolBarCY)

    if controls[selectedControl][X]+controls[selectedControl][CX]>controls[TheWindow][CX]
    and toolBarY+1>toolBarSize then
        ok = displayErrorMessage(50,{})
        return

    elsif controls[selectedControl][X]+controls[selectedControl][CX]>controls[TheWindow][CX] then
        --drop down to next bar?
        toolBarX = toolBarOrigX
        toolBarY += 1
        controls[selectedControl][X] = toolBarX
        controls[selectedControl][Y] = ((toolBarCY*toolBarY)-toolBarCY)+toolBarOrigY
        if equal(controls[selectedControl][ParentClass], "ReBar") then
            if controls[selectedControl][Y]=controls[flag][Y] then
                if flag then
                    controls[selectedControl][Y] = controls[flag][Y]+4
                else
                    controls[selectedControl][Y] = controls[flag][Y]+1
                end if
            end if
        end if
    end if

    toolBarInfo[toolBarSlot][6] = toolBarX+controls[selectedControl][CX]
    toolBarInfo[toolBarSlot][7] = toolBarY

    if not equal(controls[selectedControl][Class], "TogglePicture") then
        controls[selectedControl][CY] = toolBarSubCY
    end if

end procedure
--------------------------------------------------------------------------------
integer skipParentValidation skipParentValidation = w32False
--------------------------------------------------------------------------------
function verifyChanges(integer cell, integer event, sequence params)
object what, whereIs
integer at, haveName, flag, oldflag,it
sequence partnerList,holdPartners

    haveName = w32False

    what = params[1]

    IDE_Changed = w32True
    --backup   
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    if cell=style then
        setPropEnabled(styletype, w32True)
        showProperty(styletype, w32True)

        if match("0",what)=1
        and length(what)=1 then
            setProperty(styletype, "")
            setPropEnabled(styletype, w32False)
            controls[selectedControl][Style] = 0
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][Style] = 0
                            exit
                        end if
                    end for
                end if
            end for
        else
            controls[selectedControl][Style] = what
            if length(what) then
                setPropertyCombo(styletype, 2,{"w32or_all({...})","{...}","..."})
                controls[selectedControl][StyleType] = "{...}"
            else
                setProperty(styletype, "")
                setPropEnabled(styletype, w32False)
            end if
        end if

    elsif cell=classdef then
        controls[selectedControl][ClassDefaults] = what

    elsif cell=otherFlags then
        if not length(what) then
            controls[selectedControl][Style] = {}
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][Style] = {}
                            exit
                        end if
                    end for
                end if
            end for
        else
            controls[selectedControl][Style] = what
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][Style] = what
                            exit
                        end if
                    end for
                end if
            end for
        end if

    elsif cell=styletype then
        controls[selectedControl][StyleType] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][StyleType] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=controlStyletype then
        controls[selectedControl][StyleType] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][StyleType] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=controlOrder then
        if not length(what) then
            ok = invokeHandler(MenuRunOrder, w32HClick,{})
        end if
        return w32True

    elsif cell=windowParent
      and not skipParentValidation then
        if compare("0",what) then
            if length(what) then
                ok = checkValidName(what)
                if not ok then
                    return w32False
                end if
            end if
        end if
        controls[selectedControl][ControlParent] = what

    elsif cell=parent
      and not skipParentValidation then
        if find(controls[selectedControl][ControlParent],{"ReBar","ReBarBand"}) then
            repaintWinResize = w32True
        end if

        if find(controls[selectedControl][ControlParent],{"ToolBar","TlabToolBar"})
        or find(controls[selectedControl][SeqParentClass],{"ToolBar","TlabToolBar"}) then
            repaintWinResize = w32True
            forceRedraw = w32True
        end if

        if equal(controls[selectedControl][Class],"Window") then
            controls[selectedControl][ControlParent] = what
        else
            if equal(what,controls[TheWindow][Name]) then
                controls[selectedControl][ParentIsFrozen] = w32True
                --find existing parent and remove selected control from its child list
                flag = findSeqParentName(selectedControl)
                if flag then
                    removeFromParentChildSeq(flag, controls[selectedControl][Name])
                    --if the existing parent is toolbar or flattoolbar then need to rearrange
                    --the buttons                           
                    if find(controls[flag][Class],{"ToolBar","FlatToolBar"}) then
                        autoPositionBars(flag)
                    end if
                end if

                --and adjust treeview
                deleteTreeViewNode("",controls[selectedControl][Name])
                addTreeViewNode(controls[TheWindow][Name],controls[selectedControl][Name])
                if length(controls[selectedControl][SeqChildName]) then
                    addChildToNode(selectedControl)
                end if
                --now remove parenting
                controls[selectedControl][SeqParentName] = {}
                controls[selectedControl][SeqParentClass] = {}
                controls[selectedControl][ControlParent] = {}
                controls[selectedControl][ParentClass] = {}
                controls[selectedControl][Parent] = {}
            else
                --find seq slot for the new parent
                flag = 0
                if equal(what, controls[TheWindow][Name]) then
                    flag = 1
                end if
                if not flag then
                    for x=1 to length(controls) do
                        if equal(controls[x][Name],what) then
                            flag = x
                            exit
                        end if
                    end for
                end if

                --ok now pretend the control was moved to parent
                --need to temporarily turnoff ParentIsFrozen
                controls[selectedControl][ParentIsFrozen] = w32False
                call_proc(check_MoveDrag_id,{controls[selectedControl][X],controls[selectedControl][Y],
                                             controls[selectedControl][X],controls[selectedControl][Y],
                                             controls[selectedControl][CX],controls[selectedControl][CY],
                                             w32False,w32False})

                --if new parent is not a standard IDE container then add it now
                if not find(controls[flag][Class],{"Group","Table","TabItem","TabControl","ToolBar",
                                                   "FlatToolBar","ReBar","ReBarBand","Window","StatusBar"}) then
                    --and turn it back on again
                    controls[selectedControl][ParentIsFrozen] = w32True
                    --remove selectedcontrol from prior parent child list
                    oldflag = findSeqParentName(selectedControl)
                    removeFromParentChildSeq(oldflag, controls[selectedControl][Name])
                    --assign new parent
                    controls[selectedControl][SeqParentName] = controls[flag][Name]
                    controls[selectedControl][SeqParentClass] = controls[flag][Class]
                    controls[selectedControl][ControlParent] = controls[flag][Name]
                    controls[selectedControl][ParentClass] = controls[flag][Class]
                    controls[selectedControl][Parent] = controls[flag][Name]
                    --add to new parent child list
                    addToParentChildSeq(flag,controls[selectedControl][Name])
                    --adust treeview
                    deleteTreeViewNode("",controls[selectedControl][Name])
                    addTreeViewNode(controls[flag][Name],controls[selectedControl][Name])
                    if length(controls[selectedControl][SeqChildName]) then
                        addChildToNode(selectedControl)
                    end if
                    --if new parent is already ControlPartners to selectedControl then
                    --remove from parent's ControlPartners list
                    at = find(controls[selectedControl][Name], controls[flag][ControlPartners])
                    if at then
                        controls[flag][ControlPartners] = controls[flag][ControlPartners][1..at-1]
                                                          & controls[flag][ControlPartners][at+1..length(controls[flag][ControlPartners])]
                    end if
                    call_proc(updateProperty_id,{"Parent"})
                end if
            end if
        end if
        call_proc(updateProperty_id,{"Frozen"})
        if find(controls[selectedControl][ControlParent],{"ReBar","ReBarBand"}) then
            repaintWinResize = w32True
        end if
        if find(controls[selectedControl][ControlParent],{"ToolBar","FlatToolBar"}) then
            repaintWinResize = w32True
            forceRedraw = w32True
        end if

    elsif cell=createWith then
        if equal(what, "integer") then
            controls[selectedControl][Integers] = w32True
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][Integers] = w32True
                            exit
                        end if
                    end for
                end if
            end for
        else
            controls[selectedControl][Integers] = w32False
            for i=1 to length(MultiPropertySelect) do
                if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                    for j=1 to length(controls) do
                        if equal(controls[j][Name], MultiPropertySelect[i]) then
                            controls[j][Integers] = w32False
                            exit
                        end if
                    end for
                end if
            end for
        end if

    elsif cell=exStyle then
        controls[selectedControl][ExStyle] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][ExStyle] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=defindex then
        if length(what) then
            controls[selectedControl][DEFIndex] = what
            controls[selectedControl][MultiSel] = w32True
            setProperty(multSel, w32True)
        else
            controls[selectedControl][DEFIndex] = {}
        end if
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        if length(what) then
                            controls[j][DEFIndex] = what
                            controls[j][MultiSel] = w32True
                        else
                            controls[j][DEFIndex] = {}
                        end if
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=ccWin then
        controls[selectedControl][CCWinStyle] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][CCWinStyle] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=ccWinMain then
        if equal(what, "Normal") then
            controls[selectedControl][WinMainOpen] = 0
        elsif equal(what, "Maximize") then
            controls[selectedControl][WinMainOpen] = 1
        else
            controls[selectedControl][WinMainOpen] = 2
        end if

    elsif cell=winOpenAtCtrl then
        controls[selectedControl][WinOpenAtCtrl] = what

    elsif cell=winPos then
        at = find(what, winPosList)
        controls[selectedControl][WinPos] = at-1
        if controls[selectedControl][WinPos]>3 then
            setPropEnabled(winPosTaskBar, w32True)
        else
            setProperty(winPosTaskBar, w32False)
            setPropEnabled(winPosTaskBar, w32False)
            controls[selectedControl][WinPosTaskBar] = w32False
        end if

    elsif cell=outX then
        controls[selectedControl][OutX] = what

    elsif cell=outY then
        controls[selectedControl][OutY] = what

    elsif cell=outCX then
        controls[selectedControl][OutCX] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][OutCX] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=outCY then
        controls[selectedControl][OutCY] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][OutCY] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=controlComment then
        controls[selectedControl][ControlComment] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][ControlComment] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=buddy then
        controls[selectedControl][Buddy] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][Buddy] = what
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=hintText then
        controls[selectedControl][HintText] = what

    elsif cell=XPMMember then
        --delete resource from sequence
        deleteResource(controls[selectedControl][Name], controls[selectedControl][XPM])
        controls[selectedControl][XPMmember] = what
        --add XPM and member to resources list
        addResource(controls[selectedControl][Name],controls[selectedControl][XPM],"XPM",controls[selectedControl][XPMmember])
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][XPMmember] = what
                        addResource(controls[j][Name],controls[j][XPM],"XPM",controls[j][XPMmember])
                        exit
                    end if
                end for
            end if
        end for

    elsif cell=iconFile then
        controls[selectedControl][IcoFile] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][IcoFile] = what
                        exit
                    end if
                end for
            end if
        end for
        whereIs = dir(controls[selectedControl][IcoFile])

        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][IcoFile]))
            if at then
                haveName = w32True
            end if
        end if

    elsif cell=bitmap then
        controls[selectedControl][BitmapFile] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][BitmapFile] = what
                        exit
                    end if
                end for
            end if
        end for
        whereIs = dir(controls[selectedControl][BitmapFile])

        if sequence(whereIs) then
            at = match(".bmp",lower(controls[selectedControl][BitmapFile]))
            if at then
                haveName = w32True
                setPropEnabled(XPMFile, w32False)
            else
                setPropEnabled(XPMFile, w32True)
            end if
        else
            setPropEnabled(XPMFile, w32True)
        end if

    elsif cell=defFile then
        controls[selectedControl][IcoFile] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][IcoFile] = what
                        exit
                    end if
                end for
            end if
        end for
        whereIs = dir(controls[selectedControl][IcoFile])

        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][IcoFile]))
            if at then
                haveName = w32True
            end if
        end if

    elsif cell=hotFile  then
        controls[selectedControl][TwoIcoFile] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][TwoIcoFile] = what
                        exit
                    end if
                end for
            end if
        end for
        whereIs = dir(controls[selectedControl][TwoIcoFile])

        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][TwoIcoFile]))
            if at then
                haveName = w32True
            end if
        end if
    elsif cell=disFile then
        controls[selectedControl][TriIcoFile] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][TriIcoFile] = what
                        exit
                    end if
                end for
            end if
        end for
        whereIs = dir(controls[selectedControl][TriIcoFile])

        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][TriIcoFile]))
            if at then
                haveName = w32True
            end if
        end if
    elsif cell=closeFile then
        controls[selectedControl][TwoIcoFile] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][TwoIcoFile] = what
                        exit
                    end if
                end for
            end if
        end for
        whereIs = dir(controls[selectedControl][TwoIcoFile])

        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][TwoIcoFile]))
            if at then
                haveName = w32True
            end if
        end if
    elsif cell=openFile then
        controls[selectedControl][TriIcoFile] = what
        for i=1 to length(MultiPropertySelect) do
            if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
                for j=1 to length(controls) do
                    if equal(controls[j][Name], MultiPropertySelect[i]) then
                        controls[j][TriIcoFile] = what
                        exit
                    end if
                end for
            end if
        end for
        whereIs = dir(controls[selectedControl][TriIcoFile])

        if sequence(whereIs) then
            at = match(".ico",lower(controls[selectedControl][TriIcoFile]))
            if at then
                haveName = w32True
            end if
        end if

    elsif cell=gridHeaderDataCol then
        showProperty(gridHeaderDataColVal, w32True)
        setPropEnabled(gridHeaderDataColVal, w32True)
        if equal(what, "Actual Col") then
            controls[selectedControl][GridHeaderType] = 1
            setProperty(gridHeaderDataColVal,
                        sprintf("%d",controls[selectedControl][GridHeaderInCol]))
        elsif equal(what, "Arrows") then
            setProperty(gridHeaderDataColVal,"0")
            showProperty(gridHeaderDataColVal, w32False)
            setPropEnabled(gridHeaderDataColVal, w32False)
            controls[selectedControl][GridHeaderType] = 2
            controls[selectedControl][GridHeaderInCol] = 0
        else
            setProperty(gridHeaderDataColVal,"0")
            showProperty(gridHeaderDataColVal, w32False)
            setPropEnabled(gridHeaderDataColVal, w32False)
            controls[selectedControl][GridHeaderType] = 3
            controls[selectedControl][GridHeaderInCol] = 0
        end if

    elsif cell=gridColAlign then
        if equal(what, "Left") then
            controls[selectedControl][GridTextAlign] = 1
        elsif equal(what, "Center") then
            controls[selectedControl][GridTextAlign] = 2
        else
            controls[selectedControl][GridTextAlign] = 3
        end if

    elsif cell=gridTextAlign then
        if equal(what, "Left") then
            controls[selectedControl][GridTextAlign] = 1
        elsif equal(what, "Center") then
            controls[selectedControl][GridTextAlign] = 2
        else
            controls[selectedControl][GridTextAlign] = 3
        end if

    elsif cell=gridFormat then
        controls[selectedControl][GridFormat] = what

    elsif cell=gridCellFormat then
        controls[selectedControl][GridFormat] = what

    elsif cell=gridDataArrayName then
        controls[selectedControl][GridDataArrayName] = what

    elsif cell=gridColListValues then
        controls[selectedControl][GridColListValues] = what

    elsif cell=gridRowSelect then
        if equal(what, "Single") then
            controls[selectedControl][GridRowSelect] = 1
        elsif equal(what, "None") then
            controls[selectedControl][GridRowSelect] = 2
        end if

    elsif cell=valueEdit then
        controls[selectedControl][ValueEdit] = what

    elsif cell=labelSide then
        if equal(what, "Left") then
            controls[selectedControl][LabelSide] = 0
        else
            controls[selectedControl][LabelSide] = 1
        end if

    elsif cell=cbgraphicpos then
        if equal(what, "Left") then
            controls[selectedControl][cbGraphicPos] = 1
        elsif equal(what, "Center") then
            controls[selectedControl][cbGraphicPos] = 2
        else    --"Right"
            controls[selectedControl][cbGraphicPos] = 3
        end if

    elsif cell=cbcaptionpos then
        if equal(what, "Left") then
            controls[selectedControl][cbCaptionPos] = 1
        elsif equal(what, "Center") then
            controls[selectedControl][cbCaptionPos] = 2
        elsif equal(what, "Right") then
            controls[selectedControl][cbCaptionPos] = 3
        else
            controls[selectedControl][cbCaptionPos] = 4
        end if

    elsif cell=partners then
        partnerList = {}
        if length(what)
        and not find(what,controls[selectedControl][SeqChildName]) then
            --build partner list            
            holdPartners = what
            while True do
                it = match(",",holdPartners)
                if it then
                    partnerList &= {holdPartners[1..it-1]}
                    holdPartners = holdPartners[it+1..length(holdPartners)]
                else
                    partnerList &= {holdPartners}
                    exit
                end if
            end while
        end if
        controls[selectedControl][ControlPartners] = partnerList

    elsif cell=pbCapPos then
        if equal(what, "Left") then
            controls[selectedControl][PB_Caption_Pos] = 1
        elsif equal(what, "Right") then
            controls[selectedControl][PB_Caption_Pos] = 2
        else
            controls[selectedControl][PB_Caption_Pos] = 0
        end if

    elsif cell=xpmmerObject then
        if not length(what) then
            controls[selectedControl][XpmObject] = {}
        end if

    elsif cell=xpmmerDisableObject then
        if not length(what) then
            controls[selectedControl][XpmDisableObject] = {}
        end if

    elsif cell=varhintFontName then
        controls[selectedControl][HintFontVarName] = what

    elsif cell=varhintFontPts then
        controls[selectedControl][HintFontVarPts] = what

    elsif cell=varhintFontItalic then
        controls[selectedControl][HintFontVarItalic] = what

    elsif cell=varhintFontBold then
        controls[selectedControl][HintFontVarBold] = what

    elsif cell=varhintFontUnderline then
        controls[selectedControl][HintFontVarUnderline] = what

    elsif cell=varhintFontStrike then
        controls[selectedControl][HintFontVarStrikeout] = what

    elsif cell=varfontName then
        controls[selectedControl][FontVarName] = what

    elsif cell=varfontPts then
        controls[selectedControl][FontVarPts] = what

    elsif cell=varfontItalic then
        controls[selectedControl][FontVarItalic] = what

    elsif cell=varfontBold then
        controls[selectedControl][FontVarBold] = what

    elsif cell=varfontUnderline then
        controls[selectedControl][FontVarUnderline] = what

    elsif cell=varfontStrike then
        controls[selectedControl][FontVarStrikeout] = what

    elsif cell=varhintText then
        controls[selectedControl][HintVarText] = what

    elsif cell=varfontColor then
        controls[selectedControl][FontVarColor] = what
    end if

    if not isChecked(MenuBitmapNoSuppress) then
        haveName = w32False
    end if

    endChanges(cell)

    return w32True
end function
integer verifyChange_rid
verifyChange_rid = routine_id("verifyChanges")
----------------------------------------------------------------------------
function changeDataPerClass(integer cell, integer event, sequence params)
sequence what

    what = params[1]

    controls[selectedControl][Class] = what
    for i=1 to length(MultiPropertySelect) do
        if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
            for j=1 to length(controls) do
                if equal(controls[j][Name], MultiPropertySelect[i]) then
                    controls[j][Class] = what
                    exit
                end if
            end for
        end if
    end for

    if equal(what,"DropDownList") then
        controls[selectedControl][LastListHeight] = controls[selectedControl][CY]
        controls[selectedControl][CY] = MasterList[12][6]
        call_proc(updateProperty_id,{"Height"})
    elsif find(what,{"List","SortedList"}) then
        controls[selectedControl][CY] = controls[selectedControl][LastListHeight]
        call_proc(updateProperty_id,{"Height"})
    elsif find(what,{"TogglePicture","PictureButton"}) then
        --some graphics were bleeding through to the next control
        controls[selectedControl][BitmapFile] = {}
        controls[selectedControl][XPM] = {}
        controls[selectedControl][XPMMember] = {}
        controls[selectedControl][IcoFile] = {}
        controls[selectedControl][TwoIcoFile] = {}
        controls[selectedControl][TriIcoFile] = {}
        if controls[selectedControl][PB_Caption_Pos] then
            controls[selectedControl][cbCaptionPos] = controls[selectedControl][PB_Caption_Pos]
        end if
        if sequence(controls[selectedControl][SuppressCell]) then
            controls[selectedControl][SuppressCell] = w32False
        end if
    end if

    endChanges(cell)

    return w32True

end function
integer otherClass_rid
otherClass_rid = routine_id("changeDataPerClass")
----------------------------------------------------------------------------
function changeDataPerLayer(integer cell, integer event, sequence params)
integer foundIt, flag, cnt
object what
sequence whoIs

    what = params[1]
    if not length(what) then
        return w32False
    end if

    foundIt = w32False
    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        if equal(what, layerCaptionSeq[selectedWindow][i][1]) then
            controls[selectedControl][ControlLayer] = layerCaptionSeq[selectedWindow][i][3]
            if layerCaptionSeq[selectedWindow][i][4] then
                controls[selectedControl][SetLayerOK] = w32True
            end if
            foundIt = w32True
            exit
        end if
    end for

    if not foundIt then
        ok = displayErrorMessage(244,{})
        return w32False
    end if

    --may need to reassign parenting
    if length(controls[selectedControl][SeqParentName]) then
        --delete selected control from old parent
        flag = findSeqParentName(selectedControl)
        if flag then
            removeFromParentChildSeq(flag,controls[selectedControl][Name])
        end if
        deleteTreeViewNode("", controls[selectedControl][Name])
        controls[selectedControl][SeqParentName] = {}
        controls[selectedControl][SeqParentClass] = {}
        controls[selectedControl][Parent] = {}
        controls[selectedControl][ParentClass] = {}
        controls[selectedControl][ControlParent] = {}
        addTreeViewNode(controls[TheWindow][Name],controls[selectedControl][Name])
    end if

    if length(controls[selectedControl][SeqChildName]) then
        --delete selected control from old parent
        foundIt = length(controls[selectedControl][SeqChildName])
        cnt = 0
        for x=selectedControl to length(controls) do
            if equal(controls[x][SeqParentName],controls[selectedControl][Name]) then
                cnt += 1
                controls[x][SeqParentName] = {}
                deleteTreeViewNode("", controls[x][Name])
                addTreeViewNode(controls[TheWindow][Name],controls[x][Name])
            end if
            if cnt=foundIt then
                exit
            end if
        end for
        controls[selectedControl][SeqChildName] = {}
    end if

    --find parent of selected control
    whoIs = findDirectParent(controls[selectedControl][X], controls[selectedControl][Y],
                             controls[selectedControl][ControlParent], controls[selectedControl][Name],
                             selectedControl)
    if whoIs[1] then
        controls[selectedControl][SeqParentName] = controls[whoIs[1]][Name]
        controls[selectedControl][SeqParentClass] = whoIs[2]
        deleteTreeViewNode("", controls[selectedControl][Name])
        addTreeViewNode(controls[whoIs[1]][Name],controls[selectedControl][Name])
        if equal(whoIs[2],"TabItem") then
            controls[selectedControl][ControlParent] = controls[selectedControl][SeqParentName]
            controls[selectedControl][ParentClass] = whoIs[2]
        elsif equal(whoIs[2],"Table") then
            controls[selectedControl][Parent] = controls[whoIs[1]][Name]
            controls[selectedControl][ControlParent] = controls[selectedControl][SeqParentName]
            controls[selectedControl][ParentClass] = whoIs[2]
        end if
    end if

    call_proc(updateProperty_id,{"Parent"})

    endChanges(cell)
    return w32True

end function
integer otherLayer_rid
otherLayer_rid = routine_id("changeDataPerLayer")
--------------------------------------------------------------------------------
function checkXPMName(integer cell, integer event, sequence params)
sequence name
    name = params[1]

    setPropEnabled(XPMMember, w32False)

    IDE_Changed = w32True
    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    controls[selectedControl][XPM] = name
    for i=1 to length(MultiPropertySelect) do
        if not equal(MultiPropertySelect[i], controls[selectedControl][Name]) then
            for j=1 to length(controls) do
                if equal(controls[j][Name], MultiPropertySelect[i]) then
                    controls[j][XPM] = name
                    exit
                end if
            end for
        end if
    end for

    if length(name) then
        for i=length(name) to 1 by -1 do
            if name[i]='.' then
                name = name[i..length(name)]
                exit
            end if
        end for
        if not equal(lower(name), ".xpm") then
            setPropEnabled(XPMMember, w32True)
        end if
        setPropEnabled(bitmap, w32False)
    else
        setProperty(XPMMember,"")
        setPropEnabled(XPMMember, w32False)
        setPropEnabled(bitmap, w32True)
    end if

    endChanges(cell)

    return w32True
end function
integer XPM_rid
XPM_rid = routine_id("checkXPMName")
--------------------------------------------------------------------------------
function gotoTableSpecs(integer cell, integer event, sequence params)
    ok = invokeHandler(PopUpDesign_Table, w32HClick, {0,0,0})
    return w32True
end function
integer tablespecs_rid
tablespecs_rid = routine_id("gotoTableSpecs")
--------------------------------------------------------------------------------
function gotoXPMmer(integer cell, integer event, sequence params)
    -- open XPMmer
    if cell=xpmmer then
        xpmCell = 1     --this will tell XPMmer.ew which cell to place saved icon
    elsif cell=xpmmerDisable then
        xpmCell = 2
    end if
    openWindow(Window1, Normal)
    endChanges(cell)
    return w32True
end function
integer xpmmer_rid
xpmmer_rid = routine_id("gotoXPMmer")
------------------------------------------------------------------------------------------
-- The initial PropertySheet. It is built from opening IDE and contents are set in updateProperties
---------------------------------------------------------------------------------------------
--prop.ew define the controls
        setText(splashLoadInfo, "Initializing Property Sheet...")
        size = getClientRect(PropertySheet)

    sheetId = createProperties(PropertyTabItem, 0, propertyTitleBar, size[3], 120, 85)
        StylePopup = createEx(Popup, "", sheetId, 0, 0, 0, 0, 0, 0)
    Explore1 = createEx(MenuItem, "Visual Style Explorer", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore2 = createEx(MenuItem, "ListView Style Explorer", StylePopup, 0, 0, 0, 0, 0, 0)
        Explore3 = createEx(MenuItem, "Update Control Order", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore4 = createEx(MenuItem, "Update Initial Values", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore5 = createEx(MenuItem, "Test Transparency Values", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore6 = createEx(MenuItem, "Select From Property Templates", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore11 = createEx(MenuItem, "Copy to XPMmer Disable XPM", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore12 = createEx(MenuItem, "Copy to XPMmer XPM", StylePopup, 0, 0, 0, 0, 0, 0)
    Explorea = createEx(MenuItem, "-", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore10 = createEx(MenuItem, "Undo", StylePopup, 0, 0, 0, 0, 0, 0)
    Exploreb = createEx(MenuItem, "-", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore7 = createEx(MenuItem, "Cut", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore8 = createEx(MenuItem, "Copy", StylePopup, 0, 0, 0, 0, 0, 0)
    Explore9 = createEx(MenuItem, "Paste", StylePopup, 0, 0, 0, 0, 0, 0)

        setHandler({Explore1,Explore2,Explore3,Explore4,Explore5,Explore6,Explore7,Explore8,Explore9,Explore10,Explore11,Explore12},
                   w32HClick,
                   routine_id("popupClicked"))

        --set initially but may be changed per property later in user configurations
    setPropsWaitForEnter(w32False)
        -- (caption, parent, type)              
        name = addProperty("Name & ENTER", 0, ptEditBox)
    setPropHandler(name, peChange, name_rid)
        caption = addProperty("Caption:", 0, ptEditBox)
    setPropHandler(caption, peChange, name_rid)
        labelSide = addProperty("Caption on Side:", 0, ptDropDownList)
    setPropertyCombo(labelSide, 1, {"Left"})
    setPropHandler(labelSide, peChange, verifyChange_rid)
        valueEdit = addProperty("Data:", 0, ptEditBox)
    --only for LabeledEdit control
    setPropHandler(valueEdit, peChange, verifyChange_rid)
        showCap = addProperty(" Show in EXW:", 0, ptCheckBox)
    --showCaption is only for EditText, RichEdit and MleText class          
    setPropHandler(showCap, peChange, checkBoxes_rid)
        titleWidth = addProperty("Title Width:", 0, ptEditBox)
                --titleWidth is only shown for ListView class and not editable          
        propclass = addProperty("Class:", 0, ptDropDownList)
    setPropertyCombo(propclass, 1, {"Window"})
    setPropHandler(propclass, peChange, otherClass_rid)
        treatAsColorButton = addProperty("Color Button?",0,ptCheckBox)
    setPropHandler(treatAsColorButton, peChange, checkBoxes_rid)
        row = addProperty("Row:", 0, ptEditBox)
    --row is not modifiable for Rebar, RebarBand and StatusBar
    --or when ToolBar and FlatToolbar have no parent        
    setPropHandler(row, peChange, XY_rid)
        col = addProperty("Col:", 0, ptEditBox)
    --col is not modifiable for Rebar, RebarBand and StatusBar class
    --or when ToolBar and FlatToolbar class have no parent  
    setPropHandler(col, peChange, XY_rid)
        width = addProperty("Width:", 0, ptEditBox)
    --may not modify width for MonthCalendar, StatusBar, SepButton class    
    setPropHandler(width, peChange, XY_rid)
        height = addProperty("Height:", 0, ptEditBox)
    --may not modify height for MonthCalendar, StatusBar, SepButton, ReBar, ReBarBand class
    setPropHandler(height, peChange, XY_rid)
    suppressCell = addProperty("Suppress in EXW", 0, ptCheckBox)
        --only for Table cells
        setPropHandler(suppressCell, peChange, checkBoxes_rid)
        toolHeight = addProperty("Row Height:", 0, ptEditBox)
    --show only when Toolbar or FlatToolbar class                   
    setPropHandler(toolHeight, peChange, number_rid)
    alternatePos = addProperty("Alternate Positions",0,ptNone)
    outY = addProperty("Row", alternatePos, ptEditBox)
        setPropHandler(outY, peChange, verifyChange_rid)
    outX = addProperty("Col", alternatePos, ptEditBox)
        setPropHandler(outX, peChange, verifyChange_rid)
    outCX = addProperty("Width", alternatePos, ptEditBox)
        setPropHandler(outCX, peChange, verifyChange_rid)
    outCY = addProperty("Height", alternatePos, ptEditBox)
        setPropHandler(outCY, peChange, verifyChange_rid)
    controllayer = addProperty("Layer:", 0, ptDropDownList)
        setPropertyCombo(controllayer, 1, {"Layer 0"})
        setPropHandler(controllayer, peChange, otherLayer_rid)
    setLayerOK = addProperty("May use setLayer:",0,ptCheckBox)
        setPropHandler(setLayerOK, peChange, checkBoxes_rid)
    controlComment = addProperty("Comment/Code", 0, ptEditBox)
        setPropHandler(controlComment, peChange, verifyChange_rid)
        controlOrder = addProperty("Control Order:", 0, ptEditBox)
                --controlOrder is not shown if class is Window, Toolbar, FlatToolbar, StatusBar, Rebar
                --and ReBarBand         
        setPropHandler(controlOrder, peChange, verifyChange_rid)
        setPropHandler(controlOrder, peRightUp, popup_rid)
        proptableSpecs = addProperty("Table Specs", 0, ptButton)
    setPropHandler(proptableSpecs, peLeftUp, tablespecs_rid)
        list = addProperty("<LIST>", 0, ptDropDownList)
    --list is not shown unless class is Combo,SortedCombo,SimpleCombo,List,DropDownList,ListView                                            
    setPropHandler(list, peRightUp, popup_rid)
    defindex = addProperty("Default Indexes", 0, ptEditBox)
        --only for List and SortedList control
        setPropHandler(defindex, peChange, verifyChange_rid)
        local = addProperty("Local:", 0, ptCheckBox)
    setPropHandler(local, peChange, checkBoxes_rid)
        createWith = addProperty("Create With:", 0, ptDropDownList)
    setPropHandler(createWith, peChange, verifyChange_rid)
    classdef = addProperty("ClassDefaults:", 0, ptEditBox)
        setPropHandler(classdef, peChange, verifyChange_rid)
        setPropHandler(classdef, peRightUp, popup_rid)
        ccWin = addProperty("CCWinStyle", 0, ptEditBox)
    --only for Window class                                                                                 
    setPropHandler(ccWin, peChange, verifyChange_rid)
    setPropHandler(ccWin, peRightUp, popup_rid)
    insystray = addProperty("SysTray", 0, ptCheckBox)
        --only for first window
        setPropHandler(insystray, peChange, checkBoxes_rid)
    useInWinMain = addProperty("Use In WinMain:",0, ptCheckBox)
        setPropHandler(useInWinMain, peChange, checkBoxes_rid)
        ccWinMain = addProperty("WinMain Open", 0, ptDropDownList)
    --only for Window class 
    setPropHandler(ccWinMain, peChange, verifyChange_rid)
    winOpenAtCtrl = addProperty("Cursor in ", 0, ptEditBox)
        --only for Window class
        setPropHandler(winOpenAtCtrl, peChange, verifyChange_rid)
        winPos = addProperty("Win Position", 0, ptDropDownList)
    --only for Window class
    setPropHandler(winPos, peChange, verifyChange_rid)
    winPosTaskBar = addProperty("  Reduce by TaskBar", 0, ptCheckBox)
        --only for Window class
        setPropHandler(winPosTaskBar, peChange, checkBoxes_rid)
        enable = addProperty("Enable:", 0, ptCheckBox)
    setPropHandler(enable, peChange, checkBoxes_rid)
        visible = addProperty("Visible:", 0, ptCheckBox)
    setPropHandler(visible, peChange, checkBoxes_rid)
        pbCapPos = addProperty("Position Caption:", 0, ptDropDownList)
                --not for colored button
        setPropHandler(pbCapPos, peChange,verifyChange_rid)
    checked = addProperty("Check:", 0, ptCheckBox)
                --for CheckBox and Radio
        setPropHandler(checked, peChange, checkBoxes_rid)
        alimitText = addProperty("Limit Text To:", 0, ptEditBox)
    --for "EditText","MleText","RichEdit" classes only      
    setPropHandler(alimitText, peChange, number_rid)
    LvAddBottom = addProperty("Add To Bottom", 0, ptCheckBox)
        --for ListView
        setPropHandler(LvAddBottom, peChange, checkBoxes_rid)
    setcreatefont = addProperty("setCreateFont", 0, ptCheckBox)
    --for window class only
    setPropHandler(setcreatefont, peChange, checkBoxes_rid)
        controlStyle = addProperty("Control Styles:", 0, ptNone)
        cbthickness = addProperty("Border Thickness",controlStyle, ptEditBox)
    --for colored button only
    setPropHandler(cbthickness, peChange, number_rid)
        cbcaptionpos = addProperty("Caption Pos",controlStyle, ptDropDownList)
    --for colored button only
    setPropHandler(cbcaptionpos, peChange, verifyChange_rid)
        cbgraphicpos = addProperty("Graphic Pos",controlStyle, ptDropDownList)
    --for colored button only       
    setPropHandler(cbgraphicpos, peChange, verifyChange_rid)
        cbcentvert = addProperty("Center Caption Vertically", controlStyle, ptCheckBox)
    --for colored button only
    setPropHandler(cbcentvert, peChange, checkBoxes_rid)
        cbmultiline = addProperty("Multiline",controlStyle, ptCheckBox)
    --for colored button only
    setPropHandler(cbmultiline, peChange, checkBoxes_rid)
        cbflat = addProperty("Flat",controlStyle, ptCheckBox)
    --for colored button only
    setPropHandler(cbflat, peChange, checkBoxes_rid)
        readOnly = addProperty("Read Only", controlStyle, ptCheckBox)
    --for MleText, RichEdit and EditText classes            
    setPropHandler(readOnly, peChange, checkBoxes_rid)
        upperCase = addProperty("Upper Case", controlStyle, ptCheckBox)
    --for MleText and EditText classes              
    setPropHandler(upperCase, peChange, checkBoxes_rid)
        lowerCase = addProperty("Lower Case", controlStyle, ptCheckBox)
    --for MleText and EditText classes              
    setPropHandler(lowerCase, peChange, checkBoxes_rid)
        numeric = addProperty("Numeric", controlStyle, ptCheckBox)
    --for MleText and EditText classes      
    setPropHandler(numeric, peChange, checkBoxes_rid)
    noIntegralHeight = addProperty("No Integeral Height", controlStyle, ptCheckBox)
        --for List and ListView classes
        setPropHandler(noIntegralHeight, peChange, checkBoxes_rid)
    adjCenter = addProperty("Center Text", controlStyle, ptCheckBox)
        setPropHandler(adjCenter, peChange, checkBoxes_rid)
    adjRight = addProperty("Right Adjust Text", controlStyle, ptCheckBox)
        setPropHandler(adjRight, peChange, checkBoxes_rid)
        upDownLeft = addProperty("Adjust Left of Buddy", controlStyle, ptCheckBox)
    setPropHandler(upDownLeft, peChange, checkBoxes_rid)
        upDownHorz = addProperty("Show Horzontal", controlStyle, ptCheckBox)
    setPropHandler(upDownHorz, peChange, checkBoxes_rid)
        tabsBottom = addProperty("Tabs at Bottom", controlStyle, ptCheckBox)
    setPropHandler(tabsBottom, peChange, checkBoxes_rid)
    gridCellFormat = addProperty("      Format:",controlStyle,ptEditBox)
        --for EuGrid only
        showProperty(gridCellFormat, w32False)
        setPropHandler(gridCellFormat, peChange, verifyChange_rid)
        password = addProperty("Password:", controlStyle, ptCheckBox)
    --for EditText class only
    setPropHandler(password, peChange, checkBoxes_rid)
        hScroll = addProperty("H Scroll:", controlStyle, ptCheckBox)
    --for RichEdit only             
    setPropHandler(hScroll, peChange, checkBoxes_rid)
        vScroll = addProperty("V Scroll:", controlStyle, ptCheckBox)
    --for MLE only          
    setPropHandler(vScroll, peChange, checkBoxes_rid)
        multiline = addProperty("Multiline:", controlStyle, ptCheckBox)
                --for PushButton and ToggleButton only  
        --for TabControl gets converted to TCS_MULTILINE
    setPropHandler(multiline, peChange, checkBoxes_rid)
        clickable = addProperty("Clickable:", controlStyle, ptCheckBox)
    --for CText, RText and LText only               
    setPropHandler(clickable, peChange, checkBoxes_rid)
        minValue = addProperty("Min Value:", controlStyle, ptEditBox)
    --for UpDown,HScroll,VScroll only               
    setPropHandler(minValue, peChange, number_rid)
        maxValue = addProperty("Max Value:", controlStyle, ptEditBox)
    --for UpDown,HScroll,VScroll only               
    setPropHandler(maxValue, peChange, number_rid)
        lineChg = addProperty("Line Size:", controlStyle, ptEditBox)
    --for UpDown only               
    setPropHandler(lineChg, peChange, number_rid)
        pageChg = addProperty("Page Size:", controlStyle, ptEditBox)
    --for UpDown only               
    setPropHandler(pageChg, peChange, number_rid)
        multSel = addProperty("Multi Sel:", controlStyle, ptCheckBox)
    --for List, SortedList only                             
    setPropHandler(multSel, peChange, checkBoxes_rid)
        extSel = addProperty("Extend Sel:", controlStyle, ptCheckBox)
    --for List,SortedList only              
    setPropHandler(extSel, peChange, checkBoxes_rid)
        rbbsBreak = addProperty("RBBS_Break:", controlStyle, ptCheckBox)
    --for ReBarBand only            
    setPropHandler(rbbsBreak, peChange, checkBoxes_rid)
    mcs_multiselect = addProperty("MultiSelect", controlStyle, ptCheckBox)
        --for MonthCalendar
        setPropHandler(mcs_multiselect, peChange, checkBoxes_rid)
    pbs_smooth = addProperty("Smooth", controlStyle, ptCheckBox)
        --for ProgressBar
        setPropHandler(pbs_smooth, peChange, checkBoxes_rid)
    bs_flat = addProperty("Flat", controlStyle, ptCheckBox)
        --for PushButton
        setPropHandler(bs_flat, peChange, checkBoxes_rid)
    buddy = addProperty("Buddy Name:", controlStyle, ptEditBox)
    --for UpDown only               
    setPropHandler(buddy, peChange, verifyChange_rid)
        otherFlags = addProperty("Other Flags:", controlStyle, ptEditAndButton)
    setPropHandler(otherFlags, peChange, verifyChange_rid)
        setPropHandler(otherFlags, peEditButton, styles_rid)
        controlStyletype = addProperty("Style Type:", controlStyle, ptDropDownList)
    setPropHandler(controlStyletype, peChange, verifyChange_rid)
        style = addProperty("Style:", controlStyle, ptEditBox)
    setPropHandler(style, peChange, verifyChange_rid)
    setPropHandler(style, peRightUp, popup_rid)
        styletype = addProperty("Style Type:", controlStyle, ptDropDownList)
    setPropHandler(styletype, peChange, verifyChange_rid)
        exStyle = addProperty("Ex Style:", controlStyle, ptEditBox)
    setPropHandler(exStyle, peChange, verifyChange_rid)
    setPropHandler(exStyle, peRightUp, popup_rid)
    --style, styletype only for Window and CWindow  
    --styletype needs to be prompted with starting value depending style value of
    --zero, has no entry, or has entry.
    --styletype is initially blank when style is zero or no entry.
    --when style has an entry, change to one of the combo values which user may then change
    --if desired.   
        extExStyle = addProperty("Ext Ex Style:", controlStyle, ptDropDownList)
                --shown only for ListView class
                --is not editable       
                --not for Window class          
                --only for non Window class             
                --styletype needs to be prompted with starting value depending style value of
                --zero, has no entry, or has entry.
                --styletype is initially blank when style is zero or no entry.
                --when style has an entry, change to one of the combo values which user may then change
                --if desired.                  
    gridFormat = addProperty("Numeric Format:",0,ptEditBox)
        --for EuGrid only
        showProperty(gridFormat, w32False)
        setPropHandler(gridFormat, peChange, verifyChange_rid)
        partners = addProperty("Partners:", 0, ptEditAndButton)
    setPropHandler(partners, peChange, verifyChange_rid)
    setPropHandler(partners, peEditButton, partners_rid)
        parent = addProperty("Parent:", 0, ptDropDownList)
    --control parent
    --for window class other than first window
    setPropHandler(parent, peChange, verifyChange_rid)
        parentFrozen = addProperty("    Maint by user", 0, ptCheckBox)
    setPropHandler(parentFrozen, peChange, checkBoxes_rid)
        windowParent = addProperty("Parent:", 0, ptComboBox)
    --parent for window class for first window if .ew project 
    --user may key in anything without validation   
    setPropHandler(windowParent, peChange, verifyChange_rid)
    txtColor = addProperty("Text Color:", 0, ptEditAndButton)
        --for EditText, labels and List controls
        setPropHandler(txtColor, peEditButton, color_rid)
        setPropHandler(txtColor, peChange, defaultColor_rid)
        --colorNotWindow = addProperty("Color:", 0, ptEditAndButton)
        color = addProperty("Color:", 0, ptEditAndButton)
    --shown for selected classes
    --initially prompt to 0 except for Window and EuGrid background 
    setPropHandler(color, peEditButton, color_rid)
    setPropHandler(color, peChange, defaultColor_rid)
        barColor = addProperty("TickBar Color:",0,ptEditAndButton)
    --shown for ProgressBar class
    --initially prompt to 0                 
    setPropHandler(barColor, peEditButton, color_rid)
    setPropHandler(barColor, peChange, defaultColor_rid)
        defaultColor = addProperty("  System Colors:", 0, ptDropDownList)
    setPropHandler(defaultColor, peChange, systemColors_rid)
        mc_background = addProperty("MC_Background",0, ptEditAndButton)
    setPropHandler(mc_background, peEditButton, color_rid)
    setPropHandler(mc_background, peChange, defaultColor_rid)
        mc_text = addProperty("MC_Text",0, ptEditAndButton)
    setPropHandler(mc_text, peEditButton, color_rid)
    setPropHandler(mc_text, peChange, defaultColor_rid)
    mc_titleBK = addProperty("MC_TitleBK",0, ptEditAndButton)
    setPropHandler(mc_titleBK, peEditButton, color_rid)
    setPropHandler(mc_titleBK, peChange, defaultColor_rid)
    mc_titleText = addProperty("MC_TitleText",0, ptEditAndButton)
    setPropHandler(mc_titleText, peEditButton, color_rid)
    setPropHandler(mc_titleText, peChange, defaultColor_rid)
    mc_monthBK = addProperty("MC_MonthBK",0, ptEditAndButton)
    setPropHandler(mc_monthBK, peEditButton, color_rid)
    setPropHandler(mc_monthBK, peChange, defaultColor_rid)
    mc_trailingText = addProperty("MC_TrailingText",0, ptEditAndButton)
    setPropHandler(mc_trailingText, peEditButton, color_rid)
    setPropHandler(mc_trailingText, peChange, defaultColor_rid)
        iconFile = addProperty("Icon File:", 0, ptEditAndButton)
    --for Window, Icon class                        
    setPropHandler(iconFile, peEditButton, pickFileName_rid)
    setPropHandler(iconFile, peChange, verifyChange_rid)
        iconFileLV = addProperty("Icon Files:", 0, ptDropDownList)
    --for ListView only; not editable               
    setPropHandler(iconFileLV, peRightUp, popup_rid)
        defFile = addProperty("Def Icon File:", 0, ptEditAndButton)
    --for PictureButton class                               
    setPropHandler(defFile, peEditButton, pickFileName_rid)
    setPropHandler(defFile, peChange, verifyChange_rid)
        hotFile = addProperty("Hot Icon File:", 0, ptEditAndButton)
    --for PictureButton class on FlatToolBar                        
    setPropHandler(hotFile, peEditButton, pickFileName_rid)
    setPropHandler(hotFile, peChange, verifyChange_rid)
        disFile = addProperty("Dis Icon File:", 0, ptEditAndButton)
    --for PictureButton class on FlatToolBar                        
    setPropHandler(disFile, peEditButton, pickFileName_rid)
    setPropHandler(disFile, peChange, verifyChange_rid)
        closeFile = addProperty("Close Icon:", 0, ptEditAndButton)
    --for TreeView class                            
    setPropHandler(closeFile, peEditButton, pickFileName_rid)
    setPropHandler(closeFile, peChange, verifyChange_rid)
        openFile = addProperty("Open Icon:", 0, ptEditAndButton)
    --for TreeView class                    
    setPropHandler(openFile, peEditButton, pickFileName_rid)
    setPropHandler(openFile, peChange, verifyChange_rid)
        bitmap = addProperty("Bitmap FileName:", 0, ptEditAndButton)
    --bitmap shown only for PictureButton or TogglePicture or Bitmap class                                          
    setPropHandler(bitmap, peEditButton, pickFileName_rid)
    setPropHandler(bitmap, peChange, verifyChange_rid)
        xpmmer = addProperty("XPMmer XPM", 0, ptButton)
    setPropHandler(xpmmer, peLeftUp, xpmmer_rid)
        xpmmerObject = addProperty("  Object", 0, ptEditBox)
    setPropHandler(xpmmerObject, peChange, verifyChange_rid)
    setPropHandler(xpmmerObject, peRightUp, popup_rid)
    --not editable by user except to erase
        xpmmerDisable = addProperty("XPMmer Disable XPM", 0, ptButton)
    setPropHandler(xpmmerDisable, peLeftUp, xpmmer_rid)
        xpmmerDisableObject = addProperty("  Object", 0, ptEditBox)
    setPropHandler(xpmmerDisableObject, peChange, verifyChange_rid)
    setPropHandler(xpmmerDisableObject, peRightUp, popup_rid)
    --not editable by user except to erase          
        XPMFile = addProperty("XPM FileName:", 0, ptEditAndButton)
    --bitmap shown only for PictureButton or TogglePicture class                    
    setPropHandler(XPMFile, peChange, XPM_rid)
    setPropHandler(XPMFile, peEditButton, pickFileName_rid)
        XPMMember = addProperty("  Member:", 0, ptEditBox)
    --bitmap shown only for PictureButton or TogglePicture class            
    --when XPMFile not has .xpm extention   
    setPropHandler(XPMMember, peChange, verifyChange_rid)
        --coloredbutton = addProperty("Colored Button:",0,ptNone)
        --treatAsColorButton = addProperty("Treat As Colored Button",coloredbutton,ptCheckBox)
                --setPropHandler(treatAsColorButton, peChange, checkBoxes_rid)
        cbcolor = addProperty("Color",0,ptEditAndButton)
    setPropHandler(cbcolor, peEditButton, color_rid)
    setPropHandler(cbcolor, peChange, defaultColor_rid)
        cbpresscolor = addProperty("Press Color",0,ptEditAndButton)
    setPropHandler(cbpresscolor, peEditButton, color_rid)
    setPropHandler(cbpresscolor, peChange, defaultColor_rid)
        cbcaptioncolor = addProperty("Caption Color",0, ptEditAndButton)
    setPropHandler(cbcaptioncolor, peEditButton, color_rid)
    setPropHandler(cbcaptioncolor, peChange, defaultColor_rid)
        cbpresscaptioncolor = addProperty("Press Caption Color",0, ptEditAndButton)
    setPropHandler(cbpresscaptioncolor, peEditButton, color_rid)
    setPropHandler(cbpresscaptioncolor, peChange, defaultColor_rid)
        hintFont = addProperty("HintFont", 0, ptNone)
        showHintFontVar = addProperty("Open Vars", hintFont, ptCheckBox)
    setPropHandler(showHintFontVar, peChange, checkBoxes_rid)
        hintFontName = addProperty("Font Name", hintFont, ptEditAndButton)
    --for Window class only
    setPropHandler(hintFontName, peEditButton, font_rid)
    setPropHandler(hintFontName, peChange, font2_rid)
        varhintFontName = addProperty("-- as var", hintFont, ptEditBox)
    setPropHandler(varhintFontName, peChange, verifyChange_rid)
        hintFontPts = addProperty("Font Size:", hintFont, ptEditBox)
    setPropHandler(hintFontPts, peChange, number_rid)
        varhintFontPts = addProperty("-- as var", hintFont, ptEditBox)
    setPropHandler(varhintFontPts, peChange, verifyChange_rid)
        hintFontAttrib = addProperty("Attributes:", hintFont, ptNone)
        hintFontBold = addProperty("Bold:", hintFontAttrib, ptCheckBox)
    setPropHandler(hintFontBold, peChange, checkBoxes_rid)
        varhintFontBold = addProperty("-- as var", hintFontAttrib, ptEditBox)
    setPropHandler(varhintFontBold, peChange, verifyChange_rid)
        hintFontItalic = addProperty("Italic:", hintFontAttrib, ptCheckBox)
    setPropHandler(hintFontItalic, peChange, checkBoxes_rid)
        varhintFontItalic = addProperty("-- as var", hintFontAttrib, ptEditBox)
    setPropHandler(varhintFontItalic, peChange, verifyChange_rid)
        hintFontUnderline = addProperty("Underline:", hintFontAttrib, ptCheckBox)
    setPropHandler(hintFontUnderline, peChange, checkBoxes_rid)
        varhintFontUnderline = addProperty("--as var", hintFontAttrib, ptEditBox)
    setPropHandler(varhintFontUnderline, peChange, verifyChange_rid)
        hintFontStrike = addProperty("Strike:", hintFontAttrib, ptCheckBox)
    setPropHandler(hintFontStrike, peChange, checkBoxes_rid)
        varhintFontStrike = addProperty("-- as var", hintFontAttrib, ptEditBox)
    setPropHandler(varhintFontStrike, peChange, verifyChange_rid)
        hintText = addProperty("Hint Text:", 0, ptEditBox)
    setPropHandler(hintText, peChange, verifyChange_rid)
        varhintText = addProperty("-- as var", 0, ptEditBox)
    setPropHandler(varhintText, peChange, verifyChange_rid)
    --for all classes except ReBarBand                      
        font = addProperty("Font", 0, ptNone)
    showProperty(font, w32False)
        showFontVar = addProperty("Open Vars", font, ptCheckBox)
    setPropHandler(showFontVar, peChange, checkBoxes_rid)
        fontName = addProperty("Font Name", font, ptEditAndButton)
    --when anything in font changes and class is ReBar then need to adjust ReBarband and force
    --design to redraw                              
    setPropHandler(fontName, peEditButton, font_rid)
    setPropHandler(fontName, peChange, font2_rid)
        varfontName = addProperty("-- as var", font, ptEditBox)
    setPropHandler(varfontName, peChange, verifyChange_rid)
        fontPts  = addProperty("Font Size:", font, ptEditBox)
    setPropHandler(fontPts, peChange, number_rid)
        varfontPts  = addProperty("-- as var", font, ptEditBox)
    setPropHandler(varfontPts, peChange, verifyChange_rid)
        fontAttrib = addProperty("Attributes:", font, ptNone)
        fontBold = addProperty("Bold:", fontAttrib, ptCheckBox)
    setPropHandler(fontBold, peChange, checkBoxes_rid)
        varfontBold = addProperty("-- as var", fontAttrib, ptEditBox)
    setPropHandler(varfontBold, peChange, verifyChange_rid)
        fontItalic = addProperty("Italic:", fontAttrib, ptCheckBox)
    setPropHandler(fontItalic, peChange, checkBoxes_rid)
        varfontItalic = addProperty("-- as var", fontAttrib, ptEditBox)
    setPropHandler(varfontItalic, peChange, verifyChange_rid)
        fontUnderline = addProperty("Underline:", fontAttrib, ptCheckBox)
    setPropHandler(fontUnderline, peChange, checkBoxes_rid)
        varfontUnderline = addProperty("-- as var", fontAttrib, ptEditBox)
    setPropHandler(varfontUnderline, peChange, verifyChange_rid)
        fontStrike = addProperty("Strike:", fontAttrib, ptCheckBox)
    setPropHandler(fontStrike, peChange, checkBoxes_rid)
        varfontStrike = addProperty("-- as var", fontAttrib, ptEditBox)
    setPropHandler(varfontStrike, peChange, verifyChange_rid)
    fontColor = addProperty("Color:", fontAttrib, ptEditAndButton)
    setPropHandler(fontColor, peEditButton, color_rid)
    setPropHandler(fontColor, peChange, defaultColor_rid)
        varfontColor = addProperty("-- as var", fontAttrib, ptEditBox)
    setPropHandler(varfontColor, peChange, verifyChange_rid)
    indexTo = addProperty("Indexed To:", 0, ptDropDownList)
    removeCopyIndex = addProperty("  Remove indexing",0,ptCheckBox)
    setPropHandler(removeCopyIndex, peChange, checkBoxes_rid)
    --following are for EuGrid only
    gridHeaderInfo = addProperty("Header Info:", 0, ptNone)
        showProperty(gridHeaderInfo, w32False)
    gridHeaderColor = addProperty("Color:",gridHeaderInfo, ptEditAndButton)
        setPropHandler(gridHeaderColor, peEditButton, color_rid)
        setPropHandler(gridHeaderColor, peChange, defaultColor_rid)
    gridHeaderColHeight = addProperty("Col Height:",gridHeaderInfo, ptEditBox)
        setPropHandler(gridHeaderColHeight, peChange, number_rid)
    gridHeaderRowWidth = addProperty("Row Width:",gridHeaderInfo, ptEditBox)
        setPropHandler(gridHeaderRowWidth, peChange, number_rid)
    gridHeaderDataCol = addProperty("Header Type:",gridHeaderInfo, ptDropDownList)
        setPropHandler(gridHeaderDataCol, peChange,verifyChange_rid)
    gridHeaderDataColVal = addProperty("Data Col:",gridHeaderInfo,ptEditBox)
        setPropHandler(gridHeaderDataColVal, peChange, number_rid)
    gridColors = addProperty("Color Info:", 0, ptNone)
        showProperty(gridColors, w32False)
    gridCellBkColor = addProperty("Default Col:", gridColors, ptEditAndButton)
        setPropHandler(gridCellBkColor, peEditButton, color_rid)
        setPropHandler(gridCellBkColor, peChange, defaultColor_rid)
    gridBkColorSelect = addProperty("Bg Select:", gridColors, ptEditAndButton)
        setPropHandler(gridBkColorSelect, peEditButton, color_rid)
        setPropHandler(gridBkColorSelect, peChange, defaultColor_rid)
    gridLineColor = addProperty("Line:", gridColors, ptEditAndButton)
        setPropHandler(gridLineColor, peEditButton, color_rid)
        setPropHandler(gridLineColor, peChange, defaultColor_rid)
    gridTextColor = addProperty("Text:", gridColors, ptEditAndButton)
        setPropHandler(gridTextColor, peEditButton, color_rid)
        setPropHandler(gridTextColor, peChange, defaultColor_rid)
    gridTextColorSelect = addProperty("Selected Text:", gridColors, ptEditAndButton)
        setPropHandler(gridTextColorSelect, peEditButton, color_rid)
        setPropHandler(gridTextColorSelect, peChange, defaultColor_rid)
    gridColTextColor = addProperty("Text Color:", gridColors, ptEditAndButton)
        setPropHandler(gridColTextColor, peEditButton, color_rid)
        setPropHandler(gridColTextColor, peChange, defaultColor_rid)
    gridCellBorderColor = addProperty("Cell Border:", gridColors, ptEditAndButton)
        setPropHandler(gridCellBorderColor, peEditButton, color_rid)
        setPropHandler(gridCellBorderColor, peChange, defaultColor_rid)
    gridActiveHeaders = addProperty("Active Headers:",0,ptCheckBox)
        setPropHandler(gridActiveHeaders, peChange, checkBoxes_rid)
    gridAllowColResize = addProperty("Col Resize:",0, ptCheckBox)
        setPropHandler(gridAllowColResize, peChange, checkBoxes_rid)
    gridAllowColSort = addProperty("Col Sort:",0,ptCheckBox)
        setPropHandler(gridAllowColSort, peChange, checkBoxes_rid)
    gridCellBorder = addProperty("Cell Border:",0, ptCheckBox)
        setPropHandler(gridCellBorder, peChange, checkBoxes_rid)
    gridHighlightText = addProperty("Highlight Text:",0,ptCheckBox)
        setPropHandler(gridHighlightText, peChange, checkBoxes_rid)
    gridRowHeight = addProperty("Row Height:",0,ptEditBox)
        setPropHandler(gridRowHeight, peChange, number_rid)
    gridTextAlign = addProperty("Text Align:",0,ptDropDownList)
        showProperty(gridTextAlign, w32False)
        setPropHandler(gridTextAlign, peChange, verifyChange_rid)
    gridColAlign = addProperty("Col Align:", 0, ptDropDownList)
        showProperty(gridColAlign, w32False)
        setPropHandler(gridColAlign, peChange, verifyChange_rid)
    gridRowSelect = addProperty("Row Select:", 0, ptDropDownList)
        setPropHandler(gridRowSelect, peChange, verifyChange_rid)
    gridColListDataCol = addProperty("ColListDataCol:",0,ptEditBox)
        setPropHandler(gridColListDataCol, peChange, number_rid)
    gridColListValues = addProperty("ColListValues:",0,ptEditBox)
        setPropHandler(gridColListValues, peChange, verifyChange_rid)
    gridDataArrayName = addProperty("Data Array Name",0, ptEditBox)
        setPropHandler(gridDataArrayName, peChange, verifyChange_rid)
    transparency = addProperty("Transparency (1-256)",0,ptEditBox)
        setPropHandler(transparency, peRightUp, popup_rid)
        setPropHandler(transparency, peChange,number_rid)
    -- finally draw the thing
        redrawProperties(1)
----------------------------------------------------------------------------
include includes\viewCodeBase.ew
----------------------------------------------------------------------------
--this must be last include module since it utilizes classDefaults
include includes\ide_winstyles.ew    -- various window styles (Don Philips)
---------------------------------------------------------------------------
procedure translatePropertySheet()
    setHint(PropertyTitleBar, IDEText[727][1])
    setHint(UndockPropertyButton, IDEText[260][1])
    setText(Explore1, IDEText[261][1])
    setText(Explore2, IDEText[262][1])
    setText(Explore3, IDEText[263][1])
    setText(Explore4, IDEText[264][1])
    setText(Explore5, IDEText[973][1])
    setText(Explore6, IDEText[731][1])
    setText(Explore7, IDEText[50][1])
    setText(Explore8, IDEText[51][1])
    setText(Explore9, IDEText[52][1])
    setText(Explore10, IDEText[53][1])
    setText(Explore11, IDEText[1136][1])
    setText(Explore12, IDEText[1137][1])
    setText(PropertyTabItem, IDEText[965][1])
    setText(PropertyTabItem2, IDEText[966][1])
    setPropCaption(name, IDEText[265][1])
    setPropCaption(caption, IDEText[266][1])
    setPropCaption(showCap, IDEText[267][1])
    setPropCaption(titleWidth, IDEText[268][1])
    setPropCaption(propclass, IDEText[269][1])
    setPropCaption(row, IDEText[270][1])
    setPropCaption(col, IDEText[271][1])
    setPropCaption(width, IDEText[272][1])
    setPropCaption(height, IDEText[273][1])
    setPropCaption(suppressCell, IDEText[274][1])
    setPropCaption(toolHeight, IDEText[275][1])
    setPropCaption(alternatePos, IDEText[276][1])
    setPropCaption(outY, IDEText[277][1])
    setPropCaption(outX,IDEText[278][1])
    setPropCaption(outCX, IDEText[279][1])
    setPropCaption(outCY, IDEText[280][1])
    setPropCaption(controlComment, IDEText[281][1])
    setPropCaption(controlOrder, IDEText[282][1])
    setPropCaption(list, IDEText[283][1])
    setPropCaption(defindex, IDEText[284][1])
    setPropCaption(local, IDEText[285][1])
    setPropCaption(createWith, IDEText[286][1])
    setPropCaption(exStyle, IDEText[287][1])
    setPropCaption(extExStyle, IDEText[288][1])
    setPropCaption(style, IDEText[289][1])
    setPropCaption(styletype, IDEText[290][1])
    setPropCaption(ccWin, IDEText[291][1])
    setPropCaption(insystray, IDEText[292][1])
    setPropCaption(ccWinMain, IDEText[293][1])
    setPropCaption(winPos, IDEText[294][1])
    setPropCaption(winPosTaskBar, IDEText[295][1])
    setPropCaption(enable, IDEText[296][1])
    setPropCaption(visible, IDEText[297][1])
    setPropCaption(checked, IDEText[298][1])
    setPropCaption(alimitText, IDEText[299][1])
    setPropCaption(LvAddBottom, IDEText[300][1])
    setPropCaption(controlStyle, IDEText[301][1])
    setPropCaption(readOnly, IDEText[302][1])
    setPropCaption(upperCase, IDEText[303][1])
    setPropCaption(lowerCase, IDEText[304][1])
    setPropCaption(numeric, IDEText[305][1])
    setPropCaption(gridCellFormat, IDEText[306][1])
    setPropCaption(password, IDEText[307][1])
    setPropCaption(hScroll, IDEText[308][1])
    setPropCaption(multiline, IDEText[309][1])
    setPropCaption(clickable, IDEText[310][1])
    setPropCaption(minValue, IDEText[311][1])
    setPropCaption(maxValue, IDEText[312][1])
    setPropCaption(lineChg, IDEText[313][1])
    setPropCaption(pageChg, IDEText[314][1])
    setPropCaption(buddy, IDEText[315][1])
    setPropCaption(multSel, IDEText[316][1])
    setPropCaption(extSel, IDEText[317][1])
    setPropCaption(rbbsBreak, IDEText[318][1])
    setPropCaption(mcs_multiselect, IDEText[319][1])
    setPropCaption(pbs_smooth, IDEText[320][1])
    setPropCaption(bs_flat, IDEText[321][1])
    setPropCaption(otherFlags, IDEText[322][1])
    setPropCaption(gridFormat, IDEText[323][1])
    setPropCaption(parent, IDEText[324][1])
    setPropCaption(windowParent, IDEText[325][1])
    setPropCaption(color, IDEText[326][1])
    setPropCaption(defaultColor, IDEText[327][1])
    setPropCaption(iconFile, IDEText[328][1])
    setPropCaption(iconFileLV, IDEText[329][1])
    setPropCaption(defFile, IDEText[330][1])
    setPropCaption(hotFile, IDEText[331][1])
    setPropCaption(disFile, IDEText[332][1])
    setPropCaption(closeFile, IDEText[333][1])
    setPropCaption(openFile, IDEText[334][1])
    setPropCaption(bitmap, IDEText[335][1])
    setPropCaption(XPMFile, IDEText[336][1])
    setPropCaption(XPMMember, IDEText[337][1])
    setPropCaption(hintFont, IDEText[338][1])
    setPropCaption(hintFontName, IDEText[339][1])
    setPropCaption(hintFontPts, IDEText[340][1])
    setPropCaption(hintFontAttrib, IDEText[341][1])
    setPropCaption(hintFontBold, IDEText[342][1])
    setPropCaption(hintFontItalic, IDEText[343][1])
    setPropCaption(hintFontUnderline, IDEText[344][1])
    setPropCaption(hintFontStrike, IDEText[345][1])
    setPropCaption(hintText, IDEText[346][1])
    setPropCaption(font, IDEText[347][1])
    setPropCaption(fontName, IDEText[339][1])
    setPropCaption(fontPts, IDEText[340][1])
    setPropCaption(fontAttrib, IDEText[341][1])
    setPropCaption(fontBold, IDEText[342][1])
    setPropCaption(fontItalic, IDEText[343][1])
    setPropCaption(fontUnderline, IDEText[344][1])
    setPropCaption(fontStrike, IDEText[345][1])
    setPropCaption(fontColor, IDEText[326][1])
    setPropCaption(indexTo, IDEText[348][1])
    setPropCaption(gridHeaderInfo, IDEText[349][1])
    setPropCaption(gridHeaderColor, IDEText[326][1])
    setPropCaption(gridHeaderColHeight, IDEText[350][1])
    setPropCaption(gridHeaderRowWidth, IDEText[351][1])
    setPropCaption(gridHeaderDataCol, IDEText[352][1])
    setPropCaption(gridHeaderDataColVal, IDEText[353][1])
    setPropCaption(gridColors, IDEText[354][1])
    setPropCaption(gridCellBkColor, IDEText[355][1])
    setPropCaption(gridBkColorSelect, IDEText[356][1])
    setPropCaption(gridLineColor, IDEText[357][1])
    setPropCaption(gridTextColor, IDEText[358][1])
    setPropCaption(gridTextColorSelect, IDEText[359][1])
    setPropCaption(gridColTextColor, IDEText[360][1])
    setPropCaption(gridCellBorderColor, IDEText[361][1])
    setPropCaption(gridActiveHeaders, IDEText[362][1])
    setPropCaption(gridAllowColResize, IDEText[363][1])
    setPropCaption(gridAllowColSort, IDEText[364][1])
    setPropCaption(gridCellBorder, IDEText[365][1])
    setPropCaption(gridHighlightText, IDEText[366][1])
    setPropCaption(gridRowHeight, IDEText[367][1])
    setPropCaption(gridTextAlign, IDEText[368][1])
    setPropCaption(gridColAlign, IDEText[369][1])
    setPropCaption(gridRowSelect, IDEText[370][1])
    setPropCaption(gridColListDataCol, IDEText[371][1])
    setPropCaption(gridColListValues, IDEText[372][1])
    setPropCaption(gridDataArrayName, IDEText[373][1])
    setPropCaption(winOpenAtCtrl, IDEText[971][1])
    setPropCaption(transparency, IDEText[972][1])
    setPropCaption(noIntegralHeight, IDEText[975][1])
    setPropCaption(adjCenter, IDEText[981][1])
    setPropCaption(adjRight, IDEText[982][1])
    setPropCaption(classdef, IDEText[999][1])
    setPropCaption(txtColor, IDEText[360][1])
    setPropCaption(useInWinMain, IDEText[1023][1])
    setPropCaption(controlStyletype, IDEText[290][1])
    setPropCaption(proptableSpecs, IDEText[723][1])
    setPropCaption(valueEdit, IDEText[1033][1])
    setPropCaption(labelSide, IDEText[1037][1])
    setPropCaption(controllayer, IDEText[1047][1])
    setPropCaption(setLayerOK, IDEText[1048][1])
    setPropCaption(parentFrozen, IDEText[1044][1])
    setPropCaption(partners, IDEText[1051][1])
    setPropCaption(barColor, IDEText[1054][1])
    setPropCaption(pbCapPos, IDEText[1055][1])
    setPropCaption(xpmmer, IDEText[1091][1])
    setPropCaption(xpmmerObject, IDEText[1092][1])
    setPropCaption(xpmmerDisable, IDEText[1135][1])
    setPropCaption(xpmmerDisableObject, IDEText[1092][1])
    setText(PartnersText, IDEText[1052][1])
    setText(PartnersSave, IDEText[58][1])
    setText(PartnersCancel, IDEText[59][1])
    changePressButtonText(IDEText[1093][1])
    setPropCaption(showHintFontVar, IDEText[1124][1])
    setPropCaption(showFontVar, IDEText[1124][1])
    setPropCaption(varhintFontName, IDEText[1125][1])
    setPropCaption(varhintFontPts, IDEText[1125][1])
    setPropCaption(varhintFontItalic, IDEText[1125][1])
    setPropCaption(varhintFontBold, IDEText[1125][1])
    setPropCaption(varhintFontUnderline, IDEText[1125][1])
    setPropCaption(varhintFontStrike, IDEText[1125][1])
    setPropCaption(varfontName, IDEText[1125][1])
    setPropCaption(varfontPts, IDEText[1125][1])
    setPropCaption(varfontItalic, IDEText[1125][1])
    setPropCaption(varfontBold, IDEText[1125][1])
    setPropCaption(varfontUnderline, IDEText[1125][1])
    setPropCaption(varfontStrike, IDEText[1125][1])
    setPropCaption(varhintText, IDEText[1125][1])
    setPropCaption(fontColor, IDEText[1125][1])
    setPropCaption(upDownLeft, IDEText[1138][1])
    setPropCaption(upDownHorz, IDEText[1139][1])
    setPropCaption(tabsBottom, IDEText[1140][1])
    setPropCaption(treatAsColorButton,IDEText[1162][1])
    setPropCaption(cbcolor, IDEText[1150][1])
    setPropCaption(cbcaptioncolor, IDEText[1151][1])
    setPropCaption(cbthickness, IDEText[1152][1])
    setPropCaption(cbpresscolor, IDEText[1153][1])
    setPropCaption(cbpresscaptioncolor, IDEText[1154][1])
    setPropCaption(cbcaptionpos, IDEText[1155][1])
    setPropCaption(cbgraphicpos, IDEText[1156][1])
    setPropCaption(cbmultiline, IDEText[309][1])
    setPropCaption(cbflat, IDEText[321][1])
    setPropCaption(cbcentvert, IDEText[1163][1])
    setPropCaption(setcreatefont, IDEText[1198][1])
    setPropCaption(mc_background, IDEText[1200][1])
    setPropCaption(mc_text, IDEText[1201][1])
    setPropCaption(mc_titleBK, IDEText[1202][1])
    setPropCaption(mc_titleText, IDEText[1203][1])
    setPropCaption(mc_monthBK, IDEText[1204][1])
    setPropCaption(mc_trailingText, IDEText[1205][1])

    redrawProperties(1)
end procedure
---------------------------------------------------------------------------
procedure translateProjectView()

    setHint(UndockButton, IDEText[260][1])
    changeTreeViewText(getTVText(1),IDEText[967][1])
    changeTreeViewText(getTVText(2),IDEText[968][1])
    changeTreeViewText(getTVText(3),IDEText[969][1])

    for i=1 to length(itemtext) do
        if equal(itemtext[i],getTVText(1)) then
            itemtext[i] = IDEText[967][1]
        end if
        if equal(itemtext[i],getTVText(2)) then
            itemtext[i] = IDEText[968][1]
        end if
        if equal(itemtext[i],getTVText(3)) then
            itemtext[i] = IDEText[969][1]
        end if
    end for
end procedure
----------------------------------------------------------------------------
procedure translateIconBar()
    setText(ToolboxTabItem, IDEText[221][1])
    setText(ToolboxTabItem2, IDEText[222][1])
    setText(ToolboxTabItem3, IDEText[223][1])
    setText(ToolboxTabItem4, IDEText[224][1])
    setText(ToolboxTabItem5, IDEText[225][1])
--    setText(ToolboxTabItem6, IDEText[1199][1])
    setHint(ThePushButton, IDEText[226][1])
    setHint(TheColoredButton, IDEText[1149][1])
    setHint(TheCheckBox, IDEText[227][1])
    setHint(TheRadio, IDEText[228][1])
    setHint(TheTabControl, IDEText[229][1])
    setHint(TheTabItem, IDEText[230][1])
    setHint(TheGroup, IDEText[231][1])
    setHint(TheToolBar, IDEText[232][1])
    setHint(TheNone, IDEText[233][1])
    setHint(TheLText, IDEText[234][1])
    setHint(TheStatusBar, IDEText[235][1])
    setHint(TheMenu, IDEText[236][1])
    setHint(ThePopup, IDEText[237][1])
    setHint(TheBitmap, IDEText[238][1])
    setHint(TheIcon, IDEText[239][1])
    setHint(TheProgress, IDEText[240][1])
    setHint(TheHScroll, IDEText[241][1])
    setHint(TheVScroll, IDEText[242][1])
    setHint(TheCalendar, IDEText[243][1])
    setHint(TheRichEdit, IDEText[244][1])
    setHint(TheMle, IDEText[245][1])
    setHint(TheEditText, IDEText[246][1])
    setHint(TheLabelEdit, IDEText[1208][1])
    setHint(TheCombo, IDEText[247][1])
    setHint(TheList, IDEText[248][1])
    setHint(TheUpDown, IDEText[249][1])
    setHint(TheTreeView, IDEText[250][1])
    setHint(TheListView, IDEText[251][1])
    setHint(TheTable, IDEText[252][1])
    setHint(TheEuGrid, IDEText[253][1])
    setHint(TheFlatBar, IDEText[254][1])
    setHint(TheSepButton, IDEText[255][1])
    setHint(TheReBar, IDEText[256][1])
    setHint(TheReBarBand, IDEText[257][1])
    setHint(TheTimer, IDEText[258][1])
    setHint(TheChildWindow, IDEText[259][1])
    setHint(ToolboxUndockButton, IDEText[260][1])
end procedure
-----------------------------------------------------------------------------
procedure popupSomeWinStyles(integer Self, integer Event, sequence Params)
    createWinStyles()
    openWindow(WinStyles, Normal)
end procedure
setHandler(MenuWinStyles,w32HClick, routine_id("popupSomeWinStyles"))
------------------------------------------------------------------------------
procedure popupSomeListViewStyles(integer Self, integer Event, sequence Params)
sequence info
    info = getControlInfo(ListViewWin, {CONTROLINFO_closed})
    if length(info)
    and not info[1] then
        -- is open 
        return
    end if
    createListViewWindow()
    openWindow(ListViewWin, Normal)
end procedure
setHandler(MenuListViewStyles, w32HClick, routine_id("popupSomeListViewStyles"))
--------------------------------------------------------------------------------        
                                                                                        --"Manage Template Data"
constant TemplateWindow = createEx(Window, IDEText[125][1], 0, Default, Default, 563, 290, {WS_DLGFRAME}, 0)
constant TemplateName = createEx(SortedList, "", TemplateWindow, 12, 8, 536, 120, LBS_USETABSTOPS, 0)
                                                                --"Template Name:"
constant LText5 = createEx(LText, IDEText[126][1], TemplateWindow, 12, 136, 116, 20, 0, 0)
constant EnterName = createEx(EditText, "", TemplateWindow, 136, 132, 328, 20, 0, 0)
                                                                --"Data:"
constant LText7 = createEx(LText, IDEText[127][1], TemplateWindow, 12, 168, 120, 20, 0, 0)
constant EnterData = createEx(EditText, "", TemplateWindow, 136, 160, 328, 20, 0, 0)
                                                                                --"Add"
constant AddButton = createEx(PushButton, IDEText[497][1], TemplateWindow, 472, 132, 76, 28, 0, 0)
                                                                                --"Change"
constant ChgButton = createEx(PushButton, IDEText[501][1], TemplateWindow, 472, 160, 76, 28, 0, 0)
                                                                                --"Remove"
constant DelButton = createEx(PushButton, IDEText[498][1], TemplateWindow, 472, 188, 76, 28, 0, 0)
                                                                                        --"Save"
constant SaveButton = createEx(PushButton, IDEText[58][1], TemplateWindow, 80, 216, 88, 28, 0, 0)
                                                                                        --Close
constant CancelButton = createEx(PushButton, IDEText[59][1], TemplateWindow, 360, 216, 88, 28, 0, 0)
---------------------------------------------------------
integer firstPortion
        firstPortion = 150

--------------------------------------------------------------------------------
procedure TemplateWindow_onOpen(integer self, integer event, sequence params)
    setTabs(TemplateName, {firstPortion})
    eraseItems(TemplateName)
    --read in data
    for i=1 to length(theStyles) do
        addItem(TemplateName, theStyles[i])
    end for
    openWindow(TemplateWindow, Modal)
end procedure
setHandler(MenuRegisterStyles, w32HClick, routine_id("TemplateWindow_onOpen"))
--------------------------------------------------------------------------------
procedure TemplateName_onClick(integer self, integer event, sequence params)
sequence item,item1,item2
integer at
    --move first portion to name and second to data
    item = getItem(TemplateName,getIndex(TemplateName))
    at = find('\t',item)
    if at then
        item1 = item[1..at-1]
        setText(EnterName,item1)
        setEnable(EnterName, w32False)
        item2 = item[at+1..length(item)]
        setText(EnterData, item2)
    end if
end procedure
setHandler(TemplateName, w32HClick, routine_id("TemplateName_onClick"))
--------------------------------------------------------------------------------
procedure AddButton_onClick(integer self, integer event, sequence params)
sequence newdata, checkname
integer at
    --dont add empty Name
    if not length(getText(EnterName)) then
        return
    end if
    --make sure the name is unique
    for i=1 to getCount(TemplateName) do
        checkname = getItem(TemplateName, i)
        at = find('\t',checkname)
        if at then
            checkname = checkname[1..at-1]
        end if

        if equal(getText(EnterName),checkname) then
            return
        end if
    end for

    newdata = getText(EnterName) & "\t" & getText(EnterData)
    addItem(TemplateName, newdata)
    setText(EnterName,"")
    setText(EnterData,"")
end procedure
setHandler(AddButton, w32HClick, routine_id("AddButton_onClick"))
--------------------------------------------------------------------------------
procedure ChgButton_onClick(integer self, integer event, sequence params)
integer ok,index
sequence data
    --dont change empty Name
    if not length(getText(EnterName)) then
        return
    end if
    data = getText(EnterName) & "\t" & getText(EnterData)
    index = getIndex(TemplateName)
    if not index then
        return
    end if
    ok = deleteItem(TemplateName, index)
    ok = insertItem(TemplateName, data, index)
    setEnable(EnterName, w32True)
    setText(EnterName,"")
    setText(EnterData,"")
end procedure
setHandler(ChgButton, w32HClick, routine_id("ChgButton_onClick"))
--------------------------------------------------------------------------------
procedure DelButton_onClick(integer self, integer event, sequence params)
integer index, ok
    index = getIndex(TemplateName)
    if not index then
        return
    end if
    ok = deleteItem(TemplateName, index)
    setEnable(EnterName, w32True)
    setText(EnterName, "")
    setText(EnterData,"")
end procedure
setHandler(DelButton, w32HClick, routine_id("DelButton_onClick"))
--------------------------------------------------------------------------------
procedure SaveButton_onClick(integer self, integer event, sequence params)
    --add to theStyle
    theStyles = {}
    for i=1 to getCount(TemplateName) do
        theStyles &= {getItem(TemplateName,i)}
    end for
    --move to settingsBuffer
    settingsBuffer[cfgRegisterStyle][2] = theStyles
    closeWindow(TemplateWindow)
end procedure
setHandler(SaveButton, w32HClick, routine_id("SaveButton_onClick"))
--------------------------------------------------------------------------------
procedure CancelButton_onClick(integer self, integer event, sequence params)
    closeWindow(TemplateWindow)
end procedure
setHandler(CancelButton, w32HClick, routine_id("CancelButton_onClick"))
-------------------------------------------------------------------------------
integer SelectStyles,SelectStyleHelp,SelectStyleText,SelectStylesList,
        StylesOkButton,StylesCancelButton,SelectControlText,SelectedProp
--------------------------------------------------------------------------------
procedure SelectStyles_onOpen(integer self, integer event, sequence params)

    setText(SelectControlText,controls[selectedControl][Name])
    setText(SelectedProp, selectedProp)

    eraseItems(SelectStylesList)
    --add registered styles
    for i=1 to length(theStyles) do
        addItem(SelectStylesList,theStyles[i])
    end for
end procedure
--------------------------------------------------------------------------------
procedure StylesOkButton_onClick(integer self, integer event, sequence params)
sequence items,theParam,itemkey, itemdata
integer at

    theParam = {}

    items = getMultItems(SelectStylesList)

    --save in other styles property
    if propertyPopupCell=style
    or propertyPopupCell=otherFlags then
        if sequence(controls[selectedControl][Style]) then
            theParam = controls[selectedControl][Style]
        else
            theParam = {}
        end if
    elsif propertyPopupCell=exStyle then
        if sequence(controls[selectedControl][ExStyle]) then
            theParam = controls[selectedControl][ExStyle]
        else
            theParam = {}
        end if
        if equal(theParam,"0") then
            theParam = {}
        end if
    elsif propertyPopupCell=classdef then
        if sequence(controls[selectedControl][ClassDefaults]) then
            theParam = controls[selectedControl][ClassDefaults]
        else
            theParam = {}
        end if
    elsif propertyPopupCell=ccWin then
        if sequence(controls[selectedControl][CCWinStyle]) then
            theParam = controls[selectedControl][CCWinStyle]
        else
            theParam = {}
        end if
    end if

    for i=1 to length(items) do
        itemdata = {}
        at = find('\t',items[i])
        if at then
            itemkey = items[i][1..at-1]
            itemdata = items[i][at+1..length(items[i])]
            if not length(itemdata) then
                itemdata = itemkey
            end if
        else
            itemdata = items[i]
        end if

        if length(theParam) then
            theParam &= "," & itemdata
        else
            theParam &= itemdata
        end if
    end for

    if length(theParam) then
        if equal(getText(SelectedProp), "Style")
        or equal(getText(SelectedProp), "Other Flags") then
            controls[selectedControl][Style] = theParam
            call_proc(updateProperties_id,{})
        end if
        if equal(getText(SelectedProp),"ExStyle") then
            controls[selectedControl][ExStyle] = theParam
            call_proc(updateProperties_id,{})
        end if
        if equal(getText(SelectedProp),"ClassDef") then
            controls[selectedControl][ClassDefaults] = theParam
            call_proc(updateProperties_id,{})
        end if
        if equal(getText(SelectedProp),"CCWin") then
            controls[selectedControl][CCWinStyle] = theParam
            call_proc(updateProperties_id,{})
        end if
    end if
    closeWindow(SelectStyles)

end procedure
--------------------------------------------------------------------------------
procedure StylesCancelButton_onClick(integer self, integer event, sequence params)
    closeWindow(SelectStyles)
    call_proc(updateProperties_id,{})
end procedure
---------------------------------------------------------------------------------
procedure createSelectStylesWindow()
                                       --"Select Property Template For A Control"
    SelectStyles = createEx(Window, IDEText[731][1], Form, Default, Default, 600, 365, {WS_DLGFRAME}, 0)
    SelectStyleHelp = createEx(LText, "", SelectStyles, 0, 0, 550, 64, 0, 0)
                                         --"Selected Control:"
    SelectStyleText = createEx(LText, IDEText[732][1], SelectStyles, 8, 72, 148, 20, 0, 0)
    SelectControlText = createEx(EditText, "", SelectStyles, 8, 92, 256, 20, w32or_all({ES_READONLY}), 0)
    SelectedProp = createEx(LText, "", SelectStyles, 300, 92, 156, 20, 0, 0)

    SelectStylesList = createEx(List, "", SelectStyles, 8, 128, 550, 124, w32or_all({LBS_MULTIPLESEL,LBS_EXTENDEDSEL,LBS_USETABSTOPS,LBS_NOINTEGRALHEIGHT}), 0)
                                             --"OK"
    StylesOkButton = createEx(PushButton, IDEText[733][1], SelectStyles, 12, 264, 88, 28, 0, 0)
                                                 --"Cancel"
    StylesCancelButton = createEx(PushButton, IDEText[734][1], SelectStyles, 176, 264, 88, 28, 0, 0)

    setHandler(StylesCancelButton, w32HClick, routine_id("StylesCancelButton_onClick"))
    setHandler(StylesOkButton, w32HClick, routine_id("StylesOkButton_onClick"))
    setHandler(SelectStyles, w32HOpen, routine_id("SelectStyles_onOpen"))

    setText(SelectStyleHelp, IDEText[735][1])

    openWindow(SelectStyles, Normal)
end procedure
-------------------------------------------------------------------------------
procedure popupSomeSelectStyles(integer Self, integer Event, sequence Params)
    createSelectStylesWindow()
end procedure
setHandler(MenuSelectStyles, w32HClick, routine_id("popupSomeSelectStyles"))
--------------------------------------------------------------------------------
procedure checkOtherWindows()
sequence info

    FileTypes           = {IDEText[728][1],"*." & projectFileType}
    IcoFileTypes        = {IDEText[729][1], "*.ICO"}
    OpenFileModules     = {IDEText[730][1],"*.E;*.EW"}

    --check to see if Properties, ToolBox, Code Editor are open before translating
    info = getControlInfo(PropertySheet, {CONTROLINFO_closed})
    if not info[1] then
        -- Propeties open so translate
        translatePropertySheet()
    end if

    info = getControlInfo(IconBar, {CONTROLINFO_closed})
    if not info[1] then
        -- Tool Box open so translate
        translateIconBar()
    end if

    info = getControlInfo(CodeWin, {CONTROLINFO_closed})
    if not info[1] then
        -- CodeWin open so translate
        translateCodeWin()
    end if

    info = getControlInfo(ProjectWindow, {CONTROLINFO_closed})
    if not info[1] then
        -- Project View open so translate
        translateProjectView()
    end if

    translateLauncher()
    translateCodeBase()

    setText(TemplateWindow, IDEText[125][1])
    setText(LText5, IDEText[126][1])
    setText(LText7, IDEText[127][1])
    setText(AddButton, IDEText[497][1])
    setText(ChgButton, IDEText[501][1])
    setText(DelButton, IDEText[498][1])
    setText(SaveButton, IDEText[58][1])
    setText(CancelButton, IDEText[59][1])

    if validId(TempWindow) then
        setText(TempWindow, IDEText[753][1])
        setText(TempMenu, IDEText[754][1])
        setText(TempRunMenu, IDEText[754][1])
        setText(TempRunSave, IDEText[756][1])
        setText(TempRulesSave, IDEText[756][1])
        setText(TempText1, IDEText[758][1])
        setText(TempCloseBut, IDEText[759][1])
        setText(TempGroup1, IDEText[760][1])
        setText(TempRadioReplace, IDEText[761][1])
        setText(TempRadioStop, IDEText[762][1])
        setText(TempRadioAsk, IDEText[763][1])
        setText(TempGroup2, IDEText[764][1])
        setText(TempRadioKeepBad, IDEText[765][1])
        setText(TempRadioKeepGood, IDEText[766][1])
        setText(TempRadioKeepAlways, IDEText[767][1])
        setText(TempRadioKeepNever, IDEText[768][1])
    end if

    translateIconEditor()
end procedure
checkOtherWindows_id = routine_id("checkOtherWindows")
-------------------------------------------------------------------------------
procedure pickWindowFromProject(integer m)
    pickWindow(m)
end procedure
PickWindowId = routine_id("pickWindowFromProject")
-----------------------------------------------------------------------------
procedure changeCodeFromProject()

    if length(isModule)
    and editorChanged then
        ok = invokeHandler(MenuCodeClose, w32HClick, {})
    end if

    showWindow(CodeWin,SW_HIDE)
    setIndex(CodeControls, selectedControl)
    ok = invokeHandler(CodeControls,w32HClick,{})

    moduleX = 0
    moduleY = 0
    moduleTop = 0
    for i=1 to length(openModuleAt) do
        if equal(getItem(CodeModules,getIndex(CodeModules)), openModuleAt[i][1]) then
            moduleX = openModuleAt[i][2]
            moduleY = openModuleAt[i][3]
            moduleTop = openModuleAt[i][4]
            exit
        end if
    end for

    flushControls()

end procedure
onChangeCodeFromProject_id = routine_id("changeCodeFromProject")
-----------------------------------------------------------------------------
procedure findCorrectParent()
integer inList, at, useIt

    inList = w32False

    --find all controls selected control is inside that are in layer 0 and same layer as selected control
    parentList = {}

    for i=1 to length(controls) do
--DEV??
--      if not equal(controls[i][Name],controls[selectedControl][Name])--can't parent itself    	   		    	                
--      and (inside2( controls[i], controls[selectedControl][X], controls[selectedControl][Y])
--      and (not controls[i][ControlLayer]    
--      or controls[i][ControlLayer]=controls[selectedControl][ControlLayer])        
--      or controls[i][X]=controls[selectedControl][X]  
--      or controls[i][Y]=controls[selectedControl][Y]) 
--      and not find(controls[i][ParentClass], {"ToolBar","FlatToolBar"}) then
        if not equal(controls[i][Name],controls[selectedControl][Name])--can't parent itself    	   		    	                
        and (inside2(controls[i], controls[selectedControl][X], controls[selectedControl][Y])
             and ((not controls[i][ControlLayer]
                   or controls[i][ControlLayer]=controls[selectedControl][ControlLayer])
                  or controls[i][X]=controls[selectedControl][X]
                  or controls[i][Y]=controls[selectedControl][Y]) )
        and not find(controls[i][ParentClass], {"ToolBar","FlatToolBar"}) then
            if equal(controls[i][Class],"TabControl") then
                if equal(controls[selectedControl][Class], "TabItem") then
                    parentList &= {controls[i][Name]}
                end if
            elsif equal(controls[i][Class],"TabItem") then
                if equal(controls[i][Name],selectedTabItem) then
                    parentList &= {controls[i][Name]}
                end if
            else
                useIt = w32True
                --check where selectedControl is in possible parent
                if controls[selectedControl][X]=controls[i][X]
                or controls[selectedControl][Y]=controls[i][Y] then
                    useIt = w32False
--DEV??
--                              if controls[selectedControl][X] > controls[i][X]
--                                      and controls[selectedControl][X] < controls[i][X]+controls[i][CX]
--                              or controls[selectedControl][Y] > controls[i][Y]
--                                      and controls[selectedControl][Y] < controls[i][Y]+controls[i][CY] then
                    if (controls[selectedControl][X]>controls[i][X]
                        and controls[selectedControl][X]<controls[i][X]+controls[i][CX])
                    or (controls[selectedControl][Y]>controls[i][Y]
                        and controls[selectedControl][Y]<controls[i][Y]+controls[i][CY]) then
                        useIt = w32True
                    end if
                end if
                if useIt then
                    parentList &= {controls[i][Name]}
                end if

                if equal(controls[i][Name],controls[selectedControl][SeqParentName]) then
                    inList = w32True
                    parentList = {controls[1][Name]}
                    parentList &= {controls[i][Name]}
                end if
            end if
        end if
    end for
    if inList then
        if find(controls[selectedControl][Class], {"TabItem","ReBarBand"})
        or find(controls[selectedControl][SeqParentClass], {"EuGrid","Table"}) then
            parentList = {controls[selectedControl][SeqParentName]}
        end if
    end if

    at = find(controls[selectedControl][SeqParentName], parentList)
    if at then
        setPropertyCombo(parent, at, parentList)
    else
        setPropertyCombo(parent, 1, parentList)
    end if
end procedure
------------------------------------------------------------------------------
global procedure updateProperty(sequence property)
-- Martin Stachon : update selected property
-- (just took code form UpdateProperties)
-- note using setProperty() instead of addProperty()

sequence defaultType, validLayerParents, textLen, testFontName, propertyText
integer at,testFontAttrib,testFontBold,testFontUnderline,testFontStrikeout,testFontPts

    validLayerParents = {}

    if equal(property, "Name") then
        property = "(Name)"
    end if

    if equal(property, "Caption") then
        setProperty(caption, controls[selectedControl][Title])
        setControlFont()
        if equal(controls[selectedControl][Class], "LabelEdit") then
            if length(controls[selectedControl][FontName]) then
                testFontName = controls[selectedControl][FontName]
                testFontBold = controls[selectedControl][FontBold]
                testFontUnderline = controls[selectedControl][FontUnderline]
                testFontStrikeout = controls[selectedControl][FontStrikeout]
                testFontPts = controls[selectedControl][FontPts]
                testFontAttrib = 0
                if testFontAttrib then
                    testFontAttrib = Italic
                end if
                if testFontBold then
                    testFontAttrib += testFontBold
                end if
                if testFontUnderline then
                    testFontAttrib += 4
                end if
                if testFontStrikeout then
                    testFontAttrib += 8
                end if
                setFont(controls[selectedControl][Name], testFontName, testFontPts, testFontAttrib)
            end if
            textLen = getTextExtent(selectedControl, controls[selectedControl][Title])
            controls[selectedControl][LabelExtent] = snap(textLen[1])
        end if
    end if

    if equal(property,"Class") then
        for i=1 to length(ClassName) do
            at = find(controls[selectedControl][Class], ClassName[i])
            if at then
                setPropertyCombo(propclass, at, ClassName[i])
                exit
            end if
        end for

        if equal(controls[selectedControl][SeqParentClass], "FlatToolBar")
        and equal(controls[selectedControl][Class], "PictureButton") then
            showProperty(defFile, w32True)
            IcoFileName = controls[selectedControl][IcoFile]
            setProperty(defFile, IcoFileName)
            showProperty(hotFile, w32True)
            IcoFileName = controls[selectedControl][TwoIcoFile]
            setProperty(hotFile, IcoFileName)
            showProperty(disFile, w32True)
            IcoFileName = controls[selectedControl][TriIcoFile]
            setProperty(disFile, IcoFileName)
            redrawProperties(1)     --allows me to display showPropety fields that were not showing before          
        end if

        if find(controls[selectedControl][Class], {"PictureButton","TogglePicture"})
        and not equal(controls[selectedControl][SeqParentClass], "FlatToolBar") then
            showProperty(bitmap, w32True)
            showProperty(XPMFile, w32True)
            showProperty(XPMMember, w32True)
            setPropEnabled(XPMMember, w32False)
            setProperty(bitmap,"")
            setProperty(XPMFile,"")
            redrawProperties(1)     --allows me to display showPropety fields that were not showing before          
        end if
    end if

    if equal(controls[selectedControl][Class], "LabelEdit") then
        setProperty(valueEdit, controls[selectedControl][ValueEdit])
    end if

    --there are cases where updating Height also so updates Width
    if equal(property, "Height") then
        if find(controls[selectedControl][Class],
                {"MonthCalendar", "StatusBar", "SepButton"})  then
            setProperty(width, sprintf("%d",controls[selectedControl][CX]))
            setPropEnabled(width, w32False)
        else
            setProperty(width, sprintf("%d",controls[selectedControl][CX]))
            setPropEnabled(width, w32True)
        end if

        if find(controls[selectedControl][Class],
                {"MonthCalendar", "StatusBar", "SepButton"})  then
            setProperty(height, sprintf("%d",controls[selectedControl][CY]))
            setPropEnabled(height, w32False)
        else
            if find(controls[selectedControl][Class], {"ReBar", "ReBarBand"}) then
                setProperty(height, sprintf("%d",controls[selectedControl][CY]))
                setPropEnabled(height, w32False)
            else
                setProperty(height, sprintf("%d",controls[selectedControl][CY]))
                setPropEnabled(height, w32True)
            end if
        end if
    end if

    if equal(property, "Width") then
        if find(controls[selectedControl][Class],
                {"MonthCalendar", "StatusBar", "SepButton"})  then
            setProperty(width, sprintf("%d",controls[selectedControl][CX]))
            setPropEnabled(width, w32False)
        elsif find(controls[selectedControl][Class], {"ReBar", "ReBarBand"}) then
            setProperty(width, sprintf("%d",controls[selectedControl][CX]))
            setPropEnabled(width, w32False)
        else
            setProperty(width, sprintf("%d",controls[selectedControl][CX]))
            setPropEnabled(width, w32True)
        end if
    end if

    --there are cases where updating Column also updates Row
    if equal(property, "Column") then
--DEV???
--      if find( controls[selectedControl][Class],
--          { "ToolBar", "StatusBar","FlatToolBar" } )
--      and not length( controls[selectedControl][ControlParent] )
--      or find( controls[selectedControl][Class], {"ReBar","ReBarBand"} ) then
        if find(controls[selectedControl][Class],
                {"ToolBar", "StatusBar","FlatToolBar"})
        and (not length(controls[selectedControl][ControlParent])
             or find(controls[selectedControl][Class], {"ReBar","ReBarBand"})) then
            setProperty(col, sprintf("%d",controls[selectedControl][X]))
            setPropEnabled(col, w32False)
        else
            if not controls[selectedControl][DefaultXY]
            and selectedControl=TheWindow then
                -- w32False/w32True is backwards so do not have to convert all existing
                -- PRj files
                setProperty(col, "Default")
                setPropEnabled(col, w32True)
            else
                setProperty(col, sprintf("%d",controls[selectedControl][X]))
                setPropEnabled(col, w32True)
            end if
        end if
--DEV???
--      if find( controls[selectedControl][Class],
--          { "ToolBar", "StatusBar","FlatToolBar" } )
--      and not length( controls[selectedControl][ControlParent])
--      or find( controls[selectedControl][Class], {"ReBar","ReBarBand"} ) then
        if find(controls[selectedControl][Class],
                {"ToolBar", "StatusBar","FlatToolBar"})
        and (not length(controls[selectedControl][ControlParent])
             or find(controls[selectedControl][Class], {"ReBar","ReBarBand"})) then
            setProperty(row, sprintf("%d",controls[selectedControl][Y]))
            setPropEnabled(row, w32False)
        else
            if not controls[selectedControl][DefaultXY]
            and selectedControl=TheWindow then
                -- w32False/w32True is backwards so do not have to convert all existing
                -- PRj files
                setProperty(row, "Default")
                setPropEnabled(row, w32True)
            else
                setProperty(row, sprintf("%d",controls[selectedControl][Y]))
                setPropEnabled(row, w32True)
            end if
        end if
    end if

    if equal(property, "Row") then
--DEV???
--      if find( controls[selectedControl][Class],
--          { "ToolBar", "StatusBar","FlatToolBar" } )
--      and not length( controls[selectedControl][SeqParentName])
--      or find( controls[selectedControl][Class], {"ReBar","ReBarBand"} ) then
        if find(controls[selectedControl][Class],
                {"ToolBar", "StatusBar","FlatToolBar"})
        and (not length(controls[selectedControl][SeqParentName])
             or find(controls[selectedControl][Class], {"ReBar","ReBarBand"})) then
            setProperty(row, sprintf("%d",controls[selectedControl][Y]))
            setPropEnabled(row, w32False)
        else
            setPropEnabled(row, w32True)
            if not controls[selectedControl][DefaultXY]
            and selectedControl=TheWindow then
                -- w32False/w32True is backwards so do not have to convert all existing
                -- PRj files
                setProperty(row, "Default")
            else
                setProperty(row, sprintf("%d", controls[selectedControl][Y]))
            end if
        end if
    end if

    if equal(property, "(Name)") then
        setProperty(name, controls[selectedControl][Name])
    end if

    if equal(property, "Control Order") then
        if not find(controls[selectedControl][Class], {"Window","ToolBar",
                                                       "StatusBar","FlatToolBar","ReBar","ReBarBand"}) then
            setProperty(controlOrder, sprintf("%d",controls[selectedControl][TabOrder]))
            setPropEnabled(controlOrder, w32True)
        end if
    end if

    if equal(property, "Style") then
        if equal(controls[selectedControl][Class], "Window") then

            if atom(controls[selectedControl][Style]) then
                setProperty(style, "0")
            else
                setProperty(style, controls[selectedControl][Style])
            end if
            setPropEnabled(style, w32True)
            if length(controls[selectedControl][StyleType]) then
                at = find(controls[selectedControl][StyleType], defaultList)
                if not at then
                    setProperty(styletype, " ")
                else
                    setPropertyCombo(styletype, at, defaultList)
                end if
            else
                if atom(controls[selectedControl][Style]) then
                    setProperty(styletype, " ")
                else
                    if equal(controls[selectedControl][Style], "0") then
                        setProperty(styletype, " ")
                    else
                        if equal(controls[selectedControl][Class], "Window") then
                            defaultType = "{...}"
                            at = 2
                            setPropertyCombo(styletype, at, defaultList)
                            controls[selectedControl][StyleType] = "{...}"
                        else
                            defaultType = "w32or_all({...})"
                            at = 1
                            setPropertyCombo(styletype, at, defaultList)
                            controls[selectedControl][StyleType] = "w32or_all({...})"
                        end if
                    end if
                end if
            end if
        end if
    end if

    if equal(property, "Back Color") then
        if not find(controls[selectedControl][Class], {"ToolBar",
                                                       "PushButton","ToggleButton","DefPushButton",
                                                       "TogglePicture","PictureButton",
                                                       "MonthCalendar","TabControl","TabItem",
                                                       "FlatToolBar","SepButton","ReBar","ReBarBand","None",
                                                       "Bitmap","UpDown","Combo","SimpleCombo",
                                                       "SortedCombo","ComboBoxEx","ListView"}) then
            if selectedControl=TheWindow then
                setProperty(color, sprintf("%d",controls[selectedControl][BkColor]))
            else
                --setProperty( colorNotWindow, sprintf("%d",controls[selectedControl][BkColor]))
                setProperty(color, sprintf("%d",controls[selectedControl][BkColor]))
                if equal(controls[selectedControl][Class],"ProgressBar") then
                    setProperty(barColor, sprintf("%d",controls[selectedControl][BkBarColor]))
                end if
            end if
        end if
    end if

    if equal(property, "RBBS_BREAK") then
        if controls[selectedControl][RBBSBREAK] then
            setProperty(rbbsBreak, w32True)
        else
            setProperty(rbbsBreak, w32False)
        end if
    end if

    if equal(property, "Frozen") then
        setProperty(parentFrozen, controls[selectedControl][ParentIsFrozen])
    end if


    if equal(property, "Parent") then
        findCorrectParent()
    end if

    if equal(property, "Trans") then
        setProperty(transparency,sprintf("%d",controls[selectedControl][WinTransparency]))
    end if

    if equal(property, "UpDownLeft") then
        --find UDS_ALIGNRIGHT and replace with UDS_ALIGNLEFT if true and visa versa if false
        propertyText = getProperty(otherFlags)
        if controls[selectedControl][UpDownLeft] then
            at = match("UDS_ALIGNRIGHT",propertyText)
            if at then
                propertyText = propertyText[1..at-1] & "UDS_ALIGNLEFT" &
                               propertyText[at+14..length(propertyText)]
            else
                propertyText = "UDS_ALIGNLEFT," & propertyText[1..length(propertyText)]
            end if
        else
            at = match("UDS_ALIGNLEFT",propertyText)
            if at then
                propertyText = propertyText[1..at-1] & "UDS_ALIGNRIGHT" &
                               propertyText[at+13..length(propertyText)]
            else
                propertyText = "UDS_ALIGNRIGHT," & propertyText[1..length(propertyText)]
            end if
        end if
        if propertyText[length(propertyText)]=',' then
            propertyText = propertyText[1..length(propertyText)-1]
        end if
        setProperty(otherFlags, propertyText)
        controls[selectedControl][Style] = propertyText
    end if

    if equal(property, "UpDownHorz") then
        --add or remove UDS_HORZ to other Flags 
        propertyText = getProperty(otherFlags)
        if controls[selectedControl][UpDownHorz] then
            at = match("UDS_HORZ",propertyText)
            if not at then
                propertyText = "UDS_HORZ," & propertyText[1..length(propertyText)]
            end if
        else
            at = match("UDS_HORZ",propertyText)
            if at then
                propertyText = propertyText[1..at-1] &
                               propertyText[at+9..length(propertyText)]
            end if
        end if
        if propertyText[length(propertyText)]=',' then
            propertyText = propertyText[1..length(propertyText)-1]
        end if
        setProperty(otherFlags, propertyText)
        controls[selectedControl][Style] = propertyText
    end if

    if equal(property, "XpmObject") then
        if length(controls[selectedControl][XpmObject]) then
            setProperty(xpmmerObject, controls[selectedControl][Name] & "_xpm")
            setPropEnabled(xpmmerObject, w32True)
        else
            setProperty(xpmmerObject, "")
            setPropEnabled(xpmmerObject, w32False)
        end if
        controlResourceBack = controlResource
        --remove any existing resource for control
        deleteResource(controls[selectedControl][Name],
                       controls[selectedControl][Name] & "_xpm")
        --add new resource for control                
        addResource(controls[selectedControl][Name],
                    controls[selectedControl][XpmObject],"XpmObject",controls[selectedControl][Name] & "_xpm")
        endChanges(xpmmerObject)
        downButton = 13
        drawControl(ControlBlit, controls[selectedControl], Normal, selectedControl, 0)
        drawControl(ControlBlit, controls[selectedControl], Selected, selectedControl, 0)
        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if equal(property, "XpmDisableObject") then
        if length(controls[selectedControl][XpmDisableObject]) then
            setProperty(xpmmerDisableObject, controls[selectedControl][Name] & "D_xpm")
            setPropEnabled(xpmmerDisableObject, w32True)
        else
            setProperty(xpmmerDisableObject, "")
            setPropEnabled(xpmmerDisableObject, w32False)
        end if
        controlResourceBack = controlResource
        --remove any existing resource for control
        deleteResource(controls[selectedControl][Name],
                       controls[selectedControl][Name] & "D_xpm")
        --add new resource for control                
        addResource(controls[selectedControl][Name],
                    controls[selectedControl][XpmDisableObject],"XpmDisableObject",controls[selectedControl][Name] & "D_xpm")
        endChanges(xpmmerDisableObject)
        --keep drawing of xpmObject even though we just added xpmDisableObject because we don't
        --show it until selected with F2
        downButton = 13
        drawControl(ControlBlit, controls[selectedControl], Normal, selectedControl, 0)
        drawControl(ControlBlit, controls[selectedControl], Selected, selectedControl, 0)
        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    --setting focus allows us to use delete key on a control in Design
    --sometimes we don't want to do that, such as when the changing a Property
    --routine sends us back here.

    if focusDesign then
        if showActive then
            setFocus(Show)
        elsif offsetActive then
            setFocus(OffScreen)
        else
            setFocus(Design)
        end if
    end if

    focusDesign = w32True

end procedure
updateProperty_id = routine_id("updateProperty")
--------------------------------------------------------------------------------
procedure findCodeForEventList()
sequence IDElvItems
sequence IDElvData
integer IDElvItemNo

    IDElvItems = {}
    IDElvData = {}
    eraseItems(EventListView)

    for i=1 to length(Events) do
        if selectedControl!=TheWindow
        and i!=Intro
        and i!=Begin
        and i!=Final then
            if length(controls[selectedControl][Code][i]) then
                if equal(Events[i][1],"(General)") then
                    IDElvData = {LVIcon1, "(Control General)"}
                else
                    IDElvData = {LVIcon1,Events[i][1]}
                end if
            else
                if equal(Events[i][1],"(General)") then
                    IDElvData = {0, "(Control General)"}
                else
                    IDElvData = {0,Events[i][1]}
                end if
            end if
            IDElvItems &= {IDElvData}
        elsif selectedControl=TheWindow then
            if length(controls[selectedControl][Code][i]) then
                IDElvData = {LVIcon1,Events[i][1]}
            else
                IDElvData = {0,Events[i][1]}
            end if
            IDElvItems &= {IDElvData}
        end if
    end for

    for j=1 to length(IDElvItems) do
        IDElvItemNo = addLVItem(EventListView, IDElvItems[j][1], IDElvItems[j][2..length(IDElvItems[j])])
    end for
end procedure
findCodeForEventList_id = routine_id("findCodeForEventList")
------------------------------------------------------------------------------
global procedure updateProperties()
-- update the properties for the selected control

sequence holdClasses, defaultType
integer at, flag, layerNum
sequence showInitial, layerName, layerInfoNum, layerInfoName, textLen, testFontName
integer testFontAttrib,testFontBold,testFontUnderline,testFontStrikeout,testFontPts

    showInitial = {}
    setText(PropertySheet, "Properties - " & controls[selectedControl][Name])

    if not fromTitleBarChange then
        for i=1 to getCount(PropertyTitleBar) do
            if equal(controls[selectedControl][Name], getItem(PropertyTitleBar, i)) then
                setIndex(PropertyTitleBar, i)
                exit
            end if
        end for
    end if

    if equal(controls[selectedControl][Class],"Window") then
        --collect the window names for parent
        --include files may use window1 name or its parent's name or nothing
        parentList = {""}   --start by including Window1
        for i=1 to length(windows) do
            if treatAsInclude
            and i=1
            and length(windows[1][1][ControlParent]) then
                parentList &= {windows[1][1][ControlParent]}
            end if

            if equal(windows[i][1][Name], controls[selectedControl][Name]) then
                exit
            end if
            parentList &= {windows[i][1][Name]}
        end for
    end if

    --collect layer captions and then sort by layer number for Layer dropdownlist
    layerInfoNum = {}
    layerInfoName = {}
    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        layerNum = layerCaptionSeq[selectedWindow][i][3]
        layerName = layerCaptionSeq[selectedWindow][i][1]
        if i=1 then
            layerInfoNum = {layerNum}
            layerInfoName = {layerName}
        else
            layerInfoNum &= {layerNum}
            layerInfoName &= {layerName}
        end if
    end for

    tabNewTitle = {}

    if find(controls[selectedControl][Class], {"Window","CWindow"}) then
        setText(PopUpDesign_Styles, IDEText[717][1])--"Window Styles Explorer")
        setEnable(PopUpDesign_Styles, w32True)
    elsif equal(controls[selectedControl][Class], "ListView") then
        setText(PopUpDesign_Styles, IDEText[1049][1])--"ListView Styles Explorer")
        setEnable(PopUpDesign_Styles, w32True)
    else
        setText(PopUpDesign_Styles, IDEText[1050][1])--"Unavailable")
        setEnable(PopUpDesign_Styles, w32False)
    end if

    --hide properties that are not available for all controls
    --these not used for EuGrid
    showProperty(local, w32False)
    showProperty(createWith, w32False)
    showProperty(exStyle, w32False)
    --for colored buttons
    showProperty(cbcolor, w32False)
    showProperty(cbcaptioncolor, w32False)
    showProperty(cbthickness, w32False)
    showProperty(cbpresscolor, w32False)
    showProperty(cbpresscaptioncolor, w32False)
    showProperty(cbcaptionpos, w32False)
    showProperty(cbgraphicpos, w32False)
    showProperty(treatAsColorButton, w32False)
    --these depend upon control class
    showProperty(controlComment, w32False)
    showProperty(enable, w32False)
    showProperty(showCap, w32False)
    showProperty(titleWidth, w32False)
    setPropEnabled(titleWidth, w32False)
    showProperty(style, w32False)
    showProperty(styletype, w32False)
    showProperty(controlOrder, w32False)
    showProperty(otherFlags, w32False)
    showProperty(controlStyletype, w32False)
    showProperty(extExStyle, w32False)
    showProperty(bitmap, w32False)
    showProperty(toolHeight, w32False)
    showProperty(ccWin, w32False)
    showProperty(ccWinMain, w32False)
    showProperty(winOpenAtCtrl, w32False)
    showProperty(insystray, w32False)
    showProperty(winPos, w32False)
    showProperty(winPosTaskBar, w32False)
    showProperty(alimitText, w32False)
    showProperty(controlStyle, w32False)
    showProperty(readOnly, w32False)
    showProperty(upperCase, w32False)
    showProperty(lowerCase, w32False)
    showProperty(numeric, w32False)
    showProperty(password, w32False)
    showProperty(hScroll, w32False)
    showProperty(multiline, w32False)
    showProperty(cbmultiline, w32False)
    showProperty(clickable, w32False)
    showProperty(minValue, w32False)
    showProperty(maxValue, w32False)
    showProperty(buddy, w32False)
    showProperty(upDownLeft, w32False)
    showProperty(upDownHorz, w32False)
    showProperty(tabsBottom, w32False)
    showProperty(multSel, w32False)
    showProperty(extSel, w32False)
    showProperty(rbbsBreak, w32False)
    showProperty(iconFile, w32False)
    showProperty(iconFileLV, w32False)
    showProperty(defFile, w32False)
    showProperty(hotFile, w32False)
    showProperty(disFile, w32False)
    showProperty(closeFile, w32False)
    showProperty(openFile, w32False)
    showProperty(XPMFile, w32False)
    showProperty(XPMMember, w32False)
    showProperty(xpmmer, w32False)
    showProperty(xpmmerObject, w32False)
    showProperty(xpmmerDisable, w32False)
    showProperty(xpmmerDisableObject, w32False)
    showProperty(font, w32False)
    showProperty(fontPts, w32False)
    showProperty(fontAttrib, w32False)
    showProperty(fontBold, w32False)
    showProperty(fontItalic, w32False)
    showProperty(fontUnderline, w32False)
    showProperty(fontStrike, w32False)
    showProperty(fontColor, w32False)
    showProperty(fontName, w32False)
    showProperty(hintFont, w32False)
    showProperty(hintFontPts, w32False)
    showProperty(hintFontAttrib, w32False)
    showProperty(hintFontBold, w32False)
    showProperty(hintFontItalic, w32False)
    showProperty(hintFontUnderline, w32False)
    showProperty(hintFontStrike, w32False)
    showProperty(hintFontName, w32False)
    showProperty(list, w32False)
    showProperty(defindex, w32False)
    showProperty(extExStyle, w32False)
    showProperty(hintText, w32False)
    showProperty(windowParent, w32False)
    showProperty(parent, w32True)
    showProperty(parentFrozen, w32True)
    showProperty(proptableSpecs, w32False)
    showProperty(valueEdit, w32False)       --for LabeledEdit only          
    skipParentValidation = w32True--this allows validation to occur since it triggers a change event    
    setPropEnabled(parent, w32True)
    setPropEnabled(windowParent, w32True)
    skipParentValidation = w32False
    showProperty(color, w32False)
    showProperty(barColor, w32False)
    showProperty(defaultColor, w32False)
    showProperty(mcs_multiselect,w32False)
    showProperty(pbs_smooth, w32False)
    showProperty(bs_flat, w32False)
    showProperty(cbflat,w32False)
    showProperty(cbcentvert, w32False)
    showProperty(suppressCell, w32False)
    showProperty(LvAddBottom, w32False)
    showProperty(checked, w32False)
    showProperty(lineChg, w32False)
    showProperty(pageChg, w32False)
    showProperty(indexTo, w32False)
    showProperty(controllayer, w32False)
    showProperty(setLayerOK, w32False)
    showProperty(txtColor, w32False)
    showProperty(useInWinMain, w32False)
    showProperty(labelSide, w32False)
    showProperty(noIntegralHeight, w32False)
    showProperty(adjCenter, w32False)
    showProperty(adjRight, w32False)
    showProperty(partners, w32False)
    showProperty(pbCapPos, w32False)
    showProperty(vScroll, w32False)

    showProperty(transparency, w32False)
    setPropEnabled(transparency, w32False)
    showProperty(removeCopyIndex, w32False)
    showProperty(setcreatefont, w32False)

    showProperty(mc_background,w32False)
    showProperty(mc_text, w32False)
    showProperty(mc_titleBK, w32False)
    showProperty(mc_titleText, w32False)
    showProperty(mc_monthBK, w32False)
    showProperty(mc_trailingText, w32False)

    --these allow variables in Hint Font and Font fields:
    showProperty(varhintFontName, w32False)
    showProperty(varhintFontPts, w32False)
    showProperty(varhintFontBold, w32False)
    showProperty(varhintFontItalic, w32False)
    showProperty(varhintFontUnderline, w32False)
    showProperty(varhintFontStrike, w32False)
    showProperty(varhintText, w32False)
    showProperty(varfontName, w32False)
    showProperty(varfontPts, w32False)
    showProperty(varfontBold, w32False)
    showProperty(varfontItalic, w32False)
    showProperty(varfontUnderline, w32False)
    showProperty(varfontStrike, w32False)
    showProperty(varfontColor, w32False)

    --these are only for EuGrid and its children
    showProperty(gridHeaderInfo, w32False)
    showProperty(gridHeaderColor, w32False)
    showProperty(gridHeaderColHeight, w32False)
    showProperty(gridHeaderRowWidth, w32False)
    showProperty(gridHeaderDataCol, w32False)
    showProperty(gridHeaderDataColVal, w32False)
    showProperty(gridRowHeight, w32False)
    showProperty(gridTextAlign, w32False)
    showProperty(gridCellBkColor, w32False)
    showProperty(gridLineColor, w32False)
    showProperty(gridTextColor, w32False)
    showProperty(gridColTextColor, w32False)
    showProperty(gridColAlign, w32False)
    showProperty(gridColors, w32False)
    showProperty(gridFormat, w32False)
    showProperty(gridCellFormat, w32False)
    setPropEnabled(gridCellFormat, w32False)
    showProperty(gridDataArrayName, w32False)
    showProperty(gridRowSelect, w32False)
    showProperty(gridColListDataCol, w32False)
    showProperty(gridColListValues, w32False)
    showProperty(gridActiveHeaders, w32False)
    showProperty(gridAllowColSort, w32False)
    showProperty(gridAllowColResize, w32False)
    showProperty(gridCellBorder, w32False)
    showProperty(gridHighlightText, w32False)
    showProperty(gridBkColorSelect, w32False)
    showProperty(gridCellBorderColor, w32False)
    showProperty(gridTextColorSelect, w32False)

        --flag those properties that wait for enter key processing. This can change between uses of
        --Properties.......
    setPropsWaitForEnter(w32False)

    --bypass validations:
    --when a control has a negative value and is moved offscreen and then
    --TheWindow is clicked, the negative value from the offscreen control was
    --kicking in before the Window column values were moved into Properties.
    skipValidations = w32True

    if find("Name", waitForKeys) then
        setPropWaitForEnter(name, w32True)
        namewait = w32True
    else
        setPropWaitForEnter(name, w32True)
        namewait = w32True
    end if
    if find("Title", waitForKeys) then
        setPropWaitForEnter(caption, w32True)
    end if
    if find("X", waitForKeys) then
        setPropWaitForEnter(col, w32True)
    end if
    if find("Y", waitForKeys) then
        setPropWaitForEnter(row, w32True)
    end if
    if find("CX", waitForKeys) then
        setPropWaitForEnter(width, w32True)
    end if
    if find("CY", waitForKeys) then
        setPropWaitForEnter(height, w32True)
    end if
    if find("RowHeight", waitForKeys) then
        setPropWaitForEnter(toolHeight, w32True)
    end if
    if find("ControlParent", waitForKeys) then
        setPropWaitForEnter(windowParent, w32True)
    end if
    if find("Style", waitForKeys) then
        setPropWaitForEnter(style, w32True)
        setPropWaitForEnter(otherFlags, w32True)
    end if
    if find("BkColor", waitForKeys) then
        setPropWaitForEnter(color, w32True)
        setPropWaitForEnter(txtColor, w32True)
        setPropWaitForEnter(barColor, w32True)
    end if
    if find("FontName", waitForKeys) then
        setPropWaitForEnter(fontName, w32True)
    end if
    if find("HintFontName", waitForKeys) then
        setPropWaitForEnter(hintFontName, w32True)
    end if
    if find("FontColor", waitForKeys) then
        setPropWaitForEnter(fontColor, w32True)
    end if
    if find("IcoFile", waitForKeys) then
        setPropWaitForEnter(iconFile, w32True)
        setPropWaitForEnter(defFile, w32True)
    end if
    if find("BitmapFile", waitForKeys) then
        setPropWaitForEnter(bitmap, w32True)
    end if
    if find("XPM", waitForKeys) then
        setPropWaitForEnter(XPMFile, w32True)
    end if
    if find("XPMMember", waitForKeys) then
        setPropWaitForEnter(XPMMember, w32True)
    end if
    if find("TwoIcoFile", waitForKeys) then
        setPropWaitForEnter(hotFile, w32True)
        setPropWaitForEnter(closeFile, w32True)
    end if
    if find("TriIcoFile", waitForKeys) then
        setPropWaitForEnter(disFile, w32True)
        setPropWaitForEnter(openFile, w32True)
    end if

    -- copy attributes
    setProperty(name, controls[selectedControl][Name])

    setProperty(caption, controls[selectedControl][Title])

    if length(controls[selectedControl][IndexParent]) then
        showProperty(removeCopyIndex, w32True)
        setProperty(removeCopyIndex, w32False)
    end if

    if equal(controls[selectedControl][Class], "LabelEdit") then
        setControlFont()
        if length(controls[selectedControl][FontName]) then
            testFontName = controls[selectedControl][FontName]
            testFontBold = controls[selectedControl][FontBold]
            testFontUnderline = controls[selectedControl][FontUnderline]
            testFontStrikeout = controls[selectedControl][FontStrikeout]
            testFontPts = controls[selectedControl][FontPts]
            testFontAttrib = 0
            if testFontAttrib then
                testFontAttrib = Italic
            end if
            if testFontBold then
                testFontAttrib += testFontBold
            end if
            if testFontUnderline then
                testFontAttrib += 4
            end if
            if testFontStrikeout then
                testFontAttrib += 8
            end if
            setFont(selectedControl, testFontName, testFontPts, testFontAttrib)
        end if
        textLen = getTextExtent(selectedControl, controls[selectedControl][Title])
        controls[selectedControl][LabelExtent] = snap(textLen[1])
        showProperty(valueEdit, w32True)
        setProperty(valueEdit, controls[selectedControl][ValueEdit])
        setPropertyCombo(labelSide, 1, {"Left","Right"})
        if controls[selectedControl][LabelSide]=1 then
            setPropertyCombo(labelSide, 2, {"Left","Right"})
        end if
        showProperty(labelSide, w32True)
    end if

    if equal(controls[selectedControl][Class], "ListView") then
        showProperty(titleWidth,w32True)
        if length(controls[selectedControl][WidthTitle]) then
            setProperty(titleWidth, controls[selectedControl][WidthTitle])
        else
            setProperty(titleWidth, "")
        end if
        showProperty(LvAddBottom, w32True)
        if controls[selectedControl][SETLVInsert] then
            setProperty(LvAddBottom, w32True)
        else
            setProperty(LvAddBottom, w32False)
        end if

    end if

    if find(controls[selectedControl][Class], {"EditText", "MleText","RichEdit","LabelEdit"}) then
        --this is backwards so older PRJ files load ok
        if not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
            showProperty(showCap, w32True)
            if controls[selectedControl][Showcap] then
                setProperty(showCap, w32False)
            else
                setProperty(showCap, w32True)
            end if
        end if
    end if

    if selectedControl=TheWindow then
        setPropertyCombo(propclass, 1,{"Window"})
        showProperty(setcreatefont, w32True)
        if controls[selectedControl][setCreatefont] then
            setProperty(setcreatefont, w32True)
        else
            setProperty(setcreatefont, w32False)
        end if

    elsif equal(controls[selectedControl][Class], "Table") then
        showProperty(proptableSpecs, w32True)
        setPropertyCombo(propclass, 1,{"Table"})
        if length(controls[selectedControl][SeqChildName]) then
            setPropEnabled(proptableSpecs, w32True)
        else
            setPropEnabled(proptableSpecs, w32False)
        end if
    elsif equal(controls[selectedControl][Class], "EuGrid") then
        setPropertyCombo(propclass, 1,{"EuGrid"})
    else
        holdClasses = {}

        for i=1 to length(ClassName) do
            if find(controls[selectedControl][Class], ClassName[i]) then
                for j=1 to length(ClassName[i]) do
                    if j=1 then
                        holdClasses = {ClassName[i][j]}
                    else
                        holdClasses &= {ClassName[i][j]}
                    end if
                end for

                if length(holdClasses)=1 then
                    setPropertyCombo(propclass, 1, {controls[selectedControl][Class]})
                else
                    -- select class
                    at = find(controls[selectedControl][Class], ClassName[i])
                    setPropertyCombo(propclass, at, holdClasses)
                end if
                exit
            end if
        end for

        if not length(holdClasses) then
            setPropertyCombo(propclass, 1, {controls[selectedControl][Class]})
        end if

    end if

--DEV???
--  if find( controls[selectedControl][Class],
--      { "ToolBar", "StatusBar","FlatToolBar" } )
--  and not length( controls[selectedControl][ControlParent] )
--  or find( controls[selectedControl][Class], {"ReBar","ReBarBand"} ) then
    if find(controls[selectedControl][Class],
            {"ToolBar", "StatusBar","FlatToolBar"})
    and (not length(controls[selectedControl][ControlParent])
         or find(controls[selectedControl][Class], {"ReBar","ReBarBand"})) then
        setProperty(row, sprintf("%d",controls[selectedControl][Y]))
        setPropEnabled(row, w32False)
        setProperty(col, sprintf("%d",controls[selectedControl][X]))
        setPropEnabled(col, w32False)
    else
        setPropEnabled(row, w32True)
        setPropEnabled(col, w32True)
        if not controls[selectedControl][DefaultXY]
        and selectedControl=TheWindow then
            -- w32False/w32True is backwards so do not have to convert all existing
            -- PRj files
            setProperty(row, "Default")
            setProperty(col, "Default")
        else
            setProperty(row, sprintf("%d",controls[selectedControl][Y]))
            setProperty(col, sprintf("%d",controls[selectedControl][X]))
        end if
    end if

    if find(controls[selectedControl][Class],
            {"MonthCalendar", "StatusBar", "SepButton"})  then
        setProperty(width, sprintf("%d", controls[selectedControl][CX]))
        setProperty(height, sprintf("%d", controls[selectedControl][CY]))
        setPropEnabled(width, w32False)
        setPropEnabled(height, w32False)
        if equal(controls[selectedControl][Class], "MonthCalendar") then
            showProperty(mc_background,w32True)
            showProperty(mc_text, w32True)
            showProperty(mc_titleBK, w32True)
            showProperty(mc_titleText, w32True)
            showProperty(mc_monthBK, w32True)
            showProperty(mc_trailingText, w32True)
            setProperty(mc_background, sprintf("%d",controls[selectedControl][MC_background]))
            setProperty(mc_text, sprintf("%d",controls[selectedControl][MC_text]))
            setProperty(mc_titleBK, sprintf("%d",controls[selectedControl][MC_titleBK]))
            setProperty(mc_titleText, sprintf("%d",controls[selectedControl][MC_titleText]))
            setProperty(mc_monthBK, sprintf("%d",controls[selectedControl][MC_monthBK]))
            setProperty(mc_trailingText, sprintf("%d",controls[selectedControl][MC_trailingText]))
        end if
    else
        setProperty(width, sprintf("%d",controls[selectedControl][CX]))
        setPropEnabled(width, w32True)
        if find(controls[selectedControl][Class], {"ReBar", "ReBarBand"}) then
            setProperty(height, controls[selectedControl][CY])
            setPropEnabled(height, w32False)
        else
            setProperty(height, sprintf("%d",controls[selectedControl][CY]))
            setPropEnabled(height, w32True)
        end if
    end if

    if find(controls[selectedControl][Class], {"ToolBar","FlatToolBar"}) then
        setProperty(toolHeight, sprintf("%d",controls[selectedControl][ToolRowCY]))
        showProperty(toolHeight, w32True)
    end if

    if controls[selectedControl][TableCell] then
        --check if TableSpecs was for array mode or not
        flag = findSeqParentName(selectedControl)
        if flag then
            if controls[flag][TableArray] then
                --disable this property
                showProperty(SuppressCell, w32False)
            else
                showProperty(suppressCell, w32True)
                if controls[selectedControl][SuppressCell] then
                    setProperty(suppressCell, w32True)
                else
                    setProperty(suppressCell, w32False)
                end if
            end if
        end if
    end if

    setProperty(outX, controls[selectedControl][OutX])
    setProperty(outY, controls[selectedControl][OutY])
    setProperty(outCX, controls[selectedControl][OutCX])
    setProperty(outCY, controls[selectedControl][OutCY])
    if not equal(controls[selectedControl][Class], "EuGrid")
    and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
        showProperty(controlComment, w32True)
        setProperty(controlComment, controls[selectedControl][ControlComment])
    end if

    if not find(controls[selectedControl][Class], {"Window","ToolBar",
                                                   "StatusBar","FlatToolBar","ReBar","ReBarBand","CWindow"}) then
        setProperty(controlOrder, sprintf("%d",controls[selectedControl][TabOrder]))
        showProperty(controlOrder, w32True)
        setPropEnabled(controlOrder, w32True)
    end if

    if equal(controls[selectedControl][Class], "Window") then
        showProperty(exStyle, w32True)
        showProperty(controllayer, w32False)
        showProperty(useInWinMain, w32True)
        if controls[selectedControl][UseInWinMain] then
            setProperty(useInWinMain, w32True)
        else
            setProperty(useInWinMain, w32False)
        end if
    else
        showProperty(useInWinMain, w32False)
        showProperty(controllayer, w32True)
        setPropEnabled(setLayerOK, w32True)
        showProperty(setLayerOK, w32True)
        if equal(controls[selectedControl][SeqParentClass], "EuGrid") then
            controls[selectedControl][SetLayerOK] = w32False
            setPropEnabled(setLayerOK, w32False)
        end if
        setProperty(setLayerOK, controls[selectedControl][SetLayerOK])

        if length(layerInfoName)=1 then
            setPropertyCombo(controllayer, 1, layerInfoName)
        else
            for i=1 to length(layerInfoNum) do
                if controls[selectedControl][ControlLayer]=layerInfoNum[i] then
                    setPropertyCombo(controllayer, i, layerInfoName)
                    exit
                end if
            end for
        end if
    end if

    if length(controls[selectedControl][IndexParent]) then
        setPropertyCombo(indexTo, 1, {controls[selectedControl][IndexParent]})
        showProperty(indexTo, w32True)
    end if

    if find(controls[selectedControl][Class], {"List","Combo","SortedCombo",
                                               "SimpleCombo","ComboBoxEx","SortedList","DropDownList",
                                               "ListView"}) then
        if not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
            showProperty(list, w32True)
            if not length(controls[selectedControl][InitialVal]) then
                setPropertyCombo(list,1,{" "})
            else
                showInitial = controls[selectedControl][InitialVal]
                setPropertyCombo(list,1,showInitial)
            end if
        end if
    end if

    if find(controls[selectedControl][Class], {"List","SortedList"}) then
        showProperty(defindex, w32True)
        setProperty(defindex, controls[selectedControl][DEFIndex])

    end if

    if equal(controls[selectedControl][Class], "DropDownList") then
        showProperty(defindex, w32False)
        controls[selectedControl][MultiSel] = w32False
    end if

    showProperty(local, w32True)
    if controls[selectedControl][Local] then
        setProperty(local, w32True)
    else
        setProperty(local, w32False)
    end if

    if not equal(controls[selectedControl][Class], "EuGrid")
    and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then

        showProperty(createWith, w32True)

        if controls[selectedControl][Integers] then
            setPropertyCombo(createWith, 1,{"integer","constant"})
        else
            setPropertyCombo(createWith, 2,{"integer","constant"})
        end if

        if length(controls[selectedControl][ExStyle]) then
            setProperty(exStyle, controls[selectedControl][ExStyle])
        else
            setProperty(exStyle, "0")
        end if

        if length(controls[selectedControl][ExtExStyle]) then
            -- only for ListView from ListView Explorer
            setPropertyCombo(extExStyle, 1, controls[selectedControl][ExtExStyle])
            showProperty(extExStyle, w32True)
        end if


        if find(controls[selectedControl][Class], {"CheckBox","Radio"}) then
            showProperty(checked, w32True)
            if controls[selectedControl][Checked] then
                setProperty(checked, w32True)
            else
                setProperty(checked, w32False)
            end if
        end if
    end if

    setProperty(classdef, controls[selectedControl][ClassDefaults])

    if find(controls[selectedControl][Class], {"Window","CWindow"}) then
        showProperty(controlStyle, w32True)
        showProperty(style, w32True)
        showProperty(styletype, w32True)
        setPropEnabled(styletype, w32True)
        showProperty(exStyle, w32True)
        if equal(controls[selectedControl][Class], "Window") then
            showProperty(transparency, w32True)
            if canUseTransparency then
                setPropEnabled(transparency, w32True)
            end if
        end if
        if atom(controls[selectedControl][Style])
        and controls[selectedControl][Style]=0 then
            setProperty(style, "0")
            setPropEnabled(styletype, w32False)
            if equal(controls[selectedControl][Class], "CWindow") then
                setProperty(style, "WS_CHILD")
            end if
        else
            setProperty(style, controls[selectedControl][Style])
            if not length(controls[selectedControl][Style]) then
                setPropEnabled(styletype, w32False)
            end if
        end if

        if length(controls[selectedControl][StyleType]) then
            at = find(controls[selectedControl][StyleType], defaultList)
            if not at then
                setProperty(styletype, "")
                setPropEnabled(styletype, w32False)
            else
                setPropertyCombo(styletype, at, defaultList)
            end if
        else
            if not sequence(controls[selectedControl][Style]) then
                setProperty(styletype, "")
                setPropEnabled(styletype, w32False)
            else
                if equal(controls[selectedControl][Style], "0") then
                    setProperty(styletype, "")
                    setPropEnabled(styletype, w32False)
                else
                    if equal(controls[selectedControl][Class], "Window") then
                        defaultType = "{...}"
                        at = 2
                        setPropertyCombo(styletype, at, defaultList)
                        controls[selectedControl][StyleType] = "{...}"
                    else
                        defaultType = "w32or_all({...})"
                        at = 1
                        setPropertyCombo(styletype, at, defaultList)
                        controls[selectedControl][StyleType] = "w32or_all({...})"
                    end if
                end if
            end if
        end if
        showProperty(ccWin, w32True)
        setProperty(ccWin, controls[selectedControl][CCWinStyle])

        if length(controls[selectedControl][SysTrayIcon]) then
            setProperty(insystray, w32True)
        else
            setProperty(insystray, w32False)
        end if

        if equal(controls[selectedControl][Class], "Window") then
            if controls[selectedControl][WinTransparency] then
                if controls[selectedControl][WinTransparency]= -1 then
                    setProperty(transparency,"")
                else
                    setProperty(transparency, sprintf("%d",controls[selectedControl][WinTransparency]))
                end if
            else
                setProperty(transparency,"")
            end if
        end if
    else
        showProperty(controlStyle, w32True)
        showProperty(otherFlags, w32True)
        showProperty(controlStyletype, w32True)
        setProperty(otherFlags, controls[selectedControl][Style])
        setProperty(controlStyletype, controls[selectedControl][StyleType])
        at = find(controls[selectedControl][StyleType], defaultList)
        if not at then
            setPropertyCombo(controlStyletype, 1, defaultList)
        else
            setPropertyCombo(controlStyletype, at, defaultList)
        end if

        if not equal(controls[selectedControl][Class], "EuGrid") then
            if equal(controls[selectedControl][Class], "CheckBox") then
                if not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
                    showProperty(controlStyle, w32True)
                end if
            else
                showProperty(controlStyle, w32True)
            end if
            if not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
                showProperty(otherFlags, w32True)
                if sequence(controls[selectedControl][Style]) then
                    setProperty(otherFlags, controls[selectedControl][Style])
                else
                    setProperty(otherFlags, sprintf("%d",controls[selectedControl][Style]))
                end if
            end if
        end if
    end if

    if equal(controls[selectedControl][Class], "Window") then
        showProperty(ccWinMain, w32True)
        setPropEnabled(winPosTaskBar, w32False)
        if length(windows) then
            showProperty(winPos, w32True)
            showProperty(winPosTaskBar, w32True)
            if not controls[selectedControl][WinMainOpen] then
                setPropertyCombo(ccWinMain, 1, winMainList)
            elsif controls[selectedControl][WinMainOpen]=1 then
                setPropertyCombo(ccWinMain, 2, winMainList)
            else
                setPropertyCombo(ccWinMain, 3, winMainList)
            end if

            if not controls[selectedControl][WinPos] then
                setPropertyCombo(winPos, 1, winPosList)
            elsif controls[selectedControl][WinPos]=1 then
                setPropertyCombo(winPos, 2, winPosList)
            elsif controls[selectedControl][WinPos]=2 then
                setPropertyCombo(winPos, 3, winPosList)
            elsif controls[selectedControl][WinPos]=3 then
                setPropertyCombo(winPos, 4, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=4 then
                setPropertyCombo(winPos, 5, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=5 then
                setPropertyCombo(winPos, 6, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=6 then
                setPropertyCombo(winPos, 7, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=7 then
                setPropertyCombo(winPos, 8, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=8 then
                setPropertyCombo(winPos, 9, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            else
                setPropertyCombo(winPos, 10, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            end if
            if controls[selectedControl][WinPosTaskBar] then
                setPropEnabled(winPosTaskBar, w32True)
                setProperty(winPosTaskBar, w32True)
            else
                setProperty(winPosTaskBar, w32False)
            end if

            if equal(controls[selectedControl][Name], windows[1][1][Name]) then
                showProperty(winOpenAtCtrl, w32True)
                setProperty(winOpenAtCtrl,controls[selectedControl][WinOpenAtCtrl])
            end if

        else
            showProperty(winPos, w32True)
            showProperty(winPosTaskBar, w32True)
            if not controls[selectedControl][WinMainOpen] then
                setPropertyCombo(ccWinMain, 1, winMainList)
            elsif controls[selectedControl][WinMainOpen]=1 then
                setPropertyCombo(ccWinMain, 2, winMainList)
            else
                setPropertyCombo(ccWinMain, 3, winMainList)
            end if

            if not controls[selectedControl][WinPos] then
                setPropertyCombo(winPos, 1, winPosList)
            elsif controls[selectedControl][WinPos]=1 then
                setPropertyCombo(winPos, 2, winPosList)
            elsif controls[selectedControl][WinPos]=2 then
                setPropertyCombo(winPos, 3, winPosList)
            elsif controls[selectedControl][WinPos]=3 then
                setPropertyCombo(winPos, 4, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=4 then
                setPropertyCombo(winPos, 5, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=5 then
                setPropertyCombo(winPos, 6, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=6 then
                setPropertyCombo(winPos, 7, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=7 then
                setPropertyCombo(winPos, 8, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            elsif controls[selectedControl][WinPos]=8 then
                setPropertyCombo(winPos, 9, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            else
                setPropertyCombo(winPos, 10, winPosList)
                setPropEnabled(winPosTaskBar, w32True)
            end if
            if controls[selectedControl][WinPosTaskBar] then
                setPropEnabled(winPosTaskBar, w32True)
                setProperty(winPosTaskBar, w32True)
            else
                setProperty(winPosTaskBar, w32False)
            end if
        end if
    end if

    if not equal(controls[selectedControl][Class], "EuGrid")
    and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
        showProperty(enable, w32True)
        if controls[selectedControl][EnableC] then
            setProperty(enable, w32True)
        else
            setProperty(enable, w32False)
        end if
    end if

    if controls[selectedControl][Visible] then
        setProperty(visible, w32True)
    else
        setProperty(visible, w32False)
    end if


    if find(controls[selectedControl][Class], {"EditText","MleText","RichEdit","LabelEdit"}) then
        showProperty(alimitText, w32True)
        if controls[selectedControl][Limit] then
            setProperty(alimitText, sprintf("%d",controls[selectedControl][Limit]))
        else
            setProperty(alimitText, "")
        end if
    end if

    if equal(controls[selectedControl][Class], "Combo")
    and equal(controls[selectedControl][SeqParentClass], "EuGrid") then
        showProperty(readOnly, w32True)
        if controls[selectedControl][ReadOnly] then
            setProperty(readOnly, w32True)
        else
            setProperty(readOnly, w32False)
        end if
    end if

    if find(controls[selectedControl][Class], {"EditText","MleText","RichEdit","PushButton",
                                               "ToggleButton","LabelEdit"}) then
        if find(controls[selectedControl][Class], {"EditText","MleText","RichEdit","LabelEdit"}) then
            showProperty(readOnly, w32True)
            if controls[selectedControl][ReadOnly] then
                setProperty(readOnly, w32True)
            else
                setProperty(readOnly, w32False)
            end if

            showProperty(adjCenter, w32True)
            if controls[selectedControl][AdjCenter] then
                setProperty(adjCenter, w32True)
            else
                setProperty(adjCenter, w32False)
            end if

            showProperty(adjRight, w32True)
            if controls[selectedControl][AdjRight] then
                setProperty(adjRight, w32True)
            else
                setProperty(adjRight, w32False)
            end if

        end if

        if not equal(controls[selectedControl][Class], "EuGrid")
        and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
            if find(controls[selectedControl][Class], {"EditText","MleText","LabelEdit"}) then
                showProperty(upperCase, w32True)
                showProperty(lowerCase, w32True)
                if controls[selectedControl][Upper] then
                    setProperty(upperCase, w32True)
                else
                    setProperty(upperCase, w32False)
                end if

                if controls[selectedControl][Lower] then
                    setProperty(lowerCase, w32True)
                else
                    setProperty(lowerCase, w32False)
                end if
            end if
            if equal(controls[selectedControl][Class], "MleText") then
                showProperty(numeric, w32True)
                if controls[selectedControl][Numeric] then
                    setProperty(numeric, w32True)
                else
                    setProperty(numeric, w32False)
                end if
            end if
        end if

        if find(controls[selectedControl][Class], {"EditText","LabelEdit"}) then
            if not equal(controls[selectedControl][Class], "EuGrid")
            and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
                showProperty(password, w32True)
                if controls[selectedControl][Pswd] then
                    setProperty(password, w32True)
                else
                    setProperty(password, w32False)
                end if
            end if
        end if

        if find(controls[selectedControl][Class], {"EditText","LabelEdit"}) then
            showProperty(numeric, w32True)
            if controls[selectedControl][Numeric] then
                setProperty(numeric, w32True)
            else
                setProperty(numeric, w32False)
            end if
        end if

        if equal(controls[selectedControl][SeqParentClass], "EuGrid") then
            showProperty(multiline, w32True)
            if controls[selectedControl][Multiline] then
                setProperty(multiline, w32True)
            else
                setProperty(multiline, w32False)
            end if
        end if

        if find(controls[selectedControl][Class], {"RichEdit","MleText"}) then
            showProperty(hScroll, w32True)
            if controls[selectedControl][Hscrolls] then
                setProperty(hScroll, w32True)
            else
                setProperty(hScroll, w32False)
            end if
        end if

        if equal(controls[selectedControl][Class], "MleText") then
            showProperty(vScroll, w32True)
            if controls[selectedControl][Vscrolls] then
                setProperty(vScroll, w32True)
            else
                setProperty(vScroll, w32False)
            end if
        end if

        if find(controls[selectedControl][Class], {"PushButton","ToggleButton"}) then
            showProperty(multiline, w32True)
            if controls[selectedControl][Multiline] then
                setProperty(multiline, w32True)
            else
                setProperty(multiline, w32False)
            end if
            if not controls[selectedControl][TreatAsColorButton] then
                showProperty(pbCapPos, w32True)
                setPropertyCombo(pbCapPos, 2, {"Left","Center","Right"})
                if controls[selectedControl][PB_Caption_Pos]=1 then
                    setPropertyCombo(pbCapPos, 1, {"Left","Center","Right"})
                elsif controls[selectedControl][PB_Caption_Pos]=2 then
                    setPropertyCombo(pbCapPos, 3, {"Left","Center","Right"})
                end if
            end if
        end if


    elsif find(controls[selectedControl][Class],{"DefPushButton","CancelButton"}) then
        if not controls[selectedControl][TreatAsColorButton] then
            showProperty(pbCapPos, w32True)
            setPropertyCombo(pbCapPos, 2, {"Left","Center","Right"})
            if controls[selectedControl][PB_Caption_Pos]=1 then
                setPropertyCombo(pbCapPos, 1, {"Left","Center","Right"})
            elsif controls[selectedControl][PB_Caption_Pos]=2 then
                setPropertyCombo(pbCapPos, 3, {"Left","Center","Right"})
            end if
        end if

    elsif equal(controls[selectedControl][Class], "TabControl") then
        showProperty(multiline, w32True)
        if controls[selectedControl][Multiline] then
            setProperty(multiline, w32True)
        else
            setProperty(multiline, w32False)
        end if
        showProperty(tabsBottom, w32True)
        if controls[selectedControl][TabsBottom] then
            setProperty(tabsBottom, w32True)
        else
            setProperty(tabsBottom, w32False)
        end if

    elsif find(controls[selectedControl][Class], {"CheckBox","Radio"}) then
        showProperty(multiline, w32True)
        if controls[selectedControl][Multiline] then
            setProperty(multiline, w32True)
        else
            setProperty(multiline, w32False)
        end if

    elsif find(controls[selectedControl][Class], {"CText","LText","RText"}) then
        if equal(controls[selectedControl][SeqParentClass], "EuGrid") then
            showProperty(numeric, w32True)
            if controls[selectedControl][Numeric] then
                setProperty(numeric, w32True)
            else
                setProperty(numeric, w32False)
            end if
            showProperty(multiline, w32True)
            if controls[selectedControl][Multiline] then
                setProperty(multiline, w32True)
            else
                setProperty(multiline, w32False)
            end if
        end if

        if not equal(controls[selectedControl][Class], "EuGrid")
        and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
            showProperty(clickable, w32True)
            if controls[selectedControl][Clickable] then
                setProperty(clickable, w32True)
            else
                setProperty(clickable, w32False)
            end if
        end if

    elsif find(controls[selectedControl][Class], {"UpDown","HScroll","VScroll"}) then
        showProperty(minValue, w32True)
        showProperty(maxValue, w32True)
        setProperty(minValue, sprintf("%d",controls[selectedControl][MinValue]))
        setProperty(maxValue, sprintf("%d",controls[selectedControl][MaxValue]))
        if equal(controls[selectedControl][Class], "UpDown") then
            showProperty(buddy, w32True)
            setProperty(buddy, controls[selectedControl][Buddy])
            showProperty(upDownLeft, w32True)
            setProperty(upDownLeft, controls[selectedControl][UpDownLeft])
            showProperty(upDownHorz, w32True)
            setProperty(upDownHorz, controls[selectedControl][UpDownHorz])
        end if
        if find(controls[selectedControl][Class], {"HScroll","VScroll"}) then
            showProperty(lineChg, w32True)
            showProperty(pageChg, w32True)
            setProperty(lineChg, sprintf("%d",controls[selectedControl][LineChg]))
            setProperty(pageChg, sprintf("%d",controls[selectedControl][PageChg]))
        end if

    elsif find(controls[selectedControl][Class], {"VTrackBar","HTrackBar"}) then
        showProperty(minValue, w32True)
        showProperty(maxValue, w32True)
        setProperty(minValue, sprintf("%d",controls[selectedControl][MinValue]))
        setProperty(maxValue, sprintf("%d",controls[selectedControl][MaxValue]))
        showProperty(lineChg, w32True)
        showProperty(pageChg, w32True)
        setProperty(lineChg, sprintf("%d",controls[selectedControl][LineChg]))
        setProperty(pageChg, sprintf("%d",controls[selectedControl][PageChg]))

    elsif find(controls[selectedControl][Class], {"List","SortedList"}) then
        showProperty(multSel, w32True)
        showProperty(extSel, w32True)
        showProperty(noIntegralHeight, w32True)
        if controls[selectedControl][NoIntegralHeight] then
            setProperty(noIntegralHeight, w32True)
        else
            setProperty(noIntegralHeight, w32False)
        end if
        if controls[selectedControl][MultiSel] then
            setProperty(multSel, w32True)
        else
            setProperty(multSel, w32False)
        end if
        if controls[selectedControl][ExtendSel] then
            setProperty(extSel, w32True)
        else
            setProperty(extSel, w32False)
        end if

    elsif find(controls[selectedControl][Class], {"ReBarBand"}) then
        --if only one must be w32True and protected
        showProperty(rbbsBreak, w32True)
        if controls[selectedControl][RBBSBREAK] then
            setProperty(rbbsBreak, w32True)
        else
            setProperty(rbbsBreak, w32False)
        end if
    end if

    if find(controls[selectedControl][Class],{"PushButton","ToggleButton","PictureButton",
                                              "TogglePicture","DefPushButton","CancelButton"}) then
        if controls[selectedControl][TreatAsColorButton] then
            showProperty(cbcolor, w32True)
            showProperty(cbcaptioncolor, w32True)
            showProperty(cbthickness, w32True)
            showProperty(cbpresscolor, w32True)
            showProperty(cbpresscaptioncolor, w32True)
            showProperty(cbcaptionpos, w32True)
            showProperty(cbgraphicpos, w32True)
            showProperty(treatAsColorButton, w32True)
            setProperty(treatAsColorButton, w32True)
            showProperty(cbflat, w32True)
            showProperty(cbcentvert, w32True)
            showProperty(cbmultiline, w32True)
            showProperty(multiline, w32False)
            showProperty(bs_flat, w32False)

            if controls[selectedControl][cbColor] then
                setProperty(cbcolor, sprint(controls[selectedControl][cbColor]))
            else
                setProperty(cbcolor, "")
            end if
            if controls[selectedControl][cbCaptionColor] then
                setProperty(cbcaptioncolor, sprint(controls[selectedControl][cbCaptionColor]))
            else
                setProperty(cbcaptioncolor, "")
            end if
            if controls[selectedControl][cbThickness] then
                setProperty(cbthickness, sprint(controls[selectedControl][cbThickness]))
            else
                setProperty(cbthickness, "1")
            end if
            if controls[selectedControl][cbPressColor] then
                setProperty(cbpresscolor, sprint(controls[selectedControl][cbPressColor]))
            else
                setProperty(cbpresscolor, "")
            end if
            if controls[selectedControl][cbPressCaptionColor] then
                setProperty(cbpresscaptioncolor, sprint(controls[selectedControl][cbPressCaptionColor]))
            else
                setProperty(cbpresscaptioncolor, "")
            end if
            if controls[selectedControl][cbCaptionPos] then
                setProperty(cbcaptionpos, w32True)
            else
                setProperty(cbcaptionpos, w32False)
            end if

            if controls[selectedControl][cbMultiline] then
                setProperty(cbmultiline, w32True)
            else
                setProperty(cbmultiline, w32False)
            end if

            if controls[selectedControl][cbFlat] then
                setProperty(cbflat, w32True)
            else
                setProperty(cbflat, w32False)
            end if

            if controls[selectedControl][cbCentVert] then
                setProperty(cbcentvert, w32True)
            else
                setProperty(cbcentvert, w32False)
            end if

            if controls[selectedControl][cbGraphicPos] then
                at = controls[selectedControl][cbGraphicPos]
                setPropertyCombo(cbgraphicpos, at, {"Left", "Center", "Right"})
            else
                setPropertyCombo(cbgraphicpos, 2, {"Left","Center","Right"})
            end if

            if controls[selectedControl][cbCaptionPos] then
                at = controls[selectedControl][cbCaptionPos]
                setPropertyCombo(cbcaptionpos, at, {"Left", "Center", "Right","Unit"})
            else
                setPropertyCombo(cbcaptionpos, 2, {"Left","Center","Right","Unit"})
            end if
        else
            showProperty(multiline, w32True)
            showProperty(bs_flat, w32True)
            showProperty(treatAsColorButton, w32True)
            setProperty(treatAsColorButton, w32False)
        end if
    end if

    if not find(controls[selectedControl][Class], {"Window","ReBar","ReBarBand","ToolBar",
                                                   "FlatToolBar","StatusBar"}) then
        showProperty(partners, w32True)
        setProperty(partners, "")
        for i=1 to length(controls[selectedControl][ControlPartners]) do
            if i=1 then
                setProperty(partners,controls[selectedControl][ControlPartners][1])
            else
                setProperty(partners,getProperty(partners) & "," & controls[selectedControl][ControlPartners][i])
            end if
        end for
    end if

    if not equal(controls[selectedControl][Class],"Window") then
        parentList = {}
        findCorrectParent()
        at = find(controls[selectedControl][SeqParentName], parentList)
        if at then
            setPropertyCombo(parent, at, parentList)
        else
            setPropertyCombo(parent, 1, parentList)
        end if
        if find(controls[selectedControl][Class], {"TabItem","ReBarBand"})
        or find(controls[selectedControl][SeqParentClass], {"EuGrid","Table"}) then
            showProperty(parentFrozen, w32False)
        else
            setProperty(parentFrozen, controls[selectedControl][ParentIsFrozen])
        end if
    else
        --class is window
        showProperty(parentFrozen, w32False)
        --If .ew file, or not first window, can change parent
        --only .ew first window can type into combo
        showProperty(parent, w32False)
        showProperty(windowParent, w32False)
        if treatAsInclude then
            if length(windows)>1 then
                if not equal(controls[selectedControl][Name], windows[1][1][Name]) then
                        --secondary window                                                                      
                    if length(controls[selectedControl][ControlParent]) then
                        showProperty(parent, w32True)
                        at = find(controls[selectedControl][ControlParent], parentList)
                        if at then
                            setPropertyCombo(parent, at, parentList)
                        else
                            setPropertyCombo(parent, 1, parentList)
                        end if
                    else
                        showProperty(parent, w32True)
                        setPropertyCombo(parent, 1, parentList)
                    end if
                else
                    --primary window
                    showProperty(windowParent, w32True)
                    showProperty(insystray, w32True)
                    if length(controls[selectedControl][ControlParent]) then
                        at = find(controls[selectedControl][ControlParent], parentList)
                        if at then
                            setPropertyCombo(windowParent, at, parentList)
                        else
                            setPropertyCombo(windowParent, 1, parentList)
                        end if
                    else
                        setPropertyCombo(windowParent, 1, parentList)
                    end if
                end if
            else
                --primary window
                showProperty(windowParent, w32True)
                showProperty(insystray, w32True)
                if length(controls[selectedControl][ControlParent]) then
                    at = find(controls[selectedControl][ControlParent], parentList)
                    if at then
                        setPropertyCombo(windowParent, at, parentList)
                    else
                        setPropertyCombo(windowParent, 1, parentList)
                    end if
                else
                    setPropertyCombo(windowParent,1, parentList)
                end if
            end if
        else
            if length(windows)>1 then
                if not equal(controls[selectedControl][Name], windows[1][1][Name]) then
                    --secondary windows
                    showProperty(parent, w32True)
                    if length(controls[selectedControl][ControlParent]) then
                        at = find(controls[selectedControl][ControlParent], parentList)
                        if at then
                            setPropertyCombo(parent, at, parentList)
                        else
                            setPropertyCombo(parent, 1, parentList)
                        end if
                    else
                        setPropertyCombo(parent, 1, parentList)
                    end if
                else
                        --primary window
                    showProperty(insystray, w32True)
                    showProperty(parent, w32True)
                    setPropertyCombo(parent,1,{""})
                    setPropEnabled(parent, w32False)
                end if
            else
                --primary window
                showProperty(insystray, w32True)
                showProperty(parent, w32True)
                setPropertyCombo(parent,1,{""})
                setPropEnabled(parent, w32False)
            end if
        end if
    end if

    if find(controls[selectedControl][Class], {"CText","LText",
                                               "RText","List","EditText","LabelEdit"})
    and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
        showProperty(txtColor, w32True)
        setProperty(txtColor, sprintf("%d",controls[selectedControl][TxtColor]))
    end if

    if not find(controls[selectedControl][Class], controlsWithOutColor) then
        if equal(controls[selectedControl][Class], "Window") then
            showProperty(color, w32True)
            setProperty(color, sprintf("%d",controls[selectedControl][BkColor]))
            --set System Colors
            showProperty(defaultColor, w32True)
            if length(controls[selectedControl][SystemBkColor]) then
                setPropertyCombo(defaultColor, 1, validColors)
                for i=1 to length(validColors) do
                    if equal(controls[selectedControl][SystemBkColor], validColors[i]) then
                        setPropertyCombo(defaultColor, i, validColors)
                        exit
                    end if
                end for
            end if
        else
            showProperty(color,w32True)
            setProperty(color, sprintf("%d",controls[selectedControl][BkColor]))
            if equal(controls[selectedControl][Class],"ProgressBar") then
                showProperty(barColor, w32True)
                setProperty(barColor, sprintf("%d",controls[selectedControl][BkBarColor]))
            end if
        end if
    end if

    if find(controls[selectedControl][Class], {"Window","Icon","ListView"}) then
        if equal(controls[selectedControl][Class], "ListView") then
            showProperty(iconFileLV, w32True)
            if length(controls[selectedControl][IcoFile]) then
                setPropertyCombo(iconFileLV, 1, controls[selectedControl][IcoFile])
            else
                setPropertyCombo(iconFileLV, 1, {""})
            end if
        else
            showProperty(iconFile, w32True)
            IcoFileName = controls[selectedControl][IcoFile]
            setProperty(iconFile, IcoFileName)
        end if
    end if

        --a PushButton control may be assigned multiline but that interferes with
        --PictureButton or TogglePicture if the class is later changed to one of these.
    if find(controls[selectedControl][Class],{"PictureButton","TogglePictrue"}) then
        controls[selectedControl][Multiline] = w32False
    end if

    if equal(controls[selectedControl][ParentClass], "FlatToolBar")
    and equal(controls[selectedControl][Class], "PictureButton") then
        showProperty(defFile, w32True)
        IcoFileName = controls[selectedControl][IcoFile]
        setProperty(defFile, IcoFileName)
    end if

    if equal(controls[selectedControl][ParentClass], "FlatToolBar")
    and equal(controls[selectedControl][Class], "PictureButton") then
        showProperty(hotFile, w32True)
        IcoFileName = controls[selectedControl][TwoIcoFile]
        setProperty(hotFile, IcoFileName)
    end if

    if equal(controls[selectedControl][ParentClass], "FlatToolBar")
    and equal(controls[selectedControl][Class], "PictureButton") then
        showProperty(disFile, w32True)
        IcoFileName = controls[selectedControl][TriIcoFile]
        setProperty(disFile, IcoFileName)
    end if

    if equal(controls[selectedControl][Class], "TreeView") then
        showProperty(closeFile, w32True)
        showProperty(openFile, w32True)
        IcoFileName = controls[selectedControl][TwoIcoFile]
        setProperty(closeFile, IcoFileName)
        IcoFileName = controls[selectedControl][TriIcoFile]
        setProperty(openFile, IcoFileName)
    end if

    if equal(controls[selectedControl][Class], "Bitmap") then
        showProperty(bitmap, w32True)
        BitmapFileName = controls[selectedControl][BitmapFile]
        setProperty(bitmap, BitmapFileName)
    end if

    if find(controls[selectedControl][Class], {"PictureButton","TogglePicture","Bitmap"})
    and not equal(controls[selectedControl][ParentClass], "FlatToolBar") then
        showProperty(bitmap, w32True)
        showProperty(XPMFile, w32True)
        showProperty(XPMMember, w32True)
        setPropEnabled(XPMMember, w32False)
        setPropEnabled(xpmmer, w32True)
        showProperty(xpmmer, w32True)
        setPropEnabled(xpmmerDisable, w32True)
        showProperty(xpmmerDisable, w32True)

        setProperty(xpmmerObject,"")
        setProperty(bitmap, "")
        setPropEnabled(xpmmerObject, w32False)
        showProperty(xpmmerObject, w32True)
        setProperty(xpmmerDisableObject,"")
        setPropEnabled(xpmmerDisableObject, w32False)
        showProperty(xpmmerDisableObject, w32True)

        if length(controls[selectedControl][XpmObject]) then
            setPropEnabled(xpmmerObject, w32True)
            setProperty(xpmmerObject, controls[selectedControl][Name] & "_xpm")
        end if

        if length(controls[selectedControl][XpmDisableObject]) then
            setPropEnabled(xpmmerDisableObject, w32True)
            setProperty(xpmmerDisableObject, controls[selectedControl][Name] & "D_xpm")
        end if

        if length(controls[selectedControl][BitmapFile]) then
            BitmapFileName = controls[selectedControl][BitmapFile]
            setProperty(bitmap, BitmapFileName)
            setPropEnabled(bitmap, w32True)
            setProperty(XPMFile,"")
            setProperty(XPMMember,"")
            setPropEnabled(XPMFile, w32False)
            setPropEnabled(XPMMember, w32False)
        elsif length(controls[selectedControl][XPM]) then
            XPMFileName = controls[selectedControl][XPM]
            setProperty(XPMFile, XPMFileName)
            setPropEnabled(XPMFile, w32True)
            setProperty(bitmap,"")
            setPropEnabled(bitmap, w32False)
            if length(XPMFileName)
            and not match(".xpm", lower(controls[selectedControl][XPM])) then
                setPropEnabled(XPMMember, w32True)
                setProperty(XPMMember, controls[selectedControl][XPMmember])
            end if
            if not length(XPMFileName) then
                setProperty(XPMMember,"")
            end if
        else
            setProperty(bitmap, "")
            setProperty(XPMFile, "")
            setProperty(XPMMember, "")
            setPropEnabled(XPMMember, w32False)
            setPropEnabled(bitmap, w32True)
            setPropEnabled(XPMFile, w32True)
        end if
    end if

    if equal(controls[selectedControl][Class], "ProgressBar") then
        setProperty(pbs_smooth, controls[selectedControl][PBS_smooth])
        showProperty(pbs_smooth, w32True)
        showProperty(minValue, w32True)
        showProperty(maxValue, w32True)
        setText(minValue,sprint(controls[selectedControl][MinValue]))
        setText(maxValue,sprint(controls[selectedControl][MaxValue]))
    end if

    if equal(controls[selectedControl][Class], "MonthCalendar") then
        setProperty(mcs_multiselect, controls[selectedControl][MCS_multiselect])
        showProperty(mcs_multiselect, w32True)
    end if

    if equal(controls[selectedControl][Class], "PushButton")
    and not controls[selectedControl][TreatAsColorButton] then
        setProperty(bs_flat, controls[selectedControl][BS_flat])
        showProperty(bs_flat, w32True)
    end if

    if equal(controls[selectedControl][Class], "Window") then
        showProperty(hintFont, w32True)
        showProperty(hintFontName, w32True)
        showProperty(hintFontPts, w32True)
        showProperty(hintFontAttrib, w32True)
        showProperty(hintFontItalic, w32True)
        showProperty(hintFontBold, w32True)
        showProperty(hintFontUnderline, w32True)
        showProperty(hintFontStrike, w32True)
        showProperty(showHintFontVar, w32True)

        if not length(controls[selectedControl][HintFontName]) then
            setProperty(hintFontName, theDefaultFont[1])--"<Default>")
        else
            setProperty(hintFontName, controls[selectedControl][HintFontName])
        end if
        if length(getProperty(hintFontName))
        or length(controls[selectedControl][HintFontVarName]) then

            setProperty(varhintFontName, controls[selectedControl][HintFontVarName])

            if controls[selectedControl][HintFontPts] then
                setProperty(hintFontPts, sprintf("%d",controls[selectedControl][HintFontPts]))
            else
                setProperty(hintFontPts,sprint(theDefaultFont[2]))--"")
            end if
            setProperty(varhintFontPts, controls[selectedControl][HintFontVarPts])

            if controls[selectedControl][HintFontAttrib] then
                setProperty(hintFontItalic, w32True)
            else
                setProperty(hintFontItalic, w32False)
            end if
            setProperty(varhintFontItalic, controls[selectedControl][HintFontVarItalic])

            if controls[selectedControl][HintFontBold] then
                setProperty(hintFontBold,w32True)
            else
                setProperty(hintFontBold,w32False)
            end if
            setProperty(varhintFontBold, controls[selectedControl][HintFontVarBold])

            if controls[selectedControl][HintFontUnderline] then
                setProperty(hintFontUnderline,w32True)
            else
                setProperty(hintFontUnderline,w32False)
            end if
            setProperty(varhintFontUnderline, controls[selectedControl][HintFontVarUnderline])

            if controls[selectedControl][HintFontStrikeout] then
                setProperty(hintFontStrike,w32True)
            else
                setProperty(hintFontStrike,w32False)
            end if
            setProperty(varhintFontStrike, controls[selectedControl][HintFontVarStrikeout])

            setProperty(showHintFontVar, controls[selectedControl][ShowHintFontVar])
            if controls[selectedControl][ShowHintFontVar] then
                showProperty(varhintFontName, w32True)
                showProperty(varhintFontPts, w32True)
                showProperty(varhintFontBold, w32True)
                showProperty(varhintFontItalic, w32True)
                showProperty(varhintFontUnderline, w32True)
                showProperty(varhintFontStrike, w32True)
            end if
        else
            setProperty(hintFontName, theDefaultFont[1])--"<Default>")         
            setProperty(hintFontPts, sprint(theDefaultFont[2]))--"")
            setProperty(hintFontItalic, w32False)
            setProperty(hintFontBold, w32False)
            setProperty(hintFontUnderline, w32False)
            setProperty(hintFontStrike, w32False)
            setProperty(varhintFontName, "")
            setProperty(varhintFontPts, "")
            setProperty(varhintFontItalic, "")
            setProperty(varhintFontBold, "")
            setProperty(varhintFontUnderline, "")
            setProperty(varhintFontStrike, "")
        end if
    else
        showProperty(showHintFontVar, w32False)
    end if

    if not find(controls[selectedControl][Class], {"ReBarBand","EuGrid"})
    and not equal(controls[selectedControl][SeqParentClass], "EuGrid") then
        showProperty(font, w32True)
        showProperty(fontName, w32True)
        showProperty(fontPts, w32True)
        showProperty(fontAttrib, w32True)
        showProperty(fontBold, w32True)
        showProperty(fontItalic, w32True)
        showProperty(fontUnderline, w32True)
        showProperty(fontStrike, w32True)
        showProperty(fontColor, w32True)

        if not length(controls[selectedControl][FontName]) then
            setProperty(fontName, theDefaultFont[1])--"<Default>")
        else
            setProperty(fontName, controls[selectedControl][FontName])
        end if
        if length(getProperty(fontName))
        or length(controls[selectedControl][FontVarName]) then

            setProperty(varfontName, controls[selectedControl][FontVarName])

            if controls[selectedControl][FontPts] then
                setProperty(fontPts, sprintf("%d",controls[selectedControl][FontPts]))
            else
                setProperty(fontPts, sprint(theDefaultFont[2]))--"")
            end if
            setProperty(varfontPts, controls[selectedControl][FontVarPts])


            if controls[selectedControl][FontAttrib] then
                setProperty(fontItalic, w32True)
            else
                setProperty(fontItalic, w32False)
            end if
            setProperty(varfontItalic, controls[selectedControl][FontVarItalic])

            if controls[selectedControl][FontBold] then
                setProperty(fontBold,w32True)
            else
                setProperty(fontBold,w32False)
            end if
            setProperty(varfontBold,controls[selectedControl][FontVarBold])

            if controls[selectedControl][FontUnderline] then
                setProperty(fontUnderline,w32True)
            else
                setProperty(fontUnderline,w32False)
            end if
            setProperty(varfontUnderline, controls[selectedControl][FontVarUnderline])

            if controls[selectedControl][FontStrikeout] then
                setProperty(fontStrike,w32True)
            else
                setProperty(fontStrike,w32False)
            end if
            setProperty(varfontStrike,controls[selectedControl][FontVarStrikeout])

            if equal(controls[selectedControl][Class], "RichEdit") then
                setPropEnabled(fontColor, w32True)
                setProperty(fontColor, sprintf("%d",controls[selectedControl][FontColor]))
            else
                setPropEnabled(fontColor, w32False)
                setProperty(fontColor, "")
            end if

            if equal(controls[selectedControl][Class], "RichEdit") then
                setPropEnabled(varfontColor, w32True)
                setProperty(varfontColor, controls[selectedControl][FontVarColor])
            else
                setPropEnabled(varfontColor, w32False)
                setProperty(varfontColor, "")
            end if

            setProperty(showFontVar, controls[selectedControl][ShowFontVar])
            if controls[selectedControl][ShowFontVar] then
                showProperty(varfontName, w32True)
                showProperty(varfontPts, w32True)
                showProperty(varfontBold, w32True)
                showProperty(varfontItalic, w32True)
                showProperty(varfontUnderline, w32True)
                showProperty(varfontStrike, w32True)
                showProperty(varfontColor, w32True)
            end if
        else
            setProperty(fontName, theDefaultFont[1])--"<Default>")
            setProperty(fontPts, sprint(theDefaultFont[2]))--"")
            setProperty(fontItalic,w32False)
            setProperty(fontBold, w32False)
            setProperty(fontUnderline, w32False)
            setProperty(fontStrike, w32False)
            setProperty(fontColor, "")
            setProperty(varfontName, "")
            setProperty(varfontPts, "")
            setProperty(varfontItalic,"")
            setProperty(varfontBold, "")
            setProperty(varfontUnderline, "")
            setProperty(varfontStrike, "")
            setProperty(fontColor, "")
        end if
    end if

    showProperty(hintText, w32True)
    showProperty(varhintText, w32True)
    setProperty(hintText, controls[selectedControl][HintText])
    setProperty(varhintText, controls[selectedControl][HintVarText])

    if equal(controls[selectedControl][Class], "TabItem") then
        tabNewTitle = controls[selectedControl][Name]

    --else if it is a control within the tabItem be sure
    --to flag its tabItemParent's title as tabNewTitle
    --this allows the tabItemCombo to be rehighlighted for
    --the currently using tabItem
    elsif length(controls[selectedControl][ControlParent])
      and equal(controls[selectedControl][ParentClass], "TabItem") then
        flag = findSeqParentName(selectedControl)
        if flag then
            tabNewTitle = controls[flag][Name]
        end if
    end if

    if equal(controls[selectedControl][Class], "EuGrid") then
        showProperty(gridHeaderInfo, w32True)
        showProperty(gridHeaderColor, w32True)
        showProperty(gridHeaderColHeight, w32True)
        showProperty(gridHeaderRowWidth, w32True)
        showProperty(gridHeaderDataCol, w32True)
        showProperty(gridHeaderDataColVal, w32True)
        setPropEnabled(gridHeaderDataColVal, w32False)
        showProperty(gridRowHeight, w32True)
        showProperty(gridTextAlign, w32True)
        showProperty(gridLineColor, w32True)
        showProperty(gridTextColor, w32True)
        showProperty(gridColors, w32True)
        showProperty(gridCellBkColor, w32True)
        showProperty(gridFormat, w32True)
        showProperty(gridDataArrayName, w32True)
        showProperty(gridRowSelect, w32True)
        showProperty(gridActiveHeaders, w32True)
        showProperty(gridAllowColResize, w32True)
        showProperty(gridAllowColSort, w32True)
        showProperty(gridCellBorder, w32True)
        showProperty(gridHighlightText, w32True)
        showProperty(gridBkColorSelect, w32True)
        showProperty(gridCellBorderColor, w32True)
        showProperty(gridTextColorSelect, w32True)
        showProperty(gridHeaderColHeight, w32True)

        if controls[selectedControl][GridColHeaderCY] then
            setProperty(gridHeaderColHeight, sprintf("%d",controls[selectedControl][GridColHeaderCY]))
        else
            setProperty(gridHeaderColHeight,"0")
        end if

        if controls[selectedControl][GridRowHeaderCX] then
            setProperty(gridHeaderRowWidth, sprintf("%d",controls[selectedControl][GridRowHeaderCX]))
        else
            setProperty(gridHeaderRowWidth,"0")
        end if

        if controls[selectedControl][GridRowCY] then
            setProperty(gridRowHeight, sprintf("%d",controls[selectedControl][GridRowCY]))
        else
            setProperty(gridRowHeight,"0")
        end if

        if controls[selectedControl][GridHeaderColor] then
            setProperty(gridHeaderColor, sprintf("%d",controls[selectedControl][GridHeaderColor]))
        else
            setProperty(gridLineColor,"0")
        end if

        if controls[selectedControl][GridLineColor] then
            setProperty(gridLineColor, sprintf("%d",controls[selectedControl][GridLineColor]))
        else
            setProperty(gridLineColor,"0")
        end if

        if controls[selectedControl][GridTextColor] then
            setProperty(gridTextColor, sprintf("%d",controls[selectedControl][GridTextColor]))
        else
            setProperty(gridTextColor,"0")
        end if

        if controls[selectedControl][GridBkColorRows] then
            setProperty(gridCellBkColor, sprintf("%d",controls[selectedControl][GridBkColorRows]))
        else
            setProperty(gridCellBkColor,"0")
        end if

        if controls[selectedControl][GridBkSelectColor] then
            setProperty(gridBkColorSelect, sprintf("%d",controls[selectedControl][GridBkSelectColor]))
        else
            setProperty(gridBkColorSelect,"0")
        end if

        if controls[selectedControl][GridCellBorderColor] then
            setProperty(gridCellBorderColor, sprintf("%d",controls[selectedControl][GridCellBorderColor]))
        else
            setProperty(gridCellBorderColor,"0")
        end if

        if controls[selectedControl][GridTextColorSelect] then
            setProperty(gridTextColorSelect, sprintf("%d",controls[selectedControl][GridTextColorSelect]))
        else
            setProperty(gridTextColorSelect,"0")
        end if

        at = controls[selectedControl][GridTextAlign]
        if not at then
            at = 1
        end if
        setPropertyCombo(gridTextAlign, at, {"Left", "Center", "Right"})

        at = controls[selectedControl][GridHeaderType]
        if not at then
            at = 1
        end if
        setPropertyCombo(gridHeaderDataCol, at, {"Actual Col","Arrows","Row Number"})
        if at=1 then
            setPropEnabled(gridHeaderDataColVal, w32True)
        end if

        if length(controls[selectedControl][GridFormat]) then
            setProperty(gridFormat, controls[selectedControl][GridFormat])
        else
            setProperty(gridFormat,"")
        end if

        at = controls[selectedControl][GridRowSelect]
        if not at then
            at = 1
        end if
        setPropertyCombo(gridRowSelect, at, {"Single", "None"})

        if length(controls[selectedControl][GridDataArrayName]) then
            setProperty(gridDataArrayName, controls[selectedControl][GridDataArrayName])
        else
            setProperty(gridDataArrayName,"")
        end if

        if controls[selectedControl][GridActiveHeaders] then
            setProperty(gridActiveHeaders, w32True)
        end if

        if controls[selectedControl][GridAllowColResize] then
            setProperty(gridAllowColResize, w32True)
        end if

        if controls[selectedControl][GridAllowColSort] then
            setProperty(gridAllowColSort, w32True)
        end if

        if controls[selectedControl][GridCellBorder] then
            setProperty(gridCellBorder, w32True)
        end if

        if controls[selectedControl][GridHighlightText] then
            setProperty(gridHighlightText, w32True)
        end if

    end if

    if equal(controls[selectedControl][SeqParentClass], "EuGrid") then
        showProperty(gridColAlign, w32True)
        showProperty(gridColTextColor, w32True)

        if controls[selectedControl][GridColTextColor] then
            setProperty(gridColTextColor, sprintf("%d",controls[selectedControl][GridColTextColor]))
        else
            setProperty(gridTextColor,"0")
        end if
        at = 1
        if equal(controls[selectedControl][Class], "CText") then
            at = 2
        elsif equal(controls[selectedControl][Class], "RText") then
            at = 3
        end if

        if controls[selectedControl][GridTextAlign] then
            at = controls[selectedControl][GridTextAlign]
        end if
        setPropertyCombo(gridColAlign, at, {"Left", "Center", "Right"})

        if equal(controls[selectedControl][Class], "Combo") then
            showProperty(gridColListDataCol, w32True)
            showProperty(gridColListValues, w32True)
            if controls[selectedControl][GridColListDataCol] then
                setProperty(gridColListDataCol, sprintf("%d",controls[selectedControl][GridColListDataCol]))
            else
                setProperty(gridColListDataCol,"0")
            end if

            if length(controls[selectedControl][GridColListValues]) then
                setProperty(gridColListValues, controls[selectedControl][GridColListValues])
            else
                setProperty(gridColListValues,"")
            end if
        end if

        if find(controls[selectedControl][Class], {"EditText","LText",
                                                   "CText","RText"}) then
            showProperty(gridCellFormat, w32True)
            setPropEnabled(gridCellFormat, w32True)
            if not controls[selectedControl][Numeric]then
                controls[selectedControl][GridFormat] = {}
                setProperty(gridCellFormat,"")
                setPropEnabled(gridCellFormat, w32False)
            else
                if length(controls[selectedControl][GridFormat]) then
                    setProperty(gridCellFormat, controls[selectedControl][GridFormat])
                else
                    setProperty(gridCellFormat,"")
                end if
            end if
        else
            setProperty(gridCellFormat,"")
            controls[selectedControl][GridFormat] = {}
            showProperty(gridCellFormat, w32False)
            setPropEnabled(gridCellFormat, w32False)
        end if

    end if

    redrawProperties(1)
    skipValidations = w32False
    eraseItems(EventListView)
    findCodeForEventList()

    --setting focus allows us to use delete key on a control in Design
    --sometimes we don't want to do that, such as when the changeProperty
    --routine sends us back here.
    if focusDesign then
        if showActive then
            setFocus(Show)
        elsif offsetActive then
            setFocus(OffScreen)
        else
            setFocus(Design)
        end if
    end if

    focusDesign = w32True

end procedure
updateProperties_id = routine_id("updateProperties")
------------------------------------------------------------------------------
procedure fontColor_colorDialog()
integer color

    if controls[selectedControl][FontColor] then
        color = getColorDialog(Form, controls[selectedControl][FontColor])
    else
        color = getColorDialog(Form, 0)
    end if

    focusDesign = w32False
    controls[selectedControl][FontColor] = color
    updateProperty("Font Color")
end procedure
fontColor_id = routine_id("fontColor_colorDialog")
------------------------------------------------------------------------------
--code supplied by Matt Lewis
--and split into screen event and keyDown by Derek Parnell
integer alt_down
alt_down = 0
procedure Screen_event(integer Self, integer Event, sequence Params)

    if Params[1]=WM_SYSKEYDOWN then
        --checks for Alt-F4 to close IDE
        if Params[2]=18 then
            alt_down = 1
        elsif Params[2]=VK_F4 and alt_down then
            returnValue(1)
            closeWindow(Controls)
        end if
    elsif Params[1]=WM_SYSKEYUP then
        if Params[2]=18 then
            alt_down = 0
        end if
    end if
end procedure
setHandler(Screen, w32HEvent, routine_id("Screen_event"))
-----------------------------------------------------------------------------
sequence vGlobalKeys,
         vProcId

vGlobalKeys = {VK_F5,     VK_F6,     VK_F12, VK_F1, VK_F2, VK_F3, VK_F4}
vProcId =     {MenuRun, MenuRunTemp, MenuSaveAs,    -1,    -2,    -3,   -4}
procedure Screen_keydown(integer Self, integer Event, sequence Params)

integer lKey
integer index,action                --Launch

-- See if this is a key I'm interested in.
    lKey = find(Params[1], vGlobalKeys)
    if lKey=1 then  --F5                   
        ok = invokeHandler(MenuRun,w32HClick,{})
        return
    end if
    if lKey=2 then  --F6            
        ok = invokeHandler(MenuRunTemp,w32HClick,{})
        return
    end if
    if lKey!=0 then
        downButton = -vProcId[lKey]
        if downButton<0 then
            ok = invokeHandler(-downButton, w32HClick, {})
        else
            if (downButton=3
                and not doingFind)
            or downButton!=3 then
                if length(controls[selectedControl][XpmObject]) then
                    if downButton=1 then
                        downButton = 13
                    end if
                end if
                if length(controls[selectedControl][XpmDisableObject]) then
                    if downButton=2 then
                        downButton = 14
                    end if
                end if

                if downButton=13 or downButton=14 then
                    -- draw selected control                        
                    drawControl(ControlBlit, controls[selectedControl], Normal, selectedControl, 0)
                    drawControl(ControlBlit, controls[selectedControl], Selected, selectedControl, 0)
                    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
                else
                    call_proc(drawIt_id, {})
                end if
            end if
        end if
    end if

    -- hot keys for Launcher
    -- control key held down?
    if and_bits(Params[2], ControlMask)
    and not and_bits(Params[2],AltMask) then
       -- control key is held down
        if Params[1]>47 and Params[1]<58 then   -- ctrl-0 .. ctrl-9
            index = w32iff(Params[1]>48, Params[1]-48, 10)
            if atom(AppFiles[index][L_AppItemId]) then
                LaunchItemId = (AppFiles[index][L_AppItemId])
             -- call_proc
                action = invokeHandler(LaunchItemId, w32HClick, {})
            end if
        end if
    end if

    if Params[1]=VK_ESCAPE
    and FindWin=getActiveWindow() then
        closeWindow(FindWin)
    end if

end procedure
setHandler(Screen, w32HKeyDown, routine_id("Screen_keydown"))
-----------------------------------------------------------------------------
procedure keyPressScreen(integer Self, integer Event, sequence Params)
integer keyCode, shift

    keyCode = Params[1]
    shift   = Params[2]

    -- hot keys
    if and_bits(shift, ShiftMask) then
        if keyCode=65 then
            --Shift-A
            MultiPropertySelect = {}
        end if
    end if
    if and_bits(shift, ControlMask) then
        if keyCode=15 then
            --ctrl-O
            if getActiveWindow()=CodeWin
            or getActiveWindow()=Highlight then
                --allow syntax to take control
            else
                ok = invokeHandler(MenuOpen, w32HClick,{})
            end if
        end if
        if keyCode=16
        and isEnabled(MenuPropertyOpen) then
            --ctrl-P
            ok = invokeHandler(MenuPropertyOpen, w32HClick,{})
        end if

        if keyCode=19 then
            --ctrl-S
            if getActiveWindow()=CodeWin
            or getActiveWindow()=Highlight then
                --allow syntax to take control
            else
                ok = invokeHandler(MenuSave,w32HClick,{})
            end if
        end if

        if keyCode=20
        and isEnabled(MenuIconBarOpen) then
            --ctrl-T
            ok = invokeHandler(MenuIconBarOpen, w32HClick,{})
        end if

        if keyCode=12 then
            --ctrl-L
            ok = invokeHandler(MenuInitValueEditor, w32HClick,{})
        end if

        if keyCode=10
        and isEnabled(MenuProjectViewOpen) then
            --ctrl-J
            ok = invokeHandler(MenuProjectViewOpen, w32HClick,{})
        end if

        if keyCode=13 then
            --ctrl-M
            ok = invokeHandler(MenuMenuEditor, w32HClick,{})
        end if

        if keyCode=21 then
            --ctrl-U
            ok = invokeHandler(MenuPopupEditor, w32HClick,{})
        end if

        if keyCode=5 then
            --ctrl-E
            ok = invokeHandler(MenuCodeEditor, w32HClick,{})
        end if

        if keyCode=23 then
            --ctrl-W
            ok = invokeHandler(MenuTimerEditor, w32HClick,{})
        end if

        if keyCode=1 then
            --ctrl-A
            if getActiveWindow()=CodeWin
            or getActiveWindow()=Highlight then
                --allow syntax to take control
            else
                ok = invokeHandler(MenuIncludeOrder, w32HClick,{})
            end if
        end if
    end if
end procedure
setHandler(Screen, w32HKeyPress, routine_id("keyPressScreen"))
-----------------------------------------------------------------------------
procedure checkIfText(sequence ctrl)
    if equal(ctrl[Class], "LText")
    or equal(ctrl[Class], "RText")
    or equal(ctrl[Class], "CText") then
        --find if this control has any controls in it
        if length(ctrl[SeqChildName]) then
            --draw the Text with borders
            drawControl(ControlBlit, ctrl, Borders, 1, 0)
        end if
    end if
end procedure
------------------------------------------------------------------------------
procedure drawTabControlChildren(integer index)
integer childCnt, flag, withHatching

    childCnt = 0
    if not length(controls[index][SeqChildName]) then
        return
    end if

    for k=index to length(controls) do
        if find(controls[k][Name], controls[index][SeqChildName]) then
            childCnt += 1

            withHatching = w32False
            if hatchBackground
            and not GridHide then
                --hatch the menu bar
                withHatching = w32True
            end if

            if equal(controls[k][Class], "TabControl") then
                -- draw as normal
                drawControl(ControlBlit, controls[k], Normal,k, withHatching)
                drawTabControlChildren(k)
            elsif equal(controls[k][Class], "TabItem") then
                if controls[k][Active] then
                    --draw the tabitem
                    if k=selectedControl then
                        -- draw as selected
                        drawControl(ControlBlit, controls[k], Selected,k, withHatching)
                    else
                        -- draw as normal
                        drawControl(ControlBlit, controls[k], Normal,k, withHatching)
                    end if
                    drawTabControlChildren(k)
                end if
            else
                -- a control on tab, group, table and draw as normal
                --if a control in Table find the parent and its FitToTable value
                if length(controls[k][SeqParentName]) then
                    flag = findSeqParentName(k)
                    if flag then
                        if not controls[flag][FitToTable] then
                            if controls[k][X]+controls[k][CX]>controls[flag][X]+controls[flag][CX]
                            or controls[k][Y]+controls[k][CY]>controls[flag][Y]+controls[flag][CY] then
                                --don't draw it or know about it anywhere else in IDE except for exw
                                if equal(controls[k][SeqParentClass],"Table") then
                                    if controls[k][TableCell]=1 then
                                        --must keep showing cell 1 controls
                                        controls[k][DontDraw] = w32False
                                    else
                                        controls[k][DontDraw] = w32True
                                    end if
                                else
                                    controls[k][DontDraw] = w32False
                                end if

                            else
                                controls[k][DontDraw] = w32False
                            end if
                        else
                            controls[k][DontDraw] = w32False
                        end if
                    end if
                end if

                if not controls[k][DontDraw] then
                    drawControl(ControlBlit, controls[k], Normal,k, withHatching)
                end if
                checkIfText(controls[k])
                --it might have children eg. Group
                drawTabControlChildren(k)
            end if
        end if
    end for

end procedure
------------------------------------------------------------------------------
procedure drawTheTableCell(sequence control, integer j)
integer withHatching

    withHatching = w32False
    if hatchBackground
    and not GridHide then
        --hatch the menu bar
        withHatching = w32True
    end if

    --draw
    if j=selectedControl then
        -- draw as selected
        drawControl(ControlBlit, control, Selected,j, 0)
    else
        -- draw as normal
        drawControl(ControlBlit, control, Normal,j, withHatching)
    end if
    checkIfText(control)
end procedure
--------------------------------------------------------------------------------
--function changeYforChild(integer index, sequence reMake)
--integer childCnt
--
--  childCnt = 0
--  for i=index to length(reMake) do
--      if find(reMake[i][ParentClass],{"ReBar","ReBarBand"}) then
--          if find(reMake[i][Name], reMake[index][SeqChildName]) then
--              childCnt += 1
--              reMake[i][Y] = reMake[index][Y]
--          end if
--          if childCnt>=length(reMake[index][SeqChildName]) then
--              exit
--          end if
--      end if
--  end for
--
--  return reMake
--end function
--------------------------------------------------------------------------------
procedure drawHiddenControls(integer top)
    if top=TheWindow then
        return
    end if

    for i=1 to length(controls) do
        if find(controls[i][ControlLayer],showBackLayer)
        and not find(controls[i][ParentClass], {"TabControl","TabItem"})
        and not find(controls[i][SeqParentClass],  {"TabControl","TabItem"})
        and i!=top then
            if controls[i][X]>controls[top][X]
            and controls[i][Y]>controls[top][Y]
            and controls[i][X]+controls[i][CX]-1<controls[top][X]+controls[top][CX]-1
            and controls[i][Y]+controls[i][CY]-1<controls[top][Y]+controls[top][CY]-1 then
                drawControl(ControlBlit, controls[i], RedSelected,i,0)
            end if
        end if
    end for
end procedure
drawHiddenControls_id = routine_id("drawHiddenControls")
--------------------------------------------------------------------------------
sequence childLocation  childLocation = {}
procedure drawItAll()

integer tmp, tmpSelected, index, ok, xAdd, yAdd, newX, newY, newCY, thisBarChild,thisBarBandChild,
            farOut, testFontAttrib, reBuildToolBar, toolBarIndex, thisBar,reBarSeq,
            reBarCnt, reBarChildCnt, toolbarCnt,theBarChildCnt,
            cnt, totalCX,childCnt, withHatching, rebarparent, diff, totalCY,thisY,
            childHeight, reBarRBBS, childX, childY, xCount,fnd
sequence extent, text, textLen, parentName, childloc


    --sometimes want to delay drawing because it is called multiple times
    if delayDraw then
        return
    end if

    index = 0

    tabItemCoordinates = {}

    if equal(controls[selectedControl][Class] , "Window") then
        --reset the Layer Tab
        setRect(LayersTC, 0, 0, controls[selectedControl][CX], 20, w32True)
    end if

    --did Design Pad get resized?
    --if so refigure the ToolBar, FlatToolBar, StatusBar, Rebar

    if repaintWinResize then
        repaintWinResize = w32False
        childloc = {"",0,0}

        --recalculate the ReBar and ReBarBand in event something added, moved or deleted        
        if haveReBar then   --set in newcontrol when add a rebar and removed when delete
            for i=1 to length(controls) do
                if equal(controls[i][Class], "ReBar")
                and controls[i][ControlLayer]=thelayerNumber then
                    reBarSeq = i
                    --get its parent, if any
                    rebarparent = findSeqParentName(reBarSeq)

                    if not rebarparent then
                        rebarparent = TheWindow
                    end if

                    if not find(controls[rebarparent][Class],{"Window","CWindow"}) then
                        rebarparent = TheWindow
                    end if

                    --if font trap it now
                    if length(controls[reBarSeq][FontName]) then
                        testFontAttrib = 0
                        if controls[reBarSeq][FontAttrib] then
                            testFontAttrib = Italic
                        end if

                        testFontAttrib += controls[reBarSeq][FontBold]

                        if controls[reBarSeq][FontStrikeout] then
                            testFontAttrib += 8
                        end if

                        if controls[reBarSeq][FontUnderline] then
                            testFontAttrib += 4
                        end if
                        setFont(ControlBlit, controls[reBarSeq][FontName], controls[reBarSeq][FontPts],
                                testFontAttrib)
                    end if

                    newY = 0
                    newX = 0
                    newCY = 17
                    totalCY = newCY
                    textLen = {0,0}
                    childHeight = 0

                    reBarCnt = 0

                    --set width of reBar to its parent
                    controls[reBarSeq][CX] = controls[rebarparent][CX]

                    --save selectedControl for the duration of this routine
                    tmpSelected = selectedControl

                    selectedControl = reBarSeq
                    if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                      getIndex(PropertyTitleBar))) then
                        call_proc(updateProperty_id,{"Width"})
                    end if
                    if equal(controls[rebarparent][Class], "CWindow") then
                        controls[reBarSeq][Y] = controls[rebarparent][Y]
                        controls[reBarSeq][X] = controls[rebarparent][X]
                        if isCWindowTitleBar(rebarparent) then
                            controls[reBarSeq][Y] = controls[rebarparent][Y]+titleBar+borderY
                            controls[reBarSeq][X] = controls[rebarparent][X]+borderX
                            controls[reBarSeq][CX] = controls[rebarparent][CX]-(2*borderX)
                        end if
                        if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                          getIndex(PropertyTitleBar))) then
                            call_proc(updateProperty_id,{"Row"})
                            call_proc(updateProperty_id,{"Column"})
                            call_proc(updateProperty_id,{"Width"})
                        end if
                    end if

                        ---------------------------------------
                        --look at children of ReBar: ReBarBands
                        ---------------------------------------                  
                    if length(controls[reBarSeq][SeqChildName]) then
                        for j=reBarSeq to length(controls) do
                            if find(controls[j][Name], controls[reBarSeq][SeqChildName]) then
                                thisBarChild = j
                                if equal(controls[thisBarChild][Class], "ReBarBand") then
                                --set ReBarBand width to width of ReBar less a little offset
                                    controls[thisBarChild][CX] = controls[rebarparent][CX]-5
                                    if isCWindowTitleBar(rebarparent) then
                                        --further reduce when titlebar
                                        controls[thisBarChild][CX] -= borderX
                                    end if
                                    selectedControl = thisBarChild
                                    if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                      getIndex(PropertyTitleBar))) then
                                        call_proc(updateProperty_id,{"Width"})
                                    end if
                                    reBarCnt += 1
                                    --first reset height to agree with ReBar's less 7 pixels; need to do this
                                    --in case a control is added to reBarband and later removed
                                    controls[thisBarChild][CY] = 14
                                    if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                      getIndex(PropertyTitleBar))) then
                                        call_proc(updateProperty_id,{"Height"})
                                    end if
                                    textLen = getTextExtent(ControlBlit, controls[thisBarChild][Title])
                                    if textLen[1]=0 then
                                        textLen[1] = 5
                                    end if

                                    --adjust X and Y
                                    if reBarCnt=1 then
                                        controls[thisBarChild][X] = 5+controls[rebarparent][X]
                                        controls[thisBarChild][Y] = controls[reBarSeq][Y]+3
                                        if equal(controls[thisBarChild][Name], getItem(PropertyTitleBar,
                                                                                       getIndex(PropertyTitleBar))) then
                                            call_proc(updateProperty_id,{"Row"})
                                            call_proc(updateProperty_id,{"Column"})
                                        end if
                                        --newY is a running count of where the next reBarband is if not
                                        --on the same 'row'
                                        newY = controls[thisBarChild][Y]+controls[thisBarChild][CY]+3
                                        newX = 5+controls[thisBarChild][CX]+controls[rebarparent][X]
                                        thisY = controls[thisBarChild][Y]
                                        if newX>controls[rebarparent][CX] then
                                            controls[thisBarChild][CX] = controls[rebarparent][CX]-5
                                            if isCWindowTitleBar(rebarparent) then
                                                --further reduce when titlebar
                                                controls[thisBarChild][CX] -= borderX
                                            end if
                                            if equal(controls[thisBarChild][Name], getItem(PropertyTitleBar,
                                                                                           getIndex(PropertyTitleBar))) then
                                                call_proc(updateProperty_id,{"Width"})
                                            end if
                                        end if
                                    else
                                        if controls[thisBarChild][RBBSBREAK] then
                                            controls[thisBarChild][Y] = newY
                                            controls[thisBarChild][X] = 5+controls[rebarparent][X]
                                            if equal(controls[thisBarChild][Name], getItem(PropertyTitleBar,
                                                                                           getIndex(PropertyTitleBar))) then
                                                call_proc(updateProperty_id,{"Row"})
                                                call_proc(updateProperty_id,{"Column"})
                                            end if
                                            newX = 5+controls[rebarparent][X]
                                            if newX>controls[rebarparent][CX] then
                                                controls[thisBarChild][CX] = controls[rebarparent][CX]-5
                                                if isCWindowTitleBar(rebarparent) then
                                                    --further reduce when titlebar
                                                    controls[thisBarChild][CX] -= borderX
                                                end if
                                                if equal(controls[thisBarChild][Name], getItem(PropertyTitleBar,
                                                                                               getIndex(PropertyTitleBar))) then
                                                    call_proc(updateProperty_id,{"Width"})
                                                end if
                                            end if
                                            thisY = newY
                                            newY = controls[thisBarChild][Y]+controls[thisBarChild][CY]
                                        else
                                            --put it behind the prior reBarBand                                                             
                                            controls[thisBarChild][Y] = thisY
                                            controls[thisBarChild][X] = newX-(textLen[1]+5)
                                            --if rebarband spills over rebar then truncate it
                                            controls[thisBarChild][CX] = textLen[1]+5
                                            if equal(controls[thisBarChild][Name], getItem(PropertyTitleBar,
                                                                                           getIndex(PropertyTitleBar))) then
                                                call_proc(updateProperty_id,{"Row"})
                                                call_proc(updateProperty_id,{"Column"})
                                                call_proc(updateProperty_id,{"Width"})
                                            end if
                                            --save next X position                                                  
                                            newX += controls[rebarparent][CX]
                                        end if
                                    end if

                                    --get its CY or CY determined by ReBar font
                                    if textLen[2]>controls[thisBarChild][CY] then
                                        diff = textLen[2]-controls[thisBarChild][CY]
                                        newY += diff
                                        controls[thisBarChild][CY] = textLen[2]
                                        if equal(controls[thisBarChild][Name], getItem(PropertyTitleBar,
                                                                                       getIndex(PropertyTitleBar))) then
                                            call_proc(updateProperty_id,{"Height"})
                                        end if
                                    end if
                                    newCY = controls[thisBarChild][CY]

                        -----------------------------------            
                                    --now look at children of rebarband
                                    -----------------------------------
                                    reBarChildCnt = 0
                                    if length(controls[thisBarChild][SeqChildName]) then
                                        farOut = 0
                                        for k=thisBarChild to length(controls) do
                                            if find(controls[k][Name], controls[thisBarChild][SeqChildName]) then
                                                controls[k][DontDraw] = w32False
                                                if not controls[thisBarChild][RBBSBREAK] then
                                                    controls[k][DontDraw] = w32True
                                                end if
                                                thisBarBandChild = k
                                                reBarChildCnt += 1

                                                                        --save original x and y for moving child control's children
                                                childX = controls[k][X]
                                                childY = controls[k][Y]
                                                if reBarChildCnt=1 then
                                                --adjust its X
                                                    controls[k][X] = 5+textLen[1]+5+controls[rebarparent][X]
                                                    if find(controls[k][Class],{"ToolBar","FlatToolBar"}) then
                                                        controls[k][CX] = controls[thisBarChild][CX]-controls[k][X]
                                                        if equal(controls[k][Name], getItem(PropertyTitleBar,
                                                                                            getIndex(PropertyTitleBar))) then
                                                            call_proc(updateProperty_id,{"Width"})
                                                        end if
                                                    end if
                                                    selectedControl = k
                                                    if equal(controls[k][Name], getItem(PropertyTitleBar,
                                                                                        getIndex(PropertyTitleBar))) then
                                                        call_proc(updateProperty_id,{"Column"})
                                                    end if
                                                    --find x for next control on same rebarband                                                                             
                                                    farOut = controls[k][X]+controls[k][CX]
                                                else
                                                    controls[k][X] = farOut
                                                    if equal(controls[k][Name], getItem(PropertyTitleBar,
                                                                                        getIndex(PropertyTitleBar))) then
                                                        call_proc(updateProperty_id,{"Column"})
                                                    end if
                                                    farOut += controls[k][CX]
                                                end if
                                                --however if rebarBand is not RBBSBREAK we show
                                                --the control at end
                                                if not controls[thisBarChild][RBBSBREAK] then
                                                    controls[k][Y] = thisY
                                                    controls[k][X] = controls[thisBarChild][X]+
                                                                     textLen[1]
                                                    if equal(controls[k][Name], getItem(PropertyTitleBar,
                                                                                        getIndex(PropertyTitleBar))) then
                                                        call_proc(updateProperty_id,{"Row"})
                                                        call_proc(updateProperty_id,{"Column"})
                                                    end if
                                                end if

                                                --get the tallest control from any band
                                                if controls[k][CY]>childHeight then
                                                    childHeight = controls[k][CY]
                                                end if

                                                --child controls on rebarband at same Y as rebarband + 1
                                                controls[k][Y] = controls[thisBarChild][Y]+1
                                                if equal(controls[thisBarChild][Name], getItem(PropertyTitleBar,
                                                                                               getIndex(PropertyTitleBar))) then
                                                    call_proc(updateProperty_id,{"Row"})
                                                end if
                                                if controls[thisBarBandChild][CY]+4>newCY then
                                                    newCY = controls[thisBarBandChild][CY]+4
                                                end if
                                                if newCY>newY then
                                                    newY = newCY
                                                end if
                                                if length(controls[k][SeqChildName]) then
                                                    xCount = 0
                                                    for xx=k to length(controls) do
                                                        if find(controls[xx][Name],controls[k][SeqChildName]) then
                                                            xCount += 1
                                                            controls[xx][DontDraw] = w32False
                                                            if controls[k][DontDraw] then
                                                                controls[xx][DontDraw] = w32True
                                                            end if
                                                            --get displacaement from original position of parent
                                                            if not controls[thisBarChild][RBBSBREAK] then
                                                                fnd = w32False
                                                                for yy=1 to length(childLocation) do
                                                                    if equal(controls[xx][Name], childLocation[yy][1]) then
                                                                        childloc[2] = controls[xx][X]
                                                                        childloc[3] = controls[xx][Y]
                                                                        fnd = w32True
                                                                        exit
                                                                    end if
                                                                end for
                                                                if not fnd then
                                                                    childloc[1] = controls[xx][Name]
                                                                    childloc[2] = controls[xx][X]
                                                                    childloc[3] = controls[xx][Y]
                                                                    childLocation &= {childloc}
                                                                end if
                                                                controls[xx][X] -= (childX-controls[k][X])
                                                                controls[xx][Y] -= (childY-controls[k][Y])
                                                            else
                                                                for yy=1 to length(childLocation) do
                                                                    if equal(childLocation[yy][1], controls[xx][Name]) then
                                                                        controls[xx][X] = childLocation[yy][2]
                                                                        controls[xx][Y] = childLocation[yy][3]
                                                                    end if
                                                                end for
                                                            end if
                                                            selectedControl = xx
                                                            if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                                              getIndex(PropertyTitleBar))) then
                                                                call_proc(updateProperty_id,{"Row"})
                                                                call_proc(updateProperty_id,{"Column"})
                                                            end if
                                                        end if
                                                        if xCount>=length(controls[k][SeqChildName]) then
                                                            exit
                                                        end if
                                                    end for
                                                end if
                                                if reBarChildCnt>=length(controls[thisBarChild][SeqChildName]) then
                                                    exit
                                                end if
                                            end if
                                        end for
                                        --adjust reBarband                      
                                        controls[thisBarChild][CY] = newCY
                                        selectedControl = thisBarChild
                                        if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                          getIndex(PropertyTitleBar))) then
                                            call_proc(updateProperty_id,{"Height"})
                                        end if
                                    end if
                                end if
                            end if
                            if reBarCnt>=length(controls[reBarSeq][SeqChildName]) then
                                exit
                            end if
                        end for
                    end if

                        --refigure placement now
                    reBarCnt = 0
                    totalCY = 0
                    reBarRBBS = 0

                    for x=reBarSeq to length(controls) do
                        if find(controls[x][Name], controls[reBarSeq][SeqChildName]) then
                            if equal(controls[x][Class], "ReBarBand") then
                                reBarCnt += 1
                                if controls[x][RBBSBREAK] then
                                    reBarRBBS += 1

                                    if childHeight then
                                        controls[x][CY] = childHeight+4
                                    else
                                        controls[x][CY] = 14
                                    end if
                                    selectedControl = x
                                    if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                      getIndex(PropertyTitleBar))) then
                                        call_proc(updateProperty_id,{"Height"})
                                    end if

                                    if reBarCnt=1 then
                                        controls[x][Y] = controls[reBarSeq][Y]+3
                                    else
                                        controls[x][Y] = 3+((reBarRBBS-1)*childHeight)+4
                                        if equal(controls[rebarparent][Class],"CWindow") then
                                            controls[x][Y] += controls[rebarparent][Y]
                                            if isCWindowTitleBar(rebarparent) then
                                                controls[x][Y] += (titleBar+borderY)
                                            end if
                                        end if
                                    end if
                                    if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                      getIndex(PropertyTitleBar))) then
                                        call_proc(updateProperty_id,{"Row"})
                                    end if

                                    if length(controls[x][SeqChildName]) then
                                        reBarChildCnt = 0
                                        for y=x to length(controls) do
                                            if find(controls[y][Name],controls[x][SeqChildName]) then
                                                reBarChildCnt += 1
                                                controls[y][Y] = controls[x][Y]+1
                                                controls[y][CY] = childHeight
                                                selectedControl = y
                                                if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                                  getIndex(PropertyTitleBar))) then
                                                    call_proc(updateProperty_id,{"Row"})
                                                    call_proc(updateProperty_id,{"Height"})
                                                end if
                                            end if
                                            if reBarChildCnt>=length(controls[thisBarChild][SeqChildName]) then
                                                exit
                                            end if
                                        end for
                                    else
                                        if not childHeight then
                                            childHeight = 13
                                        end if
                                    end if
                                else
                                    --RBBSBREAK unchecked
                                    if childHeight then
                                        controls[x][CY] = childHeight+4
                                    else
                                        controls[x][CY] = 14
                                    end if
                                    selectedControl = x
                                    if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                                      getIndex(PropertyTitleBar))) then
                                        call_proc(updateProperty_id,{"Height"})
                                    end if
                                end if
                            end if
                        end if
                        if reBarCnt>=length(controls[reBarSeq][SeqChildName]) then
                            exit
                        end if
                    end for

                    totalCY = (((childHeight+1)*reBarRBBS)+(3*reBarRBBS)+4)
                    if not reBarRBBS then
                        totalCY = 21
                    end if
                    --adjust reBar         
                    controls[reBarSeq][CY] = totalCY
                    selectedControl = reBarSeq
                    if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,
                                                                      getIndex(PropertyTitleBar))) then
                        call_proc(updateProperty_id,{"Height"})
                    end if
                end if
            end for
            selectedControl = tmpSelected
        end if
    end if

    --recalculate the ToolBar or FlatToolBar in event something added, moved or deleted
    if haveToolBar then   --how many toolbars I have   
        toolbarCnt = 0
        rebarparent = TheWindow
        for i=1 to length(controls) do
            if find(controls[i][Class], {"ToolBar","FlatToolBar"})
            and controls[i][ControlLayer]=thelayerNumber then
                thisBar = i
                toolbarCnt += 1

                reBuildToolBar = w32False
                --need to resize?
                if length(controls[i][SeqParentName]) then
                    rebarparent = findSeqParentName(i)
                    if not rebarparent then
                        rebarparent = TheWindow
                    end if
                end if

                if rebarparent=TheWindow then
                    if controls[thisBar][CX]!=controls[rebarparent][CX] then
                        reBuildToolBar = w32True
                        controls[thisBar][CX] = controls[rebarparent][CX]
                    end if
                else
                    if equal(controls[rebarparent][Class], "CWindow") then
                        if isCWindowTitleBar(rebarparent) then
                            if controls[thisBar][CX]!=controls[rebarparent][CX]-(2*borderX) then
                                reBuildToolBar = w32True
                                controls[thisBar][CX] = controls[rebarparent][CX]-(2*borderX)
                                controls[thisBar][X] = controls[rebarparent][X]+borderX
                                controls[thisBar][Y] = controls[rebarparent][Y]+titleBar+borderY
                            end if
                        else
                            if controls[thisBar][CX]=controls[rebarparent][CX] then
                            else
                                reBuildToolBar = w32True
                                controls[thisBar][CX] = controls[rebarparent][CX]
                                controls[thisBar][X] = controls[rebarparent][X]
                                controls[thisBar][Y] = controls[rebarparent][Y]
                            end if
                        end if
                    else
                        if controls[thisBar][CX]!=(controls[rebarparent][X]+controls[rebarparent][CX])-controls[thisBar][X] then
                            reBuildToolBar = w32True
                            controls[thisBar][CX] = (controls[rebarparent][X]+controls[rebarparent][CX])-controls[thisBar][X]
                        end if
                    end if
                end if

                for j=1 to length(toolBarInfo) do
                    if equal(toolBarInfo[j][8], controls[thisBar][Name]) then
                        toolBarIndex = 0
                        --did position change                  
                        if toolBarInfo[j][1]!=controls[thisBar][CY] then
                            toolBarInfo[j][1] = controls[thisBar][CY]
                            reBuildToolBar = w32True
                        end if
                        if toolBarInfo[j][2]!=controls[thisBar][ToolRowCY] then
                            toolBarInfo[j][2] = controls[thisBar][ToolRowCY]
                            --change the subCY to match less fit amount
                            if equal(controls[thisBar][Class], "FlatToolBar")
                            and toolBarInfo[j][2]>=48 then
                                toolBarInfo[j][3] = toolBarInfo[j][2]-10
                            elsif toolBarInfo[j][2]>=34 then
                                toolBarInfo[j][3] = toolBarInfo[j][2]-4
                            else
                                toolBarInfo[j][3] = toolBarInfo[j][2]-2
                            end if
                            reBuildToolBar = w32True
                        end if
                        if toolBarInfo[j][4]!=controls[thisBar][X] then
                            toolBarInfo[j][4] = controls[thisBar][X]
                            reBuildToolBar = w32True
                        end if
                        if toolBarInfo[j][5]!=controls[thisBar][Y] then
                            toolBarInfo[j][5] = controls[thisBar][Y]
                            reBuildToolBar = w32True
                        end if

                        toolBarIndex = j
                        exit
                    end if
                end for

                if not toolBarIndex then
                    ok = displayErrorMessage(197,{})
                end if

                if reBuildToolBar
                or forceRedraw then
                    if not toolBarIndex then
                        ok = displayErrorMessage(197,{})
                        return
                    end if
                    toolBarX = controls[thisBar][X]
                    toolBarInfo[toolBarIndex][6] = toolBarX
                    toolBarInfo[toolBarIndex][7] = 1
                    toolBarY = 1

                    --adjust X and Y position if on Rebar or CWindow
                    if length(controls[thisBar][SeqParentName]) then
                        xAdd = toolBarInfo[toolBarIndex][4]
                        yAdd = toolBarInfo[toolBarIndex][5]
                    else
                        xAdd = 0
                        yAdd = 0
                    end if

                    --find children of toolbar
                    theBarChildCnt = 0
                    thisBarChild = 0
                    if length(controls[thisBar][SeqChildName]) then
                        for j=thisBar to length(controls) do
                            if find(controls[j][Name], controls[thisBar][SeqChildName]) then
                                theBarChildCnt += 1
                                thisBarChild = j
                                parentName = controls[thisBarChild][SeqParentName]
                                if not find(controls[thisBarChild][Class], {"None","SepButton"}) then
                                    if toolBarInfo[toolBarIndex][2] then
                                        toolBarCY = toolBarInfo[toolBarIndex][2]
                                        if controls[thisBarChild][CX]>toolBarInfo[toolBarIndex][2]
                                        and controls[thisBarChild][CY]>toolBarInfo[toolBarIndex][2] then
                                            controls[thisBarChild][CX] = toolBarInfo[toolBarIndex][3]
                                            controls[thisBarChild][CY] = toolBarInfo[toolBarIndex][3]
                                        elsif controls[thisBarChild][CY]>toolBarInfo[toolBarIndex][2] then
                                            controls[thisBarChild][CY] = toolBarInfo[toolBarIndex][3]
                                        end if
                                    end if
                                end if

                                if thisBarChild then
                                    if (toolBarX-controls[thisBarChild][X])+controls[thisBarChild][CX]>controls[rebarparent][CX] then
                                        toolBarY += 1
                                        toolBarX = toolBarInfo[toolBarIndex][4]
                                    end if
                                    controls[thisBarChild][X] = toolBarX
                                    controls[thisBarChild][Y] = ((toolBarY*toolBarCY)-toolBarCY)+yAdd
                                    toolBarX += controls[thisBarChild][CX]
                                    toolBarInfo[toolBarIndex][6] = toolBarX
                                    toolBarInfo[toolBarIndex][7] = toolBarY
                                end if
                                if theBarChildCnt>=length(controls[thisBar][SeqChildName]) then
                                    exit
                                end if
                            end if
                        end for
                    end if
                end if
                if toolbarCnt>=haveToolBar then
                    exit
                end if
            end if
        end for
    end if

    if haveEuGrid then
        cnt = 0
        --reorganize cells so stay butted up together
        for j=1 to length(controls) do
            if equal(controls[j][Class], "EuGrid")
            and controls[j][ControlLayer]=thelayerNumber then
                cnt += 1
                totalCX = controls[j][GridRowHeaderCX]+controls[j][X]
                if length(controls[j][SeqChildName]) then
                    childCnt = 0
                    for i=j to length(controls) do
                        if find(controls[i][Name],controls[j][SeqChildName]) then
                            childCnt += 1
                            controls[i][X] = totalCX
                            totalCX += controls[i][CX]
                        end if
                        if childCnt>=length(controls[j][SeqChildName]) then
                            exit
                        end if
                    end for
                end if
            end if
            if cnt=haveEuGrid then
                exit
            end if
        end for
    end if

    if haveStatusBar then
        cnt = 0
        for i=length(controls) to 1 by -1 do
            if equal(controls[i][Class], "StatusBar")
            and controls[i][ControlLayer]=thelayerNumber then
                cnt += 1
                for j=1 to length(ControlList) do
                    if equal(ControlList[j][ControlClass], "StatusBar") then
                        index = j
                        exit
                    end if
                end for

                rebarparent = findSeqParentName(i)
                if not rebarparent then
                                        --parent is Window1             
                    --resize
                    controls[i][X] = controls[TheWindow][X]
                    controls[i][Y] = controls[TheWindow][CY]
                                     -ControlList[index][ControlCY]-(MenuY+WinY+titleBar+(2*borderX))
                    controls[i][CX] = controls[TheWindow][CX]
                else
                    --must be on CWindow
                    controls[i][X] = controls[rebarparent][X]+1
                    controls[i][Y] = controls[rebarparent][CY]
                                     -(ControlList[index][ControlCY]-controls[rebarparent][Y]-titleBar-borderX)-(MenuY+WinY+titleBar+(2*borderX))
                    controls[i][CX] = controls[rebarparent][CX]
                end if

                --now find any controls with statusbar as parent and move them also
                theBarChildCnt = 0
                if length(controls[i][SeqChildName]) then
                    for j=i to length(controls) do
                        if find(controls[j][Name], controls[i][SeqChildName]) then
                            theBarChildCnt += 1
                            controls[j][Y] = controls[i][Y]+1
                        end if
                        if theBarChildCnt>=length(controls[i][SeqChildName]) then
                            exit
                        end if
                    end for
                end if
                if cnt=haveStatusBar then
                    exit
                end if
            end if
        end for
    end if

    -- is there a menu?
    MenuY = 0
    --index is 2 because if there is a menu it will have been sorted after TheWindow
    if length(controls)>1 then
        if equal(controls[2][Class], "Menu") then
            -- font size + 4 pixels on top and bottom
            setMenuFont()
            extent = getFontSize(ControlBlit)
            MenuY = extent[2]+8
        end if
    end if

    -- draw everything unselected
    tmpSelected = selectedControl
    selectedControl = TheWindow

    withHatching = w32False
    if hatchBackground
    and not GridHide then
        --hatch the menu bar
        withHatching = w32True
    end if

    -- draw the menu
    if MenuY --then
    and controls[2][ControlLayer]=thelayerNumber then
        -- menu bar
        drawButton(ControlBlit, 1, -WinY+TitleY,
                   controls[TheWindow][CX], MenuY, w32False, MenuColor, 0, withHatching)

        -- position of first menu item
        tmp = 8-WinX

        -- menu font
        setMenuFont()

        -- draw the menu items
        for i=1 to length(controls) do
            if equal(controls[i][Class], "Menu")
            and controls[i][ControlLayer]=thelayerNumber then

                -- get text
                text = controls[i][Title]

                -- display text
                setPenPos(ControlBlit, tmp, 4-WinY-TitleY)
                wPuts(ControlBlit, text)

                --first & not counted in getTextExtent
                if find('&', text) then
                    text &= "&"
                end if

                -- move ahead
                extent = getTextExtent(ControlBlit, text)
                tmp += extent[1]+MenuSpacing

            end if
        end for
    end if

    -- draw the containers first and then controls
    for j=1 to length(controls) do
        if controls[j][ControlLayer]=thelayerNumber then
            --if control is TabControl and not first one ignore
            if equal(controls[j][Class], "TabControl")
            and ( not length(controls[j][ControlParent])
                 or equal(controls[j][SeqParentClass],"CWindow") )
                 then
                --draw the tabitem
                if j=selectedControl then
                    -- draw as selected
                    drawControl(ControlBlit, controls[j], Selected,j, withHatching)
                else
                    -- draw as normal
                    drawControl(ControlBlit, controls[j], Normal,j, withHatching)
                end if
                --now get any tabitems within this TabControl
                drawTabControlChildren(j)

                if thelayerNumber           --drawing layer 1..n
                and (find(0,showBackLayer)  --with base layer as background
                     or backgroundlayer=0) then
                    --does layer 1..n have controls hiding layer 0 control?
                    drawHiddenControls(j)
                end if

            elsif length(controls[j][ControlParent]) then
                if not find(controls[j][ParentClass],{"TabControl","TabItem"}) then
                    if equal(controls[j][SeqParentClass], "Table") then
                        --find the parent and its FitToTable value
                        for k=j to 1 by -1 do
                            if equal(controls[k][Name], controls[j][SeqParentName])
                            and not controls[k][FitToTable] then
                                if controls[j][X]+controls[j][CX]>controls[k][X]+controls[k][CX]
                                or controls[j][Y]+controls[j][CY]>controls[k][Y]+controls[k][CY] then
                                    --don't draw it or know about it anywhere else in IDE except for exw
                                    controls[j][DontDraw] = w32True
                                else
                                    controls[j][DontDraw] = w32False
                                    drawTheTableCell(controls[j], j)
                                end if
                            elsif equal(controls[k][Name], controls[j][SeqParentName]) then
                                drawTheTableCell(controls[j], j)
                            end if
                        end for
                    else
                        --draw
                        if j=selectedControl then
                            -- draw as selected
                            drawControl(ControlBlit, controls[j], Selected,j, withHatching)
                        else
                            -- draw as normal
                            drawControl(ControlBlit, controls[j], Normal,j, withHatching)
                        end if

                        if thelayerNumber           --drawing layer 1..n
                        and (find(0,showBackLayer)  --with base layer as background
                             or backgroundlayer=0) then
                            --does layer 1..n have controls hiding layer 0 control?
                            drawHiddenControls(j)
                        end if

                        checkIfText(controls[j])
                    end if
                end if

            else
                --doesnt have above parent
                -- so draw                        
                if j=selectedControl then
                    -- draw as selected                
                    drawControl(ControlBlit, controls[j], Selected,j,withHatching)
                else
                    -- draw as normal
                    drawControl(ControlBlit, controls[j], Normal,j,withHatching)
                end if
                if thelayerNumber           --drawing layer 1..n
                and (find(0,showBackLayer)  --with base layer as background
                     or backgroundlayer=0) then
                    --does layer 1..n have controls hiding layer 0 control?
                    drawHiddenControls(j)
                end if

                checkIfText(controls[j])
            end if
        end if
    end for

    forceRedraw = w32False
    selectedControl = tmpSelected

    if selectedControl
    and selectedControl!=TheWindow then
        drawControl(ControlBlit, controls[selectedControl], Selected, selectedControl, withHatching)
        if thelayerNumber           --drawing layer 1..n
        and (not find(thelayerNumber,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have layer 0 controls hiding behind?
            drawHiddenControls(selectedControl)
        end if
    end if

end procedure
--------------------------------------------------------------------------------
backgroundlayer = -1
procedure drawIt()

    setPenColor(ControlBlit, getSysColor(COLOR_BTNFACE))
    drawRectangle(ControlBlit, w32True, 0, 0, sizeS[3], sizeS[4])

    if not GridHide then
        bitBlt(ControlBlit, 0, 0, GridBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    --show background layers, if any, but not when layer is 0 since it is the
    --base layer it can not have background layers
    if layerNumber!=0 then
        if length(showBackLayer) then
            if find(0,showBackLayer) then
                --always show layer 0 first
                thelayerNumber = 0
                hatchBackground = w32True
                drawItAll()
            end if
            for i=1 to length(showBackLayer) do
                if showBackLayer[i]!=0 then
                    thelayerNumber = showBackLayer[i]
                    hatchBackground = w32True
                    drawItAll()
                end if
            end for
        else
            if layerNumber!=backgroundlayer
            and backgroundlayer!= -1 then
                --show the background layer if different from layerNumber
                thelayerNumber = backgroundlayer
                hatchBackground = w32True
                drawItAll()
            end if
        end if
    end if
    --show the current layer
    hatchBackground = w32False
    setPenColor(ControlBlit, getSysColor(COLOR_BTNFACE))
    thelayerNumber = layerNumber
    drawItAll()
end procedure
drawIt_id = routine_id("drawIt")
--------------------------------------------------------------------
-- MENU ACTIONS
------------------------------------------------------------------
procedure click_MenuNew(integer Self, integer Event, sequence Params)

integer lastState
sequence treedata

    treedata = {"",""}

    lastState = Normal

    --clear backup
    backupControls = {}
    backupSelectedWindow = 1
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32False)
    setEnable(PopUpDesign_Undo, w32False)
    setVisible(ToolUndo, w32False)
    setVisible(ToolUndoD, w32True)

    if CodeWinOpen then
        reOpenCodeWin = w32True
        if isMinimized(CodeWin) then
            lastState = SW_MINIMIZE
        elsif isMaximized(CodeWin) then
            lastState = SW_MAXIMIZE
        else
            lastState = SW_NORMAL
        end if
        showWindow(CodeWin, SW_HIDE)
        setIndex(CodeControls, editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if

    -- give message before lose any data
    cancelledSaveAs = w32False
    if IDE_Changed then
        ok = displayErrorMessage(4,{})
        if ok=IDCANCEL then
            if reOpenCodeWin then
                reOpenCodeWin = w32False
                ok = invokeHandler(CodeControls,w32HClick,{})
                showWindow(CodeWin,lastState)
            end if
            return
        elsif ok=IDYES then
            ok = invokeHandler(MenuSave,w32HClick,{})
            if cancelledSaveAs then
                return
            end if
        end if
    end if

    --reset project dir back to IDE's
    projectDir = the_current_dir

    treatAsInclude = w32False
    haveReBar = 0
    haveStatusBar = 0
    haveToolBar = 0
    haveEuGrid = 0
    textOrigName = ""

    config_Ew = w32False
    config_Exw = w32True
    addCrashFile = w32False
    config_has_Winlib = w32True
    saveCfg = w32False
    savePrj = w32False

    config_Winlib_Name = "Win32lib.ew"
    if length(cfgWin32lib) then
        config_Winlib_Name = cfgWin32lib
    end if

    --get rid of any ico files drawn on controls
    for i=1 to length(iconStrings) do
        iconData = iconStrings[i]
        if validId(iconData[2]) then
            destroy(iconData[2])
        end if
    end for
    iconStrings = {}

    --clear tracking of some resources
    deleteAllResources()

    --clear Esc jump points in editor
    EscStack = {}

    --clear the include modules list
    includeModules = {}

    --clear layer tabitems except for zero
    for i=1 to length(layerTabItemSeq) do
        destroy(layerTabItemSeq[i])
    end for

    layerNum = 0
    layerNumber = 0
    layerTabItemSeq = {}

    windows = {}

    startSave = 0 endSave = 0

    -- clear file, and blank name
    newProject(Controls)

    setPropertyCombo(defaultColor, 2, validColors)

    --if went to another directory need to change back to IDE's dir after
    ok = chdir(the_current_dir)

    if length(FileBuffer) then
        setCheck(FileBuffer[length(FileBuffer)][2], w32False)
    end if

    --clear the modules keywords list
    otherKeywords = {""}

    --clear toolbar/flattoolbar info sequence
    toolBarInfo = {}

        --remove existing tree
    buildProjectFolders()

    eraseItems(CodeControls)
    addItem(CodeControls,controls[TheWindow][Name])
    setIndex(CodeControls,TheWindow)
    ok = invokeHandler(CodeControls,w32HClick,{})

    if reOpenCodeWin then
        reOpenCodeWin = w32False
        showWindow(CodeWin, lastState)
    end if

    --empty offscreen window
    copyBlt(OffScreenBlit, 0, 0, GridBlit)
    haveOffscreen = w32False

end procedure
setHandler({MenuNew,ToolNew}, w32HClick, routine_id("click_MenuNew"))
-----------------------------------------------------------------------------
function getParentDir(sequence fName)
object parentDir
integer at

    fName = reverse(fName)
    at = find('\\', fName)
    if at then
        parentDir = fName[at+1..length(fName)]
        parentDir = reverse(parentDir)
        return parentDir
    else
        return 0
    end if

end function
--------------------------------------------------------------------------------
setText(splashLoadInfo, "Initializing Event Handlers...")
------------------------------------------------------------------------------
atom r_click_OpenRecentFile
procedure click_OpenRecentFile(integer Self, integer Event, sequence Params)

integer id, hold, lastState, controlnamelength
sequence fName, data, shortName, projectFileTypeTest, extent
object parentDir,x

    --make sure file exists first
    id = getSelf()
    for i=1 to length(FileBuffer) do
        if id=FileBuffer[i][2] then
            fName = FileBuffer[i][1]
            exit
        end if
    end for
    x = dir(fName)
    if atom(x) then
        ok = displayErrorMessage(182,{fName})
        return
    end if

    projectFileTypeTest = reverse(projectFileType)
    projectFileTypeTest = append(projectFileTypeTest, '.')

    -- truncate path from name
    shortName = fName
    for i=length(fName) to 1 by -1 do
        if fName[i]='\\' then
            shortName = fName[i+1..length(fName)]
            exit
        end if
    end for

    --check valid file type
    shortName = reverse(shortName)
    if match(projectFileTypeTest, lower(shortName)) then
        --is good
    else
        ok = displayErrorMessage(147,{projectFileType})
        return
    end if

    lastState = Normal

    if CodeWinOpen then
        reOpenCodeWin = w32True
        if isMinimized(CodeWin) then
            lastState = SW_MINIMIZE
        elsif isMaximized(CodeWin) then
            lastState = SW_MAXIMIZE
        else
            lastState = SW_NORMAL
        end if
        setIndex(CodeControls,editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin,SW_HIDE)
    end if

    --ask to save prior project?
    if IDE_Changed then
        ok = displayErrorMessage(5,{})

        if ok=IDCANCEL then
            if reOpenCodeWin then
                showWindow(CodeWin,lastState)
            end if
            return
        elsif ok=IDYES then
            ok = invokeHandler(MenuSave,w32HClick,{})
        end if
    end if

    data = {"",""}

    --clear backup
    backupControls = {}
    backupSelectedWindow = 1
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32False)
    setEnable(PopUpDesign_Undo, w32False)
    setVisible(ToolUndo, w32False)
    setVisible(ToolUndoD, w32True)

    --get the filename from the menuitem
    id = getSelf()


    --find the id in the FileBuffer array
    for i=1 to length(FileBuffer) do
        setCheck(FileBuffer[i][2], w32False)
    end for

    for i=1 to length(FileBuffer) do
        if id=FileBuffer[i][2] then
            fName = FileBuffer[i][1]
            --delete
            FileBuffer = FileBuffer[1..i-1]
                         & FileBuffer[i+1..length(FileBuffer)]
            --delete the id
            if validId(id) then
                destroy(id)
            end if
            exit
        end if
    end for
    --make a new entry in list
    hold = createEx(MenuItem, fName, FileMenu, 0, 0, 0, 0, 0, 0)
    --apply the onevent
--PL (fixed in Phix\pEmit2.e 23/1/17, but I prefer the workaround anyway)
--  setHandler(hold, w32HClick, routine_id("click_OpenRecentFile"))
    setHandler(hold, w32HClick, r_click_OpenRecentFile)
    --tack the id onto back of FileBuffer
    data[1] = fName
    data[2] = hold
    FileBuffer &= {data}

    --keep only last 16 files
    if length(FileBuffer)>16 then
        if validId(FileBuffer[1][2]) then
            destroy(FileBuffer[1][2])
        end if
        FileBuffer = FileBuffer[2..length(FileBuffer)]
    end if

    setCheck(hold, w32True)

    --find the folder of the file and force current_dir to it
    --so at Menu Run, that directory will be in effect for support files within
    parentDir = getParentDir(fName)
    if sequence(parentDir) then
        projectDir = parentDir
        ok = chdir(parentDir)
    end if

    config_Winlib_Name = "Win32lib.ew"
    if length(cfgWin32lib) then
        config_Winlib_Name = cfgWin32lib
    end if

    --clear the include modules list
    includeModules = {}

    --clear layer tabitems except for zero
    for i=1 to length(layerTabItemSeq) do
        destroy(layerTabItemSeq[i])
    end for

    layerNum = 0
    layerNumber = 0
    layerTabItemSeq = {}

    --clear the modules keywords list
    otherKeywords = {""}

    --clear toolbar/flattoolbar info sequence
    toolBarInfo = {}

    --clear tracking of some resources
    deleteAllResources()

    --clear Esc jump points in editor
    EscStack = {}

    --get rid of any ico files drawn on controls
    for i=1 to length(iconStrings) do
        iconData = iconStrings[i]
        if validId(iconData[2]) then
            destroy(iconData[2])
        end if
    end for
    iconStrings = {}
    startSave = 0 endSave = 0

    -- read the project
    readProject(Controls, fName)

    -- set file name
    setOpenFileName(Controls, fName)

    eraseItems(CodeControls)
    controlnamelength = 0
    for i=1 to length(controls) do
        addItem(CodeControls,controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    ok = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    setIndex(CodeControls,TheWindow)

    if reOpenCodeWin then
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, lastState)
    end if

    --remove existing tree
    buildProjectFolders()

end procedure
r_click_OpenRecentFile = routine_id("click_OpenRecentFile")
------------------------------------------------------------------------------
procedure changeRecentFilesList(sequence fName)

object data
integer hold

--add project to FileBuffer
    data = {"",""}

    --make sure the project is not already loaded in recent files buffer.

    for i=1 to length(FileBuffer) do
        setCheck(FileBuffer[i][2], w32False)
    end for

    for i=1 to length(FileBuffer) do
        if equal(upper(fName), upper(FileBuffer[i][1])) then
            --delete the id
            if validId(FileBuffer[i][2]) then
                destroy(FileBuffer[i][2])
            end if
            --delete
            FileBuffer = FileBuffer[1..i-1]
                         & FileBuffer[i+1..length(FileBuffer)]
            exit
        end if
    end for

    if not length(FileBuffer) then
        if validId(holdSep) then
            destroy(holdSep)
        end if
    end if

    --build recent files list
    if not length(FileBuffer) then
        holdSep = createEx(MenuItem, "-", FileMenu, 0, 0, 0, 0, 0, 0)
    end if

    --create a menuitem for this file
    hold = createEx(MenuItem, fName, FileMenu, 0, 0, 0, 0, 0, 0)

    --add the behavior for this menuitem
--      setHandler(hold, w32HClick, routine_id("click_OpenRecentFile"))
    setHandler(hold, w32HClick, r_click_OpenRecentFile)

    --tack the id onto back of FileBuffer
    data[1] = fName
    data[2] = hold
    FileBuffer &= {data}
    setCheck(hold, w32True)

    --keep only last 16 files
    if length(FileBuffer)>16 then
        if validId(FileBuffer[1][2]) then
            destroy(FileBuffer[1][2])
        end if
        FileBuffer = FileBuffer[2..length(FileBuffer)]
    end if

    if length(FileBuffer) then
        setEnable(MenuClearRecent, w32True)
    end if

end procedure
------------------------------------------------------------------------------
procedure click_MenuOpen(integer Self, integer Event, sequence Params)

-- read a project file

integer lastState, controlnamelength
sequence fName, shortName, projectFileTypeTest, extent
sequence openFolder, dirName

    projectFileTypeTest = reverse(projectFileType)
    projectFileTypeTest = append(projectFileTypeTest, '.')

    lastState = Normal
    startSave = 0 endSave = 0

    --clear backup
    backupControls = {}
    backupSelectedWindow = 1
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32False)
    setEnable(PopUpDesign_Undo, w32False)
    setVisible(ToolUndo, w32False)
    setVisible(ToolUndoD, w32True)

    if CodeWinOpen then
        reOpenCodeWin = w32True
        if isMinimized(CodeWin) then
            lastState = SW_MINIMIZE
        elsif isMaximized(CodeWin) then
            lastState = SW_MAXIMIZE
        else
            lastState = SW_NORMAL
        end if
        setIndex(CodeControls,editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
        if abortClose then
            ok = w32Func(xSetForegroundWindow, {getHandle(CodeWin)})
            MenuEditDoubleClick = w32True
            return
        end if
        showWindow(CodeWin,SW_HIDE)
    end if

    if IDE_Changed then
        ok = displayErrorMessage(6,{})

        if ok=IDCANCEL then
            if reOpenCodeWin then
                reOpenCodeWin = w32False
                showWindow(CodeWin,lastState)
            end if
            return
        elsif ok=IDYES then
            ok = invokeHandler(MenuSave,w32HClick,{})
        end if
    end if

    -- get the file name
    if isChecked(CB_WantDefault)
    and length(getText(EditPrjDef)) then
        openFolder = getText(EditPrjDef)
    else
        openFolder = current_dir()
    end if
    fName = getOpenFileName(Form, openFolder & "\\*." & projectFileType, FileTypes)

    -- entered a file name?
    if length(fName)=0 then
        if reOpenCodeWin then
            reOpenCodeWin = w32False
            showWindow(CodeWin,lastState)
        end if
        setFocus(Controls)
        return
    end if

    -- truncate path from name
    shortName = fName
    for i=length(fName) to 1 by -1 do
        if fName[i]='\\' then
            dirName = fName[1..i-1]
            shortName = fName[i+1..length(fName)]
            exit
        end if
    end for

    --check valid file type
    shortName = reverse(shortName)
    if match(projectFileTypeTest, lower(shortName)) then
        --is good
    else
        ok = displayErrorMessage(147,{projectFileType})
        return
    end if

    if length(fName) then
        changeRecentFilesList(fName)
    end if

    config_Winlib_Name = "Win32lib.ew"
    if length(cfgWin32lib) then
        config_Winlib_Name = cfgWin32lib
    end if

    --clear the include modules list
    includeModules = {}

    --clear layer tabitems except for zero
    for i=1 to length(layerTabItemSeq) do
        destroy(layerTabItemSeq[i])
    end for

    layerNum = 0
    layerNumber = 0
    layerTabItemSeq = {}

    --clear the modules keywords list
    otherKeywords = {""}

    --clear toolbar/flattoolbar info sequence
    toolBarInfo = {}

    --get rid of any ico files drawn on controls
    for i=1 to length(iconStrings) do
        iconData = iconStrings[i]
        if validId(iconData[2]) then
            destroy(iconData[2])
        end if
    end for
    iconStrings = {}

    --clear tracking of some resources
    deleteAllResources()

    --clear Esc jump points in editor
    EscStack = {}

    -- read the project
    readProject(Controls, fName)

    -- set file name
    setOpenFileName(Controls, fName)

    --remove existing tree
    buildProjectFolders()

    eraseItems(CodeControls)
    controlnamelength = 0
    for i=1 to length(controls) do
        addItem(CodeControls,controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    ok = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    setIndex(CodeControls,TheWindow)

    if reOpenCodeWin then
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, lastState)
    end if

    projectDir = dirName

end procedure
setHandler({MenuOpen,ToolOpen}, w32HClick, routine_id("click_MenuOpen"))
------------------------------------------------------------------------------
integer cameFromMenuRun cameFromMenuRun = w32False
procedure click_MenuSaveAs(integer Self, integer Event, sequence Params)

-- save as
sequence fName, shortName, projectFileTypeTest
integer at, temp_saved
sequence openFolder

    if CodeWinOpen
    and not cameFromMenuRun then
        editorChanged = synGetModified()
        if not isModuleRoutine then
            --ok=invokeHandler(CodeControls,w32HClick,{})
            saveChangedCode()
        elsif editorChanged=w32True then
            if isChecked(MenuAutoSave) then
                saveTheModule(0, 0, {})
            else
                ok = displayErrorMessage(30, isModule)
                if ok=IDYES then
                    saveTheModule(0, 0, {})
                elsif ok=IDCANCEL then
                    return
                end if
            end if
        end if
    end if

    if isChecked(CB_WantDefault)
    and length(getText(EditPrjDef)) then
        openFolder = getText(EditPrjDef)
    else
        openFolder = current_dir()
    end if

    if length(openFileName)=0 then
        fName = getSaveFileName(Form, openFolder & "\\*." & projectFileType, FileTypes)
    else
        fName = getSaveFileName(Form, openFileName, FileTypes)
    end if

    projectFileTypeTest = reverse(projectFileType)

    -- truncate path from name
    if length(fName) then

        for i=length(fName) to 1 by -1 do
            if fName[i]='\\' then
                projectDir = fName[1..i-1]
                shortName = fName[i+1..length(fName)]
                exit
            end if
        end for

        shortName = reverse(shortName)

        at = find('.', shortName)
        if at then
            if not equal(projectFileTypeTest, lower(shortName[1..at-1])) then
                ok = displayErrorMessage(7,{})
                return
            end if
        else
            --add prjectFileType        --CoJaBo
            fName &= "."&projectFileType    --CoJaBo
        end if

        -- set file name
        setOpenFileName(Controls, fName)

        -- save the file
        writeProject(openFileName)
        if StopRun then
            return
        end if

        temp_saved = IDE_Changed
        --reorder the controls
        call_proc(openReorder_id,{})
        call_proc(savetheReorder_id,{})
        IDE_Changed = temp_saved

        writeCode(openFileName)
        if StopRun then
            return
        end if

        IDE_Changed = w32False
    else
        cancelledSaveAs = w32True
    end if

    setFocus(Controls)

    if CodeWinOpen then
        ok = w32Func(xSetForegroundWindow, {getHandle(CodeWin)})
    end if

    if length(openFileName) then
        changeRecentFilesList(openFileName)
    end if

end procedure
setHandler({MenuSaveAs,ToolSaveAs}, w32HClick, routine_id("click_MenuSaveAs"))
-----------------------------------------------------------------------------
sequence shortName, pathName, backup, copyName
procedure click_MenuSave(integer style, integer event, sequence params)
sequence fName, budate, budir
integer at, temp_saved

    pathName = {}

    -- get file name
    if length(openFileName)=0 then
        ok = invokeHandler(MenuSaveAs, w32HClick, {})
        return
    end if

    editorChanged = synGetModified()

    if CodeWinOpen then
        if not isModuleRoutine then
            saveChangedCode()
        elsif editorChanged=w32True then
            if isChecked(MenuAutoSave) then
                saveTheModule(0, 0, {})
            else
                ok = displayErrorMessage(30, isModule)
                if ok=IDYES then
                    saveTheModule(0, 0, {})
                elsif ok=IDCANCEL then
                    return
                end if
            end if
        end if
    end if

    --backup original file
    shortName = openFileName
    copyName = openFileName

    -- truncate path from name
    for i=length(openFileName) to 1 by -1 do
        if openFileName[i]='\\' then
            shortName = openFileName[i+1..length(openFileName)]
            copyName = shortName
            pathName = openFileName[1..i]
            projectDir = openFileName[1..i-1]
            exit
        end if
    end for

    backup = shortName
    shortName = reverse(shortName)
    at = find(".", shortName)
    if at then
        backup = shortName[at+1..length(shortName)]
        backup = reverse(backup)
    end if
    shortName = reverse(shortName)

    if isChecked(MenuBackupSave) then
        --copy file to backup
        backup &= ".bak"
        budir = getText(BackupFolderName) & "\\" --"backups\\"
        if atom(dir(getText(BackupFolderName))) then
            if not createDirectory(getText(BackupFolderName)) then
                budir = ""
            end if
        end if
        if isChecked(ReuseBak1File) then
            fName = pathName & getText(BackupFolderName) & "\\" & backup
        else
            budate = date()
            budate[1] += 1900
            budate = sprintf(".%04d-%02d-%02d.%02d-%02d-%02d",budate)
            fName = pathName & getText(BackupFolderName) & "\\" & backup & budate
--              fName = getSaveFileName ( Form, pathName & backup, {IDEText[1097][1],".bak"} )--"Backup Before Project Save"
        end if
        if length(fName) then
            ok = copyFile(pathName & copyName, fName, w32False)
            if not ok then
                ok = displayErrorMessage(9,{pathName & copyName,fName})
            end if
        end if
    end if

    -- write the file out
    writeProject(openFileName)
    if StopRun then
        return
    end if

    temp_saved = IDE_Changed
    IDE_Changed = temp_saved

    writeCode(openFileName)
    if StopRun then
        return
    end if

    IDE_Changed = w32False

    --if editor open return to same statement as before Save
    if CodeWinOpen then
        ok = w32Func(xSetForegroundWindow, {getHandle(CodeWin)})
    end if
end procedure
setHandler({MenuSave,ToolSave}, w32HClick, routine_id("click_MenuSave"))
-----------------------------------------------------------------------------
procedure click_MenuClose(integer Self, integer Event, sequence Params)
    -- close window
    closeWindow(Controls)
end procedure
setHandler(MenuClose, w32HClick, routine_id("click_MenuClose"))
----------------------------------------------------------------------------
procedure click_MenuControlUndo(integer Self, integer Event, sequence Params)
    --to prevent Ctrl+Z while disabled:
    if not isEnabled(MenuControlUndo) then
        return
    end if

    if length(backupControls) then
        windows = backupControls
        --delete any layer tabitems
        for i=1 to length(layerTabItemSeq) do
            destroy(layerTabItemSeq[i])
        end for
        toolBarInfo = toolBarInfoBack
        selectedWindow = backupSelectedWindow
        layerTabItemSeq = backupLayerTabItemSeq
        layerCaptionSeq = backupLayerCaptionSeq
        controls = windows[selectedWindow]
        if length(controlResourceBack) then
            controlResource = {}
            for i=1 to length(controls) do
                if find(controls[i][Class],{"Bitmap","PictureButton","TogglePicture"}) then
                    if length(controls[i][BitmapFile]) then
                        addResource(controls[i][Name],controls[i][BitmapFile],"Bitmap","")
                    elsif length(controls[i][XPM]) then
                        addResource(controls[i][Name],controls[i][XPM],"XPM",controls[i][XPMmember])
                    end if
                end if
            end for
        else
            controlResource = {}
        end if

        -- rebuild the list
        rebuildWindowList()

        -- select the new window
        pickWindow(selectedWindow)
        backupControls = {}
        toolBarInfoBack = {}
        controlResourceBack = {}
        backupSelectedWindow = 1
        backupLayerTabItemSeq = {}
        backupLayerCaptionSeq = {}
        setEnable(MenuControlUndo, w32False)
        setEnable(PopUpDesign_Undo, w32False)
        setVisible(ToolUndo, w32False)
        setVisible(ToolUndoD, w32True)

        --since I don't know what the last action was I need to
        buildProjectFolders()

        selectedControl = TheWindow
        drawIt()
        updateProperties()

        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        end if

        if offsetActive then
            copyBlt(OffScreen, 0, 0, OffScreenBlit)
        end if
    end if
end procedure
setHandler({MenuControlUndo,ToolUndo}, w32HClick, routine_id("click_MenuControlUndo"))
-----------------------------------------------------------------------------
global procedure ToolCopyIndex_click(integer Self, integer Event, sequence Params)
    if copyIndexSw then
        setVisible(ToolCopyIndexD, w32True)
        copyIndexSw = w32False
        setHint(ToolCopyIndex,"Indexed Copy Inactive")
    else
        setVisible(ToolCopyIndexD, w32False)
        copyIndexSw = w32True
        setHint(ToolCopyIndex,"Indexed Copy Active")
    end if
    setFocus(Controls)
end procedure
setHandler({ToolCopyIndex,ToolCopyIndexD}, w32HClick, routine_id("ToolCopyIndex_click"))
-----------------------------------------------------------------------------
procedure clickPopUpDesign_Undo(integer Self, integer Event, sequence Params)
    ok = invokeHandler(MenuControlUndo, w32HClick,{})
end procedure
setHandler(PopUpDesign_Undo, w32HClick, routine_id("clickPopUpDesign_Undo"))
------------------------------------------------------------------------------
procedure click_MenuWindow(integer Self, integer Event, sequence Params)
sequence treedata,layerTabInfo

    treedata = {"",""}

    --backup
    if CodeWinOpen then
        saveChangedCode()
    end if
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    -- add a new window to the project

    --deselect the control in the button bar
    -- unselect prior
    setCheck(MasterList[picked][ControlButton], w32False)

    dropMultipleTimes = w32False
    picked = Pointer

    --toggle on checkmark OFF
    setCheck(MenuClick, w32True)
    setText(IconOff, IDEText[208][1])   --"Off"

    --reset popups
    if hasPopup then
        hasPopup = w32False
        setEnable(PopUpDesign_PopUp, w32False)
    end if

    if CodeWinOpen then
        reOpenCodeWin = w32True
        setIndex(CodeControls,editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin,SW_HIDE)
    end if

    --clear window of any .ico and .bmp showing
    for i=1 to length(iconStrings) do
        iconData = iconStrings[i]
        if validId(iconData[2]) then
            destroy(iconData[2])
        end if
    end for
    iconStrings = {}

    --clear layer tabitems
    for i=1 to length(layerTabItemSeq) do
        destroy(layerTabItemSeq[i])
    end for

    layerNum = 0
    layerNumber = 0
    layerTabItemSeq = {}

    layerTabInfo = {{IDEText[984][1] & " " & sprint(layerNum),0,layerNum,0}}
    layerCaptionSeq &= {layerTabInfo}

    --enable resource properties
    setPropEnabled(bitmap, w32True)
    setPropEnabled(XPMFile, w32True)

    -- create the design window properties
    winCounter += 1

    newWindow(sprintf("Window%d", {winCounter}),
              sprintf("Window %d", {winCounter}),
              DesignCX, DesignCY)

    --don't show scrollbars
    setWindowScrollRange(Form, SB_HORZ, 0, 0, 1)
    setWindowScrollRange(Form, SB_VERT, 0, 0, 1)

    setHScrollPos(Form, 1)
    setVScrollPos(Form, 1)

    selectedWindow = length(windows)

    -- rebuild the list
    rebuildWindowList()

    -- select the new window
    pickWindow(length(windows))

    addTreeViewNodeWin(IDEText[967][1], controls[1][Name])  --"Form"
    treedata[1] = controls[1][Name]
    treedata[2] = controls[1][Class]
    theTreeForm &= {treedata}
    windowsList &= {controls[1][Name]}

    eraseItems(CodeControls)
    for i=1 to length(controls) do
        addItem(CodeControls,controls[i][Name])
    end for
    setIndex(CodeControls,TheWindow)

    findCurrentNode(controls[TheWindow][Name])

    --empty offscreen window
    copyBlt(OffScreenBlit, 0, 0, GridBlit)
    haveOffscreen = w32False

    if reOpenCodeWin then
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, SW_NORMAL)
    end if

end procedure
setHandler(MenuWindow, w32HClick, routine_id("click_MenuWindow"))
------------------------------------------------------------------------------
procedure click_MenuMenuEditor(integer Self, integer Event, sequence Params)

    selectedControl = TheWindow
    resetMultiDrop()

    -- open menu editor
    createMenuEditWindow()
    openWindow(MenuEditWindow, Modal)
end procedure
setHandler(MenuMenuEditor, w32HClick, routine_id("click_MenuMenuEditor"))
-----------------------------------------------------------------------------
procedure click_MenuPopupEditor(integer Self, integer Event, sequence Params)

    selectedControl = TheWindow
    resetMultiDrop()

    -- open menu editor
    createPopupEditWindow()
    openWindow(PopupEditWindow, Modal)
end procedure
setHandler(MenuPopupEditor, w32HClick, routine_id("click_MenuPopupEditor"))
------------------------------------------------------------------------------
procedure click_MenuTimerEditor(integer Self, integer Event, sequence Params)

    selectedControl = TheWindow
    resetMultiDrop()

    -- open menu editor
    createTimerEditWindow()
    openWindow(TimerEditWindow, Modal)
end procedure
setHandler(MenuTimerEditor, w32HClick, routine_id("click_MenuTimerEditor"))
------------------------------------------------------------------------------
procedure click_MenuXPMmer(integer Self, integer Event, sequence Params)
integer holdselcontrol

    holdselcontrol = selectedControl
    selectedControl = TheWindow
    resetMultiDrop()

    selectedControl = holdselcontrol
    if not find(controls[selectedControl][Class], {"PictureButton","TogglePicture","Bitmap"}) then
        VOID = displayErrorMessage(263,{})
--                      "Must use XPMmer with PictureButton, TogglePicture or Bitmap control"
        return
    end if

    -- open XPMmer
    xpmCell = 1
    openWindow(Window1, Normal)
end procedure
setHandler(MenuXPMmer, w32HClick, routine_id("click_MenuXPMmer"))
-----------------------------------------------------------------------------
procedure click_MenuInitValueEditor(integer Self, integer Event, sequence Params)
    createInitialWindow()
    openWindow(InitialWindow, Modal)
end procedure
setHandler(MenuInitValueEditor, w32HClick, routine_id("click_MenuInitValueEditor"))
------------------------------------------------------------------------------
procedure click_Config_Ew(integer Self, integer Event, sequence Params)
sequence shortName

    if isChecked(Config_Ew) then
        treatAsInclude = w32True
        -- truncate path from name
        shortName = openFileName

        if not length(shortName) then
            shortName = "Untitled"
        end if

        for i=length(openFileName) to 1 by -1 do
            if openFileName[i]='\\' then
                shortName = openFileName[i+1..length(openFileName)]
                exit
            end if
        end for
        setText(Controls, Application & " Module - " & shortName)
        if equal(controls[selectedControl][Class], "Window") then
            doProperties = w32True
        end if
    end if
end procedure
------------------------------------------------------------------------------
procedure click_Config_Exw(integer Self, integer Event, sequence Params)
sequence shortName

    if isChecked(Config_Exw) then
        treatAsInclude = w32False
        -- truncate path from name
        shortName = openFileName
        if not length(shortName) then
            shortName = "Untitled"
        end if

        for i=length(openFileName) to 1 by -1 do
            if openFileName[i]='\\' then
                shortName = openFileName[i+1..length(openFileName)]
                exit
            end if
        end for
        setText(Controls, Application & " - " & shortName)
        if equal(controls[selectedControl][Class], "Window") then
            doProperties = w32True
        end if
    end if
end procedure
------------------------------------------------------------------------------
procedure click_SaveCfg(integer Self, integer Event, sequence Params)
    if isChecked(SaveCfg)
    and length(getText(Config_Winlib_Name)) then
        cfgWin32lib = getText(Config_Winlib_Name)
    end if
end procedure
-----------------------------------------------------------------------------
procedure click_SavePrj(integer Self, integer Event, sequence Params)
    if isChecked(SavePrj)
    and length(getText(Config_Winlib_Name)) then
        prjWin32lib = getText(Config_Winlib_Name)
    end if
end procedure
-------------------------------------------------------------------------------
procedure change_RunCommandLine(integer Self, integer Event, sequence Params)
    commandLineRun = getText(RunCommandLine)
end procedure
--------------------------------------------------------------------------------
procedure click_ButClose2(integer self, integer event, sequence params)
    --save values for proj.ew
    config_Ew = isChecked(Config_Ew)
    config_Exw = isChecked(Config_Exw)
    addCrashFile = isChecked(AddCrashFile)
    saveCfg = isChecked(SaveCfg)
    savePrj = isChecked(SavePrj)
    config_has_Winlib = isChecked(Config_has_Winlib)
    config_Winlib_Name = getText(Config_Winlib_Name)
    config_Title = getText(EditTitle)
    config_Author = getText(EditAuthor)
    config_Version = getText(EditVersion)
    config_Date = getText(EditDate)
    config_WinLibVer = getText(Win32libVer)
    config_Desc = getText(MleDesc)
    config_Comment = getText(MleComment)

    closeWindow(ConfigInclude)
    if doProperties then
        updateProperties()
    end if
end procedure
--------------------------------------------------------------------------------
procedure createConfigInclude()
                                --"Generated Project Information"
    ConfigInclude = createEx(Window, IDEText[736][1], 0, Default, Default, 587, 450, {WS_DLGFRAME}, 0)
                                --"File Type"
    Config_Group1 = createEx(Group, IDEText[737][1], ConfigInclude, 0, 0, 148, 60, 0, 0)
    Config_Ew = createEx(Radio, ".EW", Config_Group1, 8, 17, 124, 20, 0, 0)
    Config_Exw = createEx(Radio, ".EXW", Config_Group1, 8, 37, 128, 20, 0, 0)
                                        --"Include Win32lib Statement"
    Config_has_Winlib = createEx(CheckBox, IDEText[738][1], ConfigInclude, 0, 72, 180, 44, w32or_all({BS_MULTILINE}), 0)
    Config_Winlib_Name = createEx(EditText, "", ConfigInclude, 0, 140, 180, 20, 0, 0)
    AddCrashFile = createEx(CheckBox,IDEText[1212][1], ConfigInclude, 4, 176, 268, 20, 0, 0)
                                      --"Save Win32lib Name"
    Config_save_Options = createEx(Group, IDEText[739][1], ConfigInclude, 0, 208, 208, 92, 0, 0)
                          --"Save As Default"
    SaveCfg = createEx(Radio, IDEText[740][1], Config_save_Options, 4, 16, 196, 20, 0, 0)
                          --"Save In Project"
    SavePrj = createEx(Radio, IDEText[741][1], Config_save_Options, 4, 36, 196, 20, 0, 0)
                          --"Do Not Save"
    SaveNo = createEx(Radio, IDEText[742][1], Config_save_Options, 4, 56, 196, 20, 0, 0)
                                    --"Run Project With Command Line:"
    CommandLineLabel = createEx(LText, IDEText[974][1], ConfigInclude, 0, 308, 200, 40, 0, 0)
    RunCommandLine = createEx(EditText, "", ConfigInclude, 4, 344, 180, 20, 0, 0)
                              --"Title:"
    ConfigText1 = createEx(RText, IDEText[743][1], ConfigInclude, 188, 8, 148, 20, 0, 0)
                               --"Author:"
    ConfigText3 = createEx(RText, IDEText[744][1], ConfigInclude, 188, 48, 148, 20, 0, 0)
                               --"Date:"
    ConfigText4 = createEx(RText, IDEText[745][1], ConfigInclude, 188, 68, 148, 20, 0, 0)
                               --"Version:"
    ConfigText2 = createEx(RText, IDEText[746][1], ConfigInclude, 188, 28, 148, 20, 0, 0)
                                --"Description:"
    ConfigText5 = createEx(RText, IDEText[747][1], ConfigInclude, 188, 128, 148, 20, 0, 0)
                               --"Comments:"
    ConfigText6 = createEx(RText, IDEText[748][1], ConfigInclude, 188, 200, 148, 20, 0, 0)
    EditTitle = createEx(EditText, "", ConfigInclude, 336, 4, 236, 20, 0, 0)
    EditVersion = createEx(EditText, "", ConfigInclude, 336, 24, 236, 20, 0, 0)
    EditAuthor = createEx(EditText, "", ConfigInclude, 336, 44, 236, 20, 0, 0)
    EditDate = createEx(EditText, "", ConfigInclude, 336, 64, 236, 20, 0, 0)
    Win32libVer = createEx(EditText, "", ConfigInclude, 336, 84, 236, 20, 0, 0)
    MleDesc = createEx(MleText, "", ConfigInclude, 336, 128, 236, 64, 0, 0)
    MleComment = createEx(MleText, "", ConfigInclude, 336, 196, 240, 96, 0, 0)
                                 --"OK"
    ButClose2 = createEx(PushButton, IDEText[749][1], ConfigInclude, 272, 372, 88, 28, 0, 0)
                              --"Required Win32lib Version:"
    ConfigText7 = createEx(RText, IDEText[750][1], ConfigInclude, 188, 88, 148, 40, 0, 0)
                                --"Win32lib Name:"
    Config_Text1 = createEx(LText, IDEText[751][1], ConfigInclude, 0, 120, 148, 20, 0, 0)

    setHandler(Config_Ew, w32HClick, routine_id("click_Config_Ew"))
    setHandler(Config_Exw, w32HClick, routine_id("click_Config_Exw"))
    setHandler(SaveCfg, w32HClick, routine_id("click_SaveCfg"))
    setHandler(SavePrj, w32HClick, routine_id("click_SavePrj"))
    setHandler(ButClose2, w32HClick, routine_id("click_ButClose2"))
    setHandler(RunCommandLine, w32HChange, routine_id("change_RunCommandLine"))

    setText(RunCommandLine, commandLineRun)
    setCheck(Config_Ew, config_Ew)
    setCheck(Config_Exw, config_Exw)
    setCheck(Config_has_Winlib, config_has_Winlib)
    setText(EditTitle, config_Title)
    setText(EditAuthor, config_Author)
    setText(EditVersion, config_Version)
    setText(EditDate, config_Date)
    setText(Win32libVer, config_WinLibVer)
    setText(MleDesc, config_Desc)
    setText(MleComment, config_Comment)
    setCheck(AddCrashFile, addCrashFile)

end procedure
------------------------------------------------------------------------------
procedure configFileType(integer Self, integer Event, sequence Params)
    resetMultiDrop()

    stopMouse = w32True

    createConfigInclude()

    if treatAsInclude then
        setCheck(Config_Ew, w32True)
        setCheck(Config_Exw, w32False)
    else
        setCheck(Config_Exw, w32True)
        setCheck(Config_Ew, w32False)
    end if

    if not length(getText(Config_Winlib_Name)) then
        setText(Config_Winlib_Name, "Win32lib.ew")
    end if

    if length(cfgWin32lib) then
        setText(Config_Winlib_Name, cfgWin32lib)
    end if

    if length(prjWin32lib) then
        setText(Config_Winlib_Name, prjWin32lib)
    end if

    setCheck(SaveCfg, w32False)
    setCheck(SavePrj, w32False)
    setCheck(Config_has_Winlib, w32True)

    if saveCfg then
        setCheck(SaveCfg, w32True)
    end if
    if savePrj then
        setCheck(SavePrj, w32True)
    end if
    if not config_has_Winlib then
        setCheck(Config_has_Winlib, w32False)
    end if
    doProperties = w32False

    openWindow(ConfigInclude, Modal)
    stopMouse = w32False

end procedure
setHandler(MenuRunOption, w32HClick, routine_id("configFileType"))
-----------------------------------------------------------------------------
procedure click_MenuRunOrder(integer Self, integer Event, sequence Params)
    createReorderwindow()
    openWindow(ReorderWindow, Modal)
end procedure
setHandler(MenuRunOrder, w32HClick, routine_id("click_MenuRunOrder"))
-----------------------------------------------------------------------------
procedure click_MenuIncludeOrder(integer Self, integer Event, sequence Params)
    createIncludeWindow()
    openWindow(IncludeWindow, Modal)
end procedure
setHandler(MenuIncludeOrder, w32HClick, routine_id("click_MenuIncludeOrder"))
-----------------------------------------------------------------------------
procedure click_MenuMsgboxes(integer Self, integer Event, sequence Params)
    createMBoxWin()
    openWindow(MBoxWin, Modal)
end procedure
setHandler(MenuMsgboxes, w32HClick, routine_id("click_MenuMsgboxes"))
-----------------------------------------------------------------------------
procedure click_MenuSystray(integer Self, integer Event, sequence Params)
    createSystrayWin()
    openWindow(SystrayWin, Modal)
end procedure
setHandler(MenuSystray, w32HClick, routine_id("click_MenuSystray"))
-----------------------------------------------------------------------------
procedure click_MenuListValues(integer Self, integer Event, sequence Params)
sequence info
    if equal(controls[selectedControl][Class], "ListView") then
        info = getControlInfo(ListViewWin, {CONTROLINFO_closed})
        if length(info)
        and not info[1] then
            -- is open 
            return
        end if
    end if

    if equal(controls[selectedControl][Class], "ListView") then
        createListViewWindow()
        openWindow(ListViewWin, Normal)
    else
        createInitialWindow()
        openWindow(InitialWindow, Modal)
    end if
end procedure
setHandler(MenuListValues, w32HClick, routine_id("click_MenuListValues"))
------------------------------------------------------------------------------
function getTempFileName()
sequence tempName
integer at

    if not length(openFileName) then
        tempName = reverse(projectDir & "\\Unidentified.exw")
    else
        tempName = reverse(openFileName)
    end if

    at = find('.', tempName)
    if at then
        tempName = tempName[at+1..length(tempName)]
    end if
    tempName = reverse(tempName)

    tempFileName = tempName & "_TEMP"

    if treatAsInclude then
        tempFileName &= ".ew"
    else
        tempFileName &= ".exw"
    end if

    return tempFileName

end function
------------------------------------------------------------------------------
procedure saveGlobals()
    tempRadioReplace        = isChecked(TempRadioReplace)
    tempRadioStop           = isChecked(TempRadioStop)
    tempRadioAsk            = isChecked(TempRadioAsk)
    tempRadioKeepBad        = isChecked(TempRadioKeepBad)
    tempRadioKeepGood       = isChecked(TempRadioKeepGood)
    tempRadioKeepAlways     = isChecked(TempRadioKeepAlways)
    tempRadioKeepNever      = isChecked(TempRadioKeepNever)
end procedure
------------------------------------------------------------------------------
include includes\\process.ew    --controls running generated exw (Tone Skoda)
--------------------------------------------------------------------------------
integer propUW, projUW, toolUW, formUW
propUW = w32False projUW = w32False toolUW = w32False formUW = w32False
--------------------------------------------------------------------------------
object err
procedure actualMenuRun(sequence fName, integer temporaryRun)
integer at, IDEwasMax, IDEwasMin

--START Tone Skoda 1
atom hNewProcess --new process handle
object newProcessInfo
atom hMem
sequence exePathName
--END Tone Skoda 1
    if StopRun then
        return
    end if
    --clear prior error from StatusBar
    hMem = allocate_string(" ")
    VOID = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
    free(hMem)

    propUW = w32False
    projUW = w32False
    toolUW = w32False
    formUW = w32False
    IDEwasMax = w32False
    IDEwasMin = w32False

    if isMaximized(Controls) then
        IDEwasMax = w32True
    elsif isMinimized(Controls) then
        IDEwasMin = w32True
    end if

    if isChecked(MenuUndockProperty)
    and not isChecked(MenuClosedProperty) then
        if isMinimized(PropertyUndockWindow) then
            propUW = w32True
        end if
    end if

    if isChecked(MenuUndockToolKit)
    and not isChecked(MenuClosedToolKit) then
        if isMinimized(IconBarUndockWindow) then
            toolUW = w32True
        end if
    end if

    if isChecked(MenuUndockProject)
    and not isChecked(MenuClosedProject) then
        if isMinimized(ProjectUndockWindow) then
            projUW = w32True
        end if
    end if

    if isChecked(MenuUndockForm)
    and isMinimized(FormUndockWindow) then
        formUW = w32True
    end if

    if not isChecked(NoMinMenuRun) then  --in configurations    
        showWindow(Controls, SW_SHOWMINIMIZED)  --with this Controls is still activated!                
    end if

    backupSelectedWindow = 1
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq

    exePathName = whereEu & "\\bin\\exw.exe"
    --Tone Skoda 

    if length(fName) then
    -- remove extention
        fName = reverse(fName)
        at = find('.', fName)
        if at then
            fName = fName[at+1..length(fName)]
        end if
        fName = reverse(fName)

        -- append .exw extention
        if treatAsInclude then
            fName &= ".ew"
        else
            fName &= ".exw"
        end if

        --change to Project directory
        ok = chdir(projectDir)

        --delete old ex.err
        deleteExErr()

        runShortName = fName

        --minimize the ruler
        minimizeRuler()

        hProjectProcess = 0         --part of Tone enhancement
        projectRunning = w32True

        --turn off selected text in editor
        synTurnOffSelection()

        hNewProcess = 0 --Tone

                --Tone
        if length(commandLineRun) then
            newProcessInfo = CreateProcessHi(exePathName & " \"" & fName & "\"" & commandLineRun)
        else
            newProcessInfo = CreateProcessHi(exePathName & " \"" & fName & "\"")
        end if

        if atom(newProcessInfo) then
            err = read_error_file()
            if atom(err) then
                ok = displayErrorMessage(12,{})
            end if
        else
            if not length(newProcessInfo) then
                err = read_error_file()
                if atom(err) then
                    ok = displayErrorMessage(12,{})
                end if
            else
                hNewProcess = newProcessInfo[1]
                hProjectProcess = hNewProcess
            end if
        end if

        CkProgress(hNewProcess)
    --end Tone
    end if

    if not isChecked(NoMinMenuRun) then
        --if user did not indicate minimization then dont bother with restoring
        if IDEwasMin then
        elsif IDEwasMax then
            showWindow(Controls, SW_MAXIMIZE)
        else
            showWindow(Controls, SW_NORMAL)
        end if
    end if

    projectRunning = w32False

    --show run error message if any
    err = read_error_file()

    if atom(err) then
        --there was no error
        --do we delete the temp file, if there is one?
        if temporaryRun then
            if tempRadioKeepGood then
                    --do nothing keep file
            elsif tempRadioKeepAlways then
                    --do nothing keep file
            elsif tempRadioKeepNever then
                --delete it
                if sequence(dir(fName)) then
                    ok = deleteFile(fName)
                end if
            elsif tempRadioKeepBad then
                --delete it
                if sequence(dir(fName)) then
                    ok = deleteFile(fName)
                end if
            end if
        end if

        fName = ""

        --if editor open return to same statement as before menu run
        if CodeWinOpen
        and not length(isModule) then
            if not length(CursorPos) then
                --a user reported that CursorPos was blank and IDE crashed
                --but I could not get a crash,
                --so....
                CursorPos = synGetCursorPos()
            end if
            showScroll = CursorPos[2]
            showCol = CursorPos[1]
            hMem = allocate_string(sprintf("X: %d",{CursorPos[1]}))
            ok = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
            free(hMem)
            hMem = allocate_string(sprintf("Y: %d",{CursorPos[2]}))
            ok = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
            free(hMem)
        end if

        if CodeWinOpen then
            setFocus(CodeWin)
        end if

    else
        --show code editor
        goto_error()
        setText(StatBar, err[2])

        --do we delete the temp file, if there is one?
        if temporaryRun then
            if tempRadioKeepGood then
                --delete it
                if sequence(dir(fName)) then
                    ok = deleteFile(fName)
                end if
            elsif tempRadioKeepBad then
                    --do nothing
            elsif tempRadioKeepAlways then
                    --do nothing
            elsif tempRadioKeepNever then
                --delete it
                if sequence(dir(fName)) then
                    ok = deleteFile(fName)
                end if
            end if
        end if

        fName = ""
        showWindow(CodeWin, SW_NORMAL)
        setFocus(CodeWin)
    end if

end procedure
-------------------------------------------------------------------------------
procedure click_MenuRunTemp(integer Self, integer Event, sequence Params)
object whereIs
integer temp_saved

        -- was is saved?
    tempFileName = getTempFileName()

    closeWindow(TempWindow)

    editorChanged = synGetModified()
    if CodeWinOpen then
        if not isModuleRoutine then     --length(isModule) then
            saveChangedCode()   --because I want to return to save control-event unless ex.err
        elsif editorChanged then
            showWindow(Controls, SW_RESTORE)
            if isChecked(MenuAutoSave) then
                saveTheModule(0, 0, {})
            else
                ok = displayErrorMessage(30, isModule)
                showWindow(Controls, SW_MINIMIZE)
                if ok=IDYES then
                    saveTheModule(0, 0, {})
                elsif ok=IDCANCEL then
                    showWindow(Controls, SW_RESTORE)
                    return
                end if
            end if
        end if
    end if

    --if does file already exist?   
    whereIs = dir(tempFileName)
    if atom(whereIs) then
        --we are ok file does not exist
        --save it now
        temp_saved = IDE_Changed
        call_proc(openReorder_id,{})
        call_proc(savetheReorder_id,{})
        IDE_Changed = temp_saved

        writeCode(tempFileName)
        if StopRun then
            tempFileName = ""
            showWindow(Controls, SW_RESTORE)
            return
        end if
    else
        if tempRadioStop then
            ok = displayErrorMessage(11,{tempFileName})
            tempFileName = ""
            showWindow(Controls, SW_RESTORE)
            return
        end if
        if tempRadioAsk then
            tempFileName = getOpenFileName(Form,current_dir() & "\\*.exw", {IDEText[1111][1],".exw"})
            if not length(tempFileName) then
                tempFileName = ""
                showWindow(Controls, SW_RESTORE)
                return
            end if
        end if

        --reuse existing temp file or new temp file
        --save it now
        temp_saved = IDE_Changed
        call_proc(openReorder_id,{})
        call_proc(savetheReorder_id,{})
        IDE_Changed = temp_saved
        writeCode(tempFileName)
        if StopRun then
            tempFileName = ""
            showWindow(Controls, SW_RESTORE)
            return
        end if
    end if

    actualMenuRun(tempFileName, w32True)

end procedure
setHandler(MenuRunTemp, w32HClick, routine_id("click_MenuRunTemp"))
----------------------------------------------------------------------------
procedure click_TempCloseBut(integer Self, integer Event, sequence Params)
    closeWindow(TempWindow)
end procedure
-----------------------------------------------------------------------------
procedure click_TempRulesSave(integer Self, integer Event, sequence Params)

    if isChecked(TempRadioReplace) then
        tempRules1 = 1
    elsif isChecked(TempRadioStop) then
        tempRules1 = 2
    elsif isChecked(TempRadioAsk) then
        tempRules1 = 3
    else
        tempRules1 = 0
    end if

    if isChecked(TempRadioKeepBad) then
        tempRules2 = 1
    elsif isChecked(TempRadioKeepGood) then
        tempRules2 = 2
    elsif isChecked(TempRadioKeepAlways) then
        tempRules2 = 3
    elsif isChecked(TempRadioKeepNever) then
        tempRules2 = 4
    else
        tempRules2 = 0
    end if

    saveGlobals()
    saveDefaultSettings()

end procedure
-----------------------------------------------------------------------------
procedure createTempWindow()
    TempWindow = createEx(Window, IDEText[753][1], Controls, Default, Default, 478, 341, {WS_THICKFRAME+WS_DLGFRAME}, 0)
                              --"&Run"
    TempMenu = createEx(Menu, IDEText[754][1], TempWindow, 0, 0, 0, 0, 0, 0)
                                     --"&Run"
    TempRunMenu = createEx(MenuItem, IDEText[754][1], TempMenu, 0, 0, 0, 0, 0, 0)
                                --"&Save"
    TempRunSave = createEx(Menu, IDEText[756][1], TempWindow, 0, 0, 0, 0, 0, 0)
    TempRulesSave = createEx(MenuItem, IDEText[756][1], TempRunSave, 0, 0, 0, 0, 0, 0)
                                --"temporary.exw"
    TempText1 = createEx(LText, IDEText[758][1], TempWindow, 4, 0, 400, 30, 0, 0)
                                        --"Close"
    TempCloseBut = createEx(PushButton, IDEText[759][1], TempWindow, 300, 38, 90, 30, 0, 0)
                                --"When temp file already exists"
    TempGroup1 = createEx(Group, IDEText[760][1], TempWindow, 4, 32, 290, 96, 0, 0)
                                       --"Replace"
    TempRadioReplace = createEx(Radio, IDEText[761][1], TempGroup1, 12, 16, 260, 20, 0, 0)
                                   --"Stop"
    TempRadioStop = createEx(Radio, IDEText[762][1], TempGroup1, 12, 40, 264, 20, 0, 0)
                                   --"Ask for new file name"
    TempRadioAsk = createEx(Radio, IDEText[763][1], TempGroup1, 12, 64, 266, 20, 0, 0)
                                 --"Action after run"
    TempGroup2 = createEx(Group, IDEText[764][1], TempWindow, 4, 138, 254, 112, 0, 0)
                                      --"Keep if bad EXW"
    TempRadioKeepBad = createEx(Radio, IDEText[765][1], TempGroup2, 8, 16, 244, 20, 0, 0)
                                       --"Keep if good EXW"
    TempRadioKeepGood = createEx(Radio, IDEText[766][1], TempGroup2, 8, 40, 240, 20, 0, 0)
                                          --"Keep always"
    TempRadioKeepAlways = createEx(Radio, IDEText[767][1], TempGroup2, 8, 64, 240, 20, 0, 0)
                                         --"Never Keep"
    TempRadioKeepNever = createEx(Radio, IDEText[768][1], TempGroup2, 8, 88, 244, 20, 0, 0)

    setHandler(TempRulesSave, w32HClick, routine_id("click_TempRulesSave"))
    setHandler(TempRunMenu, w32HClick, routine_id("click_MenuRunTemp"))
    setHandler(TempCloseBut, w32HClick, routine_id("click_TempCloseBut"))

    setCheck(TempRadioReplace,tempRadioReplace)
    setCheck(TempRadioStop, tempRadioStop)
    setCheck(TempRadioAsk, tempRadioAsk)
    setCheck(TempRadioKeepBad, tempRadioKeepBad)
    setCheck(TempRadioKeepGood, tempRadioKeepGood)
    setCheck(TempRadioKeepAlways, tempRadioKeepAlways)
    setCheck(TempRadioKeepNever, tempRadioKeepNever)

end procedure
-------------------------------------------------------------------------------
procedure click_MenuRulesTemp(integer Self, integer Event, sequence Params)

    createTempWindow()
    tempFileName = getTempFileName()
    setText(TempText1,tempFileName)

    openWindow(TempWindow, Modal)

end procedure
setHandler(MenuRulesTemp, w32HClick, routine_id("click_MenuRulesTemp"))
------------------------------------------------------------------------------
procedure click_MenuRun(integer Self, integer Event, sequence Params)
integer at
sequence fName

    -- save it, if it needs saving...
    -- if project has not been saved then force a temporary run
    if not length(openFileName) then
        ok = invokeHandler(MenuRunTemp, w32HClick,{})
        return
    else
        ok = invokeHandler(MenuSave, w32HClick, {})
        if StopRun then
            showWindow(Controls, SW_RESTORE)
            if CodeWinOpen then
                setFocus(CodeWin)
            end if
            return
        end if
    end if

    --    AFD: to try and stop freeze at F5 or MenuRun click
    for i=1 to 1000 do
        doEvents(0)
    end for
        --    End AFD

    actualMenuRun(openFileName, w32False)

    if atom(err) then
        --there was no ex.err or crash file
        if isChecked(MenuBackupAfterSave) then
            --copy file to 'after save' backup
            shortName = reverse(shortName)
            at = match(".", shortName)
            if at then
                backup = shortName[at+1..length(shortName)]
                backup = reverse(backup)
            end if
            shortName = reverse(shortName)
            backup &= ".AfterSave.bak"
            if isChecked(ReuseBak2File) then
                fName = pathName & backup
            else
                fName = getSaveFileName(Form, pathName & backup, {IDEText[1098][1],".bak"})--"Backup After Project Good Run"
            end if
            if length(fName) then
                ok = copyFile(pathName & copyName, fName, w32False)
                if not ok then
                    ok = displayErrorMessage(9,{pathName & copyName,fName})
                end if
            end if
            if CodeWinOpen then
                setFocus(CodeWin)
            end if
        end if
    end if

end procedure
setHandler({MenuRun,ToolRun}, w32HClick, routine_id("click_MenuRun"))
--------------------------------------------------------------------------------
procedure click_MenuPass(integer Self, integer Event, sequence Params)
integer editorChanged, temp_saved, what_happens
sequence text,argument,application, selectedEditor, passName

    selectedEditor = getText(DefaultEditor)
    if not length(selectedEditor) then
        selectedEditor = the_current_dir & "\\Editor.exw"
    end if

    editorChanged = synGetModified()
    if CodeWinOpen then
        if not isModuleRoutine then     --length(isModule) then
            saveChangedCode()   --because I want to return to save control-event unless ex.err
        elsif editorChanged then
            if isChecked(MenuAutoSave) then
                saveTheModule(0, 0, {})
            end if
        end if
    end if
    temp_saved = IDE_Changed
    call_proc(openReorder_id,{})
    call_proc(savetheReorder_id,{})
    IDE_Changed = temp_saved
    passName = projectDir & "\\IDEPassFile"
    if treatAsInclude then
        passName &= ".ew"
    else
        passName &= ".exw"
    end if

    writeCode(passName)--projectDir & "\\IDEPassFile.exw" )
    if StopRun then
        return
    end if
    if equal("ed.ex", lower(selectedEditor[length(selectedEditor)-4..length(selectedEditor)])) then
        selectedEditor = selectedEditor[1..length(selectedEditor)-5] & "ed.bat"
    end if
    if equal(".exw", lower(selectedEditor[length(selectedEditor)-3..length(selectedEditor)])) then
        argument = selectedEditor & " " & passName--projectDir & "\\IDEPassFile.ew"
        application = "exw.exe"
    else --.bat, .exe       
        application = selectedEditor
        argument = passName--projectDir & "\\IDEPassFile.exw"
    end if
    what_happens = shellExecuteEx("open",
    -- with the program to call:
                                  application,
    -- the parameter to pass to application to run:
                                  argument,
    -- in this directory:
                                  0,
    -- and last, the 'show' parameter:
                                  SW_SHOW, 0)
    if what_happens<33 then
        if what_happens=2 then
            text = " Application not found!"
        elsif what_happens=31 then
            text = " Application / Document not associated!"
        else
            text = "Strange error!"
        end if
        ok = displayErrorMessage(207,{sprint(what_happens),text})
    end if
end procedure
setHandler(MenuPass, w32HClick, routine_id("click_MenuPass"))
-------------------------------------------------------------------------------
procedure resize_Binding(integer Self, integer Event, sequence Params)
sequence size

    if Params[1]=SIZE_MAXIMIZED
    or Params[1]=SIZE_RESTORED then
        --resize the Binging Option edit box
        size = getClientRect(Binding)
        setCtlSize(BindingOptions, size[3],24)
    end if
end procedure
------------------------------------------------------------------------------
procedure cleanBinding()
    --save fields for next bind    
    checkDebug = isChecked(BindDebug)
    checkList = isChecked(BindList)
    checkQuiet = isChecked(BindQuiet)
    checkCon = isChecked(BindCon)
    bindingOutName = getText(BindOutName)
    bindingIconName = getText(BindingIconName)
    bindingOptions = getText(BindingOptions)

--    if validId(Binding) then
--        destroy(Binding)
--    end if
--    Binding = -1
end procedure
-----------------------------------------------------------------------------
procedure click_CloseButton(integer Self, integer Event, sequence Params)
    cleanBinding()
    closeWindow(Binding)
end procedure
------------------------------------------------------------------------------
procedure click_BindingButton(integer Self, integer Event, sequence Params)
integer controlsIsMaxed

    cleanBinding()
    closeWindow(Binding)

    --save Controls state
    controlsIsMaxed = w32False
    if isMaximized(Controls) then
        controlsIsMaxed = w32True
    end if
    -- minimize the application
    showWindow(Controls, SW_MINIMIZE)

    --delete old ex.err
    deleteExErr()

    setEnable(MenuBind, w32False)

    -- bind windows version
    system(bindingOptions, 2)

    if controlsIsMaxed then
        showWindow(Controls, SW_MAXIMIZE)
    else
        showWindow(Controls, SW_NORMAL)
    end if

    setEnable(MenuBind, w32True)

    --update PRj file with binding options
    writeProject(openFileName)

    --show the window properties
    delayDraw = w32True
    call_proc(updateProperties_id,{})
    delayDraw = w32False
    drawIt()

                -- check success of bind
    if compare(dir("ex.err"), -1)=0 then
        ok = displayErrorMessage(14,{})
    else
        ok = displayErrorMessage(15,{bindName})
    end if

end procedure
------------------------------------------------------------------------------
procedure updateBindingOptions()
    setText(BindingOptions,
            whereEu & "\\bin\\bindw " &
            "\"" & bindName & "\"")
    if isChecked(BindDebug) then
        setText(BindingOptions, getText(BindingOptions) & " -full_debug")
    end if
    if isChecked(BindList) then
        setText(BindingOptions, getText(BindingOptions) & " -list")
    end if
    if isChecked(BindQuiet) then
        setText(BindingOptions, getText(BindingOptions) & " -quiet")
    end if
    if isChecked(BindCon) then
        setText(BindingOptions, getText(BindingOptions) & " -con")
    end if
    if isChecked(BindOut)
    and length(getText(BindOutName)) then
        setText(BindingOptions, getText(BindingOptions)
                & " -out " & "\"" & getText(BindOutName) & "\"")
    end if
    if isChecked(BindIcon)
    and length(getText(BindingIconName)) then
        setText(BindingOptions,getText(BindingOptions) &
                " -icon " & "\"" & getText(BindingIconName) & "\"")
    end if
end procedure
------------------------------------------------------------------------------
procedure click_BindingCheckBoxes(integer Self, integer Event, sequence Params)
    --routine gets used anytime any checkbox is altered or one of the Name editboxes
    --changes
    updateBindingOptions()
end procedure
------------------------------------------------------------------------------
procedure click_TextBindingFind(integer Self, integer Event, sequence Params)
object icofilename
sequence currentdirectory
integer ok

    currentdirectory = current_dir()
    icofilename = {}
    icofilename = getOpenFileName(Binding,current_dir() & "\\*.ico",IcoFileTypes)
    if length(icofilename) then
        setText(BindingIconName, icofilename)
    end if
    ok = chdir(currentdirectory)
end procedure
---------------------------------------------------------------------------------
procedure createBindingWindow()
                                      --"Bind Options"
    Binding = createEx(Window, IDEText[769][1], 0, Default, Default, 593, 393, {WS_THICKFRAME+WS_DLGFRAME}, 0)
                                                                        --"Full Debug"
    BindDebug = createEx(CheckBox, IDEText[770][1], Binding, 8, 8, 148, 20, 0, 0)
                                                                        --"List"
    BindList = createEx(CheckBox, IDEText[771][1], Binding, 8, 28, 148, 20, 0, 0)
                                                                        --"Quiet"
    BindQuiet = createEx(CheckBox, IDEText[772][1], Binding, 8, 56, 148, 20, 0, 0)
                                                                        --"Out (exe filename)"
    BindOut = createEx(CheckBox, IDEText[773][1], Binding, 8, 84, 180, 20, 0, 0)
    BindOutName = createEx(EditText, "", Binding, 192, 84, 388, 20, 0, 0)
                                                                        --"Con"
    BindCon = createEx(CheckBox, IDEText[774][1], Binding, 8, 108, 148, 20, 0, 0)
                                                                                --"Icon"
    BindIcon = createEx(CheckBox, IDEText[775][1], Binding, 8, 132, 148, 20, 0, 0)
                                              --"Window Icon File Name"
    TextBind = createEx(LText, IDEText[781][1], Binding, 56, 156, 360, 20, 0, 0)
    BindingIconName = createEx(EditText, "", Binding, 52, 176, 368, 20, 0, 0)
    TextBindingFind = createEx(PushButton, "...", Binding, 421, 188, 20, 16, 0, 0)
    BindingOptions = createEx(EditText, "", Binding, 8, 252, 564, 20, 0, 0)
                                             --"Bind File\nSave Options"
    RunBindButton = createEx(PushButton, IDEText[778][1], Binding, 10, 276, 290, 76, w32or_all({BS_MULTILINE}), 0)
                                                   --"Close"
    TextBindingClose = createEx(PushButton, IDEText[785][1], Binding, 320, 276, 248, 76, 0, 0)

    setCheck(BindDebug, checkDebug)
    setCheck(BindList, checkList)
    setCheck(BindQuiet, checkQuiet)
    setCheck(BindCon, checkCon)
    setText(BindOutName, bindingOutName)
    if length(bindingOutName) then
        setCheck(BindOut, w32True)
    end if
    setText(BindingIconName, bindingIconName)
    if length(bindingIconName) then
        setCheck(BindIcon,w32True)
    end if
    setText(BindingOptions,
            whereEu & "\\bin\\bindw " &
            "\"" & bindName & "\"")
    if length(bindingOptions) then
        setText(BindingOptions, bindingOptions)
    end if
    updateBindingOptions()

    setHandler(Binding, w32HResize, routine_id("resize_Binding"))
    setHandler(RunBindButton, w32HClick, routine_id("click_BindingButton"))
    setHandler({BindDebug,BindList,BindQuiet,BindCon,BindOut,BindIcon},w32HClick,
               routine_id("click_BindingCheckBoxes"))
    setHandler({BindOutName,BindingIconName},w32HChange,routine_id("click_BindingCheckBoxes"))
    setHandler(TextBindingFind, w32HClick, routine_id("click_TextBindingFind"))
    setHandler(TextBindingClose, w32HClick, routine_id("click_CloseButton"))
end procedure
----------------------------------------------------------------------------------
procedure click_MenuRunBind(integer Self, integer Event, sequence Params)
integer at, gotIt
sequence directory

    gotIt = 0
--    whereEu &= "\\bin"
    directory = dir(whereEu & "\\bin")


    for i=1 to length(directory) do
        if wildcard_file(upper("bindw.*"), upper(directory[i][D_NAME])) then
            gotIt = 1
            exit
        end if
    end for

    if not gotIt then
        ok = displayErrorMessage(13,{})
        return
    end if

    --deselect the control in the button bar
    dropMultipleTimes = w32False
    picked = Pointer

    --toggle on checkmark OFF
    setCheck(MenuClick, w32True)
    setText(IconOff, IDEText[208][1])    --"Off"


    -- save it, if it needs saving...
    ok = invokeHandler(MenuSave, w32HClick, {})

    if StopRun then
        return
    end if


    -- was is saved?
    if length(openFileName) then

        -- copy name
        bindName = openFileName

        -- remove extention
        bindName = reverse(bindName)
        at = find('.', bindName)
        if at then
            bindName = bindName[at+1..length(bindName)]
            bindName = reverse(bindName)
        end if

        -- append .exw extention
        if treatAsInclude then
            bindName &= ".ew"
        else
            bindName &= ".exw"
        end if

        createBindingWindow()
        openWindow(Binding, Modal)

        setFocus(BindingOptions)

    end if

end procedure
setHandler(MenuBind, w32HClick, routine_id("click_MenuRunBind"))
-------------------------------------------------------------------------------
procedure click_RunItem(integer Self, integer Event, sequence Params)       --Launch
sequence fName,currentdirectory
integer ok

    currentdirectory = current_dir()

    fName = getOpenFileName(Form, current_dir() & "\\*.exw",
                            {IDEText[33][1], "*.exw",   --"Euphoria Files"
                             IDEText[34][1], "*.*"}) --"All Files"

    -- entered a file name?
    if length(fName)=0 then
        return
    end if

    shellExecute("open",fName,SW_SHOW)

    ok = chdir(currentdirectory)
end procedure
setHandler(RunItem, w32HClick, routine_id("click_RunItem"))
-----------------------------------------------------------------------------
procedure click_EditLaunchItem(integer self, integer event, sequence params)        --Launch
    openWindow(LauncherWin, Normal)
end procedure
setHandler(EditLaunchItem, w32HClick, routine_id("click_EditLaunchItem"))
-----------------------------------------------------------------------------
procedure change_cbPlayScale(integer Self, integer Event, sequence Params)
    setRulerScale(getIndex(cbPlayScale))
    closeWindow(MeasureScale)
end procedure
setHandler(cbPlayScale, w32HChange, routine_id("change_cbPlayScale"))
------------------------------------------------------------------------------
procedure click_MenuMeasureOpen(integer self, integer event, sequence params)
    setText(MeasureScale, IDEText[752][1])
    openRuler()
end procedure
setHandler(MenuMeasureOpen, w32HClick, routine_id("click_MenuMeasureOpen"))
------------------------------------------------------------------------------
procedure click_MeasureHelp(integer Self, integer Event, sequence Params)

    if not length(RulerDocs) then
        ok = displayErrorMessage(16,{})
        return
    end if

    resetMultiDrop()

    shellExecute("open",RulerDocs,5)

end procedure
setHandler(MenuMeasureHelp, w32HClick, routine_id("click_MeasureHelp"))
------------------------------------------------------------------------------
procedure click_MeasureScale(integer Self, integer Event, sequence Params)


    eraseItems(cbPlayScale)

    for i=1 to 10 do
        addItem(cbPlayScale, sprintf("%d", i))
    end for

    setIndex(cbPlayScale, 2)

    openWindow(MeasureScale, Normal)
end procedure
setHandler(mniRulerScale, w32HClick, routine_id("click_MeasureScale"))
------------------------------------------------------------------------------
-- about... behavior
procedure click_MenuAbout(integer Self, integer Event, sequence Params)

    stopMouse = w32True

    resetMultiDrop()

    if aboutBox= -1 then
        createAboutBox()
    end if

    openWindow(aboutBox, Normal)

    stopMouse = w32False

end procedure
setHandler(MenuAbout, w32HClick, routine_id("click_MenuAbout"))
-----------------------------------------------------------------------------
procedure createKeysWindow()
                                  --"Control Keys"
    KeysWindow = createEx(Window, IDEText[786][1], Form, Default, Default, 550, 400, 0,WS_EX_TOOLWINDOW)
    setWindowBackColor(KeysWindow,BrightWhite)
    LText2 = createEx(LText, "", KeysWindow, 0, 0, 148, 690, 0, 0)
    LText3 = createEx(LText, "", KeysWindow, 148, 0, 380, 690, 0, 0)
end procedure
------------------------------------------------------------------------------
procedure scroll_KeysWindow(integer self, integer event, sequence parms)
integer VChange, Pos, scrolltype

    -- Test for vertical scroll
    if parms[1]=WM_VSCROLL then
        scrolltype = w32lo_word(parms[2])
        if find(scrolltype, {SB_THUMBPOSITION, SB_BOTTOM,
                             SB_TOP, SB_LINEDOWN,
                             SB_LINEUP, SB_PAGEDOWN,
                             SB_PAGEUP}) then

            Pos = 0

            -- Get new scrollbar position depending on scroll event
            if scrolltype=SB_THUMBPOSITION then
                Pos = w32hi_word(parms[2])
            elsif scrolltype=SB_BOTTOM then
                Pos = MinScroll
            elsif scrolltype=SB_TOP then
                Pos = MaxScroll
            elsif scrolltype=SB_LINEUP then
                Pos = OldVPos-1
            elsif scrolltype=SB_LINEDOWN then
                Pos = OldVPos+1
            elsif scrolltype=SB_PAGEUP then
                Pos = OldVPos-ScrollPage
            elsif scrolltype=SB_PAGEDOWN then
                Pos = OldVPos+ScrollPage
            end if

            -- Clip to range
            if Pos<MinScroll then
                Pos = MinScroll
            elsif Pos>MaxScroll then
                Pos = MaxScroll
            end if

             -- Scroll window
            VChange = OldVPos-Pos
            w32Proc(xScrollWindow, {getHandle(self),0, VChange, 0, 0})
            setVScrollPos(self, Pos)
            OldVPos = Pos
        end if

    end if
end procedure
-------------------------------------------------------------------------------
procedure open_Keys(integer self, integer event, sequence params)
    setText(LText2, "ctrl+O"
            & {13,10} & "Ctrl+S"
            & {13,10} & "F12"
            & {13,10} & "Ctrl+J"
            & {13,10} &"Ctrl+P"
            & {13,10} & "Ctrl+T"
            & {13,10} & "Ctrl+E"
            & {13,10} & "Ctrl+M"
            & {13,10} & "Ctrl+U"
            & {13,10} & "Ctrl+W"
            & {13,10} & "Ctrl+Z"
            & {13,10} & "Ctrl+L"
            & {13,10} & "Ctrl+A"
            & {13,10} & "F1,F2,F3"
            & {13,10} & "F5"
            & {13,10} & "F6"
            & {13,10} & "ESCAPE"
            & {13,10} & "DELETE"
            & {13,10} & "DELETE+CTRL"
            & {13,10} & "DELETE+SHIFT"
            & {13,10} & "Ctrl"
            & {13,10} & "Shift"
            & {13,10} & "Arrow keys"
            & {13,10} & "Shift+arrows"
            & {13,10} & "Ctrl+arrows"
            & {13,10} & "Shift+S"
            & {13,10} & "Shift+A"
            & {13,10} & "Shift+R"
           )

    setText(LText3, IDEText[1181][1]
            & {13,10} & IDEText[1182][1]
            & {13,10} & IDEText[1183][1]
            & {13,10} & IDEText[715][1]
            & {13,10} & IDEText[714][1]
            & {13,10} & IDEText[716][1]
            & {13,10} & IDEText[711][1]
            & {13,10} & IDEText[712][1]
            & {13,10} & IDEText[713][1]
            & {13,10} & IDEText[1196][1]
            & {13,10} & IDEText[50][1]
            & {13,10} & IDEText[1184][1]
            & {13,10} & IDEText[634][1]
            & {13,10} & IDEText[1185][1]
            & {13,10} & IDEText[1186][1]
            & {13,10} & IDEText[1187][1]
            & {13,10} & IDEText[549][1]
            & {13,10} & IDEText[718][1]
            & {13,10} & IDEText[720][1]
            & {13,10} & IDEText[720][1]
            & {13,10} & IDEText[1188][1]
            & {13,10} & IDEText[1189][1]
            & {13,10} & IDEText[1190][1]
            & {13,10} & IDEText[1191][1]
            & {13,10} & IDEText[1192][1]
            & {13,10} & IDEText[1193][1]
            & {13,10} & IDEText[1194][1]
            & {13,10} & IDEText[1195][1]
           )
end procedure
-------------------------------------------------------------------------------
procedure click_MenuKeys(integer Self, integer Event, sequence Params)
    if KeysWindow= -1 then
        createKeysWindow()
        setHandler(KeysWindow, w32HOpen, routine_id("open_Keys"))
        setHandler(KeysWindow, w32HEvent, routine_id("scroll_KeysWindow"))
    end if
    -- Set scroll range
    setWindowScrollRange(KeysWindow, SB_VERT, MinScroll, MaxScroll,ScrollPage)

    openWindow(KeysWindow, Normal)
end procedure
setHandler(MenuKeys, w32HClick, routine_id("click_MenuKeys"))
------------------------------------------------------------------------------
procedure click_MenuConts(integer Self, integer Event, sequence Params)

    if not length(IdeDocs) then
        ok = displayErrorMessage(17,{})
        return
    end if

    resetMultiDrop()

    shellExecute("open",IdeDocs,5)

end procedure
setHandler(MenuConts, w32HClick, routine_id("click_MenuConts"))
-----------------------------------------------------------------------------
integer skipResize      skipResize = w32False
integer propertyWidth propertyWidth = propertySize[1]
--these determine the size of PropertySheet when undocked 
--based on last size of PropertyUndockWindow right before redocking
integer propertyUndockX,propertyUndockY,propertyUndockCX,propertyUndockCY
propertyUndockX = 0
propertyUndockY = 0
propertyUndockCX = 0
propertyUndockCY = 0
--------------------------------------------------------------------------------
procedure UndockProperty()
sequence propertyClient, projectSize, controlClient, controlRect, hiddenWindowSize, info, info1

    --property now to be undocked
    propertySize = getRect(PropertySheet)
    controlRect = getRect(Controls)
    setRect(PropertyUndockWindow, controlRect[1]+propertySize[1]+borderX,
            controlRect[2]+propertySize[2]+borderX, propertySize[3]-propertySize[1],
            propertySize[4]-propertySize[2], w32True)

    if propertyUndockX
    or propertyUndockY
    or propertyUndockCX
    or propertyUndockCY then
        setRect(PropertyUndockWindow, propertyUndockX, propertyUndockY, propertyUndockCX, propertyUndockCY, w32True)
    end if

    controlClient = getClientRect(Controls)
    propertyClient = getClientRect(PropertyUndockWindow)
    propertySize = getCtlSize(PropertyUndockWindow)
    --set controls where they belong relative to PropertyUndockWindow   
    setRect(PropertyUndockButton, propertyClient[3]-10,propertyClient[2],10,10,w32True)
    setCtlSize(PropertyTabControl, propertyClient[3], propertyClient[4]-propertyTitleBar)
    size = getCtlSize(PropertyTabControl)
    setCtlSize(sheetId, size[1], size[2]-20)
    setCtlSize(EventListView, size[1], size[2]-20)
    ok = sendMessage(EventListView,LVM_SETCOLUMNWIDTH,0,propertySize[2]-20)
    IDEsize = getClientRect(PropertyUndockWindow)
    setCtlSize(PropertyTitleBar, propertyClient[3]-13, IDEsize[4])

    if not isChecked(MenuUndockProject) then
        projectSize = getCtlSize(ProjectWindow)
        --resize the Project window to full length of controls client area              
        setRect(ProjectWindow, 0, 0, projectSize[1], controlClient[4], w32True)
    end if

    --setParent code contributed by Mario Steel
    ok = w32Func(xSetParent,{getHandle(PropertyTitleBar),getHandle(PropertyUndockWindow)})
    ok = w32Func(xSetParent,{getHandle(PropertyTabControl),getHandle(PropertyUndockWindow)})

    showWindow(PropertySheet, SW_HIDE)
    showWindow(PropertyUndockWindow, SW_NORMAL)

    info = getControlInfo(PropertyUndockWindow, {CONTROLINFO_closed})
    info1 = getControlInfo(ProjectUndockWindow, {CONTROLINFO_closed})
    if (isChecked(MenuUndockProperty) or info[1]=w32True)
    and (isChecked(MenuUndockProject) or info1[1]=w32True) then
        --expand HiddenWindow to fill Controls client area
        hiddenWindowSize = getCtlSize(HiddenWindow)
        setRect(HiddenWindow,0,0,controlClient[3],hiddenWindowSize[2],w32True)
        if isMaximized(Form) then
            --resize form
            hiddenWindowSize = getCtlSize(HiddenWindow)
            setRect(Form,0,0,hiddenWindowSize[1],hiddenWindowSize[2],w32True)
            showWindow(Form, SW_MAXIMIZE)
        end if
    end if

        --make propertysheet on top
    moveZOrder(PropertyUndockWindow, HWND_TOP)

end procedure
--------------------------------------------------------------------------------
procedure putPropertyBackInPlace()
sequence propertyClient, propertySize
        --used in RedockProperty and w32HClose
        --put these back where they belong relative to PropertySheet
        --setParent code contributed by Mario Steel     
    ok = w32Func(xSetParent,{getHandle(PropertyTitleBar),getHandle(PropertySheet)})
    ok = w32Func(xSetParent,{getHandle(PropertyTabControl),getHandle(PropertySheet)})
    propertyClient = getClientRect(PropertySheet)
    propertySize = getCtlSize(PropertySheet)
    setCtlSize(PropertyTabControl, propertyClient[3], propertyClient[4]-propertyTitleBar)
    size = getCtlSize(PropertyTabControl)
    setCtlSize(sheetId, size[1], size[2]-20)
    setCtlSize(EventListView, size[1], size[2]-20)
    ok = sendMessage(EventListView,LVM_SETCOLUMNWIDTH,0,propertySize[2]-20)
    setRect(UndockPropertyButton, propertyClient[3]-10,propertyClient[2],10,10,w32True)
    IDEsize = getClientRect(Controls)
    setCtlSize(PropertyTitleBar, propertyClient[3]-13, IDEsize[4])
    --save sizes and location for next undock
    propertySize = getRelRect(PropertyUndockWindow, Screen)
    propertyUndockX = propertySize[1]
    propertyUndockY = propertySize[2]-toolBar
    propertySize = getCtlSize(PropertyUndockWindow)
    propertyUndockCX = propertySize[1]
    propertyUndockCY = propertySize[2]
end procedure
--------------------------------------------------------------------------------
procedure RedockProperty()
sequence propertySize, projectSize, controlClient, hiddenWindowRect, formSize

    skipResize = w32True

    if isMinimized(PropertyUndockWindow) then
        showWindow(PropertyUndockWindow, SW_RESTORE)
    end if

    putPropertyBackInPlace()

    showWindow(PropertySheet, SW_RESTORE)
    showWindow(PropertyUndockWindow, SW_HIDE)

    --if ProjectTree docked use its cx size
    propertySize = getRect(PropertySheet)
    projectSize = getRect(ProjectWindow)
    controlClient = getClientRect(Controls)

    if not isChecked(MenuUndockProject) then
        setRect(PropertySheet, 0, 0, projectSize[3]-projectSize[1],
                propertySize[4]-propertySize[2],w32True)
        --fill rest with projectwindow                  
        setRect(ProjectWindow, 0, propertySize[4]-propertySize[2], projectSize[3]-projectSize[1],
                controlClient[4]-(propertySize[4]-propertySize[2]),w32True)
    else
        setRect(PropertySheet, 0, 0, propertyWidth, controlClient[4],w32True)
    end if


    --move hiddenwindow out of the way
    hiddenWindowRect = getRect(HiddenWindow)
    if hiddenWindowRect[1]<propertyWidth then
        setRect(HiddenWindow,propertyWidth,0,controlClient[3]-propertyWidth,
                (hiddenWindowRect[4]-hiddenWindowRect[2]),w32True)
    end if
    --check Form in case it was resized. Be sure it still fits in window
    formSize = getRect(Form)
    hiddenWindowRect = getCtlSize(HiddenWindow)
    if (formSize[3]-formSize[1])>hiddenWindowRect[1] then
        setRect(Form,formSize[1],formSize[2],
                hiddenWindowRect[1],formSize[4]-formSize[2],w32True)
    end if
    if isMaximized(Form) then
        --resize form
        setRect(Form,0,0,hiddenWindowRect[1],hiddenWindowRect[2],w32True)
        showWindow(Form, SW_MAXIMIZE)
    end if

    skipResize = w32False

end procedure
--------------------------------------------------------------------------------
procedure MenuUndockProperty_onClick(integer self, integer event, sequence params)--params is ()
    setCheck(self, not isChecked(self))
    if isChecked(MenuUndockProperty) then
        --undock
        UndockProperty()
    else
        --dock
        RedockProperty()
    end if
end procedure
setHandler(MenuUndockProperty, w32HClick, routine_id("MenuUndockProperty_onClick"))
--------------------------------------------------------------------------------
procedure click_DockPropertySheet(integer Self, integer Event, sequence Params)
    ok = invokeHandler(MenuUndockProperty,w32HClick,{0,0,0})
end procedure
setHandler({UndockPropertyButton,PropertyUndockButton}, w32HClick, routine_id("click_DockPropertySheet"))
------------------------------------------------------------------------------
integer projectUndockX,projectUndockY,projectUndockCX,projectUndockCY
projectUndockX = 0
projectUndockY = 0
projectUndockCX = 0
projectUndockCY = 0
--------------------------------------------------------------------------------
procedure UndockProject()
sequence projectClient, propertySize, projectSize, controlClient, controlRect, hiddenWindowSize, info, info1

    --project now to be undocked
    projectSize = getRect(ProjectWindow)
    controlRect = getRect(Controls)
    setRect(ProjectUndockWindow, controlRect[1]+projectSize[1]+borderX, controlRect[2]+projectSize[2]+titleBar, projectSize[3]-projectSize[1],
            projectSize[4]-projectSize[2], w32True)

    if projectUndockX
    or projectUndockY
    or projectUndockCX
    or projectUndockCY then
        setRect(ProjectUndockWindow, projectUndockX, projectUndockY, projectUndockCX, projectUndockCY, w32True)
    end if

    controlClient = getClientRect(Controls)
    projectClient = getClientRect(ProjectUndockWindow)
    projectSize = getCtlSize(ProjectUndockWindow)
    --set controls where they belong relative to ProjectUndockWindow
    setRect(ProjectUndockButton, projectClient[3]-10,projectClient[2],10,10,w32True)
    setCtlSize(TV, projectClient[3], projectClient[4])

    if not isChecked(MenuUndockProperty) then
        propertySize = getCtlSize(PropertySheet)
        --resize the Property window to full length of controls client area
        setRect(PropertySheet, 0, 0, propertySize[1], controlClient[4], w32True)
    end if

    --setParent code contributed by Mario Steel     
    ok = w32Func(xSetParent,{getHandle(TV),getHandle(ProjectUndockWindow)})

    showWindow(ProjectWindow, SW_HIDE)
    showWindow(ProjectUndockWindow, SW_NORMAL)
    info = getControlInfo(PropertyUndockWindow, {CONTROLINFO_closed})
    info1 = getControlInfo(ProjectUndockWindow, {CONTROLINFO_closed})
    if (isChecked(MenuUndockProperty) or info[1]=w32True)
    and (isChecked(MenuUndockProject) or info1[1]=w32True) then
        --expand HiddenWindow to fill Controls client area              
        hiddenWindowSize = getCtlSize(HiddenWindow)
        setRect(HiddenWindow,0,0,controlClient[3],hiddenWindowSize[2],w32True)
        if isMaximized(Form) then
            --resize form
            hiddenWindowSize = getCtlSize(HiddenWindow)
            setRect(Form,0,0,hiddenWindowSize[1],hiddenWindowSize[2],w32True)
            showWindow(Form, SW_MAXIMIZE)
        end if
    end if
    --make project on top
    moveZOrder(ProjectUndockWindow, HWND_TOP)

end procedure
--------------------------------------------------------------------------------
procedure putProjectBackInPlace()
sequence projectClient, projectSize
        --setParent code contributed by Mario Steel     
    ok = w32Func(xSetParent,{getHandle(TV),getHandle(ProjectWindow)})

    --put these back where they belong relative to ProjectWindow
    projectClient = getClientRect(ProjectWindow)
    projectSize = getCtlSize(ProjectWindow)
    setRect(UndockButton, projectClient[3]-10,projectClient[2],10,10,w32True)
    setCtlSize(TV, projectSize[1],projectSize[2])

    --save sizes and location for next undock
    projectSize = getRelRect(ProjectWindow, Screen)
    projectUndockX = projectSize[1]
    projectUndockY = projectSize[2]-toolBar
    projectSize = getRect(ProjectWindow)
    projectUndockCX = projectSize[3]-projectSize[1]
    projectUndockCY = (projectSize[4]-projectSize[2])
end procedure
--------------------------------------------------------------------------------
procedure RedockProject()
sequence propertySize, projectSize, controlClient, hiddenWindowRect, formSize
    skipResize = w32True
    if isMinimized(ProjectUndockWindow) then
        showWindow(ProjectUndockWindow, SW_NORMAL)
    end if

    putProjectBackInPlace()

    showWindow(ProjectWindow, SW_RESTORE)
    showWindow(ProjectUndockWindow, SW_HIDE)

    --if Property docked use its cx size
    propertySize = getRect(PropertySheet)
    controlClient = getClientRect(Controls)
    projectSize = getRect(ProjectWindow)

    if not isChecked(MenuUndockProperty) then
        setRect(ProjectWindow, 0, propertySize[4]-propertySize[2], propertySize[3]-propertySize[1],
                controlClient[4]-(propertySize[4]-propertySize[2]),w32True)
        --fill rest with propertywindow
        setRect(PropertySheet, 0, 0, propertySize[3]-propertySize[1],
                controlClient[4]-(projectSize[4]-projectSize[2]),w32True)
    else
        setRect(ProjectWindow, 0, 0, propertyWidth, controlClient[4],w32True)
    end if


    --move hiddenwindow out of the way
    hiddenWindowRect = getRect(HiddenWindow)
    if hiddenWindowRect[1]<propertyWidth then
        setRect(HiddenWindow,propertyWidth,0,controlClient[3]-propertyWidth,
                (hiddenWindowRect[4]-hiddenWindowRect[2]),w32True)
    end if
    --check Form in case it was resized. Be sure it still fits in window
    formSize = getRect(Form)
    hiddenWindowRect = getCtlSize(HiddenWindow)
    if (formSize[3]-formSize[1])>hiddenWindowRect[1] then
        setRect(Form,formSize[1],formSize[2],
                hiddenWindowRect[1],formSize[4]-formSize[2],w32True)
    end if
    if isMaximized(Form) then
        --resize form
        hiddenWindowRect = getCtlSize(HiddenWindow)
        setRect(Form,0,0,hiddenWindowRect[1],hiddenWindowRect[2],w32True)
        showWindow(Form, SW_MAXIMIZE)
    end if

    skipResize = w32False
end procedure
--------------------------------------------------------------------------------
procedure MenuUndockProject_onClick(integer self, integer event, sequence params)--params is ()
    setCheck(self, not isChecked(self))
    if isChecked(MenuUndockProject) then
        --undock
        UndockProject()
    else
        --dock
        RedockProject()
    end if
end procedure
setHandler(MenuUndockProject, w32HClick, routine_id("MenuUndockProject_onClick"))
--------------------------------------------------------------------------------
procedure UndockButton_onClick(integer self, integer event, sequence params)--params is ()
    ok = invokeHandler(MenuUndockProject,w32HClick,{0,0,0})
end procedure
setHandler({UndockButton,ProjectUndockButton}, w32HClick, routine_id("UndockButton_onClick"))
--------------------------------------------------------------------------------
procedure UndockToolKit()
sequence toolkitRect, controlClient, controlRect, hiddenWindowSize, formSize

        --ToolKit now to be undocked    

    controlRect = getRect(Controls)
    controlClient = getClientRect(Controls)
    hiddenWindowSize = getRect(HiddenWindow)
    toolkitRect = getRect(IconBar)


    setRect(IconBarUndockWindow, (controlRect[1]+controlClient[3])-(toolkitRect[3]-toolkitRect[1])+borderX,
            (controlRect[2]+controlClient[4])-(toolkitRect[4]-toolkitRect[2])+titleBar,
            toolkitRect[3]-toolkitRect[1],
            (toolkitRect[4]-toolkitRect[2])+titleBar, w32True)

            --setParent code contributed by Mario Steel
    ok = w32Func(xSetParent,{getHandle(ToolboxTabControl),getHandle(IconBarUndockWindow)})

    showWindow(IconBar, SW_HIDE)
    showWindow(IconBarUndockWindow, SW_NORMAL)

    --expand HiddenWindow to fill Controls client area
    hiddenWindowSize = getRect(HiddenWindow)
    setRect(HiddenWindow,hiddenWindowSize[1],0,hiddenWindowSize[3]-hiddenWindowSize[1],controlClient[4],w32True)
    if not isChecked(MenuUndockForm) then
        if isMaximized(Form) then
            --expand bottomof Form to fill hiddenwindow
            hiddenWindowSize = getRect(HiddenWindow)
            formSize = getRect(Form)
            setRect(Form,formSize[1],formSize[2],hiddenWindowSize[3],
                    hiddenWindowSize[4],w32True)
            showWindow(Form,SW_MAXIMIZE)
        end if
    end if

    --make toolkit on top    
    moveZOrder(IconBarUndockWindow, HWND_TOP)
end procedure
--------------------------------------------------------------------------------
procedure putToolKitBackInPlace()
sequence toolkitSize, toolkitRect, controlsClientSize

--setParent code contributed by Mario Steel     
    ok = w32Func(xSetParent,{getHandle(ToolboxTabControl),getHandle(IconBar)})
    --find its position in case controls had been resized after undocking
    toolkitSize = getCtlSize(IconBar)
    toolkitRect = getRect(IconBar)
    controlsClientSize = getClientRect(Controls)
    setRect(IconBar, controlsClientSize[3]-toolkitSize[1], controlsClientSize[4]-toolkitSize[2],
            toolkitSize[1], toolkitSize[2], w32True)
end procedure
--------------------------------------------------------------------------------
procedure RedockToolKit()
sequence toolkitSize, controlClient, hiddenWindowRect, formRect, projectSize

    if isMinimized(IconBarUndockWindow) then
        openWindow(IconBarUndockWindow, Normal)
    end if

    putToolKitBackInPlace()

    showWindow(IconBar, SW_RESTORE)
    showWindow(IconBarUndockWindow, SW_HIDE)

    toolkitSize = getRect(IconBar)
    controlClient = getClientRect(Controls)

    --move hiddenwindow out of the way
    hiddenWindowRect = getCtlSize(HiddenWindow)

    if hiddenWindowRect[2]>toolkitSize[2] then
        if isChecked(MenuUndockProperty)
        and isChecked(MenuUndockProject) then
            setRect(HiddenWindow,0,0,hiddenWindowRect[1],
                    controlClient[4]-(toolkitSize[4]-toolkitSize[2]),w32True)
        else
            if not isChecked(MenuUndockProperty) then
                projectSize = getCtlSize(PropertySheet)
                setRect(HiddenWindow,projectSize[1],0,
                        controlClient[3]-projectSize[1],
                        controlClient[4]-(toolkitSize[4]-toolkitSize[2]),w32True)
            else
                if not isChecked(MenuUndockProject) then
                    projectSize = getCtlSize(ProjectWindow)
                    setRect(HiddenWindow,projectSize[1],0,
                            controlClient[3]-projectSize[1],
                            controlClient[4]-(toolkitSize[4]-toolkitSize[2]),w32True)
                end if
            end if
        end if
    end if

    if not isChecked(MenuUndockForm) then
        formRect = getCtlSize(Form)
        hiddenWindowRect = getClientRect(HiddenWindow)
        if formRect[1]>hiddenWindowRect[3] then
            setCtlSize(Form, hiddenWindowRect[3],formRect[2])
        elsif formRect[2]>hiddenWindowRect[4] then
            setCtlSize(Form, formRect[1],hiddenWindowRect[4])
        elsif formRect[1]>hiddenWindowRect[3]
          and formRect[2]>hiddenWindowRect[4] then
            setCtlSize(Form, hiddenWindowRect[3], hiddenWindowRect[4])
        else
            setCtlSize(Form, formRect[1], formRect[2])
        end if
        if isMaximized(Form) then
            showWindow(Form, SW_MAXIMIZE)
        end if
    end if

end procedure
--------------------------------------------------------------------------------
procedure UndockToolButton_onClick(integer self, integer event, sequence params)--params is ()
    ok = invokeHandler(MenuUndockToolKit,w32HClick,{0,0,0})
end procedure
setHandler({ToolboxUndockButton,IconBarUndockButton}, w32HClick, routine_id("UndockToolButton_onClick"))
--------------------------------------------------------------------------------
procedure MenuUndockToolKit_onClick(integer self, integer event, sequence params)--params is ()
    setCheck(self, not isChecked(self))
    if isChecked(MenuUndockToolKit) then
        --undock
        UndockToolKit()
    else
        --dock
        RedockToolKit()
    end if
end procedure
setHandler(MenuUndockToolKit, w32HClick, routine_id("MenuUndockToolKit_onClick"))
------------------------------------------------------------------------------
procedure click_HelpButton(integer Self, integer Event, sequence Params)
sequence helpDocs,DummyFirst,DummyLast,goDocs
integer handle

    helpDocs = IdeDocs

    if not length(IdeDocs) then
        ok = displayErrorMessage(17,{})
        return
    end if

    DummyFirst = "<html>\n<head>\n<meta http-equiv=refresh"
                 & " content=\"0;\nurl=file:///" & helpDocs
    goDocs = "#Tool Box Icons"
    DummyLast  = "\">\n</head>\n</html>"
    handle = open("redirect.htm", "w")
    puts(handle, DummyFirst & goDocs & DummyLast)
    close(handle)

    -- EXECUTE THE HTML REDIRECT FILE:
    shellExecute("open","redirect.htm",SW_SHOWNORMAL)

end procedure
setHandler({ToolboxHelp,IconBarToolboxHelp}, w32HClick, routine_id("click_HelpButton"))
------------------------------------------------------------------------------
procedure change_WinList(integer Self, integer Event, sequence Params)
sequence extent
integer controlnamelength

    if getIndex(WinList)>length(windows) then
        return
    elsif not getIndex(WinList) then
        return
    end if

    --clear backup
    backupControls = {}
    backupSelectedWindow = 1
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32False)
    setEnable(PopUpDesign_Undo, w32False)
    setVisible(ToolUndo, w32False)
    setVisible(ToolUndoD, w32True)

    --save code editor if open
    if CodeWinOpen
    and not codeWinError then
        reOpenCodeWin = w32True
        setIndex(CodeControls,editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, SW_HIDE)
    end if

    -- save current controls
    windows[selectedWindow] = controls

    --clear window of any .ico and .bmp showing
    for i=1 to length(iconStrings) do
        iconData = iconStrings[i]
        if validId(iconData[2]) then
            destroy(iconData[2])
        end if
    end for
    iconStrings = {}

    --clear layer tabitems except for zero
    for i=1 to length(layerTabItemSeq) do
        destroy(layerTabItemSeq[i])
    end for

    layerNum = 0
    layerNumber = 0
    layerTabItemSeq = {}

    --deselect the control in the button bar
    -- unselect prior
    setCheck(MasterList[picked][ControlButton], w32False)

    dropMultipleTimes = w32False
    picked = Pointer

    --toggle on checkmark OFF
    setCheck(MenuClick, w32True)
    setText(IconOff, IDEText[208][1])   --"Off"

    -- pick the selected window
    pickWindow(getIndex(WinList))

    -- initial values
    state           = Normal    -- mouse not in a mode
    mouseDown       = 0         -- mouse button not held down
    selectedTabItem = {}
    hasPopup        = w32False
    selectedControl = TheWindow

    if showActive then
        setText(Show, controls[1][Title])
    end if

    eraseItems(CodeControls)
    controlnamelength = 0
    for i=1 to length(controls) do
        addItem(CodeControls,controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    ok = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    setIndex(CodeControls,TheWindow)

    --select node in Project View
    findCurrentNode(controls[TheWindow][Name])

    if reOpenCodeWin
    and not codeWinError then
        reOpenCodeWin = w32False
        setIndex(CodeControls,TheWindow)
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, SW_NORMAL)
        MenuEditDoubleClick = w32True  --force titlebar to show
    end if

end procedure
setHandler(WinList, w32HChange, routine_id("change_WinList"))--change from click keeps open --Josef
------------------------------------------------------------------------------
procedure click_MenuWinDel(integer Self, integer Event, sequence Params)
integer state,controlnamelength
sequence extent

    --delete the entry in the WinList
    --can not delete all windows!

    state = Normal

    if CodeWinOpen then
        reOpenCodeWin = w32True
        if isMaximized(CodeWin) then
            state = SW_MAXIMIZE
        elsif isMinimized(CodeWin) then
            state = SW_MINIMIZE
        else
            state = SW_NORMAL
        end if
        --save data in case user cancels request
        setIndex(CodeControls,editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if

    --ask to be sure this is what user wants
    ok = displayErrorMessage(18,{})

    if ok=IDCANCEL
    or ok=IDNO then
        if reOpenCodeWin then
            showWindow(CodeWin, state)
        end if
        return
    end if

    --deselect the control in the button bar
    -- unselect prior
    setCheck(MasterList[picked][ControlButton], w32False)

    dropMultipleTimes = w32False
    picked = Pointer

    --toggle on checkmark OFF
    setCheck(MenuClick, w32True)
    setText(IconOff, IDEText[208][1]) --"Off"

    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    backupSelectedWindow = selectedWindow
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    showBackLayer = {}

    layerNum = 0
    layerNumber = 0

    deleteSelectedWindowResource(selectedWindow)

    --if to be deleted window was parent of other windows then need to
    --reassign them to the first window
    for i=getIndex(WinList)+1 to length(windows) do
        if equal(windows[i][1][ControlParent], windows[getIndex(WinList)][1][Name]) then
            windows[i][1][ControlParent] = windows[1][1][Name]
        end if
    end for

    ok = deleteItem(WinList, getIndex(WinList))

    deleteTreeViewNode("", controls[1][Name])

    windows = windows[1..selectedWindow-1]
              & windows[selectedWindow+1..length(windows)]
    layerCaptionSeq = layerCaptionSeq[1..selectedWindow-1]
                      & layerCaptionSeq[selectedWindow+1..length(layerCaptionSeq)]
    --delete any layer tabitems other than layer 0
    for i=1 to length(layerTabItemSeq) do
        destroy(layerTabItemSeq[i])
    end for
    layerTabItemSeq = {}

    IDE_Changed = w32True

    if length(windows) then
        windows[1][1][ControlParent] = {}
        windows[1][1][ParentClass] = {}

        selectedWindow = 1
        -- initial values
        state           = Normal    -- mouse not in a mode
        mouseDown       = 0         -- mouse button not held down
        selectedTabItem = {}
        hasPopup        = w32False
        selectedControl = TheWindow
        pickWindow(1)

    else
        eraseItems(WinList)
        newProject(Controls)
        selectedControl = TheWindow
        copyBlt(ControlBlit, 0, 0, GridBlit)
        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        end if
        if offsetActive then
            copyBlt(OffScreen, 0, 0, OffScreenBlit)
        end if

    end if

    eraseItems(CodeControls)
    controlnamelength = 0
    for i=1 to length(controls) do
        addItem(CodeControls,controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    ok = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)

    setIndex(CodeControls, TheWindow)
    if reOpenCodeWin then
        ok = invokeHandler(CodeControls, w32HClick,{})
        showWindow(CodeWin, state)
    end if
end procedure
setHandler({MenuWinDel,ToolDelete}, w32HClick, routine_id("click_MenuWinDel"))
------------------------------------------------------------------------------
procedure click_MenuLayer(integer Self, integer Event, sequence Params)
sequence layerTabInfo,lValues,validlayers,selectedLayer
atom activeTab
integer atEnd, layer

    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    backupSelectedWindow = selectedWindow
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    --show an empty grid
    drawGrid(GridBlit)
    copyBlt(ControlBlit, 0, 0, GridBlit)
    bitBlt(Design, 0, 0, ControlBlit,0,0, gridX, gridY, SRCCOPY)
    --if active window was not last Tab then place new tab after it
    --first trap where active tab is
    activeTab = getTabItem(LayersTC)
    atEnd = w32True
    if activeTab!=layerTabItemSeq[length(layerTabItemSeq)] then
        atEnd = w32False
    end if

    --build new tabitem for layer number
    layerNum += 1
    layerNumber = layerNum
    LayersTI = createEx(TabItem,IDEText[984][1] & " " & sprint(layerNum),LayersTC,0, 0, 0, 0, 0, 0)
    setHandler(LayersTI,w32HClick,routine_id("change_LayerTI"))
    setHandler(LayersTC,w32HMouse,routine_id("mouse_LayerTC"))
    defineUserProperty(LayersTI,"layer",{layerNum})
    setUserProperty(LayersTI,"layer",{layerNum})
    layerTabItemSeq &= LayersTI

    --add entry to layerCaptionSeq for selectedWindow
    layerTabInfo = {{IDEText[984][1] & " " & sprint(layerNum),0,layerNum,0}}
    layerCaptionSeq[selectedWindow] &= layerTabInfo

    setCheck(MenuTabAllUseLayer, w32False)

    if not atEnd then
        --first save layer number in UserProperties so can place on another tab
        --after rearrange
        validlayers = {}
        for i=1 to length(layerTabItemSeq) do
            lValues = getUserProperty(layerTabItemSeq[i],"layer")
            if length(lValues) then
                layer = lValues[1][1]
                validlayers &= layer
            end if
        end for
        --rearrange tabs so new tab is after active tab
        at = find(activeTab,layerTabItemSeq)

        if at then
            --move last tab behind active tab
            validlayers = validlayers[1..at] & validlayers[length(validlayers)]
                          & validlayers[at+1..length(validlayers)-1]

            selectedLayer = layerCaptionSeq[selectedWindow]
            selectedLayer = selectedLayer[1..at]
                            & {selectedLayer[length(selectedLayer)]}
                            & selectedLayer[at+1..length(selectedLayer)-1]
            layerCaptionSeq[selectedWindow] = selectedLayer

            for i=1 to length(layerTabItemSeq) do
                setUserProperty(layerTabItemSeq[i],"layer",{validlayers[i]})
                setText(layerTabItemSeq[i],layerCaptionSeq[selectedWindow][i][1])
            end for

            setFocus(layerTabItemSeq[at+1])
        end if
    end if

    --clear window of any .ico and .bmp showing
    for i=1 to length(iconStrings) do
        iconData = iconStrings[i]
        if validId(iconData[2]) then
            destroy(iconData[2])
        end if
    end for
    iconStrings = {}

    --now build design with controls matching this layer
    selectedControl = TheWindow
    call_proc(updateProperties_id,{})
    setIndex(PropertyTitleBar, 1)
    call_proc(drawIt_id,{})

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
end procedure
setHandler(MenuLayer,w32HClick,routine_id("click_MenuLayer"))
----------------------------------------------------------------------------
procedure click_MenuTabAllUseLayer(integer Self, integer Event, sequence Params)
sequence lValues
integer index,whichlayer,reshowProp

    setCheck(MenuTabAllUseLayer, not isChecked(MenuTabAllUseLayer))

    --turn on/off all usesetlayer for all controls in the active layer
    lValues = getUserProperty(getTabItem(LayersTC),"layer")
    if length(lValues) then
        whichlayer = lValues[1][1]
    end if

    reshowProp = w32False
    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        if equal(layerCaptionSeq[selectedWindow][i][3],whichlayer) then
            index = i
            for j=1 to length(controls) do
                if j!=TheWindow
                and controls[j][ControlLayer]=layerCaptionSeq[selectedWindow][i][3] then
                    controls[j][SetLayerOK] = isChecked(MenuTabAllUseLayer)
                    reshowProp = w32True
                end if
            end for
        end if
    end for

    --update layer information
    layerCaptionSeq[selectedWindow][index][4] = isChecked(MenuTabAllUseLayer)

    if reshowProp then
        updateProperties()
    end if
end procedure
setHandler(MenuTabAllUseLayer,w32HClick,routine_id("click_MenuTabAllUseLayer"))
-----------------------------------------------------------------------------
procedure click_MenuLayerDel(integer Self, integer Event, sequence Params)
atom lastTabItem
sequence lValues, text, textback
integer at

    if layerNumber=0 then
        --can not delete level zero which is the main controls for project
        return
    end if

    --backup
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    backupSelectedWindow = selectedWindow
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    --get active tabitem
    lastTabItem = getTabItem(LayersTC)
    destroy(lastTabItem)

    --remove controls for this layer
    while w32True do
        at = w32False
        for i=1 to length(controls) do
            if controls[i][ControlLayer]=layerNumber then
                --remove control from controls sequence and ProjectView
                selectedControl = i
                deleteTheControl()
                at = w32True
                exit
            end if
        end for
        if not at then
            exit
        end if
    end while

    --remove from sequence
    at = find(lastTabItem, layerTabItemSeq)
    if at then
        layerTabItemSeq = layerTabItemSeq[1..at-1] & layerTabItemSeq[at+1..length(layerTabItemSeq)]
        layerCaptionSeq[selectedWindow] = layerCaptionSeq[selectedWindow][1..at-1]
                                          & layerCaptionSeq[selectedWindow][at+1..length(layerCaptionSeq[selectedWindow])]
    end if
    --remove from sequence
    at = find(layerNumber, showBackLayer)
    if at then
        showBackLayer = showBackLayer[1..at-1] & showBackLayer[at+1..length(showBackLayer)]
    end if
    text = "Form Design"
    if length(showBackLayer) then
        text = "Form Design: Background Layers = "
    end if
    for i=1 to length(showBackLayer) do
        if i>1 then
            text &= ", "
        end if
        textback = {}
        for j=1 to length(layerCaptionSeq[selectedWindow]) do
            if showBackLayer[i]=layerCaptionSeq[selectedWindow][j][3] then
                textback = layerCaptionSeq[selectedWindow][j][1]
                exit
            end if
        end for
        --show tab caption
        if length(textback) then
            text &= textback
        else
            text &= sprint(showBackLayer[i])
        end if
    end for
    setText(Form, text)

    --get active layer
    lValues = getUserProperty(getTabItem(LayersTC),"layer")
    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        if layerCaptionSeq[selectedWindow][i][3]=lValues[1][1] then
            setCheck(MenuTabAllUseLayer,layerCaptionSeq[selectedWindow][i][4])
            exit
        end if
    end for

    --now build design with controls matching this layer
    selectedControl = TheWindow
    layerNumber = lValues[1][1]
    call_proc(updateProperties_id,{})
    setIndex(PropertyTitleBar, 1)
    drawIt()

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
end procedure
setHandler(MenuLayerDel,w32HClick,routine_id("click_MenuLayerDel"))
--------------------------------------------------------------------------------
sequence tempCaptionSeq, changeName
----------------------------------------------------------------------------------
procedure LayerRenameWindow_onActivate(integer self, integer event, sequence params)--params is ()
        --build combo list of windows and layer tab captions
    --build all window captions
    eraseItems(LayerRenameWinCombo)
    for i=1 to length(windows) do
        addItem(LayerRenameWinCombo, windows[i][1][Name])
    end for
    --set index to currently active window
    setIndex(LayerRenameWinCombo,selectedWindow)

    eraseItems(LayerRenameLayerCombo)
    --build current window's layer captions
    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        addItem(LayerRenameLayerCombo, layerCaptionSeq[selectedWindow][i][1])
    end for
    setIndex(LayerRenameLayerCombo, 1)
    setText(LayerRenameEdit,layerCaptionSeq[getIndex(LayerRenameWinCombo)][1][1])
end procedure
--------------------------------------------------------------------------------
procedure LayerRenameEdit_onKeyDown(integer self, integer event, sequence params)--params is ( atom scanCode, atom shift )
integer ok

    if params[1]=13 then
        ok = invokeHandler(LayerRenameOk,w32HClick,{})
    end if
end procedure
---------------------------------------------------------------------------------
procedure LayerRenameWinCombo_click(integer self, integer event, sequence params)
    --lookup layers in selected window and replace layer caption combo
    --set Index to no selection
    eraseItems(LayerRenameLayerCombo)
    for i=1 to length(layerCaptionSeq[getIndex(LayerRenameWinCombo)]) do
        addItem(LayerRenameLayerCombo, layerCaptionSeq[getIndex(LayerRenameWinCombo)][i][1])
    end for
    setIndex(LayerRenameLayerCombo, 1)
    setText(LayerRenameEdit,layerCaptionSeq[getIndex(LayerRenameWinCombo)][1][1])
end procedure
-------------------------------------------------------------------------------
procedure LayerRenameLayerCombo_click(integer self, integer event, sequence params)
    setText(LayerRenameEdit, getItem(LayerRenameLayerCombo,getIndex(LayerRenameLayerCombo)))
    setFocus(LayerRenameEdit)
end procedure
--------------------------------------------------------------------------------
procedure LayerRenameOk_onClick(integer self, integer event, sequence params)--params is () 
integer index, ok

        --change entry in layer caption combo
    index = getIndex(LayerRenameLayerCombo)

    if index then
        --save layer name before change; for changing in window titlebar
        changeName = getItem(LayerRenameLayerCombo,index)

        ok = deleteItem(LayerRenameLayerCombo, index)
        ok = insertItem(LayerRenameLayerCombo, getText(LayerRenameEdit), index)
        setIndex(LayerRenameLayerCombo, index)
    end if
    --update temporary caption sequence
    --use activeWindow and index as occurance to array
    tempCaptionSeq[getIndex(LayerRenameWinCombo)][index][1] = getText(LayerRenameEdit)

end procedure
--------------------------------------------------------------------------------
procedure LayerRenameOk_onKeyDown(integer self, integer event, sequence params)--params is ( atom scanCode, atom shift )
integer ok

    if params[1]=13 then
        ok = invokeHandler(LayerRenameOk,w32HClick,{})
    end if
end procedure
--------------------------------------------------------------------------------
procedure LayerRenameDone_onClick(integer self, integer event, sequence params)--params is ()
sequence textback, text

        --copy temporary caption sequence to official sequence
    layerCaptionSeq = tempCaptionSeq

    --find and change layer name in Window Titlebar, if present
    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        setText(layerTabItemSeq[i],layerCaptionSeq[selectedWindow][i][1])
    end for
    text = "Form Design"
    if length(showBackLayer) then
        text = "Form Design: Background Layers = "
    end if
    for i=1 to length(showBackLayer) do
        if i>1 then
            text &= ", "
        end if
        textback = {}
        for j=1 to length(layerCaptionSeq[selectedWindow]) do
            if showBackLayer[i]=layerCaptionSeq[selectedWindow][j][3] then
                textback = layerCaptionSeq[selectedWindow][j][1]
                exit
            end if
        end for
        --show tab caption
        if length(textback) then
            text &= textback
        else
            text &= sprint(showBackLayer[i])
        end if
    end for
    setText(Form, text)

    closeWindow(LayerRenameWindow)
end procedure
--------------------------------------------------------------------------------
procedure LayerRenameCancel_onClick(integer self, integer event, sequence params)--params is ()
    closeWindow(LayerRenameWindow)
end procedure
----------------------------------------------------------------------------------
procedure createLayerRenameScreen()
    LayerRenameWindow = createEx(Window, IDEText[992][1], 0, Default, Default, 337, 227, {WS_DLGFRAME+WS_THICKFRAME}, 0)
    LayerRenameTitle1 = createEx(LText, IDEText[993][1], LayerRenameWindow, 8, 8, 148, 20, 0, 0)
    LayerRenameWinCombo = createEx(Combo, "", LayerRenameWindow, 156, 4, 148, 20*6, 0, 0)
    LayerRenameTitle2 = createEx(LText, IDEText[994][1], LayerRenameWindow, 8, 28, 148, 20, 0, 0)
    LayerRenameLayerCombo = createEx(Combo, "", LayerRenameWindow, 156, 24, 148, 20*6, 0, 0)
    LayerRenameTitle3 = createEx(LText, IDEText[995][1], LayerRenameWindow, 8, 60, 148, 20, 0, 0)
    LayerRenameEdit = createEx(EditText, "", LayerRenameWindow, 156, 56, 148, 24, 0, 0)
    LayerRenameOk = createEx(PushButton, IDEText[996][1], LayerRenameWindow, 156, 84, 148, 28, 0, 0)
    LayerRenameDone = createEx(PushButton, IDEText[997][1], LayerRenameWindow, 52, 140, 88, 28, 0, 0)
    LayerRenameCancel = createEx(PushButton, IDEText[998][1], LayerRenameWindow, 192, 140, 88, 28, 0, 0)

    setHandler(LayerRenameWindow, w32HActivate, routine_id("LayerRenameWindow_onActivate"))
    setHandler(LayerRenameEdit, w32HKeyDown, routine_id("LayerRenameEdit_onKeyDown"))
    setHandler(LayerRenameWinCombo,w32HChange,routine_id("LayerRenameWinCombo_click"))
    setHandler(LayerRenameLayerCombo,w32HChange,routine_id("LayerRenameLayerCombo_click"))
    setHandler(LayerRenameOk, w32HClick, routine_id("LayerRenameOk_onClick"))
    setHandler(LayerRenameOk, w32HKeyDown, routine_id("LayerRenameOk_onKeyDown"))
    setHandler(LayerRenameDone, w32HClick, routine_id("LayerRenameDone_onClick"))
    setHandler(LayerRenameCancel, w32HClick, routine_id("LayerRenameCancel_onClick"))

    openWindow(LayerRenameWindow, Modal)
end procedure
------------------------------------------------------------------------------
procedure translate_layerRename()
    if validId(LayerRenameWindow) then
        setText(MenuLayerRename, IDEText[991][1])
        setText(LayerRenameWindow, IDEText[992][1])
        setText(LayerRenameTitle1, IDEText[993][1])
        setText(LayerRenameTitle2, IDEText[994][1])
        setText(LayerRenameTitle3, IDEText[995][1])
        setText(LayerRenameOk, IDEText[996][1])
        setText(LayerRenameDone, IDEText[997][1])
        setText(LayerRenameCancel, IDEText[998][1])
    end if
end procedure
translateLayerRename_id = routine_id("translate_layerRename")
------------------------------------------------------------------------------
procedure click_MenuLayerRename(integer Self, integer Event, sequence Params)
    if LayerRenameWindow= -1 then
        createLayerRenameScreen()
    else
        openWindow(LayerRenameWindow, Modal)
    end if
    tempCaptionSeq = layerCaptionSeq
end procedure
setHandler(MenuLayerRename,w32HClick,routine_id("click_MenuLayerRename"))
------------------------------------------------------------------------------
procedure deactivateTabChildren(integer index)
integer childCnt

    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name], controls[index][SeqChildName]) then
                childCnt += 1
                if equal(controls[i][Class], "TabControl") then
                    controls[i][Active] = w32False
                    if length(controls[i][SeqChildName]) then
                        deactivateTabChildren(i)
                    end if
                elsif equal(controls[i][Class], "TabItem") then
                    if i=selectedControl then
                        controls[i][Active] = w32True
                        --dont do anything with selectedcontrols children yet
                    else
                        controls[i][Active] = w32False
                        if length(controls[i][SeqChildName]) then
                            deactivateTabChildren(i)
                        end if
                    end if
                end if
                if childCnt>=length(controls[index][SeqChildName]) then
                    exit
                end if
            end if
        end for
    end if

end procedure
------------------------------------------------------------------------------
procedure activateTabChildren(integer index)
integer childCnt

    childCnt = 0
    for i=index to length(controls) do
        if find(controls[i][Name], controls[index][SeqChildName]) then
            childCnt += 1
            if equal(controls[i][Class], "TabControl") then
                controls[i][Active] = w32True
                if length(controls[i][SeqChildName]) then
                    activateTabChildren(i)
                end if
                exit
            end if

            if equal(controls[i][Class], "TabItem") then
                --this is hit only when checking the first TabControl on the
                --selected TabItem
                controls[i][Active] = w32True
                if length(controls[i][SeqChildName]) then

                    activateTabChildren(i)
                end if
                exit
            end if

            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end if
    end for
end procedure
------------------------------------------------------------------------------
procedure change_TabItemComboList(integer Self, integer Event, sequence Params)
sequence indexItem
integer index, flag, flag2, flag3, childCnt

--deselect the control in the button bar
-- unselect prior
    setCheck(MasterList[picked][ControlButton], w32False)

    dropMultipleTimes = w32False
    picked = Pointer

    --toggle on checkmark OFF
    setCheck(MenuClick, w32True)
    setText(IconOff, IDEText[208][1])   --"Off"

    indexItem = {}

    index = getIndex(TheTabItemCombo)
    if not index then
        return
    end if

    --find the index in controls for the tabItemCombo
    indexItem = getItem(TheTabItemCombo,getIndex(TheTabItemCombo))
    for i=1 to length(controls) do
        if equal(controls[i][Name], indexItem)
        and equal(controls[i][Class], "TabItem") then
            if not fromTitleBarChange then
                                --skip this when come from TitleBarChange or the wrong control
                                --gets set in the PropertyTitleBar                                          
                selectedControl = i
                selectedTabItem = controls[i][Name]
                controls[selectedControl][Active] = w32True
                delayDraw = w32True
                updateProperties()
                delayDraw = w32False
            end if
            exit
        end if
    end for

    --deactive other tabItems in the same TabControl and their TabItems
    --but not those under selected TabItem

    --find the parent of the selectedTabItem
    flag = findSeqParentName(selectedControl)
    if flag
    and find(controls[flag][Class], {"TabControl","TabItem"}) then
        --deactivate TabItems in TabControl's child list except the selectedControl
        --and any of its child TabControl's TabItems       
        deactivateTabChildren(flag)

        --if the parent TabControl has a TabItem parent, then it must be
        --made active and any other tabs at its level must be inactive.
        if length(controls[flag][SeqParentName]) then
            flag2 = findSeqParentName(flag)  --finds TabItem parent of TabControl(flag)
            if flag2
            and find(controls[flag2][Class], {"TabControl","TabItem"}) then
                --find the tabcontrol of this tabitem
                flag3 = findSeqParentName(flag2)
                if flag3
                and find(controls[flag3][Class], {"TabControl","TabItem"}) then
                    childCnt = 0
                    for i=flag3 to length(controls) do
                        if find(controls[i][Name], controls[flag3][SeqChildName]) then
                            childCnt += 1
                            if i=flag2 then
                                controls[flag2][Active] = w32True
                            else
                                controls[i][Active] = w32False
                            end if
                            if childCnt>=length(controls[flag3][SeqChildName]) then
                                exit
                            end if
                        end if
                    end for
                end if
            end if
        end if
    end if

    controls[selectedControl][Active] = w32True  --should have been done already

    --now activate the first tab of any TabControls under the selected TabItem
    --and its controls, if tabcontrol
    if length(controls[selectedControl][SeqChildName]) then
        activateTabChildren(selectedControl)
    end if

    drawIt()

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if
    if offsetActive then
        copyBlt(OffScreen, 0, 0, OffScreenBlit)
    end if

end procedure
setHandler(TheTabItemCombo, w32HChange, routine_id("change_TabItemComboList")) --change from w32HClick keeps dropdown open --Josef
------------------------------------------------------------------------------
procedure click_MenuInst(integer Self, integer Event, sequence Params)

    stopMouse = w32True

    ok = displayErrorMessage(27,{})

    if ok=IDYES then
        dropMultipleTimes = w32True
        setCheck(MenuClick, w32False)
        setText(IconOff, IDEText[812][1])    --"On"
    else
        setText(IconOff, IDEText[208][1])   --"Off"
        resetMultiDrop()
        picked = TheWindow
    end if

    stopMouse = w32False

end procedure
setHandler(MenuInst, w32HClick, routine_id("click_MenuInst"))
------------------------------------------------------------------------------
procedure click_MenuClick(integer Self, integer Event, sequence Params)
    if isChecked(MenuClick) then
        setCheck(MenuClick, w32False)
        dropMultipleTimes = w32True
        setText(IconOff, IDEText[812][1])    --"On"
    else
        setCheck(IconOff, w32True)
        setText(IconOff, IDEText[208][1])   --"Off"
        resetMultiDrop()
        picked = TheWindow
    end if
end procedure
setHandler(MenuClick, w32HClick, routine_id("click_MenuClick"))
------------------------------------------------------------------------------
procedure click_IconOff(integer Self, integer Event, sequence Params)

    if equal(getText(IconOff), IDEText[208][1]) then --"Off"
        setText(IconOff, IDEText[812][1])      --"On"
        setCheck(MenuClick, w32False)
        dropMultipleTimes = w32True
    else
        setText(IconOff, IDEText[208][1])   --"Off"
        setCheck(MenuClick, w32True)
        resetMultiDrop()
        picked = TheWindow
    end if

end procedure
setHandler(IconOff, w32HClick, routine_id("click_IconOff"))
------------------------------------------------------------------------------
procedure click_MenuFormLock(integer Self, integer Event, sequence Params)

    if isChecked(MenuFormLock) then
        setCheck(MenuFormLock, w32False)

        --set focus to design or any cursor key will not be detected by onKeyPress
        setFocus(Design)
        if showActive then
            setFocus(Show)
        end if

        if offsetActive then
            setFocus(OffScreen)
        end if
    else
        setCheck(MenuFormLock, w32True)
    end if

end procedure
setHandler(MenuFormLock, w32HClick, routine_id("click_MenuFormLock"))
------------------------------------------------------------------------------
procedure click_MenuColorNoSuppress(integer Self, integer Event, sequence Params)

    if isChecked(MenuColorNoSuppress) then
        setCheck(MenuColorNoSuppress, w32False)
    else
        setCheck(MenuColorNoSuppress, w32True)
    end if

    selectedControl = TheWindow

    if isChecked(MenuColorNoSuppress) then
        setPenColor(tile, controls[TheWindow][BkColor])
        if controls[TheWindow][BkColor]<0 then
            setPenColor(tile, Black)
        end if
    else
        setPenColor(tile, getSysColor(COLOR_BTNFACE))
    end if

    drawRectangle(tile, w32True, 0, 0, sizeS[3], sizeS[4])
    drawGrid(GridBlit)
    copyBlt(ControlBlit, 0, 0, GridBlit)

    drawIt()
    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if
    if offsetActive then
        copyBlt(OffScreen, 0, 0, OffScreenBlit)
    end if
end procedure
setHandler(MenuColorNoSuppress, w32HClick, routine_id("click_MenuColorNoSuppress"))
-----------------------------------------------------------------------------
procedure click_MenuFontNoSuppress(integer Self, integer Event, sequence Params)

    if isChecked(MenuFontNoSuppress) then
        setCheck(MenuFontNoSuppress, w32False)
    else
        setCheck(MenuFontNoSuppress, w32True)
    end if
end procedure
setHandler(MenuFontNoSuppress, w32HClick, routine_id("click_MenuFontNoSuppress"))
-----------------------------------------------------------------------------
procedure click_MenuBitmapNoSuppress(integer Self, integer Event, sequence Params)

    if isChecked(MenuBitmapNoSuppress) then
        setCheck(MenuBitmapNoSuppress, w32False)
    else
        setCheck(MenuBitmapNoSuppress, w32True)
    end if
end procedure
setHandler(MenuBitmapNoSuppress, w32HClick, routine_id("click_MenuBitmapNoSuppress"))
------------------------------------------------------------------------------
procedure click_MenuClearRecent(integer Self, integer Event, sequence Params)
    for i=1 to length(FileBuffer) do
        if validId(FileBuffer[i][2]) then
            destroy(FileBuffer[i][2])
        end if
    end for

    if length(FileBuffer) then
        if validId(holdSep) then
            destroy(holdSep)
        end if
    end if

    FileBuffer = {}
    setEnable(MenuClearRecent, w32False)
end procedure
setHandler(MenuClearRecent, w32HClick, routine_id("click_MenuClearRecent"))
------------------------------------------------------------------------------
procedure click_MenuProjectViewOpen(integer Self, integer Event, sequence Params)
    ok = invokeHandler(MenuUndockProject, w32HClick,{0,0,{}})
    openWindow(ProjectWindow, Normal)
    setCheck(MenuClosedProject, w32False)
    setEnable(MenuUndockProject, w32True)
    buildProjectFolders()
end procedure
setHandler(MenuProjectViewOpen, w32HClick, routine_id("click_MenuProjectViewOpen"))
------------------------------------------------------------------------------
procedure click_MenuPropertyOpen(integer Self, integer Event, sequence Params)
    ok = invokeHandler(MenuUndockProperty, w32HClick,{0,0,{}})

    openWindow(PropertySheet, Normal)
    setCheck(MenuClosedProperty, w32False)
    setEnable(MenuUndockProperty, w32True)
    updateProperties()
end procedure
setHandler(MenuPropertyOpen, w32HClick, routine_id("click_MenuPropertyOpen"))
------------------------------------------------------------------------------
procedure click_MenuIconBarOpen(integer Self, integer Event, sequence Params)
    RedockToolKit()
    setCheck(MenuClosedToolKit, w32False)
    setEnable(MenuUndockToolKit, w32True)
end procedure
setHandler(MenuIconBarOpen, w32HClick, routine_id("click_MenuIconBarOpen"))
------------------------------------------------------------------------------
procedure click_MenuCodeEditor(integer Self, integer Event, sequence Params)
integer state
sequence size1

    setIndex(CodeControls,selectedControl)
    ok = invokeHandler(CodeControls,w32HClick,{})
    if CodeWinOpen then
        if isMinimized(CodeWin) then
            --it probably is hidden behind docked Property or ProjectView
            showWindow(CodeWin, SW_NORMAL)
        elsif isMaximized(CodeWin) then
            showWindow(CodeWin, SW_MAXIMIZE)
        end if
    else
        state = HowOpenCodeWin()
        if state=0 then
            --some error
            showWindow(CodeWin, SW_NORMAL)
        elsif state=1 then
            showWindow(CodeWin, SW_MAXIMIZE)
        elsif state=2  then
            showWindow(CodeWin, SW_MINIMIZE)
        elsif state=3 then
            showWindow(CodeWin, SW_NORMAL)
            size1 = getRect(Controls)
            setRect(CodeWin, size1[1]+codePosition[1]+borderX,
                    size1[2]+codePosition[2]+titleBar+menuBar+borderX,
                    codePosition[3], codePosition[4], w32True)
        else
            showWindow(CodeWin, SW_NORMAL)
        end if
        CodeWinOpen = w32True
    end if

end procedure
setHandler(MenuCodeEditor, w32HClick, routine_id("click_MenuCodeEditor"))
------------------------------------------------------------------------------
procedure click_MenuConfiguration(integer Self, integer Event, sequence Params)

    selectedControl = TheWindow
    resetMultiDrop()

    stopMouse = w32True

    openWindow(ConfigWindow, Modal)
    stopMouse = w32False

end procedure
setHandler({MenuConfigurations,ToolConfiguration}, w32HClick, routine_id("click_MenuConfiguration"))
-----------------------------------------------------------------------------
procedure click_MenuHide(integer Self, integer Event, sequence Params)

    resetMultiDrop()

    if isChecked(MenuHide) then
        setCheck(MenuHide, w32False)
        GridHide = w32False
        if not gridBuildYet then
            --only need to build the grid once unless a color,
            --snap size or type grid change is selected
            gridBuildYet = w32True
            drawGrid(GridBlit)
            copyBlt(ControlBlit, 0, 0, GridBlit)
        end if
    else
        setCheck(MenuHide, w32True)
        GridHide = w32True
    end if

    drawIt()
    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if
    if offsetActive then
        copyBlt(OffScreen, 0, 0, OffScreenBlit)
    end if

end procedure
setHandler(MenuHide, w32HClick, routine_id("click_MenuHide"))
------------------------------------------------------------------------------
procedure click_MenuDisable(integer Self, integer Event, sequence Params)

    resetMultiDrop()

    if isChecked(MenuDisable) then
        setCheck(MenuDisable, w32False)
        GridDisable = w32False
    else
        setCheck(MenuDisable, w32True)
        GridDisable = w32True
    end if

end procedure
setHandler(MenuDisable, w32HClick, routine_id("click_MenuDisable"))
-----------------------------------------------------------------------------
procedure close_Controls(integer Self, integer Event, sequence Params)
atom lResponse

    stopMouse = w32True

    -- give message and exit
    setFocus(Controls)

    --moved out of IDE_changed test.
    saveDefaultSettings()

    if projectRunning then
        ok = displayErrorMessage(20,{})
        returnValue(1)
        return  --Josef Jindra
    end if

    if IDE_Changed then
        lResponse = displayErrorMessage(21,{})

        if lResponse=IDYES then
            -- save work
            ok = invokeHandler(MenuSave, w32HClick, {})
            if not length(openFileName) then
                --user cancelled save or saveAs
                returnValue(1)
                return
            end if
            if StopRun then
                return
            end if
            closedUp = w32True
            --remove any held resources
            deleteAllResources()
            terminateProcess()

        elsif lResponse=IDNO then
            closedUp = w32True
            --remove any held resources
            deleteAllResources()
            terminateProcess()

        elsif lResponse=IDCANCEL then
            returnValue(1)
            stopMouse = w32False
            return
        end if
    else
        closedUp = w32True
    end if

    closeWindow(CodeWin)
    Close_MainWin(0,0,{})   --this is in syntax

    stopMouse = w32False

    --remove editor F1 help redirect.htm if present
    ok = deleteFile("redirect.htm")
    --remove pass file to external editor if present
    ok = deleteFile("IDEPassFile.exw")

    if validId(Show) then
        destroy(Show)
    end if
    if validId(OffScreen) then
        destroy(OffScreen)
    end if

    w32Proc(xReleaseMutex,{hMutex})

end procedure
setHandler(Controls, w32HClose, routine_id("close_Controls"))
--------------------------------------------------------------------------------
procedure close_Form(integer Self, integer Event, sequence Params)
    if not closedUp then
        returnValue(1)
    end if
end procedure
setHandler({Form,FormUndockWindow}, w32HClose, routine_id("close_Form"))
----------------------------------------------------------------------------
procedure close_PropertySheet(integer Self, integer Event, sequence Params)
sequence projectSize, controlsClient
    returnValue(1)
    putPropertyBackInPlace()
    showWindow(PropertyUndockWindow, SW_HIDE)
    closeWindow(PropertySheet)
    setCheck(MenuClosedProperty, w32True)
    setEnable(MenuUndockProperty, w32False)
    if not isChecked(MenuUndockProject) then
        --expand projectView
        projectSize = getCtlSize(PropertySheet)
        controlsClient = getClientRect(Controls)
        setCtlSize(ProjectWindow, projectSize[1], controlsClient[4])
    end if
end procedure
setHandler(PropertyUndockWindow, w32HClose, routine_id("close_PropertySheet"))
---------------------------------------------------------------------------
procedure close_IconBar(integer Self, integer Event, sequence Params)
    returnValue(1)
    putToolKitBackInPlace()
    showWindow(IconBarUndockWindow, SW_HIDE)
    closeWindow(IconBar)
    setCheck(MenuClosedToolKit, w32True)
    setEnable(MenuUndockToolKit, w32False)
end procedure
setHandler(IconBarUndockWindow, w32HClose, routine_id("close_IconBar"))
----------------------------------------------------------------------------
procedure close_ProjectView(integer Self, integer Event, sequence Params)
sequence propertySize, controlsClient
    returnValue(1)
    putProjectBackInPlace()
    showWindow(ProjectUndockWindow, SW_HIDE)
    closeWindow(ProjectWindow)
    setCheck(MenuClosedProject, w32True)
    setEnable(MenuUndockProperty, w32False)
    if not isChecked(MenuUndockProperty) then
        --expand property sheet
        propertySize = getCtlSize(PropertySheet)
        controlsClient = getClientRect(Controls)
        setCtlSize(PropertySheet, propertySize[1], controlsClient[4])
    end if
end procedure
setHandler(ProjectUndockWindow, w32HClose, routine_id("close_ProjectView"))
-----------------------------------------------------------------------------
procedure click_PopUpDesign_CodeEditor(integer Self, integer Event, sequence Params)
integer at, state
sequence saveModule, size1

--clear backup
    backupControls = {}
    backupSelectedWindow = 1
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq

    setEnable(MenuControlUndo, w32False)
    setEnable(PopUpDesign_Undo, w32False)
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
    setVisible(ToolUndo, w32False)
    setVisible(ToolUndoD, w32True)

    if cameFromProjectView
    and length(isModule) then
        --may need to strip out any "\\" because it might be include a
        --portion of path
        saveModule = isModule
        isModule = reverse(isModule)
        at = match("\\", isModule)
        if at then
            isModule = isModule[1..at-1]
        end if
        isModule = reverse(isModule)

        for i=1 to getCount(CodeModules) do
            if equal(isModule, getItem(CodeModules, i)) then
                setIndex(CodeModules, i)
                exit
            end if
        end for

        isModule = saveModule

        --reset last cursor position from onchangecodefromproject()
        for i=1 to length(openModuleAt) do
            if equal(getItem(CodeModules,getIndex(CodeModules)), openModuleAt[i][1]) then
                openModuleAt[i][2] = moduleX
                openModuleAt[i][3] = moduleY
                openModuleAt[i][4] = moduleTop
                exit
            end if
        end for
        state = HowOpenCodeWin()
        CodeWinOpen = w32True
        ok = invokeHandler(CodeModules, w32HChange, {})
        if state=0 then
            --some error
            showWindow(CodeWin, SW_RESTORE)
        elsif state=1 then
            showWindow(CodeWin, SW_MAXIMIZE)
        elsif state=2 then
            showWindow(CodeWin, SW_MINIMIZE)
        elsif state=3 then
            showWindow(CodeWin, SW_NORMAL)
            size1 = getRect(Controls)
            setRect(CodeWin, size1[1]+codePosition[1],
                    size1[2]+codePosition[2]+titleBar+menuBar+borderX-toolBar,
                    codePosition[3], codePosition[4], w32True)
        else
            showWindow(CodeWin, SW_NORMAL)
        end if
        setFocus(Highlight)
        MenuEditDoubleClick = w32True  --to force titlebar to stay lit
        return
    else
        --Josef start
        eraseItems(CodeControls)
        for i=1 to length(controls) do
            addItem(CodeControls,controls[i][Name])
        end for
        --Josef end

        CodeWinOpen = w32True
        setIndex(CodeControls, selectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, SW_RESTORE)
        MenuEditDoubleClick = w32True  --to force titlebar to stay lit
    end if
end procedure
setHandler(PopUpDesign_CodeEditor, w32HClick, routine_id("click_PopUpDesign_CodeEditor"))
--------------------------------------------------------------------------------
procedure EventListView_onClick(integer Self, integer Event, sequence Params)--params is ()
sequence eventSelected, classModule

    eventSelected = getLVSelected(EventListView)
    if length(eventSelected)>0 then
        if CodeWinOpen then
            setIndex(CodeControls, selectedControl)
            ok = invokeHandler(CodeControls,w32HClick,{})
        end if
        --build the code for editor
        classModule = getLVItemText(EventListView, eventSelected[1], 1)
        for i=1 to length(Events) do
            if equal(classModule, Events[i][1]) then
                showEvent = i
                exit
            end if
        end for
        showScroll = 1
        showCol = 1
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, SW_RESTORE)
        if not CodeWinOpen then
            CodeWinOpen = w32True
        end if
    end if

end procedure
setHandler(EventListView, w32HClick, routine_id("EventListView_onClick"))
----------------------------------------------------------------------------
--Roland Stowasser
procedure click_PopUpDesign_MenuEditor(integer Self, integer Event, sequence Params)
    stopMouse = w32True
    selectedControl = TheWindow
    resetMultiDrop()

    --backup controls
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    -- open menu editor
    createMenuEditWindow()
    openWindow(MenuEditWindow, Modal)

    stopMouse = w32False
end procedure
setHandler(PopUpDesign_MenuEditor, w32HClick, routine_id("click_PopUpDesign_MenuEditor"))
----------------------------------------------------------------------------
--Roland Stowasser
procedure click_PopUpDesign_PopupEditor(integer Self, integer Event, sequence Params)

    selectedControl = TheWindow
    resetMultiDrop()

    --backup controls
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    -- open menu editor
    createPopupEditWindow()
    openWindow(PopupEditWindow, Modal)
end procedure
setHandler(PopUpDesign_PopupEditor, w32HClick, routine_id("click_PopUpDesign_PopupEditor"))
----------------------------------------------------------------------------
--Roland Stowasser
procedure click_PopUpDesign_ProjectTreeOpen(integer Self, integer Event, sequence Params)
sequence info
    info = getControlInfo(ProjectWindow, {CONTROLINFO_closed})
    if info[1] then
        --was closed so open
        openWindow(ProjectWindow, Normal)
    else
        if isChecked(MenuUndockProject) then
            ok = invokeHandler(MenuUndockProject, w32HClick, {0,0,0})
        end if
        showWindow(ProjectWindow, SW_NORMAL)
        --rebuild existing tree
        buildProjectFolders()
    end if
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_ProjectTreeOpen, w32HClick, routine_id("click_PopUpDesign_ProjectTreeOpen"))
----------------------------------------------------------------------------
procedure click_PopUpDesign_PropertyOpen(integer Self, integer Event, sequence Params)
sequence info
    info = getControlInfo(PropertySheet, {CONTROLINFO_closed})
    if info[1] then
        --was closed so open            
        showWindow(PropertySheet, SW_NORMAL)
    else
        --need to dock if was undocked
        if isChecked(MenuUndockProperty) then
            ok = invokeHandler(MenuUndockProperty, w32HClick, {0,0,0})
        end if
        showWindow(PropertySheet, SW_NORMAL)
        updateProperties()
    end if
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_PropertyOpen, w32HClick, routine_id("click_PopUpDesign_PropertyOpen"))
---------------------------------------------------------------------------------
procedure click_PopUpDesign_IconBarOpen(integer Self, integer Event, sequence Params)
sequence info
    info = getControlInfo(IconBar, {CONTROLINFO_closed})
    if info[1] then
        --was closed so open
        openWindow(IconBar, Normal)
    else
        if isChecked(MenuUndockToolKit) then
            ok = invokeHandler(MenuUndockToolKit, w32HClick, {0,0,0})
        end if
        showWindow(IconBar, SW_NORMAL)
        setFocus(IconBar)
    end if
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_IconBarOpen, w32HClick, routine_id("click_PopUpDesign_IconBarOpen"))

---------------------------------------------------------------------------
procedure click_PopUpDesign_Styles(integer Self, integer Event, sequence Params)
    if equal(getText(PopUpDesign_Styles), IDEText[717][1]) then
        ok = invokeHandler(MenuWinStyles, w32HClick, {})
    else
        ok = invokeHandler(MenuListViewStyles, w32HClick, {})
    end if
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_Styles, w32HClick, routine_id("click_PopUpDesign_Styles"))
----------------------------------------------------------------------------
procedure click_PopUpDesign_DeleteTabControl(integer Self, integer Event, sequence Params)
integer flag

    if equal(controls[selectedControl][Class], "TabItem") then
        --find parent
        flag = findSeqParentName(selectedControl)
        if flag then
            selectedControl = flag
            deleteTheControl()
        end if
    else
        deleteTheControl()
    end if
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_DeleteTabControl, w32HClick,
           routine_id("click_PopUpDesign_DeleteTabControl"))
--------------------------------------------------------------------------------
procedure TS_FitYes_onClick(integer self, integer event, sequence params)--params is ()
    if isChecked(TS_FitYes) then
        setCheck(TS_VScroll,w32False)
        setCheck(TS_HScroll,w32False)
        setCheck(TS_Resizable, w32False)
        setEnable(TS_VScroll, w32False)
        setEnable(TS_HScroll, w32False)
        setEnable(TS_Resizable, w32False)
        setEnable(TS_Note1,w32False)
--        setEnable(TS_Note2,w32False)
--        setEnable(TS_Note3, w32False)
    end if
end procedure
--------------------------------------------------------------------------------
procedure TS_FitNo_onClick(integer self, integer event, sequence params)--params is ()
    if isChecked(TS_FitNo) then
        setEnable(TS_HScroll, w32True)
        setEnable(TS_VScroll, w32True)
        setEnable(TS_Resizable, w32True)
        setEnable(TS_Note1, w32True)
--        setEnable(TS_Note2, w32True)
--        setEnable(TS_Note3, w32True)
    end if
end procedure
--------------------------------------------------------------------------------
procedure TSCheckBox3_onClick(integer self, integer event, sequence params)--params is ()
    if isChecked(TSCheckBox3) then
        setCheck(TSCheckBox1,w32True)
    end if
end procedure
------------------------------------------------------------------------------
procedure revertToOriginalSetHandler(integer selectedControl)
        --change routine_id of children of selectedControl to control and event
integer at
sequence nameEvent

    nameEvent = {}
    for i=selectedControl to length(controls) do
        if equal(controls[i][SeqParentName],controls[selectedControl][Name]) then
            for j=1 to length(controls[i][Code]) do
                for k=1 to length(controls[i][Code][j]) do
                    at = match("end procedure",controls[i][Code][j][k])
                    if at then
                                                --ignore end procedure
                    else
                        at = match("procedure",controls[i][Code][j][k])
                        if at then
                            --parse for the control,event
                            nameEvent = controls[i][Code][j][k][11..length(controls[i][Code][j][k])]
                            at = match("(", nameEvent)
                            if at then
                                nameEvent = nameEvent[1..at-1]
                                nameEvent = w32trim(nameEvent)
                            end if
                        end if
                    end if
                    at = match("setHandler",controls[i][Code][j][k])
                    if at then
                        at = match("routine_id",controls[i][Code][j][k])
                        controls[i][Code][j][k] = controls[i][Code][j][k][1..at+9]
                                                  & "(\"" & nameEvent & "\"))"
                    end if
                end for
            end for
        end if
    end for
end procedure
--------------------------------------------------------------------------------
procedure click_TSPushButton1(integer Self, integer Event, sequence Params)

integer holdSelectedControl, cnt, col, row, numcontrols, cell, preserveNames
sequence the, holdName, treedata, renameTableCells, usedCell, name, extent
integer childCnt, controlnamelength, addedToArray

    addedToArray = w32False
    treedata = {"",""}

    --hold the original values for checking if changed below
    the = controls[selectedControl]

    --find all cells of this table, if any, and save their name and caption for
    --replacement into cells after rebuilding
    --watch for multiple controls in a cell
    usedCell = {}
    cell = 0
    --make usedCells length same as Table controls col*rows.
    usedCell = repeat({{"~","~"}},the[TableCols]*the[TableRows])

    childCnt = 0
    if length(the[SeqChildName]) then
        for i=selectedControl to length(controls) do
            if controls[i][TableCell]
            and find(controls[i][Name], the[SeqChildName]) then
                childCnt += 1
                cell = controls[i][TableCell]
                if equal(usedCell[cell][1], {"~","~"}) then
                    usedCell[cell][1][1] = controls[i][Name]
                    usedCell[cell][1][2] = controls[i][Title]
                else
                    usedCell[cell] &= {{"~","~"}}
                    usedCell[cell][length(usedCell[cell])][1] = controls[i][Name]
                    usedCell[cell][length(usedCell[cell])][2] = controls[i][Title]
                end if
            end if
            if childCnt>=length(the[SeqChildName]) then
                exit
            end if
        end for
    end if

    renameTableCells = {}
    numcontrols = length(usedCell[1])
    renameTableCells = repeat(repeat(repeat({"~","~"},numcontrols),the[TableCols]),the[TableRows])
    row = 1
    col = 0
    for i=1 to length(usedCell) do
        col += 1
        if col>the[TableCols] then
            col = 1
            row += 1
        end if
        for j=1 to numcontrols do
            renameTableCells[row][col][j][1] = usedCell[i][j][1]
            renameTableCells[row][col][j][2] = usedCell[i][j][2]
        end for
    end for

    controls[selectedControl][TableCols] = getNumber(TSEditText1)
    controls[selectedControl][TableColsSpace] = getNumber(TSEditText2)
    controls[selectedControl][TableRows] = getNumber(TSEditText3)
    controls[selectedControl][TableRowsSpace] = getNumber(TSEditText4)

    if controls[selectedControl][TableCols]>1
    or controls[selectedControl][TableRows]>1 then
        if isChecked(TSCheckBox1) then
            controls[selectedControl][TableArray] = w32True
            if controls[selectedControl][TableGenInExw] then
                setCheck(TSCheckBox3, w32True)
            end if
        else
            controls[selectedControl][TableArray] = w32False
            controls[selectedControl][TableGenInExw] = w32False
            setCheck(TSCheckBox3, w32False)
        end if
    end if

    if isChecked(TSCheckBox2) then
        controls[selectedControl][PreserveName] = w32True
    else
        controls[selectedControl][PreserveName] = w32False
    end if

    if isChecked(TS_FitYes) then
        controls[selectedControl][FitToTable] = w32True
    else
        controls[selectedControl][FitToTable] = w32False
        controls[selectedControl][TableGenBorder] = w32False
    end if

    if isChecked(TS_HScroll) then
        controls[selectedControl][TableHScroll] = w32True
    else
        controls[selectedControl][TableHScroll] = w32False
    end if

    if isChecked(TS_VScroll) then
        controls[selectedControl][TableVScroll] = w32True
    else
        controls[selectedControl][TableVScroll] = w32False
    end if

    if isChecked(TS_Resizable) then
        controls[selectedControl][TableResizable] = w32True
    else
        controls[selectedControl][TableResizable] = w32False
    end if

    if isChecked(TSCheckBox3) then
        controls[selectedControl][TableGenInExw] = w32True
        controls[selectedControl][TableArray] = w32True
        setCheck(TSCheckBox1,w32True)
    else
        controls[selectedControl][TableGenInExw] = w32False
    end if

    if isChecked(TSCheckBox4) then
        controls[selectedControl][TableGenBorder] = w32True
    else
        controls[selectedControl][TableGenBorder] = w32False
    end if

    if isChecked(TSRow) then
        if controls[selectedControl][CommonSetHandler]!=1 then
            revertToOriginalSetHandler(selectedControl)
        end if
        controls[selectedControl][CommonSetHandler] = 1
    elsif isChecked(TSCol) then
        if controls[selectedControl][CommonSetHandler]!=2 then
            revertToOriginalSetHandler(selectedControl)
        end if
        controls[selectedControl][CommonSetHandler] = 2
    elsif isChecked(TSAll) then
        if controls[selectedControl][CommonSetHandler]!=3 then
            revertToOriginalSetHandler(selectedControl)
        end if
        controls[selectedControl][CommonSetHandler] = 3
    else
        if controls[selectedControl][CommonSetHandler]!=0 then
            revertToOriginalSetHandler(selectedControl)
        end if
        controls[selectedControl][CommonSetHandler] = 0
    end if

    if isChecked(TSCheckAll) then
        controls[selectedControl][TableButtonAllColor] = w32True
    else
        controls[selectedControl][TableButtonAllColor] = w32False
    end if

    controls[selectedControl][TableButtonAllCopy] = w32False
    if isChecked(TSCheckCopy) then
        controls[selectedControl][TableButtonAllCopy] = w32True
    end if

    if equal(getItem(PropertyTitleBar, getIndex(PropertyTitleBar)),
             controls[selectedControl][Name]) then
        updateProperty("Column")
    else
        updateProperties()
    end if

    closeWindow(TableSpecs)

    --now build the controls, if any
    cnt = 0
    childCnt = 0
    damagedFlag = 0

    if length(controls[selectedControl][SeqChildName]) then
        for i=selectedControl to length(controls) do
            if find(controls[i][Name], controls[selectedControl][SeqChildName]) then
                childCnt += 1
                if cnt<controls[i][TableCell] then
                    cnt = controls[i][TableCell]
                end if
            end if
            if childCnt>=length(controls[selectedControl][SeqChildName]) then
                exit
            end if
        end for
    end if

    if cnt=1 then  --only cell one
        buildNewTable(controls[selectedControl][TableCols],
                      controls[selectedControl][TableRows],
                      controls[selectedControl][TableColsSpace],
                      controls[selectedControl][TableRowsSpace],{},0,
                      isChecked(TS_FitYes))

        --avoid duplication of 1 control
        if not damagedFlag then
            if controls[selectedControl][TableCols]>1
            or controls[selectedControl][TableRows]>1 then
                --add the tables now
                for i=1 to length(tables) do
                    controls &= {tables[i]}
                    if tables[i][TableCell]!=1 then
                        addTreeViewNode(tables[i][ControlParent],tables[i][Name])
                        treedata[1] = tables[i][Name]
                        treedata[2] = tables[i][Class]
                        theTreeForm &= {treedata}
                    end if
                end for
            end if
        else
                        --add the tables now
            for i=1 to length(tables) do
                controls &= {tables[i]}
                if tables[i][TableCell]!=1 then
                    addTreeViewNode(tables[i][ControlParent],tables[i][Name])
                    treedata[1] = tables[i][Name]
                    treedata[2] = tables[i][Class]
                    theTreeForm &= {treedata}
                end if
            end for
        end if

    else
        preserveNames = isChecked(TSCheckBox2)
        if the[TableCols]!=controls[selectedControl][TableCols]
        or the[TableRows]!=controls[selectedControl][TableRows]
        or the[TableColsSpace]!=controls[selectedControl][TableColsSpace]
        or the[TableRowsSpace]!=controls[selectedControl][TableRowsSpace]
        or the[PreserveName]!=controls[selectedControl][PreserveName]
        or the[FitToTable]!=controls[selectedControl][FitToTable]
        then
            rebuildTableNow(controls[selectedControl][TableCols],
                            controls[selectedControl][TableRows],
                            controls[selectedControl][TableColsSpace],
                            controls[selectedControl][TableRowsSpace], renameTableCells,
                            preserveNames, isChecked(TS_FitYes), controls[selectedControl][LabelExtent])
        else
            --nothing changed

            --and rebuild the design form
            holdSelectedControl = selectedControl
            selectedControl = TheWindow
            call_proc(drawIt_id,{})
            selectedControl = holdSelectedControl

            -- draw selected control
            drawControl(ControlBlit, controls[selectedControl], Selected,selectedControl, 0)

            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
            if showActive then
                bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
            end if

            if offsetActive then
                copyBlt(OffScreen, 0, 0, OffScreenBlit)
            end if

            return
        end if

        if controls[selectedControl][TableCols]>1
        or controls[selectedControl][TableRows]>1 then
            --add the tables now
            for i=1 to length(tables) do
                controls &= {tables[i]}
                if tables[i][TableCell]!=1 then
                    addTreeViewNode(tables[i][ControlParent],tables[i][Name])
                    treedata[1] = tables[i][Name]
                    treedata[2] = tables[i][Class]
                    theTreeForm &= {treedata}
                end if
            end for
        end if
    end if

    holdName = controls[selectedControl][Name]

    --insure control index in Code Editor stays in sync with sorted controls
    name = getItem(CodeControls,getIndex(CodeControls))
    controls = sort(controls)
    eraseItems(CodeControls)
    controlnamelength = 0
    for i=1 to length(controls) do
        addItem(CodeControls,controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    ok = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)

    for i=1 to getCount(CodeControls) do
        if equal(name,getItem(CodeControls,i)) then
            setIndex(CodeControls, i)
            editorSelectedControl = i
            exit
        end if
    end for

    --find selected control again
    for i=1 to length(controls) do
        if equal(holdName,controls[i][Name]) then
            selectedControl = i
            exit
        end if
    end for

    --and rebuild the design form
    holdSelectedControl = selectedControl
    selectedControl = TheWindow
    call_proc(drawIt_id,{})
    selectedControl = holdSelectedControl
    -- draw selected control
    drawControl(ControlBlit, controls[selectedControl], Selected,selectedControl, 0)

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if offsetActive then
        copyBlt(OffScreen, 0, 0, OffScreenBlit)
    end if

end procedure
-----------------------------------------------------------------------------
procedure click_TSPushButton2(integer Self, integer Event, sequence Params)
    closeWindow(TableSpecs)
end procedure
-----------------------------------------------------------------------------
procedure click_PopUpDesign_Table(integer Self, integer Event, sequence Params)

                                    --"Table Specifications"
    TableSpecs = createEx(Window, IDEText[788][1], Form, Default, Default, 640, 480, {WS_THICKFRAME+WS_DLGFRAME}, 0)
    TSEditText1 = createEx(EditText, "1", TableSpecs, 120, 8, 48, 20, 0, 0)
    TSEditText3 = createEx(EditText, "1", TableSpecs, 120, 32, 48, 20, 0, 0)
    TSEditText2 = createEx(EditText, "1", TableSpecs, 276, 8, 48, 20, 0, 0)
    TSEditText4 = createEx(EditText, "1", TableSpecs, 276, 32, 48, 20, 0, 0)
    TSUpDown1 = createEx(UpDown, "UpDown6", TableSpecs, 168, 8, 0, 0, w32or_all({UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS}), 0)
    TSUpDown3 = createEx(UpDown, "UpDown7", TableSpecs, 324, 32, 0, 0, w32or_all({UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS}), 0)
    TSUpDown2 = createEx(UpDown, "UpDown8", TableSpecs, 168, 8, 0, 0, w32or_all({UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS}), 0)
    TSUpDown4 = createEx(UpDown, "UpDown9", TableSpecs, 324, 32, 0, 0, w32or_all({UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS}), 0)
                                                                                --"Generate array in EXW"
    TSCheckBox3 = createEx(CheckBox, IDEText[1034][1], TableSpecs, 72, 360, 320, 20, 0, 0)
                                                                        --"Add border around Table (Uses Group instead of LText)"
    TSCheckBox4 = createEx(CheckBox, IDEText[1035][1], TableSpecs, 28, 312, 472, 20, 0, 0)
                                  --"Columns"
    TSLText1 = createEx(LText, IDEText[789][1], TableSpecs, 184, 8, 88, 20, 0, 0)
                                   --"Rows"
    TSLText3 = createEx(LText, IDEText[790][1], TableSpecs, 184, 32, 88, 20, 0, 0)
                                   --"Size To Fit Cells"
    TSGroup1 = createEx(Group, IDEText[791][1], TableSpecs, 48, 84, 296, 224, 0, 0)
                                   --"Add:"
    TSGroup2 = createEx(Group, IDEText[792][1], TSGroup1, 24, 64, 256, 80, 0, 0)
                                   --"Yes"
    TS_FitYes = createEx(Radio, IDEText[793][1], TSGroup1, 8, 20, 256, 20, 0, 0)
                                  --"No and..."
    TS_FitNo = createEx(Radio, IDEText[794][1], TSGroup1, 8, 40, 256, 20, 0, 0)
                                        --"Vertical Scrollbar"
    TS_VScroll = createEx(CheckBox, IDEText[795][1], TSGroup2, 8, 16, 232, 20, 0, 0)
                                       --"Horizontal Scrollbar"
    TS_HScroll = createEx(CheckBox, IDEText[796][1], TSGroup2, 8, 36, 232, 20, 0, 0)
                                          --"Treat As Array When Create EXW"
    TSCheckBox1 = createEx(CheckBox, IDEText[797][1], TableSpecs, 28, 336, 360, 20, 0, 0)
                                   --"Pixels Between Columns"
    TSLText2 = createEx(LText, IDEText[798][1], TableSpecs, 340, 8, 256, 20, 0, 0)
                                   --"Pixels Between Rows"
    TSLText4 = createEx(LText, IDEText[799][1], TableSpecs, 340, 32, 256, 20, 0, 0)
                                  --"Table Creation:"
    TSLText5 = createEx(LText, IDEText[802][1], TableSpecs, 208, 64, 248, 20, 0, 0)
                                  --"Only Cells that fit will show in"
    TS_Note1 = createEx(LText, IDEText[803][1], TSGroup1, 24, 148, 264, 20, 0, 0)
                                   --"Design but full Table is accessable"
--        TS_Note2 = createEx( LText, IDEText[804][1], TSGroup1, 24, 168, 252, 20, 0, 0 )
                                  --"by right click."
--        TS_Note3 = createEx( LText, IDEText[805][1], TSGroup1, 24, 188, 148, 20, 0, 0 )
                                        --"Preserve Cell Name/Caption"
    TSCheckBox2 = createEx(CheckBox, IDEText[806][1], TableSpecs, 28, 384, 362, 20, 0, 0)
                                         --"Resizeable"
    TS_Resizable = createEx(CheckBox, IDEText[807][1], TSGroup2, 8, 56, 232, 20, 0, 0)
                                                                                --"Common SetHandlers:"
    TSSetHandler = createEx(Group, IDEText[1144][1], TableSpecs, 364, 84, 224, 76, 0, 0)
                                                                --"Row"
    TSRow = createEx(Radio, IDEText[1145][1], TSSetHandler, 8, 16, 88, 20, 0, 0)
                                                                --"Column"
    TSCol = createEx(Radio, IDEText[1146][1], TSSetHandler, 100, 16, 112, 20, 0, 0)
                                                                --"All"
    TSAll = createEx(Radio, IDEText[1148][1], TSSetHandler, 8, 44, 84, 20, 0, 0)
                                                                --"None"
    TSNone = createEx(Radio, IDEText[1147][1], TSSetHandler, 100, 40, 112, 20, 0, 0)
                                                                --"Colored Button Information:" 
    TSGroupColor = createEx(Group, IDEText[1157][1], TableSpecs, 364, 168, 260, 104, 0, 0)
                                                                                --"Make all buttons"
    TSCheckAll = createEx(CheckBox, IDEText[1158][1], TSGroupColor, 8, 20, 244, 20, 0, 0)
                                                                        --"colored buttons"
    TSTextAll = createEx(LText, IDEText[1159][1], TSGroupColor, 28, 40, 224, 20, 0, 0)                                        --"Accept"
                                                                        --"Copy color information"
    TSCheckCopy = createEx(CheckBox, IDEText[1160][1], TSGroupColor, 8, 60, 244, 20, 0, 0)
                                                        --"from cell 1"
    TSTextCopy = createEx(LText, IDEText[1161][1], TSGroupColor, 28, 80, 224, 20, 0, 0)
                                                                                --Accept
    TSPushButton1 = createEx(PushButton, IDEText[800][1], TableSpecs, 188, 408, 88, 28, 0, 0)
                                             --"Cancel"
    TSPushButton2 = createEx(PushButton, IDEText[801][1], TableSpecs, 368, 408, 88, 28, 0, 0)

    setBuddy(TSUpDown2, TSEditText2)
    setBuddy(TSUpDown1, TSEditText1)
    setBuddy(TSUpDown3, TSEditText3)
    setBuddy(TSUpDown4, TSEditText4)

    setScrollRange(TSUpDown1, 1, 99)
    setScrollRange(TSUpDown2, 1, 99)
    setScrollRange(TSUpDown3, 1, 99)
    setScrollRange(TSUpDown4, 1, 99)

    setHandler(TS_FitYes, w32HClick, routine_id("TS_FitYes_onClick"))
    setHandler(TS_FitNo, w32HClick, routine_id("TS_FitNo_onClick"))
    setHandler(TSPushButton1, w32HClick, routine_id("click_TSPushButton1"))
    setHandler(TSPushButton2, w32HClick, routine_id("click_TSPushButton2"))
    setHandler(TSCheckBox3, w32HClick, routine_id("TSCheckBox3_onClick"))
--DEV PL no such routines...
--  setHandler(TSCheckAll, w32HClick, routine_id("TSCheckALL_onClick"))
--  setHandler(TSCheckCopy, w32HClick, routine_id("TSCheckCopy_onClick"))

    openWindow(TableSpecs, Modal)
                        --" Table Specifications for "
    setText(TableSpecs, IDEText[808][1] & controls[selectedControl][Title])

    if controls[selectedControl][TableArray] then
        setCheck(TSCheckBox1, w32True)
        if controls[selectedControl][TableGenInExw] then
            setCheck(TSCheckBox3, w32True)
        end if

        if controls[selectedControl][TableCols]=1
        and controls[selectedControl][TableRows]=1 then
            setCheck(TSCheckBox1, w32False)
            setCheck(TSCheckBox3, w32False)
            controls[selectedControl][TableArray] = w32False
        end if
    else
        setCheck(TSCheckBox1, w32False)
    end if

    setText(TSEditText1, sprint(controls[selectedControl][TableCols]))
    setText(TSEditText2, sprint(controls[selectedControl][TableColsSpace]))
    setText(TSEditText3, sprint(controls[selectedControl][TableRows]))
    setText(TSEditText4, sprint(controls[selectedControl][TableRowsSpace]))

    setCheck(TS_FitNo, w32False)
    setCheck(TS_FitYes, w32True)
    setCheck(TS_HScroll, w32False)
    setCheck(TS_VScroll, w32False)
    setCheck(TS_Resizable, w32False)
    setCheck(TSCheckBox2, w32True)
    setEnable(TS_HScroll, w32False)
    setEnable(TS_VScroll, w32False)
    setEnable(TS_Resizable, w32False)
    setEnable(TS_Note1, w32False)
--    setEnable(TS_Note2, w32False)
--    setEnable(TS_Note3, w32False)
    setCheck(TSCheckAll, w32False)
    setCheck(TSCheckCopy, w32False)
    if not controls[selectedControl][PreserveName] then
        setCheck(TSCheckBox2, w32False)
    end if
    if not controls[selectedControl][FitToTable] then
        setCheck(TS_FitYes, w32False)
        setCheck(TS_FitNo, w32True)
        setEnable(TS_HScroll, w32True)
        setEnable(TS_VScroll, w32True)
        setEnable(TS_Resizable, w32True)
        setEnable(TS_Note1, w32True)
--        setEnable(TS_Note2, w32True)
--        setEnable(TS_Note3, w32True)
    end if
    if controls[selectedControl][TableHScroll] then
        setCheck(TS_HScroll, w32True)
    end if
    if controls[selectedControl][TableVScroll] then
        setCheck(TS_VScroll, w32True)
    end if
    if controls[selectedControl][TableResizable] then
        setCheck(TS_Resizable, w32True)
    end if

    if controls[selectedControl][TableButtonAllColor] then
        setCheck(TSCheckAll, w32True)
    end if
    if controls[selectedControl][TableButtonAllCopy] then
        setCheck(TSCheckCopy, w32True)
    end if

    setCheck(TSNone, w32True)
    setCheck(TSRow, w32False)
    setCheck(TSCol, w32False)
    setCheck(TSAll, w32False)
    if controls[selectedControl][CommonSetHandler]=1 then
        setCheck(TSRow, w32True)
        setCheck(TSNone, w32False)
        setCheck(TSAll, w32False)
        setCheck(TSCol, w32False)
    elsif controls[selectedControl][CommonSetHandler]=2 then
        setCheck(TSCol, w32True)
        setCheck(TSRow, w32False)
        setCheck(TSNone, w32False)
        setCheck(TSAll, w32False)
    elsif controls[selectedControl][CommonSetHandler]=3 then
        setCheck(TSAll, w32True)
        setCheck(TSCol, w32False)
        setCheck(TSNone, w32False)
        setCheck(TSRow, w32False)
    end if
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)

end procedure
setHandler(PopUpDesign_Table, w32HClick, routine_id("click_PopUpDesign_Table"))
--------------------------------------------------------------------------------
procedure PushButton7_onClick(integer self, integer event, sequence params)--params is ()
sequence alphabacklayers, textback, text
integer test

    showBackLayer = {}
    --get the background layers
    alphabacklayers = getMultItems(List3)
    for i=1 to length(alphabacklayers) do
        textback = alphabacklayers[i]
        for j=1 to length(layerCaptionSeq[selectedWindow]) do
            if equal(textback, layerCaptionSeq[selectedWindow][j][1]) then
                test = layerCaptionSeq[selectedWindow][j][3]
                showBackLayer &= test
                exit
            end if
        end for
    end for
    if not length(showBackLayer) then
        ok = displayErrorMessage(243,{})
        return
    end if
    closeWindow(MultipleLayersSelect)

    text = "Form Design: Background Layers = "
    for i=1 to length(showBackLayer) do
        if i>1 then
            text &= ", "
        end if
        textback = {}
        for j=1 to length(layerCaptionSeq[selectedWindow]) do
            if showBackLayer[i]=layerCaptionSeq[selectedWindow][j][3] then
                textback = layerCaptionSeq[selectedWindow][j][1]
                exit
            end if
        end for
        if length(textback) then
            text &= textback
        else
            text &= sprint(showBackLayer[i])
        end if
    end for
    setText(Form, text)

    drawIt()

    backgroundlayer = -1

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if equal(getText(PopUpDesign_Layers),IDEText[986][1]) then
        setText(PopUpDesign_Layers,IDEText[987][1])
    else
        setText(PopUpDesign_Layers,IDEText[986][1])
    end if
end procedure
setHandler(PushButton7, w32HClick, routine_id("PushButton7_onClick"))
--------------------------------------------------------------------------------
procedure PushButton8_onClick(integer self, integer event, sequence params)--params is ()
    closeWindow(MultipleLayersSelect)
end procedure
setHandler(PushButton8, w32HClick, routine_id("PushButton8_onClick"))
------------------------------------------------------------------------------
procedure click_PopUpDesign_Layers(integer Self, integer Event, sequence Params)
sequence lValues, textback

    if equal(getText(PopUpDesign_Layers),IDEText[987][1]) then
        backgroundlayer = -1
        showBackLayer = {}
        setText(Form, "Form Design")
    else
        if length(layerTabItemSeq)=1 then
            backgroundlayer = -1
            showBackLayer = {0}
            setText(Form, "Form Design")
        elsif length(layerTabItemSeq)=2 then
            backgroundlayer = 0
            showBackLayer = {0}
            setText(Form, "Form Design: Background Layers = " &
                    layerCaptionSeq[selectedWindow][1][1])
        elsif length(layerTabItemSeq)>2 then
            eraseItems(List3)
            for i=1 to length(layerTabItemSeq) do
                -- show window to pick background
                lValues = getUserProperty(layerTabItemSeq[i], "layer")
                if length(lValues)
                and lValues[1][1]!=layerNumber then
                    textback = {}
                    for j=1 to length(layerCaptionSeq[selectedWindow]) do
                        if lValues[1][1]=layerCaptionSeq[selectedWindow][j][3] then
                            textback = layerCaptionSeq[selectedWindow][j][1]
                            exit
                        end if
                    end for
                    addItem(List3, textback)
                end if
            end for
            setIndex(List3,1)
            openWindow(MultipleLayersSelect, Normal)
            return
        end if
    end if

    drawIt()
    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if equal(getText(PopUpDesign_Layers),IDEText[986][1]) then
        setText(PopUpDesign_Layers,IDEText[987][1])
    else
        setText(PopUpDesign_Layers,IDEText[986][1])
    end if
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_Layers, w32HClick, routine_id("click_PopUpDesign_Layers"))
------------------------------------------------------------------------------
procedure click_PopUpDesign_FullSize(integer Self, integer Event, sequence Params)
integer Tablecontrol, Tablecontrol1
atom styles
integer theClass, marginX, marginY, width, height, childCnt

    sCX = dCX
    sCY = dCY

    if Show= -1 then
        Show = createEx(Window, "Window1", Design, sX, sY, sCX, sCY,
                        {WS_SYSMENU,WS_THICKFRAME,WS_CLIPCHILDREN,WS_CLIPSIBLINGS}, 0)
        call_proc(createShowHandlers_id,{})
    end if
    openWindow(Show, Normal)
    showActive = w32True
    setText(Show, controls[1][Title])
    setEnable(PopUpDesign_FullSize, w32False)
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
    bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)

    if equal(controls[selectedControl][Class], "Table") then
        marginX = 0
        marginY = 0
        width = 0
        height = 0
        IDEAssociatedTable = {}

        styles = WS_CHILD

        if controls[selectedControl][TableHScroll] then
            styles = or_bits(styles, WS_HSCROLL)
        end if

        if controls[selectedControl][TableVScroll] then
            styles = or_bits(styles, WS_VSCROLL)
        end if

        if controls[selectedControl][TableResizable] then
            styles = or_bits(styles, WS_THICKFRAME)
        end if

        CWindows = createEx(Window, "", Show, controls[selectedControl][X],
                            controls[selectedControl][Y],controls[selectedControl][CX],
                            controls[selectedControl][CY],{styles},0)

        Tablecontrol1 = createEx(LText,controls[selectedControl][Title], CWindows, 0,0,
                                 sizeS[3], sizeS[4], 0, 0)
        if controls[selectedControl][BkColor] then
            setWindowBackColor(Tablecontrol1, controls[selectedControl][BkColor])
        end if

        childCnt = 0
        if length(controls[selectedControl][SeqChildName]) then
            for i=selectedControl to length(controls) do
                if controls[i][TableCell]
                and find(controls[i][Name], controls[selectedControl][SeqChildName]) then
                    childCnt += 1
                    for j=1 to length(ClassName) do
                        for k=1 to length(ClassName[j]) do
                            if equal(controls[i][Class], ClassName[j][k]) then
                                theClass = WinlibClassName[j][k]
                                exit
                            end if
                        end for
                    end for
                    Tablecontrol = createEx(theClass, controls[i][Title],
                                            Tablecontrol1,controls[i][X]-controls[selectedControl][X],
                                            controls[i][Y]-controls[selectedControl][Y],controls[i][CX],controls[i][CY],
                                            0, 0)

                                            --find extent of controls
                    if not marginX then
                        marginX = controls[i][X]-controls[selectedControl][X]
                    end if
                    if not marginY then
                        marginY = controls[i][Y]-controls[selectedControl][Y]
                    end if
                    --find widest and tallest control in case more than 1 per cell
                    if controls[i][X]+controls[i][CX]>width then
                        width = controls[i][X]+controls[i][CX]
                    end if
                    if controls[i][Y]+controls[i][CY]>height then
                        height = controls[i][Y]+controls[i][CY]
                    end if
                end if
                if childCnt>=length(controls[selectedControl][SeqChildName]) then
                    exit
                end if
            end for
        end if

        width = width+marginX+marginX
        height = height+marginY+marginY

        setCtlSize(Tablecontrol1,width,height)
        openWindow(CWindows, Normal)

        IDEAssociatedTable &= {{CWindows,Tablecontrol1,0,0}}
        setHandler(CWindows, w32HEvent, routine_id("event_IDEChildWin"))
        setHandler(CWindows, w32HResize, routine_id("resize_IDEChildWin"))
        resize_IDEChildWin(CWindows,0,{})
    end if
end procedure
setHandler(PopUpDesign_FullSize, w32HClick, routine_id("click_PopUpDesign_FullSize"))
------------------------------------------------------------------------------
procedure close_Show(integer Self, integer Event, sequence Params)
    showActive = w32False
    closeWindow(CWindows)
    setEnable(PopUpDesign_FullSize, w32True)
end procedure
------------------------------------------------------------------------------
procedure close_OffScreen(integer Self, integer Event, sequence Params)
    offsetActive = w32False
    setEnable(PopUpDesign_OffScreen, w32True)
    selectedControl = TheWindow
    updateProperties()
end procedure
setHandler(OffScreen, w32HClose, routine_id("close_OffScreen"))
------------------------------------------------------------------------------
procedure click_PopUpDesign_OffScreen(integer Self, integer Event, sequence Params)
    if OffScreen= -1 then
        OffScreen = createEx(Window, "Off-Screen", Design, 0, 0, sCX, sCY,
                             {WS_SYSMENU,WS_THICKFRAME}, 0)
        setHandler(OffScreen, w32HClose, routine_id("close_OffScreen"))
    end if
    openWindow(OffScreen, Normal)
    offsetActive = w32True
    setText(OffScreen, "Off-Screen")
    setEnable(PopUpDesign_OffScreen, w32False)
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
    copyBlt(OffScreen, 0, 0, OffScreenBlit)
end procedure
setHandler(PopUpDesign_OffScreen, w32HClick, routine_id("click_PopUpDesign_OffScreen"))
------------------------------------------------------------------------------
procedure click_PopUpDesign_DeleteControl(integer Self, integer Event, sequence Params)
integer flag,skipDelete
sequence parentCell1

    --make sure tabitem name agrees with selectedTabItem
    if Self=PopUpDesign_DeleteTabItem
    and not equal(selectedTabItem, controls[selectedControl][Name]) then
        flag = findSeqParentName(selectedControl)
        if flag then
            for i=flag to length(controls) do
                if equal(selectedTabItem, controls[i][Name]) then
                    selectedControl = i
                    exit
                end if
            end for
        end if
    end if

    if controls[selectedControl][TableCell]>1 then
        ok = displayErrorMessage(112,{})
        return
    elsif controls[selectedControl][TableCell] then
        skipDelete = w32False
        parentCell1 = controls[selectedControl][SeqParentName]

        --can only delete cell 1 if no other cells created
        for i=1 to length(controls) do
            if equal(controls[i][SeqParentName], parentCell1)
            and i!=selectedControl
            and controls[i][TableCell]>1 then
                ok = displayErrorMessage(113,{})
                skipDelete = w32True
                exit
            end if
        end for
        --but if only cell 1 then delete it
        if skipDelete then
            return
        end if
    end if
    deleteTheControl()
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler({PopUpDesign_DeleteCtrl,PopUpDesign_DeleteTabItem},
           w32HClick,routine_id("click_PopUpDesign_DeleteControl"))
------------------------------------------------------------------------------
procedure producePopup(integer startAt)
integer
            ids,
            parent,
            priorPopupName,
            priorPopupItemName,
            priorSubpopupName,
            priorSub2popupName,
            priorSub3popupName

    --in order to make the Popup a real control must be able to destroy it
    --in case it has changed since last display.
    --Place the created ids in this sequence and destroy them as necessary

    --show the real popup
    --destroy all elements of realPopupIds and reload
    for i=1 to length(realPopupIds) do
        if validId(realPopupIds[i]) then
            destroy(realPopupIds[i])
        end if
    end for

    realPopupIds = {}
    parent = 0

    priorPopupName = 0
    priorPopupItemName = 0
    priorSubpopupName = 0
    priorSub2popupName = 0
    priorSub3popupName = 0

    for i=startAt to length(controls) do
        if equal(controls[i][Class], "Popup") then
            parent = Design
            if showActive then
                parent = Show
            end if
            if offsetActive then
                parent = OffScreen
            end if

        elsif equal(controls[i][Class], "PopupItem") then
            -- parent was last popup
            parent = priorPopupName

        elsif equal(controls[i][Class], "Subpopup") then
            -- parent was last popup Item
            parent = priorPopupItemName

        elsif equal(controls[i][Class], "SubpopupItem")
           or equal(controls[i][Class], "Sub2popup") then
            -- parent was last Subpopup
            parent = priorSubpopupName

        elsif equal(controls[i][Class], "Sub2popupItem")
           or equal(controls[i][Class], "Sub3popup") then
            -- parent was last Subsubpopup
            parent = priorSub2popupName

        elsif equal(controls[i][Class], "Sub3popupItem") then
            -- parent was last Subsubsuppopup
            parent = priorSub3popupName
        end if

        --create the real popup
        if equal(controls[i][Class], "Popup") then

            ids = createEx(Popup, controls[i][Title], Design,0,0,0,0,0,0)

            if showActive then
                ids = createEx(Popup, controls[i][Title], Show,0,0,0,0,0,0)
            end if

            realPopupIds &= {ids}

        elsif find(controls[i][Class], {"Subpopup","Sub2popup","Sub3popup"})
                then
            ids = createEx(Menu, controls[i][Title], parent,0,0,0,0,0,0)

        elsif find(controls[i][Class], {"PopupItem","SubpopupItem","Sub2popupItem",
                                        "Sub3popupItem"}) then

            ids = createEx(MenuItem, controls[i][Title], parent,0,0,0,0,0,0)
        end if

        if equal(controls[i][Class], "Popup") then
            -- save name
            priorPopupName = ids

        elsif equal(controls[i][Class], "PopupItem") then
            -- save name
            priorPopupItemName = ids

        elsif equal(controls[i][Class], "Subpopup") then
            -- save name
            priorSubpopupName = ids

        elsif equal(controls[i][Class], "Sub2popup") then
            -- save name
            priorSub2popupName = ids

        elsif equal(controls[i][Class], "Sub3popup") then
            -- save name
            priorSub3popupName = ids
        end if

    end for

    --show the popup
    popup(realPopupIds[1], MouseX, MouseY)

    hasPopup = w32True

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

end procedure
------------------------------------------------------------------------------
procedure change_PopupBox(integer Self, integer Event, sequence Params)

sequence PopupItem
integer hit, index


    hit = 0

    --for version .55
    index = getIndex(PopupBox)
    if not index then
        if validId(SelectPopUp) then
            destroy(SelectPopUp)
        end if
        SelectPopUp = -1

        stopMouse = w32False
        return
    end if

    PopupItem = getItem(PopupBox, getIndex(PopupBox))


    for i=1 to length(controls) do
        if equal(controls[i][Class], "Popup")
        and equal(controls[i][Name], PopupItem) then
            hit = i
            exit
        end if
    end for

    if validId(SelectPopUp) then
        destroy(SelectPopUp)
    end if
    SelectPopUp = -1

    stopMouse = w32False

    producePopup(hit)

end procedure
-------------------------------------------------------------------------------
procedure click_cancelPopupButton(integer Self, integer Event, sequence Params)
    if validId(SelectPopUp) then
        destroy(SelectPopUp)
    end if
    SelectPopUp = -1

    stopMouse = w32False
end procedure
-------------------------------------------------------------------------------
procedure click_PopUpDesign_PopUp(integer Self, integer Event, sequence Params)
integer cx, cy, lastId
sequence newMouse

    cx = 0
    cy = 0

    if hasPopup then
        selectedControl = TheWindow
        drawIt()
    end if

    if SelectPopUp= -1 then
        newMouse = ClientToScreen(Design,MouseX,MouseY)
        --new window look and positioning by Elliott S. de Andrade
                                                                        --"Pick Popup"
        SelectPopUp = createEx(Window, IDEText[809][1], 0, newMouse[1], newMouse[2],  --MouseX, MouseY,
                               200, 175,{WS_DLGFRAME}, WS_EX_TOOLWINDOW)
        PopupBox = createEx(List,"", SelectPopUp, 5, 5, 185, 97, 0, 0)
                                               --"Cancel"
        cancelPopupButton = createEx(PushButton,IDEText[810][1],SelectPopUp,50,110,90,30,0,0)
        setHandler(PopupBox, w32HClick, routine_id("change_PopupBox"))
        setHandler(cancelPopupButton,w32HClick,routine_id("click_cancelPopupButton"))

    end if

    --if there is more than one, need a list box to pick from
    --then emulate the popup
    eraseItems(PopupBox)
    lastId = 0

    for i=1 to length(controls) do
        if equal(controls[i][Class], "Popup") then
            addItem(PopupBox, controls[i][Name])
            lastId = i
        end if
    end for

    if getCount(PopupBox)>1 then
        --show the popup box
        stopMouse = w32True
        openWindow(SelectPopUp, Modal)
        return
    end if

    producePopup(lastId)

end procedure
setHandler(PopUpDesign_PopUp, w32HClick, routine_id("click_PopUpDesign_PopUp"))
-----------------------------------------------------------------------------------
procedure click_PopUpDesign_UndockForm(integer Self, integer Event, sequence Params)
                                             --"Undock Form"
    if equal(getText(PopUpDesign_UndockForm), IDEText[726][1]) then
        setText(PopUpDesign_UndockForm, IDEText[811][1])        --"Redock Form"
    else
        setText(PopUpDesign_UndockForm, IDEText[726][1])        --"Undock Form"         
    end if
    ok = invokeHandler(MenuUndockForm, w32HClick, {0,0,0})
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_UndockForm, w32HClick, routine_id("click_PopUpDesign_UndockForm"))
--------------------------------------------------------------------------------
integer formX, formY, formCX, formCY, formMax
--these are used to redock Form to same position and size as prior to undock
formX = 0 formY = 0 formCX = 0 formCY = 0 formMax = 0
------------------------------------------------------------------------------
--these values are used in Form, projectWindow and PropertySheet w32HResize to determine the
--offset of Form to HiddenWinodw
integer doFormDiffCalc
doFormDiffCalc = w32False
--------------------------------------------------------------------------------
procedure MenuUndockForm_onClick(integer self, integer event, sequence params)--params is ()
sequence formRect, controlsRect, hiddenRect, bottom, designRect, projectRect
integer lastHScroll, lastVScroll
    setCheck(self, not isChecked(self))
    if isChecked(MenuUndockForm) then
        --undock form   
        formRect = getRelRect(Form, HiddenWindow)
        formX = formRect[1]
        formY = formRect[2]
        formCX = formRect[3]-formRect[1]
        formCY = formRect[4]-formRect[2]
        formMax = w32False
        if isMaximized(Form) then
            formMax = w32True
        end if
        showWindow(Form, SW_HIDE)
        formRect = getRelRect(Form,Screen)

        --save last scroll positions from Form while docked
        lastHScroll = getHScrollPos(Form)
        lastVScroll = getVScrollPos(Form)

        --setParent code contributed by Mario Steel             
        ok = w32Func(xSetParent,{getHandle(Design),getHandle(FormUndockWindow)})
        ok = w32Func(xSetParent,{getHandle(LayersTC),getHandle(FormUndockWindow)})

        --place undocked form in same place it was              
        setRect(FormUndockWindow, formRect[1], formRect[2]-toolBar, formCX, formCY, w32True)
        --place tab and design window
        formRect = getCtlSize(FormUndockWindow)
        setRect(LayersTC, 0, 0, formRect[1], 20, w32True)
        designRect = getCtlSize(Design)
        setRect(Design, 0, 20, designRect[1], designRect[2],w32True)

        --set scrollbars otherwise they are at goofy positions
        setHScrollPos(Form, lastHScroll)
        setVScrollPos(Form, lastVScroll)

        showWindow(FormUndockWindow, SW_NORMAL)
        moveZOrder(FormUndockWindow, HWND_TOP)

    else

        --redock Form           
        lastHScroll = getHScrollPos(Form)
        lastVScroll = getVScrollPos(Form)
        --setParent code contributed by Mario Steel             
        ok = w32Func(xSetParent,{getHandle(Design),getHandle(Form)})
        ok = w32Func(xSetParent,{getHandle(LayersTC),getHandle(Form)})

        --place tab and design window
        formRect = getCtlSize(FormUndockWindow)--(Form)
        setRect(LayersTC, 0, 0, formRect[1], 20, w32True)
        designRect = getCtlSize(Design)
        setRect(Design, 0, 20, designRect[1], designRect[2],w32True)
        --set scrollbars properly
        setHScrollPos(Form, lastHScroll)
        setVScrollPos(Form, lastVScroll)

        controlsRect = getClientRect(Controls)
        bottom = {0,0}
        if not isChecked(MenuUndockToolKit) then
            bottom = getCtlSize(IconBar)
        end if
        if isChecked(MenuUndockProperty)
        and isChecked(MenuUndockProject) then
            --hiddenwindow occupies full control client area less toolbox                           
            setRect(HiddenWindow,0,0,controlsRect[3],controlsRect[4]-bottom[2],w32True)
            projectRect = {0,0}
        else
            if not isChecked(MenuUndockProperty) then
                projectRect = getCtlSize(PropertySheet)
            elsif not isChecked(MenuUndockProject) then
                projectRect = getCtlSize(ProjectWindow)
            end if
            if formRect[1]+projectRect[1]>controlsRect[3] then
                setRect(HiddenWindow, projectRect[1], 0, formRect[1]+borderX,controlsRect[4]-bottom[2],w32True)
            end if
        end if

        showWindow(FormUndockWindow, SW_HIDE)
        hiddenRect = getClientRect(HiddenWindow)
        formCX = formRect[1]
        formCY = formRect[2]

        --if form width is greater than controls width less project width               
        if formCX>(controlsRect[3]-projectRect[1]) then
            formCX = (controlsRect[3]-projectRect[1])
        end if

        if formCY>hiddenRect[4] then
            formCY = hiddenRect[4]
        end if

        setRect(Form, formX, formY, formCX, formCY, w32True)

        if formMax then
            formMax = w32False
            showWindow(Form, SW_MAXIMIZE)
        else
            showWindow(Form, SW_NORMAL)
        end if
    end if

end procedure
setHandler(MenuUndockForm, w32HClick, routine_id("MenuUndockForm_onClick"))
------------------------------------------------------------------------------
procedure change_PropertyTitleBar(integer Self, integer Event, sequence Params)
integer wantedSelectedControl, index
sequence lValues

    --unselect the prior control
    call_proc(drawControl_id,{ControlBlit, controls[selectedControl],
                              Normal,selectedControl,0})
    if thelayerNumber           --drawing layer 1..n
    and (find(0,showBackLayer)  --with base layer as background
         or backgroundlayer=0) then
        --does layer 1..n have controls hiding layer 0 control?
        drawHiddenControls(selectedControl)
    end if

    --select the one from dropdownlist
    index = getIndex(PropertyTitleBar)
    for i=1 to length(controls) do
        if equal(controls[i][Name], getItem(PropertyTitleBar, index)) then
            selectedControl = i
            exit
        end if
    end for

    wantedSelectedControl = selectedControl

    if equal(controls[selectedControl][Class], "TabItem") then
        --set the tabItemCombo to this tabitem
        for m=1 to getCount(TheTabItemCombo) do
            if equal(getItem(TheTabItemCombo, m),
                     controls[selectedControl][Name]) then
                setIndex(TheTabItemCombo, m)
                ok = invokeHandler(TheTabItemCombo, w32HChange,{})
                exit
            end if
        end for
    end if

    if equal(controls[selectedControl][ParentClass], "TabItem") then
        fromTitleBarChange = w32True
        --set the tabItemCombo to this tabitem highest parent
        for m=1 to getCount(TheTabItemCombo) do
            --find the title of the parent
            for n=1 to length(controls) do
                if equal(controls[selectedControl][ControlParent],
                         controls[n][Name]) then
                    if equal(getItem(TheTabItemCombo, m),
                             controls[n][Name]) then
                        setIndex(TheTabItemCombo, m)
                        ok = invokeHandler(TheTabItemCombo, w32HChange,{})
                        exit
                    end if
                end if
            end for
        end for
        fromTitleBarChange = w32False
    end if

    if controls[wantedSelectedControl][ControlLayer]!=layerNumber then
        for i=1 to length(layerTabItemSeq) do
            lValues = getUserProperty(layerTabItemSeq[i],"layer")
            if length(lValues)
            and lValues[1][1]=controls[wantedSelectedControl][ControlLayer] then
                setFocus(layerTabItemSeq[i])
                change_LayerTI(0,0,{})
                exit
            end if
        end for
    else
        selectedControl = TheWindow
        drawIt()
    end if

    selectedControl = wantedSelectedControl

    delayDraw = w32True
    fromTitleBarChange = w32True
    call_proc(updateProperties_id,{})
    fromTitleBarChange = w32False
    delayDraw = w32False

    if controls[selectedControl][X]>=0 then
        call_proc(drawControl_id,{ControlBlit, controls[selectedControl],
                                  Selected,selectedControl,0})
        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            drawHiddenControls(selectedControl)
        end if
        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if CodeWinOpen then
        for i=1 to getCount(CodeControls) do
            if equal(controls[selectedControl][Name],getItem(CodeControls,i)) then
                setIndex(CodeControls,i)
                ok = invokeHandler(CodeControls,w32HClick,{})
                exit
            end if
        end for
        MenuEditDoubleClick = w32True
    end if

end procedure
setHandler(PropertyTitleBar, w32HChange, routine_id("change_PropertyTitleBar"))
------------------------------------------------------------------------------
--code from Brian Broker
-- define MINMAXINFO structure
constant
  ptReserved     = w32allot(SIZEOF_POINT),
  ptMaxSize      = w32allot(SIZEOF_POINT),
  ptMaxPosition  = w32allot(SIZEOF_POINT),
  ptMinTrackSize = w32allot(SIZEOF_POINT),
  ptMaxTrackSize = w32allot(SIZEOF_POINT),
  SIZEOF_MINMAXINFO = w32allotted_size()

procedure event_Controls(integer Self, integer Event, sequence Params)
atom event,wParam,lParam,ptMin

    event = Params[1]
    wParam = Params[2]
    lParam = Params[3]

    if not getActiveWindow() then
        closeWindow(HintWin)
    end if

    --code from Brian Broker
    if event=WM_GETMINMAXINFO then
        -- get w32address of ptMinTrackSize in MINMAXINFO structure
        --   passed by lParam
        ptMin = w32address(lParam, ptMinTrackSize)
        -- set minimum size of window
        w32store(ptMin, ptX, 640)
        w32store(ptMin, ptY, 480)
    end if

end procedure
setHandler(Controls, w32HEvent, routine_id("event_Controls"))
----------------------------------------------------------------------------
procedure scroll_Form(integer Self, integer Event, sequence Params)
integer pos, pos1

    inScrolling = w32True

    pos = getHScrollPos(Form)
    pos1 = getVScrollPos(Form)

    dX = -pos
    dY = -pos1

    setRect(Design, dX,dY+20,dCX,dCY, w32True)  --20 is Layer toolbar

    inScrolling = w32False
end procedure
setHandler(Form, w32HScroll, routine_id("scroll_Form"))
----------------------------------------------------------------------------
procedure scroll_FormUndockWindow(integer Self, integer Event, sequence Params)
integer pos, pos1

    inScrolling = w32True

    pos = getHScrollPos(FormUndockWindow)
    pos1 = getVScrollPos(FormUndockWindow)

    dX = -pos
    dY = -pos1

    setRect(Design, dX,dY+20,dCX,dCY, w32True)  --20 is Layer toolbar

    inScrolling = w32False
end procedure
setHandler(FormUndockWindow, w32HScroll, routine_id("scroll_FormUndockWindow"))
-----------------------------------------------------------------------------
procedure event_Form(integer Self, integer Event, sequence Params)
sequence formRect,hiddenWindowClient
atom ptMax
atom theEvent, wParam, lParam

    theEvent = Params[1]
    wParam = Params[2]
    lParam = Params[3]

    --code from Brian Broker
    if theEvent=WM_GETMINMAXINFO then
        if not isChecked(MenuUndockForm) then
            size = getClientRect(HiddenWindow)

            -- get w32address of ptMaxTrackSize in MINMAXINFO structure
            --   passed by lParam
            ptMax = w32address(lParam, ptMaxTrackSize)
            -- set maximum size of window
            w32store(ptMax, ptX, size[3])
            w32store(ptMax, ptY, size[4])
        end if
    end if

    if theEvent=WM_MOVE then
        formRect = getCtlSize(Form)
        setRect(Form, 0, 0, formRect[1], formRect[2], w32True)
        return
    end if

    if theEvent=WM_SIZE then
        if not isChecked(MenuUndockForm) then
            formRect = getRect(Form)
            hiddenWindowClient = getClientRect(HiddenWindow)
            if formRect[1]<0 then
                setRect(Form,0,formRect[2],formRect[3]-formRect[1],formRect[4]-formRect[2],w32True)
            end if
            if formRect[2]<0 then
                setRect(Form,formRect[1],0,formRect[3]-formRect[1],formRect[4]-formRect[2],w32True)
            end if
            if formRect[1]+(formRect[3]-formRect[1])>hiddenWindowClient[3] then
                setRect(Form, hiddenWindowClient[3]-(formRect[3]-formRect[1]),formRect[2],formRect[3]-formRect[1],formRect[4]-formRect[2],w32True)
            end if
            if formRect[2]+(formRect[4]-formRect[2])>hiddenWindowClient[4] then
                setRect(Form, formRect[1],hiddenWindowClient[4]-(formRect[4]-formRect[2]),formRect[3]-formRect[1],formRect[4]-formRect[2],w32True)
            end if
        end if
        formRect = getCtlSize(Form)
        setCtlSize(LayersTC, formRect[1], 20)
    end if

end procedure
setHandler(Form, w32HEvent, routine_id("event_Form"))
------------------------------------------------------------------------------
--Martin Stachon windows position changing code
constant
 WM_WINDOWPOSCHANGING = #0046,
 WINDOWPOS_hwnd            = w32allot(Long),
 WINDOWPOS_hwndInsertAfter = w32allot(Long),
 WINDOWPOS_x               = w32allot(Long),
 WINDOWPOS_y               = w32allot(Long),
 WINDOWPOS_cx              = w32allot(Long),
 WINDOWPOS_cy              = w32allot(Long),
 WINDOWPOS_flags           = w32allot(Long),
 SIZEOF_WINDOWPOS          = w32allotted_size()

procedure event_Design(integer Self, integer Event, sequence Params)
atom event, wParam, lParam
--Martin Stachon
atom cur_flags

    event = Params[1]
    wParam = Params[2]
    lParam = Params[3]

    if event=WM_WINDOWPOSCHANGING then
        -- lParam is pointer to WINDOWPOS structure
        if inScrolling then
            return
        end if
        cur_flags = w32fetch(lParam, WINDOWPOS_flags)
        w32store(lParam, WINDOWPOS_flags, or_bits(SWP_NOMOVE, cur_flags))
    end if

end procedure
setHandler(Design, w32HEvent, routine_id("event_Design"))
------------------------------------------------------------------------------
procedure event_Property(integer Self, integer Event, sequence Params)
atom theEvent,wParam,lParam,ptMin,ptMax
sequence controlsClient

    theEvent = Params[1]
    wParam = Params[2]
    lParam = Params[3]

    controlsClient = getClientRect(Controls)

    --code from Brian Broker
    if theEvent=WM_GETMINMAXINFO then
        if isChecked(MenuUndockProperty) then
            return
        end if
        -- get w32address of ptMinTrackSize in MINMAXINFO structure
        --   passed by lParam
        ptMin = w32address(lParam, ptMinTrackSize)
        -- set minimum size of window
        w32store(ptMin, ptX, 180)
        w32store(ptMin, ptY, 25)
        ptMax = w32address(lParam, ptMaxTrackSize)
        -- set maximum size of window
        w32store(ptMax, ptX,  controlsClient[3])
        w32store(ptMax, ptY, controlsClient[4]-20)
        if isChecked(MenuUndockProject) then
            w32store(ptMax, ptY, controlsClient[4])
        end if
    end if

end procedure
setHandler(PropertySheet, w32HEvent, routine_id("event_Property"))
--------------------------------------------------------------------------------
procedure event_ProjectWindow(integer Self, integer Event, sequence Params)
atom theEvent,wParam,lParam,ptMin,ptMax
sequence projectCtlSize, controlsClient

    theEvent = Params[1]
    wParam = Params[2]
    lParam = Params[3]

    projectCtlSize = getCtlSize(PropertySheet)
    controlsClient = getClientRect(Controls)

    --code from Brian Broker
    if theEvent=WM_GETMINMAXINFO then
        if isChecked(MenuUndockProject) then
            return
        end if
        -- get w32address of ptMinTrackSize in MINMAXINFO structure
        --   passed by lParam
        ptMin = w32address(lParam, ptMinTrackSize)
        -- set minimum size of window
        w32store(ptMin, ptX, 180)
        w32store(ptMin, ptY, 35)
        ptMax = w32address(lParam, ptMaxTrackSize)
        -- set maximum size of window
        w32store(ptMax, ptX,  controlsClient[3])
        w32store(ptMax, ptY, controlsClient[4]-20)
        if isChecked(MenuUndockProperty) then
            w32store(ptMax, ptY, controlsClient[4])
        end if
    end if

end procedure
setHandler(ProjectWindow, w32HEvent, routine_id("event_ProjectWindow"))
------------------------------------------------------------------------------
--integer formMaxed     formMaxed=w32False
procedure resize_Controls(integer Self, integer Event, sequence Params)
integer style, x, y
integer dockWidth
sequence size, size2, size3, size4
sequence info, hiddenRect

    style = Params[1]
    x = Params[2]
    y = Params[3]

    dockWidth = 183 --protection

    if not havePropertySheet then
        --we are still initializing the app          
        return
    end if

    if style=SIZE_MINIMIZED then

        if validId(HintWin) then
            doingHints = w32False
            closeWindow(HintWin)
        end if

        if TestWin!= -1 then
            info = getControlInfo(TestWin, {CONTROLINFO_closed})
            if not info[1] then
               -- TestWin is open so minimize
                showWindow(TestWin, SW_HIDE)
            end if
        end if

        if TestLVWin!= -1 then
            info = getControlInfo(TestLVWin, {CONTROLINFO_closed})
            if not info[1] then
                -- TestLVWin is open so minimize
                showWindow(TestLVWin, SW_HIDE)
            end if
        end if

        info = getControlInfo(WinCodeBase, {CONTROLINFO_closed})
        if not info[1] then
            closeWindow(WinCodeBase)
        end if

        info = getControlInfo(TabWindow1, {CONTROLINFO_closed})
        if not info[1] then
            closeWindow(TabWindow1)
        end if

        if isChecked(MenuUndockProperty)
        and not isChecked(MenuClosedProperty) then
            if isMinimized(PropertyUndockWindow) then
                propUW = w32True
            end if
        end if

        if isChecked(MenuUndockProject)
        and not isChecked(MenuClosedProject) then
            if isMinimized(ProjectUndockWindow) then
                projUW = w32True
            end if
        end if

        if isChecked(MenuUndockToolKit)
        and not isChecked(MenuClosedToolKit) then
            if isMinimized(IconBarUndockWindow) then
                toolUW = w32True
            end if
        end if

        if isChecked(MenuUndockForm) then
            if isMinimized(FormUndockWindow) then
                formUW = w32True
            end if
        end if
        if CodeWinOpen then
            showWindow(CodeWin, SW_HIDE)
        end if

        return
    end if
--      end of minimize


    if projectRunning then
        setIndex(WinList,selectedWindow)
        propUW = w32False
        projUW = w32False
        toolUW = w32False
        formUW = w32False
        return
    end if

    size = getClientRect(Controls)
    setRect(WinList, 308, 2, 160, size[4]-2, w32True)
    setRect(TheTabItemCombo, 470, 2, 160, size[4]-2, w32True)

    size = getRelRect(IconBar, Controls)
    size3 = getClientRect(Controls)
    hiddenRect = getRect(HiddenWindow)

    if not isChecked(MenuUndockToolKit) then
    --reposition toolbox into bottom right corner
        setRect(IconBar, size3[3]-(size[3]-size[1]), size3[4]-(size[4]-size[2]), size[3]-size[1],
                (size[4]-size[2]), w32True)
        --be sure hidden Window height is always adjusted
        size = getCtlSize(IconBar)
        setRect(HiddenWindow, hiddenRect[1],0,hiddenRect[3]-hiddenRect[1],size3[4]-size[2], w32True)
    else
        setRect(HiddenWindow, hiddenRect[1],0,hiddenRect[3]-hiddenRect[1],size3[4],w32True)
    end if

    if not isChecked(MenuUndockProperty)
    and not isChecked(MenuUndockProject) then
        --if property docked and project docked then resize length of project   
        size = getRect(PropertySheet)
        size3 = getClientRect(Controls)
        size2 = getRect(ProjectWindow)
        setRect(ProjectWindow, size2[1], size[4]-size[2],size2[3]-size2[1],
                size3[4]-(size[4]-size[2]),w32True)
    else
        if isChecked(MenuUndockProperty)
        and isChecked(MenuUndockProject) then
            --when both undocked hidden window goes full length of client area
            size3 = getClientRect(Controls)
            size = getCtlSize(IconBar)
            if isChecked(MenuUndockToolKit) then
                size = {0,0}
            end if
            setRect(HiddenWindow, 0, 0, size3[3], size3[4]-size[2], w32True)
        else
            if isChecked(MenuUndockProperty) then
                                --if property undocked then project occupies full length                        
                size3 = getClientRect(Controls)
                size2 = getRect(ProjectWindow)
                setRect(ProjectWindow, 0, 0,size2[3]-size2[1],size3[4],w32True)
                if not isChecked(MenuClosedProperty) then
                    if propUW then  --property was undocked/minimized before Controls minimized                                                                                                                                                                                                                     
                        showWindow(PropertyUndockWindow, SW_MINIMIZE)
                    end if
                end if
            end if

            if isChecked(MenuUndockProject) then
                --if project undocked then property occupies full length                                
                size3 = getClientRect(Controls)
                size = getRect(PropertySheet)
                setRect(PropertySheet, 0, 0,size[3]-size[1],size3[4],w32True)
                if not isChecked(MenuClosedProject) then
                    if projUW then  --project was undocked/minimized before Controls minimized                                                                                      
                        showWindow(ProjectUndockWindow, SW_MINIMIZE)
                    end if
                end if
            end if
        end if
    end if
    if isChecked(MenuUndockProperty) then
        IDEsize = getClientRect(PropertyUndockWindow)
        setRect(PropertyTitleBar, 0, 0, IDEsize[3]-13, IDEsize[4], w32True)
    else
        IDEsize = getClientRect(Controls)
        size = getClientRect(PropertySheet)
        setCtlSize(PropertyTitleBar, size[3]-13, IDEsize[4])
    end if

    --if hiddenwindow is beyond controls client width then project must have
    --been expanded so do not touch hiddenWindow cx
    --otherwise size hiddenwindow to fit    
    hiddenRect = getCtlSize(HiddenWindow)
    size3 = getClientRect(Controls)
    size = getRect(HiddenWindow)
    if not isChecked(MenuUndockProperty)
    or not isChecked(MenuUndockProject) then
        --position hiddenwindow?
        if not isChecked(MenuUndockProperty) then
            size2 = getCtlSize(PropertySheet)
        else
            size2 = getCtlSize(ProjectWindow)
        end if
        if hiddenRect[1]+size2[1]>size3[3] then
            --dont resize, we must be squishing Form
            --but Form may be adjusted, if needed
            if not isChecked(MenuUndockProject) then
                ok = invokeHandler(ProjectWindow, w32HResize, {0,0,{}})
            else
                ok = invokeHandler(PropertySheet, w32HResize, {0,0,{}})
            end if
        else
--I'm leaving these comments here to remind me I can not resize hiddenWindow because when
--resizing Property or ProjectView I need HiddenWindow to be extended beyond controls           
            if isChecked(MenuUndockToolKit) then
--                              setRect(HiddenWindow, size[1], 0, size3[3]-size2[1], size3[4], w32True)         
            else
                size4 = getCtlSize(IconBar)
--                              setRect(HiddenWindow, size[1], 0, size3[3]-size2[1], size3[4]-size4[2], w32True)
            end if
        end if
    end if

    if isChecked(MenuUndockToolKit) then
        if not isChecked(MenuClosedToolKit) then
            if toolUW then  --ToolKit was undocked/minimized before Controls minimized                                              
                showWindow(IconBarUndockWindow, SW_MINIMIZE)
            end if
        end if
    end if

    if isChecked(MenuUndockForm) then
        if formUW then  --Form was undocked/minimized before Controls minimized                 
            showWindow(FormUndockWindow, SW_MINIMIZE)
        end if
    elsif isMaximized(Form) then
        hiddenRect = getClientRect(HiddenWindow)
        setCtlSize(Form, hiddenRect[3],hiddenRect[4])
        showWindow(Form, SW_MAXIMIZE)
    end if

    if CodeWinOpen then
        if isMinimized(CodeWin) then
            showWindow(CodeWin, SW_MINIMIZE)
        else
            showWindow(CodeWin, SW_RESTORE)
            moveZOrder(CodeWin, HWND_TOP)
        end if
    end if

    if TestWin!= -1 then
        info = getControlInfo(TestWin, {CONTROLINFO_closed})
        if not info[1] then
            -- TestWin is open so restore
            showWindow(TestWin, SW_RESTORE)
        end if
    end if

    if TestLVWin!= -1 then
        info = getControlInfo(TestLVWin, {CONTROLINFO_closed})
        if not info[1] then
            -- TestLVWin is open so restore
            showWindow(TestLVWin, SW_RESTORE)
        end if
    end if

    --make sure window combo shows correct name; problem occured when had Window1
    --and Window2 windows -- after Menu Run wrong name showing
    setIndex(WinList,selectedWindow)

    propUW = w32False
    projUW = w32False
    toolUW = w32False
    formUW = w32False
end procedure
setHandler(Controls, w32HResize, routine_id("resize_Controls"))
--------------------------------------------------------------------------------
procedure resize_Form(integer Self, integer Event, sequence Params)
integer cx
sequence hiddenSize,formSize,controlClient,hiddenClient

    cx = Params[2]
    controlClient = getClientRect(Controls)
    formSize = getRect(Form)
    hiddenSize = getRect(HiddenWindow)
    hiddenClient = getClientRect(HiddenWindow)

    if cx>(controlClient[3]-hiddenSize[1])  then
        cx = controlClient[3]-hiddenSize[1]
        setRect(Form, formSize[1], formSize[2], cx, hiddenClient[4], w32True)
    end if

    if dCX<=cx then
        setWindowScrollRange(Form, SB_HORZ, 0, 0, 1)
        setHScrollPos(Form, 1)
    else
        setWindowScrollRange(Form, SB_HORZ, 1, dCX, Params[2])
    end if

    if dCY+20<=Params[3] then --20 is layer toolbar
        setWindowScrollRange(Form, SB_VERT, 0, 0, 1)
        setVScrollPos(Form, 1)
    else
        setWindowScrollRange(Form, SB_VERT, 1, dCY+20, Params[3])  --20 is layer toolbar
    end if

    if doFormDiffCalc then
        hiddenSize = getClientRect(HiddenWindow)
        formDiff = hiddenSize[3]-cx
    end if
end procedure
setHandler(Form, w32HResize, routine_id("resize_Form"))
--------------------------------------------------------------------------------
procedure resize_UndockForm(integer Self, integer Event, sequence Params)
sequence formRect

    formRect = getCtlSize(FormUndockWindow)
    setRect(LayersTC, 0, 0, formRect[1], 20, w32True)

end procedure
setHandler(FormUndockWindow, w32HResize, routine_id("resize_UndockForm"))
--------------------------------------------------------------------------------
procedure resize_Design(integer Self, integer Event, sequence Params)
integer style, x, y
sequence size, control, toRepaint
integer updateThePropertyWidth, updateThePropertyHeight

    style = Params[1]
    x = Params[2]
    y = Params[3]

    if cameFromProperty then
        --dont change window cx, cy in propertysheet and do it here too.
        return
    end if

    toRepaint = {}

    if style=SIZE_RESTORED then
        --change dCX and dCY
        size = getRect(Design)

        updateThePropertyWidth = w32False
        updateThePropertyHeight = w32False
        if dCX!=size[3]-size[1] then
            updateThePropertyWidth = w32True
        end if
        if dCY!=size[4]-size[2] then
            updateThePropertyHeight = w32True
        end if

        dCX = size[3]-size[1]
        dCY = size[4]-size[2]

        if showActive
        and not fromShow then
            setRect(Show, sX, sY, dCX, dCY, w32True)
        end if
        gridX = dCX
        gridY = dCY
        controls[TheWindow][CX] = dCX
        controls[TheWindow][CY] = dCY

        --resize layer tabs
        setCtlSize(LayersTC, dCX, 20)

        size = getClientRect(Form)

        if dCX<=size[3] then
            setWindowScrollRange(Form, SB_HORZ, 0, 0, 1)
        else
            setWindowScrollRange(Form, SB_HORZ, 1, dCX, size[3])
        end if
        if dCY<=size[4] then
            setWindowScrollRange(Form, SB_VERT, 0, 0, 1)
        else
            setWindowScrollRange(Form, SB_VERT, 1, dCY+20, size[4]+20)   --20 is Layer toolbar;thckness of scrollbar         
        end if

        setHScrollPos(Form, 1)
        setVScrollPos(Form, 1)

        if updateThePropertyWidth
        or updateThePropertyHeight then
            if getIndex(PropertyTitleBar)=1 then
                if updateThePropertyWidth
                and updateThePropertyHeight then
                    updateProperty("Height")
                elsif updateThePropertyWidth then
                    updateProperty("Width")
                elsif updateThePropertyHeight then
                    updateProperty("Height")
                end if
            else
                selectedControl = TheWindow
                delayDraw = w32True
                updateProperties()
                delayDraw = w32False
            end if

            --Martin Stachon
            for i=1 to length(controls) do
                if find(controls[i][Class],
                        {"FlatToolBar","StatusBar","ReBar","ReBarBand","ToolBar"}) then
                    repaintWinResize = w32True
                    control = controls[i]
                    toRepaint &= {{control[X], control[Y],control[X]+control[CX],
                                   control[Y]+control[CY]}}
                end if
            end for

            repaintWinResize = w32True
            drawIt()
            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)

            --Martin Stachon
            for i=1 to length(controls) do
                if find(controls[i][Class],
                        {"FlatToolBar","StatusBar","ReBar","ReBarBand","ToolBar"}) then
                    control = controls[i]
                    toRepaint &= {{control[X], control[Y],control[X]+control[CX],
                                   control[Y]+control[CY]}}
                end if
            end for

        end if

        repaintWinResize = w32True
        for i=1 to length(toRepaint) do
            repaintRect(Design, toRepaint[i][1], toRepaint[i][2], toRepaint[i][3],
                        toRepaint[i][4])
        end for

    end if

end procedure
setHandler(Design, w32HResize, routine_id("resize_Design"))
-----------------------------------------------------------------------------
procedure resize_Show(integer Self, integer Event, sequence Params)
integer style, x, y
sequence size, control, toRepaint
integer updateThePropertyWidth, updateThePropertyHeight

    style = Params[1]
    x = Params[2]
    y = Params[3]

    if cameFromProperty then
        --dont change window cx, cy in propertysheet and do it here too.
        return
    end if

    toRepaint = {}

    if style=SIZE_RESTORED then
        --change dCX and dCY
        size = getRect(Show)
        updateThePropertyWidth = w32False
        updateThePropertyHeight = w32False
        if dCX!=size[3]-size[1] then
            updateThePropertyWidth = w32True
        end if
        if dCY!=size[4]-size[2] then
            updateThePropertyHeight = w32True
        end if

        dCX = size[3]-size[1]
        dCY = size[4]-size[2]

        fromShow = w32True
        setRect(Design, dX, dY+20, dCX, dCY, w32True)    --20 is Layer toolbar
        fromShow = w32False

        gridX = dCX
        gridY = dCY
        controls[TheWindow][CX] = dCX
        controls[TheWindow][CY] = dCY

        if updateThePropertyWidth
        or updateThePropertyHeight then
            if getIndex(PropertyTitleBar)=1 then
                if updateThePropertyWidth
                and updateThePropertyHeight then
                    updateProperty("Height")
                elsif updateThePropertyWidth then
                    updateProperty("Width")
                elsif updateThePropertyHeight then
                    updateProperty("Height")
                end if
            else
                selectedControl = TheWindow
                delayDraw = w32True
                updateProperties()
                delayDraw = w32False
            end if

            --Martin Stachon
            for i=1 to length(controls) do
                if find(controls[i][Class],
                        {"FlatToolBar","StatusBar","ReBar","ReBarBand","ToolBar"}) then
                    control = controls[i]
                    toRepaint &= {{control[X], control[Y],control[X]+control[CX],
                                   control[Y]+control[CY]}}
                end if
            end for

            drawIt()

            --Martin Stachon
            for i=1 to length(controls) do
                if find(controls[i][Class],
                        {"FlatToolBar","StatusBar","ReBar","ReBarBand","ToolBar"}) then
                    control = controls[i]
                    toRepaint &= {{control[X], control[Y],control[X]+control[CX],
                                   control[Y]+control[CY]}}
                end if
            end for
        end if

        for i=1 to length(toRepaint) do
            repaintRect(Design, toRepaint[i][1], toRepaint[i][2], toRepaint[i][3],
                        toRepaint[i][4])
        end for

    end if
end procedure

--------------------------------------------------------------------------
procedure resize_ProjectTree(integer Self, integer Event, sequence Params)
sequence projectClient,projectSize,controlClient,size, hiddenSize, formSize,toolsize

    --doFormDiffCalc and formDiff are determined in Form w32HResize.
    --formDiff is the amount of unused area to the right of Form in HiddenWindow.
    doFormDiffCalc = w32False
    projectClient = getClientRect(ProjectWindow)
    projectSize = getCtlSize(ProjectWindow)

    --resize the project button and Tree    
    setRect(UndockButton,projectClient[3]-10,projectClient[2],10,10,w32True)
    setRect(TV,projectClient[1],projectClient[2]+20,projectClient[3],projectClient[4]-20,w32True)

    projectSize = getRect(ProjectWindow)
    controlClient = getClientRect(Controls)
    toolsize = getCtlSize(IconBar)
    if isChecked(MenuUndockToolKit) then
        toolsize = {0,0}
    end if

    if not isChecked(MenuUndockProperty)
    or not isChecked(MenuUndockProject) then
        --adjust Form Design's HiddenWindow placement
        hiddenSize = getCtlSize(HiddenWindow)
        if hiddenSize[1]+(projectSize[3]-projectSize[1])<controlClient[3] then
            setRect(HiddenWindow,projectSize[3]-projectSize[1],0,
                    controlClient[3]-(projectSize[3]-projectSize[1]), controlClient[4]-toolsize[2],w32True)
        else
            setRect(HiddenWindow,projectSize[3]-projectSize[1],0,
                    hiddenSize[1], controlClient[4]-toolsize[2],w32True)
        end if
        if not isChecked(MenuUndockForm) then
            formSize = getCtlSize(Form)
            if hiddenSize[1]+(projectSize[3]-projectSize[1])>controlClient[3] then
                --there gets to be a point where Form can't be squished any further but
                --Form still moves to the right.
                --Maybe there is a way to know the smallest width of a window?          
                hiddenSize = getClientRect(HiddenWindow)
                formSize[1] = hiddenSize[3]-formDiff
                if formSize[1]+(projectSize[3]-projectSize[1])>controlClient[3] then
                    --adjust Form to fit within Controls client area
                    formSize[1] = controlClient[3]-(projectSize[3]-projectSize[1])
                end if
            else
                --adjust Form to fit within hiddenWindow client area                            
                hiddenSize = getClientRect(HiddenWindow)
                formSize[1] = hiddenSize[3]-formDiff
            end if
            setCtlSize(Form, formSize[1],formSize[2])
            --adjust Layer tab to fit form
            setCtlSize(LayersTC, formSize[1], 20)
        end if
    end if
    doFormDiffCalc = w32True

    --resize property, unless either are undocked
    if isChecked(MenuUndockProject)
    or isChecked(MenuUndockProperty) then
        return
    end if

    size = getRect(PropertySheet)
    if not skipResize then
        setRect(PropertySheet,0,0,projectSize[3]-projectSize[1],controlClient[4]-(projectSize[4]-projectSize[2]),w32True)
    else
        setRect(PropertySheet,0,0,size[3]-size[1],controlClient[4]-(projectSize[4]-projectSize[2]),w32True)
    end if

end procedure
setHandler(ProjectWindow, w32HResize, routine_id("resize_ProjectTree"))
--------------------------------------------------------------------------------
procedure resize_ProjectUndockWindow(integer Self, integer Event, sequence Params)
sequence projectClient
    if isChecked(MenuClosedProject) then
        return
    end if
    projectClient = getClientRect(ProjectUndockWindow)

    --resize the project button and Tree    
    setRect(ProjectUndockButton,projectClient[3]-10,projectClient[2],10,10,w32True)
    setRect(TV,projectClient[1],projectClient[2]+20,projectClient[3],projectClient[4]-20,w32True)
end procedure
setHandler(ProjectUndockWindow, w32HResize, routine_id("resize_ProjectUndockWindow"))
-----------------------------------------------------------------------------
procedure resize_PropertySheet(integer Self, integer Event, sequence Params)
sequence propertyClient, propertySize, controlClient, size, hiddenSize, formSize,
                toolsize

    doFormDiffCalc = w32False
    propertyClient = getClientRect(PropertySheet)
    propertySize = getCtlSize(PropertySheet)

    --resize the properties contents
    setCtlSize(PropertyTabControl, propertyClient[3], propertyClient[4]-propertyTitleBar)
    size = getCtlSize(PropertyTabControl)
    setCtlSize(sheetId, size[1], size[2]-20)
    setCtlSize(EventListView, size[1], size[2]-20)
    ok = sendMessage(EventListView,LVM_SETCOLUMNWIDTH,0,Params[2]-20)
    setRect(UndockPropertyButton, propertyClient[3]-10,propertyClient[2],10,10,w32True)
    IDEsize = getClientRect(Controls)
    setCtlSize(PropertyTitleBar, propertyClient[3]-13, IDEsize[4])

    propertySize = getRect(PropertySheet)
    controlClient = getClientRect(Controls)
    toolsize = getCtlSize(IconBar)
    if isChecked(MenuUndockToolKit) then
        toolsize = {0,0}
    end if

    if not isChecked(MenuUndockProperty)
    or not isChecked(MenuUndockProject) then
        --adjust Form Design's HiddenWindow placement
        hiddenSize = getCtlSize(HiddenWindow)
        if hiddenSize[1]+(propertySize[3]-propertySize[1])<controlClient[3] then
            setRect(HiddenWindow,propertySize[3]-propertySize[1],0,
                    controlClient[3]-(propertySize[3]-propertySize[1]), controlClient[4]-toolsize[2],w32True)
        else
            setRect(HiddenWindow,propertySize[3]-propertySize[1],0,
                    hiddenSize[1], controlClient[4]-toolsize[2],w32True)
        end if
        if not isChecked(MenuUndockForm) then
            formSize = getCtlSize(Form)
            if hiddenSize[1]+(propertySize[3]-propertySize[1])>controlClient[3] then
                --there gets to be a point where Form can't be squished any further but
                --Form still moves to the right.
                --Maybe there is a way to know the smallest width of a window?          
                hiddenSize = getClientRect(HiddenWindow)
                formSize[1] = hiddenSize[3]-formDiff
                if formSize[1]+(propertySize[3]-propertySize[1])>controlClient[3] then
                    --adjust Form to fit within Controls client area
                    formSize[1] = controlClient[3]-(propertySize[3]-propertySize[1])
                end if
            else
                --adjust Form to fit within hiddenWindow client area                            
                hiddenSize = getClientRect(HiddenWindow)
                formSize[1] = hiddenSize[3]-formDiff
            end if
            setCtlSize(Form, formSize[1],formSize[2])
            --adjust Layer tab to fit form
            setCtlSize(LayersTC, formSize[1],20)
        end if
    end if
    doFormDiffCalc = w32True

    --resize project view, unless either are undocked
    if isChecked(MenuUndockProject)
    or isChecked(MenuUndockProperty) then
        return
    end if

    size = getRect(ProjectWindow)
    propertySize = getRect(PropertySheet)

    if not skipResize then
        setRect(ProjectWindow,size[1],propertySize[4]-propertySize[2],propertySize[3]-propertySize[1],
                controlClient[4]-(propertySize[4]-propertySize[2]),w32True)
    else
        setRect(ProjectWindow,size[1],propertySize[4]-propertySize[2],size[3]-size[1],
                controlClient[4]-(propertySize[4]-propertySize[2]),w32True)
    end if

end procedure
setHandler(PropertySheet, w32HResize, routine_id("resize_PropertySheet"))
--------------------------------------------------------------------------------
procedure resize_PropertyUndockWindow(integer Self, integer Event, sequence Params)
sequence propertyClient, propertySize, size

    if isChecked(MenuClosedProperty) then
        return
    end if

    propertyClient = getClientRect(PropertyUndockWindow)
    propertySize = getCtlSize(PropertyUndockWindow)

    --resize the properties contents        
    setRect(PropertyTabControl, 0, propertyTitleBar, propertyClient[3],
            propertyClient[4]-propertyTitleBar,w32True)
    size = getCtlSize(PropertyTabControl)
    setCtlSize(sheetId, size[1], size[2]-20)
    setCtlSize(EventListView, size[1], size[2]-20)
    ok = sendMessage(EventListView,LVM_SETCOLUMNWIDTH,0,Params[2]-20)
    setRect(PropertyUndockButton, propertyClient[3]-10,propertyClient[2],10,10,w32True)
    IDEsize = getClientRect(PropertyUndockWindow)
    setRect(PropertyTitleBar,0, 0, propertyClient[3]-13, IDEsize[4],w32True)
end procedure
setHandler(PropertyUndockWindow, w32HResize, routine_id("resize_PropertyUndockWindow"))
-----------------------------------------------------------------------------
procedure paint_Design(integer Self, integer Event, sequence Params)
    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)

    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if offsetActive then
        copyBlt(OffScreen, 0, 0, OffScreenBlit)
    end if
end procedure
setHandler(Design,w32HPaint, routine_id("paint_Design"))
--------------------------------------------------------------------------
procedure createShowHandlers()
    --when Show is activated again, need to set up handlers
    setHandler(Show, w32HPaint, routine_id("paint_Design"))
    setHandler(Show, w32HResize, routine_id("resize_Show"))
    setHandler(Show, w32HClose, routine_id("close_Show"))
    setHandler(Show, w32HMouse, routine_id("mouse_Design"))
    setHandler(Show, w32HKeyDown, routine_id("keyDown_Design"))
    setHandler(Show, w32HKeyPress, routine_id("keyPress_Design"))
end procedure
createShowHandlers_id = routine_id("createShowHandlers")
---------------------------------------------------------------------------
procedure activate_Controls(integer Self, integer Event, sequence Params)
integer dockWidth
sequence params, size, size1
integer hold, at

    delayDraw = w32True

    whereEu = getenv("EUDIR")
    if atom(whereEu) then
--DEV PL
--/**/  whereEu = "."
--/*
        ok = displayErrorMessage(238,{})
        abort(1)
--*/
    end if
    --take only first entry
    at = find(';',whereEu)
    if at then
        whereEu = whereEu[1..at-1]
    end if

    euIncFiles = {}
    d = getenv("EUINC")
    at = 0

    if sequence(d) then
        --parse for ; between file names
        while length(d) do
            at = find(';', d)
            if at then
                euIncFiles &= {d[1..at-1]}
                d = d[at+1..length(d)]
            else
                if length(d) then
                    euIncFiles &= {d}
                end if
                exit
            end if
        end while
    end if

    if first then

        ControlList = MasterList

        --load saved Grid configurations, altered controlList and recent Projects
        LoadSavedControlList()

        newProject(Controls)

        setPropertyCombo(defaultColor, 2, validColors)

        -- to prevent a newproject initiating when maximize/restore/minimize
        -- window from the WINDOWS task bar
        first = w32False
        setPenColor(tile, getSysColor(COLOR_BTNFACE))
        drawRectangle(tile, w32True, 0, 0, sizeS[3], sizeS[4])
        drawGrid(GridBlit)
        copyBlt(ControlBlit, 0, 0, GridBlit)
        copyBlt(OffScreenBlit, 0, 0, GridBlit)
        openWindow(HiddenWindow,Normal)
        openWindow(Form, Normal)
        openWindow(Design, Normal)
        openWindow(PropertySheet, Normal)
        openWindow(ProjectWindow, Normal)

        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)

        openWindow(IconBar, Normal)
        setFocus(ToolboxTabItem)    --set focus to first tab

        params = command_line()
        if length(params)>2 then
            autoLoad = w32True

            --params might contain valid filename
            params = params[3]

            --get the long name if there is one
            d = dir(params)

            if not atom(d) then
                --find the filename minus path
                for i=length(params) to 1 by -1 do
                    if params[i]='\\' then
                        params = params[1..i] & d[1][D_NAME]
                        exit
                    end if
                end for
            end if

            if length(params) then
                --read the project
                readProject(Controls, params)
            end if
        elsif isChecked(CB_Start)
          and length(CB_StartFileName) then
            --change the projectDir
            testParam = reverse(CB_StartFileName)
            at = find('\\', testParam)
            if at then
                testParam = testParam[at+1..length(testParam)]
                --establish project directory
                projectDir = reverse(testParam)
            end if
            autoLoad = w32True
            readProject(Controls, CB_StartFileName)
        end if

        --build recent files list
        for i=1 to length(FileBuffer) do
            if i=1 then
                holdSep = createEx(MenuItem, "-", FileMenu, 0, 0, 0, 0, 0, 0)
            end if
            --create a menuitem for this file
            hold = createEx(MenuItem, FileBuffer[i][1], FileMenu, 0, 0, 0, 0, 0, 0)

            --add the behavior for this menuitem
--          setHandler(hold, w32HClick, routine_id("click_OpenRecentFile"))
            setHandler(hold, w32HClick, r_click_OpenRecentFile)

            --tack the id onto back of FileBuffer
            FileBuffer[i][2] = hold
        end for

        -- Load Launch config file                --Launch
        LoadLaunchCfg()                           --Launch

        -- select the window
        selectedControl = TheWindow

        havePropertySheet = w32True
        openingIDE = w32False
        delayDraw = w32False
    end if

    ok = invokeHandler(Controls, w32HResize, {SIZE_RESTORED,cCX,cCY})

    dockWidth = 183

    --establish property sheet
    size = getClientRect(PropertySheet)
    --move the dock button
    setRect(UndockPropertyButton, size[3]-10,size[2],10,10,w32True)
    --resize the Property drop down
    IDEsize = getClientRect(Controls)
    setCtlSize(PropertyTitleBar, size[3]-13, IDEsize[4])
    setCtlSize(PropertyTabControl, size[3], size[4]-propertyTitleBar)
    size = getClientRect(PropertyTabControl)
    setCtlSize(sheetId, size[3], size[4]-20)
    setCtlSize(EventListView, size[3], size[4]-20)
    ok = sendMessage(EventListView,LVM_SETCOLUMNWIDTH,0,size[3]-20)

    --if user left property and projectview expanded when closed IDE then
    --need to re-establish the size of HiddenWindow
    doFormDiffCalc = w32False
    if formDiff then
        size = getCtlSize(HiddenWindow)
        setCtlSize(HiddenWindow,size[1]+formDiff+(2*borderX),size[2])
                                --borderx because formDiff calculated for client area                                           
    end if

    --did user want these windows Always Maximized?   
    if isChecked(Design_R1) then
        size = getClientRect(HiddenWindow)
        setCtlSize(Form, size[1],size[2])
        openWindow(Form, Maximized)
    end if
    if isChecked(Design_R2)
    and formWasMaxed then
        size = getClientRect(HiddenWindow)
        if length(formPosition) then
            setCtlSize(Form, formPosition[3],size[2])
        else
            setCtlSize(Form, size[1],size[2])
        end if
        openWindow(Form, Maximized)
    end if
    if isChecked(IDE_R1) then
        ok = invokeHandler(Controls, w32HResize, {SIZE_MAXIMIZED,cCX,cCY})
        showWindow(Controls, SW_MAXIMIZE)
    end if
    if isChecked(IDE_R2)
    and controlsWasMaxed then
        ok = invokeHandler(Controls, w32HResize, {SIZE_MAXIMIZED,cCX,cCY})
        showWindow(Controls, SW_MAXIMIZE)
    end if

    --position controls
    if isChecked(IDE_R3)        --last position and size
    and length(controlsPosition) then
        if controlsWasMaxed then
            ok = invokeHandler(Controls, w32HResize, {SIZE_MAXIMIZED,cCX,cCY})
            showWindow(Controls, SW_MAXIMIZE)
        elsif controlsPosition[4]<theControlWindowSize[4] then
            --probably was minimzed
        else
            setRect(Controls, controlsPosition[1], controlsPosition[2],
                    controlsPosition[3], controlsPosition[4], w32True)
        end if
    end if

    if isChecked(Design_R3) --last position and size
    and length(formPosition) then
        if formWasMaxed then
            if formDiff then
                size = getCtlSize(HiddenWindow)
                setCtlSize(Form, size[1],size[2])
            end if
            openWindow(Form, Maximized)
        else
            --position form            
            if isChecked(IDE_R4) then
                if formPosition[1]<0 then formPosition[1] = 0 end if
                if formPosition[2]<0 then formPosition[2] = 0 end if
            end if
            if isChecked(MenuUndockForm) then
                setRect(FormUndockWindow, formPosition[1], formPosition[2],
                        formPosition[3], formPosition[4], w32True)
                moveZOrder(FormUndockWindow, HWND_TOP)
            else
                if formDiff then
                    size = getCtlSize(HiddenWindow)
                    setCtlSize(Form, size[1]+formDiff,size[2])
                else
                    setRect(Form, 0, 0,     formPosition[3], formPosition[4], w32True)
                end if
            end if
        end if
    end if
--
    if isChecked(Prop_CB1) then                 --closed
        click_DockPropertySheet(PropertySheet, w32HClick,{})
        showWindow(PropertyUndockWindow, SW_HIDE)
        closeWindow(PropertySheet)
    else
        if isChecked(Prop_CB2)                  --want undocked
        or propWasUnDocked then                 --was undocked    
            click_DockPropertySheet(PropertySheet, w32HClick,{})
        end if

        if isChecked(Prop_R1) then              --last position and size                                    
            --test position of propertysheet
            if isChecked(IDE_R4) then
                if propertyPosition[1]<0 then propertyPosition[1] = 0 end if
                if propertyPosition[2]<0 then propertyPosition[2] = 0 end if
            end if
            if isChecked(MenuUndockProperty) then
                setRect(PropertyUndockWindow, propertyPosition[1], propertyPosition[2],
                        propertyPosition[3], propertyPosition[4], w32True)
                IDEsize = getClientRect(PropertyUndockWindow)
                setCtlSize(PropertyTitleBar, IDEsize[2]-13, IDEsize[4])
                moveZOrder(PropertyUndockWindow, HWND_TOP)
            else
                setRect(PropertySheet, 0, 0,
                        propertyPosition[3], propertyPosition[4], w32True)
                size = getClientRect(PropertySheet)
                --move the dock button
                setRect(UndockPropertyButton, size[3]-10,size[2],10,10,w32True)
                --resize the Property drop down
                IDEsize = getClientRect(Controls)
                setCtlSize(PropertyTitleBar, size[3]-13, IDEsize[4])
                setCtlSize(PropertyTabControl, size[3], size[4]-propertyTitleBar)
                size = getClientRect(PropertyTabControl)
                setCtlSize(sheetId, size[3], size[4]-20)
                setCtlSize(EventListView, size[3], size[4]-20)
                ok = sendMessage(EventListView,LVM_SETCOLUMNWIDTH,0,size[3]-20)
            end if
        end if
    end if

    if isChecked(PV_CB1) then               --closed
        UndockButton_onClick(ProjectWindow, w32HClick,{})
        showWindow(ProjectUndockWindow, SW_HIDE)
        closeWindow(ProjectWindow)
    else
        if isChecked(PV_CB2)            --want undocked
        or pvWasUnDocked then           --was undocked
            UndockButton_onClick(ProjectWindow, w32HClick,{})
        end if

        if isChecked(PV_R1) then        --last position and size                                          
            if isChecked(IDE_R4) then
                if projectPosition[1]<0 then projectPosition[1] = 0 end if
                if projectPosition[2]<0 then projectPosition[2] = 0 end if
            end if
            if isChecked(MenuUndockProject) then
                setRect(ProjectUndockWindow, projectPosition[1], projectPosition[2],
                        projectPosition[3], projectPosition[4], w32True)
                --because redock wants size of ProjectWindow.......
                setRect(ProjectWindow, projectPosition[1], projectPosition[2],
                        projectPosition[3], projectPosition[4], w32True)
                moveZOrder(ProjectUndockWindow, HWND_TOP)
            else
                if isChecked(MenuUndockProperty) then
                    size1 = getClientRect(Controls)
                    setRect(ProjectWindow, 0,0,
                            projectPosition[3], size1[4], w32True)
                else
                    size = getCtlSize(PropertySheet)
                    setRect(ProjectWindow, 0, size[2],
                            projectPosition[3], projectPosition[4], w32True)
                end if
            end if
        end if
    end if

    if isChecked(Design_CB1)    --undock
    or formWasUndocked then             --was undocked
        ok = invokeHandler(MenuUndockForm, w32HClick, {})
    end if

    if not isChecked(Code_CB1) then
        openWindow(CodeWin, Normal)
        setIndex(CodeWin, TheWindow)
        ok = invokeHandler(CodeControls,w32HClick,{})
    else
        openWindow(CodeWin, Minimize)
        setIndex(CodeWin, TheWindow)
        ok = invokeHandler(CodeControls,w32HClick,{})
        showWindow(CodeWin, SW_HIDE)
        CodeWinOpen = w32False
    end if
    if isChecked(Code_R1)
    and not isChecked(Code_CB1) then
        CodeWinWasMaxed = w32True
        openWindow(CodeWin, Maximized)
        setIndex(CodeControls,TheWindow)
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if
    if isChecked(Code_R2)
    and codeWasMaxed
    and not isChecked(Code_CB1) then
        CodeWinWasMaxed = w32True
        openWindow(CodeWin, Maximized)
        setIndex(CodeControls,TheWindow)
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if
    if isChecked(Code_R3)
    and length(codePosition) then
        --position editor
        if codeWasMaxed
        and not isChecked(Code_CB1) then
            CodeWinWasMaxed = w32True
            openWindow(CodeWin, Maximized)
            setIndex(CodeControls,TheWindow)
            ok = invokeHandler(CodeControls,w32HClick,{})
        elsif codePosition[4]=titleBar+(2*borderX)
           or codeWasMined then
                --probably was minimized        
            showWindow(CodeWin, Minimized)
        else
            size1 = getRect(Controls)
            if isChecked(Code_CB1) then
                showWindow(CodeWin, SW_HIDE)
                CodeWinOpen = w32False
                setCtlPosition(CodeWin, codePosition[1],codePosition[2])
                setCtlSize(CodeWin,codePosition[3],codePosition[4])
            else
                setRect(CodeWin, size1[1]+codePosition[1]+borderX,
                        size1[2]+codePosition[2]+titleBar+menuBar+borderX,
                        codePosition[3], codePosition[4], w32True)
            end if
        end if
    end if

    if not CodeWinWasMaxed then
        CodeWinWasOpened = w32False
    end if

    setVScrollPos(Form, 1)
    setHScrollPos(Form, 1)

    --when user has resolution other than 800 X 600 and large fonts,
    --sometimes IDE's menuBar has more than l line of menu items.
    --so get the size again now.
    --But it doesn't help with positioning other windows within Controls when
    --using getClientRect.
    menuBar = getSystemMetrics(SM_CYMENU)
    if CodeWinOpen then
        size = getCtlSize(CodeWin)
        ok = invokeHandler(CodeWin,w32HResize,{w32HResize,size[1],size[2]})
        moveZOrder(CodeWin, HWND_TOP)
    else
        setFocus(Controls)
    end if
    closeWindow(splash)
    --read the module and extract global routines for colorazation
    readModuleFile("coloredbuttons.ew")
    updateKeywords()
end procedure
setHandler(Controls, w32HActivate, routine_id("activate_Controls"))
------------------------------------------------------------------------------
procedure openReorderID()
    if ReorderWindow!= -1 then
        ok = invokeHandler(ReorderWindow, w32HOpen, {})
    else
        createReorderwindow()
        ok = invokeHandler(ReorderWindow, w32HOpen, {})
    end if
end procedure
openReorder_id = routine_id("openReorderID")
------------------------------------------------------------------------------
procedure open_ToolBox(integer self, integer event, sequence params)
    if translateNow then
        translateIconBar()
    end if
end procedure
setHandler(IconBar,w32HOpen,routine_id("open_ToolBox"))
--------------------------------------------------------------------------------
procedure open_PropertySheet(integer self, integer event, sequence params)
    if translateNow then
        translatePropertySheet()
    end if
end procedure
setHandler(PropertySheet, w32HOpen,routine_id("open_PropertySheet"))
--------------------------------------------------------------------------------
procedure open_ProjectView(integer self, integer event, sequence params)
    if translateNow then
        translateProjectView()
    end if
end procedure
setHandler(ProjectWindow, w32HOpen,routine_id("open_ProjectView"))
------------------------------------------------------------------------------
procedure open_Controls(integer self, integer event, sequence params)
    openWindow(PropertyUndockWindow, Normal)
    openWindow(ProjectUndockWindow, Normal)
    openWindow(IconBarUndockWindow, Normal)
    openWindow(FormUndockWindow, Normal)
    showWindow(PropertyUndockWindow, SW_HIDE)
    showWindow(ProjectUndockWindow, SW_HIDE)
    showWindow(IconBarUndockWindow, SW_HIDE)
    showWindow(FormUndockWindow, SW_HIDE)

    if translateNow then
        translateControlWindow()
    end if
end procedure
setHandler(Controls,w32HOpen,routine_id("open_Controls"))
------------------------------------------------------------------------------
-- Craig Welch add for autosave
procedure Autosave(integer self, integer event, sequence params)
    if params[1]=1  then                                                    -- we're only using one timer, but allow for others later
        killTimer(Controls, 1)
        -- don't fire while we're processing
        if not length(openFileName) then                        -- can't save a file we don't know about
            setTimer(Controls, 1, autosave_time)
            return
        end if
        if synGetModified() then
            if not isModuleRoutine then
                ok = invokeHandler(CodeControls,w32HClick,{})--save the current control-event into the Controls sequence
                                                                                                   --so saving the file includes these latest changes
            else
                if equal(getItem(CodeModules,getIndex(CodeModules)), "Unidentified.e") then
                    return  --we don't want to handle unsaved modules
                end if
                saveTheModule(0, 0, {})
            end if
            writeProject(openFileName)
            resetModified()                                                 -- reset the 'modified' flag so that we don't save unnecessarily
        end if
        setTimer(Controls, 1, autosave_time)            -- reset the timer for the next autosave
    end if

end procedure
setHandler(Controls, w32HTimer, routine_id("Autosave"))
--------------------------------------------------------------------------------
sequence crashName
procedure showCrashMessage()
    if length(openFileName) then
        crashName = projectDir & "\\CrashFile_" & openFileName
    else
        crashName = the_current_dir & "\\CrashFile_Unidentified." & projectFileType
    end if

    if (startSave and endSave)--user processed completely through writeProject
    or (not startSave and length(controls)) then--user had not writeProject but had controls
        --there is a project to save or new project to save event; it might be just Window1
        crash_message("An unexpected error has occurred!\n" &
                      "IDE has saved your project as " & crashName & ".\n")
    elsif startSave and not endSave then
        --user started the writeProject process but the crash happened before completing it                                     
        crash_message("An unexpected error has occurred!\n" &
                      "IDE has saved your project as " & crashName & ".\n" &
                      "Your project failed when saving your project or new project\n" &
                      "so " & crashName & " and will be much use to you for\n" &
                      "reloading into IDE. Please refer to ex.err or ex_crash.err, if they exist\n")
    end if
end procedure
--------------------------------------------------------------------------------              
function IDEcrash(object x)
    if object(x) then end if
    if not length(controls) then
        return 0        --this allows normal ex.err to occur
    end if

    showCrashMessage()
    if not isModuleRoutine then --control-event was in editor                           
        ok = invokeHandler(CodeControls,w32HClick,{}) --save the current control-event into the Controls sequence
                                                                                        --so saving the file includes these latest change                             
    else
        saveTheModule(0, 0, {})                                         --save a file that was loaded via Open Module
    end if
    writeProject(crashName)
    return 0

end function
--DEV
constant r_IDEcrash = routine_id("IDEcrash")
if r_IDEcrash then end if
--/*
--crash_routine(routine_id("IDEcrash"))
crash_routine(r_IDEcrash)
--*/
------------------------------------------------------------------------------
function AppCleanUp(integer ErrCode, sequence ErrText, integer ControlId, integer LastCleanUp)
    if ErrCode then
        VOID = message_box("IDE is closing due to Winlib fatal error","",0)
        VOID = invokeHandler(Controls, w32HClose,{})
    end if
    return 0 -- Continue with other clean up routines.
end function

   -- Link in my clean-up routine
    VOID = attachCleanUp(routine_id("AppCleanUp"))
--------------------------------------------------------------------------------
    -- windows event loop
WinMain(Controls, Normal)

