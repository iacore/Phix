-- ide_code.ew
-- code editor for win32lib IDE

integer ok
object VOID

global sequence     --holds local keywords from modules
    localKeywords
    localKeywords = {}

global sequence     --holds local keywords from control-events
    ceKeywords
    ceKeywords = {}

global sequence         --holds filename and routine name for jump to and return
                                        --or control-event pair and routine name for jump to and return
        jumpToKeywords
        jumpToKeywords = {}
-------------------------------------------------------------------------------
include includes\ide_syntax.ew                   --Don Phillips and modified for IDE
-------------------------------------------------------------------------------
constant
    WM_NCACTIVATE = #86     -- martin
------------------------------------------------------------------------------
--  Code Editor Wrapper Window
------------------------------------------------------------------------------
global constant
                                                                        --"Code Editor"
CodeWin             = createDockBar(IDEText[430][1], Controls, Default, Default, 630, 344, WS_CLIPCHILDREN, 0),
CodeControls        = createEx(List, "", CodeWin, 0,0,100,100,w32or_all({WS_HSCROLL}),0),
Highlight           = Syntax2(CodeWin, 50, 0, 1, 1, {WS_CHILD,WS_VISIBLE,WS_CLIPCHILDREN,WS_CLIPSIBLINGS}, WS_EX_CLIENTEDGE),
StatBar             = createEx(StatusBar, "", CodeWin, 0, 0, 1, 1, 0, 0)
constant
SchoochButton        = createEx(PushButton,"",CodeWin,0,0,0,0,0,0),
                                     --"&Module File"
MenuCodeSaveModule  = createEx(Menu, IDEText[431][1], CodeWin, 0, 0, 0, 0, 0, 0),
                                        --"&New"
MenuCodeNew         = createEx(MenuItem, IDEText[432][1], MenuCodeSaveModule, 0, 0, 0, 0, 0, 0)

global constant                           --"&Open"
MenuCodeOpen        = createEx(MenuItem, IDEText[433][1], MenuCodeSaveModule, 0, 0, 0, 0, 0, 0)

constant                                         --"Save&As"
MenuCodeSaveAs      = createEx(MenuItem, IDEText[434][1], MenuCodeSaveModule, 0, 0, 0, 0, 0, 0)
global constant
                                        --"&Save"
MenuCodeSave        = createEx(MenuItem, IDEText[435][1], MenuCodeSaveModule, 0, 0, 0, 0, 0, 0),
                       --"&BackUp Before Save"
MenuCodeBackUp      = createEx(MenuItem, IDEText[436][1], MenuCodeSaveModule, 0, 0, 0, 0, 0, 0),
                                        --"&Close"
MenuCodeClose       = createEx(MenuItem, IDEText[437][1], MenuCodeSaveModule, 0, 0, 0, 0, 0, 0)
constant
                                   --"&Print"
MenuPrintIt         = createEx(Menu, IDEText[438][1], CodeWin, 0, 0, 0, 0, 0, 0),
                                       --"&Print Options"
MenuPrint           = createEx(MenuItem,IDEText[439][1],MenuPrintIt, 0, 0, 0, 0, 0, 0),
                                    --"&Edit"
MenuEdit            = createEx(Menu, IDEText[440][1], CodeWin, 0, 0, 0, 0, 0, 0),
                                        --"&Undo \t Ctrl+Z"                                       
MenuUndo            = createEx(MenuItem, IDEText[441][1], MenuEdit, 0, 0, 0, 0, 0, 0),

MenuEditSep1        = createEx(MenuItem, "-", MenuEdit, 0, 0, 0, 0, 0, 0),
                                        --"Cu&t \t Ctrl+X"
MenuCut             = createEx(MenuItem, IDEText[442][1], MenuEdit, 0, 0, 0, 0, 0, 0),
                                         --"&Copy \t Ctrl+C"
MenuCopy            = createEx(MenuItem, IDEText[443][1], MenuEdit, 0, 0, 0, 0, 0, 0),
                                         --"&Paste \t Ctrl+V"
MenuPaste           = createEx(MenuItem, IDEText[444][1], MenuEdit, 0, 0, 0, 0, 0, 0),
                                        --"&Select All"
MenuSelectAll       = createEx(MenuItem, IDEText[445][1], MenuEdit, 0, 0, 0, 0, 0, 0),
MenuEditSep2        = createEx(MenuItem, "-", MenuEdit, 0, 0, 0, 0, 0, 0),
                                         --"Block &Indent \t Ctrl+B"
MenuBlkIndent       = createEx(MenuItem, IDEText[976][1], MenuEdit, 0, 0, 0, 0, 0, 0),
                                         --"Block Un-indent \t Ctrl+Shift+B"
MenuBlkUnindent     = createEx(MenuItem, IDEText[1017][1], MenuEdit, 0, 0, 0, 0, 0, 0),
                                         --"&Block Comment \t Ctrl+D"
MenuBlkComment      = createEx(MenuItem, IDEText[977][1], MenuEdit, 0, 0, 0, 0, 0, 0),
                                    --"&View Code Base"
CodeBaseMenuInCodeWin = createEx(Menu,IDEText[1000][1],CodeWin,0,0,0,0,0,0)
                                                           --"&View"
global constant CodeBaseMenuItemInCodeWin = createEx(MenuItem,IDEText[1001][1],CodeBaseMenuInCodeWin,0,0,0,0,0,0)
constant
                                    --"&Search"
MenuSearch          = createEx(Menu, IDEText[446][1], CodeWin, 0, 0, 0, 0, 0, 0),
                                    --"&Find/Replace"
MenuFindWhere       = createEx(Menu, IDEText[447][1], MenuSearch, 0, 0, 0, 0, 0, 0),
                                        --"&Curent Control-Event"
MenuFind            = createEx(MenuItem, IDEText[448][1], MenuFindWhere, 0, 0, 0, 0, 0, 0),
                                        --"&All Controls-Events"
MenuFindAll         = createEx(MenuItem, IDEText[449][1], MenuFindWhere, 0, 0, 0, 0, 0, 0),
                                        --"&Project"
MenuFindPrj         = createEx(MenuItem, IDEText[450][1], MenuFindWhere, 0, 0, 0, 0, 0, 0),
                                         --"&Go To Line....."
MenuGoTo            = createEx(MenuItem, IDEText[451][1], MenuSearch, 0, 0, 0, 0, 0, 0),
                                    --"&List"
MenuList            = createEx(Menu, IDEText[452][1], CodeWin, 0, 0, 0, 0, 0, 0),
                                        --"&List Routine Names"
MenuEditRoutines    = createEx(MenuItem, IDEText[453][1], MenuList, 0, 0, 0, 0, 0, 0),
                                    --"Op&tions"
MenuOpt             = createEx(Menu, IDEText[454][1],CodeWin, 0, 0, 0, 0, 0, 0),
                                         --"&Register Hot Keys"
MenuHotKeys         = createEx(MenuItem, IDEText[455][1], MenuOpt, 0, 0, 0, 0, 0, 0),
MenuOptSepa         = createEx(MenuItem, "-", MenuOpt, 0, 0, 0, 0, 0, 0),
                                                                                --"Select Events For Control"
MenuEventsList          = createEx(MenuItem, IDEText[1040][1], MenuOpt, 0, 0, 0, 0, 0, 0),
                                       --"Editor &Options"
MenuEditorOption    = createEx(MenuItem,IDEText[456][1], MenuOpt, 0, 0, 0, 0, 0, 0),
MenuOptSep1         = createEx(MenuItem, "-", MenuOpt, 0, 0, 0, 0, 0, 0)
global constant
                                        --"AutoComplete"
MenuAutoComplete    = createEx(MenuItem, IDEText[813][1], MenuOpt, 0, 0, 0, 0, 0, 0),
                                        --"&Enable Hints"
MenuIgnoreHints     = createEx(MenuItem,IDEText[457][1], MenuOpt, 0, 0, 0, 0, 0, 0),
                                        --"Show &Hint in Status Bar"
MenuHintsStatus     = createEx(MenuItem, IDEText[458][1], MenuOpt, 0, 0, 0, 0, 0, 0)
constant
MenuOptSep2         = createEx(MenuItem, "-", MenuOpt, 0, 0, 0, 0, 0, 0),
                                    --"When changing Control:"
MenuControlAction   = createEx(Menu, IDEText[1013][1], MenuOpt, 0, 0, 0, 0, 0, 0)
global constant
                                         --"Find first event with code"
MenuFirstEvent      = createEx(MenuItem, IDEText[1014][1], MenuControlAction, 0, 0, 0, 0, 0, 0),
                                         --"Find event from prior control"
MenuLastEvent       = createEx(MenuItem, IDEText[1015][1], MenuControlAction, 0, 0, 0, 0, 0, 0),
                                         --"Find last event edited for selected control"
MenuThisLastEvent   = createEx(MenuItem, IDEText[1016][1], MenuControlAction, 0, 0, 0, 0, 0, 0),
                                         --"Hide Number Gutter"
MenuHideGutter      = createEx(MenuItem, IDEText[985][1], MenuOpt, 0, 0, 0, 0, 0, 0),
                                                                                  --"AutosaveOptions"
MenuAutosaveOpts    = createEx(MenuItem, IDEText[1166][1], MenuOpt, 0, 0, 0, 0, 0, 0),
                                                                                --"Save Without Asking"
MenuAutoSave            = createEx(MenuItem, IDEText[1027][1], MenuOpt, 0, 0, 0, 0, 0, 0)
constant
                                    --"When SaveAs &Module
MenuSaveOptions     = createEx(Menu, IDEText[460][1], MenuOpt, 0, 0, 0, 0, 0, 0)
global constant
                                        --"Always add new module to &Project"
SaveToProject       = createEx(MenuItem, IDEText[461][1], MenuSaveOptions, 0, 0, 0, 0, 0, 0),
                                        --"&Ask to add to Project"
AskSaveToProject    = createEx(MenuItem, IDEText[462][1], MenuSaveOptions, 0, 0, 0, 0, 0, 0)
constant
                                    --"&Generate Program"
MenuCodeRuns        = createEx(Menu, IDEText[463][1], CodeWin, 0, 0, 0, 0, 0, 0)
global constant
                                      --"&Syntax Highlight Only Euphoria,Win32lib Keywords"
MenuColorFile     = createEx(MenuItem, IDEText[1022][1], MenuOpt, 0, 0, 0, 0, 0, 0),                                         --"&Run \t F5"
                                      --"&Syntax Highlight Local Routine Names"                                      
MenuColorLocals     = createEx(MenuItem, IDEText[1020][1], MenuOpt, 0, 0, 0, 0, 0, 0),
                                                                                --"Color Control Names"
MenuColorControlName = createEx(MenuItem, IDEText[1053][1], MenuOpt, 0, 0, 0, 0, 0, 0),
                                      --{"Name change in &Properties is ignored for Code Editor Statements
ChangeName          = createEx(MenuItem, IDEText[1024][1], MenuOpt, 0, 0, 0, 0, 0, 0),
MenuCodeRun         = createEx(MenuItem, IDEText[464][1], MenuCodeRuns, 0, 0, 0, 0, 0, 0),
                                        --"&Temp Run \t F6"
MenuCodeRunTemp     = createEx(MenuItem, IDEText[465][1],MenuCodeRuns, 0, 0, 0, 0, 0, 0)
constant
                                                                        --"Tools"
MenuTool                        = createEx(Menu, IDEText[1095][1], CodeWin, 0,0,0,0,0,0),
                                                                                --"Show Color Palette"
MenuColorwheel          = createEx(MenuItem, IDEText[1096][1], MenuTool, 0,0,0,0,0,0),
                                    --"&Help"
MenuHelp            = createEx(Menu, IDEText[466][1], CodeWin, 0, 0, 0, 0, 0, 0),
                                        --"&Library"
ButLibHtml          = createEx(MenuItem, IDEText[467][1], MenuHelp, 0, 0, 0, 0, 0, 0),
                                        --"&Win32Lib"
ButWinlibHtml       = createEx(MenuItem, IDEText[468][1], MenuHelp, 0, 0, 0, 0, 0, 0),
                                                                                --&ColoredButton
ButCbHtml                       = createEx(MenuItem, IDEText[1210][1],MenuHelp, 0, 0, 0, 0, 0, 0),
ButMenuSep          = createEx(MenuItem, "-", MenuHelp, 0, 0, 0, 0, 0, 0),
                                       --"&Keys"
MenuCodeKeys        = createEx(MenuItem, IDEText[469][1], MenuHelp, 0, 0, 0, 0, 0, 0)
--------------------------------------------------------------------------------

sequence
    size
    size            = getClientRect(CodeWin)
--------------------------------------------------------------------------------
global constant
CodeModules         = createEx(DropDownList, "Modules", CodeWin, size[3]-160-5, 4,
                               160, size[4]-4, 0, 0),
--dummy to parallel CodeModules and hold path
PathModules         = createEx(Combo, "", CodeWin, -200, -200, 160, 24*6, 0, 0)
                                      --"View Code Base"
global constant WinCodeBase = createEx(Window,IDEText[1002][1] , CodeWin, Default, Default, 597, 367, 0, WS_EX_TOOLWINDOW) --was Form
--------------------------------------------------------------------------------
constant
popups = createEx(Popup,"",CodeWin,0,0,0,0,0,0),
                                                --"Show events for this control that have coding"
popup1 = createEx(MenuItem,IDEText[776][1],popups,0,0,0,0,0,0),
                                                --"Show Controls in a Sorted List"
popup2 = createEx(MenuItem,IDEText[777][1],popups,0,0,0,0,0,0),
                                                --"Show Controls in other project windows"
popup3 = createEx(MenuItem,IDEText[779][1],popups,0,0,0,0,0,0),
                                                --"Show Sorted Controls in other project windows"
popup4 = createEx(MenuItem,IDEText[780][1],popups,0,0,0,0,0,0)
--------------------------------------------------------------------------------
--Window to show popup result                   "Events For:"
constant PopupWindow = createEx(Window, IDEText[782][1], CodeWin, Default, Default, 124, 315, 0, {WS_EX_TOOLWINDOW})
--PickedControl and PopupDropDown swap in and out depending upon request from popup
constant PickedControl = createEx(LText, "", PopupWindow, 0, 4, 116, 20, 0, 0)
constant PopupDropDown = createEx(DropDownList, "", PopupWindow, 0, 4, 116, 20*6, 0, 0)
setVisible(PopupDropDown, w32False)
constant PopupSortedList = createEx(SortedList, "", PopupWindow, 0, 28, 116, 260, w32or_all({WS_HSCROLL}), 0)
setVisible(PopupSortedList, w32False)
constant PopupList = createEx(List, "", PopupWindow, 0, 28, 116, 260, w32or_all({WS_HSCROLL}), 0)
                                                                        --"Search"
constant PopupText = createEx(LText, IDEText[783][1], PopupWindow, 0, 270, 104, 20, 0, 0)
constant PopupSearch = createEx(EditText, "", PopupWindow, 12, 292, 90, 20, 0, 0)
--------------------------------------------------------------------------------
include includes\printOptions.ew
include includes\tabbedpalette.ew
--------------------------------------------------------------------------------
global constant
-- Hint window
HintWin             = createEx(Window, "", 0, Default, Default, 600, 30, {WS_THICKFRAME+WS_POPUP}, {WS_EX_TOPMOST,WS_EX_TOOLWINDOW})
constant
RichHint            = createEx(RichEdit, "", HintWin, 0, 0, 580, 30, ES_READONLY, 0)
-------------------------------------------------------------------------------
                                                                                        --"Autosave Options"
constant AutosaveOptions = createEx(Window, IDEText[1166][1], 0, Default, Default, 325, 177, 0, 0)
                                                                                                --"Turn on/off Autosave"
global constant AutosaveCheckbox = createEx(CheckBox, IDEText[1168][1], AutosaveOptions, 12, 16, 204, 20, 0, 0)
global constant AutosaveMinutes = createEx(EditText, "5", AutosaveOptions, 12, 40, 44, 28, 0, 0)
global constant AutosaveMinChg = createEx(UpDown, "", AutosaveOptions, 36, 40, 0, 0, w32or_all({UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS}), 0)
setScrollRange(AutosaveMinChg, 1, 60)
                                                                                --"Autosave every selected minutes"
constant AutosaveText = createEx(LText, IDEText[1167][1], AutosaveOptions, 56, 40, 300, 20, 0, 0)
                                                                                        --"OK"
constant AutoSaveOK = createEx(PushButton, IDEText[44][1], AutosaveOptions, 64, 88, 68, 28, 0, 0)
---------------------------------------------------------
--------------------------------------------------------------------------------
procedure AutosaveCheckbox_onClick(integer self, integer event, sequence params)
    if isChecked(AutosaveCheckbox) then
        autosave_OnOff = w32True
        killTimer(Controls,1)--just in case it is still alive
        autosave_time = getNumber(AutosaveMinutes)*60*1000
        setTimer(Controls, 1, autosave_time)
    else
        autosave_OnOff = w32False
        killTimer(Controls,1)
    end if
end procedure
setHandler(AutosaveCheckbox, w32HClick, routine_id("AutosaveCheckbox_onClick"))
--------------------------------------------------------------------------------
procedure AutosaveMinChg_onScroll(integer self, integer event, sequence params)
    autosave_time = getNumber(AutosaveMinutes)*60*1000
end procedure
setHandler(AutosaveMinChg, w32HScroll, routine_id("AutosaveMinChg_onScroll"))
--------------------------------------------------------------------------------
procedure AutoSaveOK_onClick(integer self, integer event, sequence params)
    closeWindow(AutosaveOptions)
end procedure
setHandler(AutoSaveOK, w32HClick, routine_id("AutoSaveOK_onClick"))
setBuddy(AutosaveMinChg, AutosaveMinutes)
--------------------------------------------------------------------------------
--  Window RegisterHotKeyWin
integer IDEok
sequence IDElvItems
sequence IDElvData
integer IDElvItemNo
atom lvMask
integer lvOk
sequence LVSelected
integer RegisterHotKeyWin    RegisterHotKeyWin = -1
integer HotKeyLV
integer EditAction
integer ChangeButton
integer DeleteButton
integer CreateNewFileButton
integer OkButton
integer HotKeySearch
integer HotKeyFileName
integer HotKeyMakeDefault
integer LText2FKey
integer LTextFKey
integer EditKey
object LVDataIndex
integer index
integer currentMakeDefault             currentMakeDefault = w32True
sequence currentHotKeyFileName         currentHotKeyFileName = {}
integer translateCodeWin_id
global sequence openModuleAt           openModuleAt = {}
integer moduleY                        moduleY = 0
integer moduleX                        moduleX = 0
integer moduleTopLine                  moduleTopLine = 0
global integer CodeWinExists           CodeWinExists = w32False
sequence jumpEvent
integer jumpIsFromModule,jumpId,jumpIsToModule,jumpToCol,jumpToRow
sequence jumpKey jumpKey = {}
sequence jumpName, F1Name
integer jumpPos1,jumpPos2,jumpTopLine,foundIt
jumpIsFromModule = w32False
jumpId = 0
jumpEvent = {}
jumpIsToModule = w32False
jumpToCol = 0
jumpToRow = 1
jumpName = {}
F1Name = {}
jumpPos1 = 0
jumpPos2 = 1
sequence jumpModule
--, lastModifiedLine
jumpModule = {}
-------------------------------------------------------------------------------
synFileInEditor(w32False)
adjustEscLineNumber(w32False)

setHint(HintWin,IDEText[470][1])
setHint(RichHint,IDEText[470][1])
setHint(CodeControls, IDEText[1028][1])
setCheck(MenuCodeBackUp, w32True)
setCheck(MenuHideGutter, w32False)
setCheck(MenuLastEvent, w32True)
setCheck(MenuFirstEvent, w32False)
setCheck(MenuThisLastEvent, w32False)

setEnable(MenuEditRoutines, w32False)

setIcon(CodeWin, the_current_dir & "\\resources\\ide_editor.ico")

statusBar = getCtlSize(StatBar) --used in ide.exw to set size when create a control
--------------------------------------------------------------------------------
--this is a sequence by control Class of event Name and indicator if can be used for this control
--format is { {},{} } where the first index is the control class and the second is made up of
--1 to lenght(Events) event name and an indicator if good for the control class
--this is maintained in IDE_orderEvents.ew and accessed from Options in Code Editor
global sequence EventsPerControlClass
EventsPerControlClass = {}
global sequence tempEventsPerControlClass
-- update with file data in CodeWin w32HOpen event
------------------------------------------------------------------------------
--     support windows
------------------------------------------------------------------------------
--List of Routines
atom
    ListRoutinesWindow,
    AllRoutines,

    KeysCodeWin,
    LText2,
    LText3,
    ButClose

    ListRoutinesWindow          = -1
    AllRoutines                 = -1
    KeysCodeWin                 = -1
---------------------------------------------------------------------------
--    declaratives
---------------------------------------------------------------------------
global integer
    cameFromMenuEditor,         --go back there after close
    cameFromPopupEditor,        --go back there after cose
    cameFromTimerEditor,        --goback there after close

    --if user starts using Code Editor then clicks on a control in Design, the
    --selectedControl value changes to the clicked control. Code Editor doesn't
    --know this has happened. Solution: onOpen of Editor, place selectedControl in
    --this variable.

    --new note: this doesn't always help. If a control is created and code created but not saved,
    --and the user deletes that control, the code is still sitting in code editor. When user clicks
    --for another control to be loaded into editor it gets the deleted code instead. Probably need to
    --save the control-event pair. If the control is deleted while still in editor, then clear the editor.
    editorSelectedControl,

    --forward referencing rid
    readModuleFile_id,

    errorEvent                  --holds ex.err event in error

    cameFromMenuEditor          = w32False
    cameFromPopupEditor         = w32False
    cameFromTimerEditor         = w32False
    editorSelectedControl       = TheWindow
    errorEvent                  = 0

integer
    exiting,                    -- tells editor not to reopen codewin

    --forward referencing rid
    findAllRoutines_id,
    saveTheModule_id,
    modifyTheHint_id,
    HelpHtml_id,

    HintCurY,                   --location of cursor in hints params in editor
    HintCurX,
    recordCnt,
    HintIndex,                  --index of params into Hint
    commas,                     --determines the current param
    getFromNextLine,
    schoochOn

    HintCurY                    = 0
    HintCurX                    = 1
    HintIndex                   = 0
    commas                      = 0
    exiting                     = w32False
    getFromNextLine             = w32False
    schoochOn                   = w32False

sequence
    moduleData,
    moduleRoutineLine,
    modulePath,                 --path to ex.err module and open module
    haveFileName,
    HintList,
    HintWord,                   --last hint word used
    HintText,                   --last hint word text used
    hintColors,                 --standard colors
    colorTable,                 --parsed hintColors for RichEdit control
    win32lib,
--  CBLib,
    library,
    builtins,
    keywords,
    hintLoc,                    --where Hint Window was when last closed or moved to by user
    HotKeyText                  --text value for HotKeys

    modulePath                  = {}
    haveFileName                = {}
    HintList                    = {}
    HintWord                    = {}
    HintText                    = {}
    win32lib                    = {}
    library                     = {}
    builtins                    = {}
    keywords                    = {}
    hintLoc                     = {}
    HotKeyText = {{""},{""},{""},{""},{""},{""},{""},{""},{""},{""},{""},{""},{""},{""},{""},{""}}

global sequence
    HintsExtra

    HintsExtra                  = {}
global integer
    doingHints                  --true when currently checking for hint param to color
    doingHints = w32False
------------------------------------------------------------------------------
include includes\\Ide_hints.e
--------------------------------------------------------------------------------
HintList = HintStandard
-------------------------------------------------------------------------------
global sequence
    otherKeywords   --holds keywords from modules which is then updated into syntax
    otherKeywords = {}

sequence
    controlEventPairing
    --what is this? As control-event pairing starts to develop, I needed some way
    --to know where CodeEvent index is in the Events list which runs the order
    --of coding in controls[control][Code]. The number pairing is the order from
    --getIndex(CodeEvent) and the second is the physical placement.
controlEventPairing = {
{"Window",{{"(Begin/Version)",1,22},{"(Intro)",2,20},{"(General)",3,1},{"w32HChange",4,2},
{"w32HClick",5,3},{"w32HClose",6,4},{"w32HDestroy",7,5},{"w32HEvent",8,6},{"w32HGotFocus",9,7},
{"w32HKeyDown",10,8},{"w32HKeyPress",11,9},{"w32HKeyUp",12,10},{"w32HLostFocus",13,11},{"w32HMouse",14,12},
{"w32HOpen",15,13},{"w32HPaint",16,14},{"w32HScroll",17,15},{"w32HResize",18,16},
{"w32HTimer",19,17},{"w32HActivate",20,18},{"w32HDragAndDrop",21,19},{"w32HAfterEvent",22,23},{"w32HDropDown",23,24},{"w32HMouseTrap",24,26},{"w32HCloseUp",25,25},{"w32HKeyboard",26,27},{"(Final)",27,21}}},

{"Allelse",{{"(Control General)",1,1},{"w32HChange",2,2},
{"w32HClick",3,3},{"w32HClose",4,4},{"w32HDestroy",5,5},{"w32HEvent",6,6},{"w32HGotFocus",7,7},
{"w32HKeyDown",8,8},{"w32HKeyPress",9,9},{"w32HKeyUp",10,10},{"w32HLostFocus",11,11},{"w32HMouse",12,12},
{"w32HOpen",13,13},{"w32HPaint",14,14},{"w32HScroll",15,15},{"w32HResize",16,16},
{"w32HTimer",17,17},{"w32HActivate",18,18},{"w32HDragAndDrop",19,19},{"w32HAfterEvent",20,23},{"w32HDropDown",21,24},{"w32HMouseTrap",22,26},{"w32HCloseUp",23,25},{"w32HKeyboard",24,27}}}
}

--------------------------------------------------------------------------------
global procedure editorUpdateHintsList()
    HintList = HintStandard & HintsExtra
end procedure
--------------------------------------------------------------------------------
global procedure updateKeywords()
sequence data
integer index

--make sure there is an entry for Module in order to color it
    data = synGetSavable()
    index = find("Module",data[1])
    if index then
        if length(otherKeywords) then
            data[2][index] = otherKeywords
        else
            --remove the keywords
            data[2][index] = {}
        end if
        synSetSavableCorrected(data)
    else
        --make sure there is an entry for Module in order to color it
        if length(otherKeywords) then
            synAddWordList("Module",otherKeywords,#FF00FF)
        end if
    end if
end procedure
--------------------------------------------------------------------------------
function verifyClassEventPermitted(sequence testClass, sequence testEvent)

    if not length(testClass)
    or not length(testEvent) then
        return w32True
    end if

    if match("*", testEvent) then
        testEvent = testEvent[1..length(testEvent)-2]
    end if

    if find(testEvent, {"(General)","(Control General)"}) then
        --every class can use general
        return w32True
    end if

    for x=1 to length(tempEventsPerControlClass) do
        if match(lower(tempEventsPerControlClass[x][1]), lower(testClass)) then
            for y=1 to length(tempEventsPerControlClass[x][2]) do
                if match(tempEventsPerControlClass[x][2][y][1], testEvent)
                and tempEventsPerControlClass[x][2][y][2] then
                    return w32True
                end if
            end for
            exit
        end if
    end for
    return w32False
end function
----------------------------------------------------------------
--keep track of current cursor position and display in status bar
procedure onChange_Highlight(integer Self, integer Event, sequence Params)
--Don Phillips code
sequence CurrentLineData
atom Void
atom hMem
integer at, commas

    CursorPos = synGetCursorPos()
    hMem = allocate_string(sprintf("X: %d",{CursorPos[1]}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
    free(hMem)
    hMem = allocate_string(sprintf("Y: %d",{CursorPos[2]}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
    free(hMem)

    if not doingHints then
        return
    end if

    --find out about Hints
    if CursorPos[2]!=HintCurY then
        --if hints are in status bar then remove
        if isChecked(MenuHintsStatus) then
            hMem = allocate_string(" ")
            Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
            free(hMem)
        else
            closeWindow(HintWin)
        end if
        --not on same line anymore
        doingHints = w32False
        return
    elsif CursorPos[1]<HintCurX then
        --if hints are in status bar then remove
        if isChecked(MenuHintsStatus) then
            hMem = allocate_string(" ")
            Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
            free(hMem)
        else
            closeWindow(HintWin)
        end if

        --moved before Hint
        doingHints = w32False
        return
    end if

    if isChecked(MenuHintsStatus) then
        return
    end if

    --ok parse the data entered for the number of commas
    --dummy protection
    if not HintCurX then
        HintCurX = 1
    end if
    CurrentLineData = synGetTextLine(CursorPos[2])
    CurrentLineData = CurrentLineData[HintCurX..CursorPos[1]]
    commas = 0
    at = find(',', CurrentLineData)
    if not at then
        commas = 1
    else
        commas = 1
        while at do
            CurrentLineData = CurrentLineData[at+1..length(CurrentLineData)]
            commas += 1
            at = find(',', CurrentLineData)
        end while
    end if

    if at=length(CurrentLineData) then
        call_proc(modifyTheHint_id,{commas})
    end if

end procedure
setHandler(Highlight, w32HChange, routine_id("onChange_Highlight"))
-------------------------------------------------------------------------------
global function trimR(sequence S)

    if not length(S) then
        return {}
    end if

    for i=length(S) to 1 by -1 do
        if S[i]!=' ' then return S[1..i] end if
    end for
    return {}

end function
-------------------------------------------------------------------------------
global function trimL(sequence S)

    while w32True do
        if not length(S) then
            return {}
        end if

        if S[1]=32
        or S[1]=9 then
            S = S[2..length(S)]
        else
            return S
        end if
    end while
end function
-------------------------------------------------------------------------------
global function findIfHasHeader(sequence text)
integer at

    if not length(text) then
        return 0
    else
        for i=1 to length(text) do
            text[i] = trimL(text[i])
            at = match("procedure", text[i])
            if at=1 then
                return 1
            end if
        end for
    end if

    return 0
end function
--------------------------------------------------------------------------------
sequence eventCaption  eventCaption = {}
global integer CodeEvents
sequence theSelectedItem

include FList.ew

------------------------------------------------------------------------------
global procedure saveChangedCode()
sequence text,shortText,pos,ceName
integer foundIt,hasText, isEvent

    if not editorSelectedControl then
        return
    end if

    if not event then
        return
    end if

    --test if added, changed or removed text
    editorChanged = synGetModified()
    if not editorChanged
    and not doingFind then
        return
    end if

    --Timer and Menu without ! in title can not have code
    if equal(controls[editorSelectedControl][Class], "Timer") then
        return
    end if

    if equal(controls[editorSelectedControl][Class], "Menu")
    and not match("!",controls[editorSelectedControl][Title]) then
        return
    end if

    -- get the current code
    text = synGetAllText()
    hasText = w32False
    if event!=General
    and event!=Begin
    and event!=Intro
    and event!=Final then
        for i=1 to length(text) do
            --check for data and also trim spaces at end of line
            text[i] = trimR(text[i])
            if hasText=w32False then
                if length(text[i]) then
                    if match("procedure", text[i])=1
                    or match("end procedure", text[i])=1
                    or match("setHandler", text[i])=1 then
                        --skip
                    else
                        isEvent = w32False
                        for j=1 to getFLCount(CodeEvents) do
                            theSelectedItem = returnFLItem(CodeEvents, j)
                            shortText = theSelectedItem[1]
                            if match("*",shortText) then
                                shortText = shortText[1..length(shortText)-2]
                            end if
                            shortText = shortText&"["
                            if match(shortText, text[i])=1 then
                                --skip
                                isEvent = w32True
                                exit
                            end if
                        end for
                        if isEvent then
                            --skip
                        else
                            hasText = w32True
                        end if
                    end if
                end if
            end if
        end for
    else
        for i=1 to length(text) do
            text[i] = trimR(text[i])
            if length(text[i]) then
                hasText = w32True
            end if
        end for
    end if

    if not hasText then
        text = {}
    end if

    if editorSelectedControl then
        controls[editorSelectedControl][Code][event] = text
        --save the event in controls for stockEditor
        if hasText then
            controls[editorSelectedControl][LastEditorEvent] = event
        end if
    end if

    if editorChanged
    or not length(text) then
        IDE_Changed = w32True
        --update projectview
        addClassModuleToProjectView(controls[editorSelectedControl], event)
    end if

    if editorChanged
    or not length(text) then
        --update property event list
        call_proc(findCodeForEventList_id,{})
    end if

    editorChanged = w32False

    if length(text) then
        --trap last cursor position for next time this control-event is displayed
        pos = synGetCursorPos()
        foundIt = w32False
        ceName = controls[editorSelectedControl][Name] & Events[event][1]
        if not equal(jumpKey,"Esc") then
                        --when jumpKey = Esc the last modified row might replace the esc jump point                                       
            for i=1 to length(openModuleAt) do
                if equal(ceName, openModuleAt[i][1]) then
                    openModuleAt[i][2] = pos[1]
                    openModuleAt[i][3] = pos[2]
                    openModuleAt[i][4] = synGetTopLine()
                    foundIt = w32True
                    exit
                end if
            end for
            if not foundIt then
                openModuleAt &= {{ceName,pos[1],pos[2],synGetTopLine()}}
            end if
        end if
    end if

end procedure
--------------------------------------------------------------------------------
sequence dashes dashes = "---------------------------------------------------------------"

global procedure buildNewEventCombo()
integer at,k,hasData,header,found
sequence thisControlIndexes,data,text,testClass

    synSetLocalCase(w32False)

    deleteFLItem(CodeEvents, -1)
    editorSelectedControl = getIndex(CodeControls)

    for i=1 to length(controlEventPairing)-1 do
        at = equal(controls[editorSelectedControl][Class], controlEventPairing[i][1])
        if at then
            thisControlIndexes = controlEventPairing[at][2]
            exit
        end if
    end for

    if not at then
        at = length(controlEventPairing)
        thisControlIndexes = controlEventPairing[at][2]
    end if

    if at then
        for j=1 to length(thisControlIndexes) do

            --controlEventPairing is in order of CodeEvents dropdown
            --slot 3 is the actual event for Events and Code[events]

            k = thisControlIndexes[j][3]

            -- get the event name
            text = thisControlIndexes[j][1]

            -- is there code attached?
            header = w32False

            if equal(text, "(General)")
            or equal(text, "(Control General)")
            or equal(text, "(Begin/Version)")
            or equal(text, "(Intro)")
            or equal(text, "(Final)") then
                --use editorSelectedControl instead of selectedControl
                if length(controls[editorSelectedControl][Code][k]) then
                    text &= " *"
                end if
            else
                --use editorSelectedControl instead of selectedControl
                data = controls[editorSelectedControl][Code][k]
                if not length(data) then
                    header = w32False
                else
                    header = findIfHasHeader(data)
                    if header then
                        hasData = w32False
                        for i=1 to length(data) do
                            if match("end procedure", data[i]) then
                                exit
                            end if
                            if length(data[i])
                            and not match("procedure", data[i]) then
                                hasData = w32True
                                exit
                            end if
                        end for
                        if hasData then
                            text &= " *"
                        end if
                    else
                        if length(controls[editorSelectedControl][Code][k])>1 then
                            text &= " *"
                        end if
                    end if
                end if
            end if

            found = w32False
            testClass = {}

            if equal(controls[editorSelectedControl][Class], "Window") then
                testClass = "Window"
            elsif equal(controls[editorSelectedControl][Class], "CWindow") then
                testClass = "CWindow"
            elsif equal(controls[editorSelectedControl][Class], "Timer") then
                testClass = "Timer"
            elsif find(controls[editorSelectedControl][Class], {"Menu","Submenu",
                                                                "Sub2menu","Sub3menu"}) then
                testClass = "Menu"
            elsif find(controls[editorSelectedControl][Class], {"MenuItem","SubmenuItem",
                                                                "Sub2menuItem","Sub3menuItem"}) then
                testClass = "MenuItem"
            elsif find(controls[editorSelectedControl][Class], {"Popup","Subpopup",
                                                                "Sub2popup","Sub3popup"}) then
                testClass = "Popup"
            elsif find(controls[editorSelectedControl][Class], {"PopupItem","SubpopupItem",
                                                                "Sub2popupItem","Sub3popupItem"}) then
                testClass = "PopupItem"
            elsif equal(controls[editorSelectedControl][Class], "TabControl") then
                testClass = "TabControl"
            else
                for x=1 to length(ClassName) do
                    for y=1 to length(ClassName[x]) do
                        if equal(controls[editorSelectedControl][Class],ClassName[x][y]) then
                            testClass = ClassName[x][1]
                            found = w32True
                            exit
                        end if
                    end for
                    if found then
                        exit
                    end if
                end for
            end if

            for x=1 to length(tempEventsPerControlClass) do
                if equal(testClass,tempEventsPerControlClass[x][1]) then
                    for y=1 to length(tempEventsPerControlClass[x][2]) do
                        if match(tempEventsPerControlClass[x][2][y][1],text)
                        and tempEventsPerControlClass[x][2][y][2] then
                            if match("*",text) then
                                addFLItem(CodeEvents, text, {Red,-1,Bold})
                            else
                                addFLItem(CodeEvents, text, {Black,-1,Bold})
                            end if
                            exit
                        end if
                    end for
                    exit
                end if
            end for
        end for

        if editorSelectedControl!=TheWindow then
            if not find(controls[editorSelectedControl][Class],{"TabControl","Group"}) then
                addFLItem(CodeEvents, dashes, Black)
                addFLItem(CodeEvents, controls[TheWindow][Name] & "_General", {Black,-1,Bold})
                if length(controls[editorSelectedControl][SeqParentName])
                and length(controls[editorSelectedControl][SeqParentClass])
                and not find(controls[editorSelectedControl][SeqParentClass],{"Menu","SubMenu","Sub2menu","Sub3menu"}) then
                    addFLItem(CodeEvents, controls[editorSelectedControl][SeqParentName] & "_General", {Black,-1,Bold})
                end if
            end if
        end if
    end if

end procedure
--------------------------------------------------------------------------------
global procedure findNextEvent()
integer foundIt, at, index, found
sequence thisControlIndexes, shortText, testClass

    index = getIndex(CodeControls)
    if index=1 then --Window control
        at = 1
    else
        at = length(controlEventPairing)
    end if

    if not event then
        thisControlIndexes = controlEventPairing[at][2]
        for i=1 to length(thisControlIndexes) do
            if equal(thisControlIndexes[i][1], "w32HClick") then
                event = thisControlIndexes[i][2]    --events as from CodeEvents              
                exit
            end if
        end for
    end if

    --find event based on what is in CodeEvents; if events changes before Controls this gets hit first
    foundIt = w32False
    --if prior event was (Control General) need to compare to (General)
    --and visa versa
    shortText = eventCaption --caption is event from prior event/control

    if equal(controls[index][Class], "Window") then
        if length(shortText)
        and match("(Control General)",shortText) then
            shortText = "(" & shortText[10..length(shortText)]
        end if
    else
        if length(shortText)
        and match("(General)",shortText) then
            shortText = "(Control " & shortText[2..length(shortText)]
        end if
    end if

    for j=1 to length(controlEventPairing)-1 do
        at = equal(controls[index][Class], controlEventPairing[j][1])
        if at then
            thisControlIndexes = controlEventPairing[at][2]
            for i=1 to length(thisControlIndexes) do
                if match("*", shortText) then
                    shortText = shortText[1..length(shortText)-2]
                end if
                if match(thisControlIndexes[i][1], shortText) then
                    found = w32False
                    testClass = {}
                    if equal(controls[index][Class], "Window") then
                        testClass = "Window"
                    elsif equal(controls[index][Class], "CWindow") then
                        testClass = "CWindow"
                    elsif equal(controls[editorSelectedControl][Class], "Timer") then
                        testClass = "Timer"
                    elsif find(controls[editorSelectedControl][Class], {"Menu","Submenu",
                                                                        "Sub2menu","Sub3menu"}) then
                        testClass = "Menu"
                    elsif find(controls[editorSelectedControl][Class], {"MenuItem","SubmenuItem",
                                                                        "Sub2menuItem","Sub3menuItem"}) then
                        testClass = "MenuItem"
                    elsif find(controls[editorSelectedControl][Class], {"Popup","Subpopup",
                                                                        "Sub2popup","Sub3popup"}) then
                        testClass = "Popup"
                    elsif find(controls[editorSelectedControl][Class], {"PopupItem","SubpopupItem",
                                                                        "Sub2popupItem","Sub3popupItem"}) then
                        testClass = "PopupItem"
                    else
                        for x=1 to length(ClassName) do
                            for y=1 to length(ClassName[x]) do
                                if equal(controls[index][Class],ClassName[x][y]) then
                                    testClass = ClassName[x][1]
                                    found = w32True
                                    exit
                                end if
                            end for
                            if found then
                                exit
                            end if
                        end for
                    end if
                    for x=1 to length(tempEventsPerControlClass) do
                        if equal(tempEventsPerControlClass[x][1], testClass) then
                            for y=1 to length(tempEventsPerControlClass[x][2]) do
                                if match(tempEventsPerControlClass[x][2][y][1], shortText)
                                and tempEventsPerControlClass[x][2][y][2] then
                                    event = thisControlIndexes[i][3]    --now event is Events index
                                    foundIt = w32True
                                    exit
                                end if
                            end for
                            exit
                        end if
                        exit
                    end for
                end if
            end for
            if not foundIt then
                --as other controls are split out, need to check here if found the event
                --and if not look for onClick or whatever control is good if onClick isnt
                --need to find onclick?            
                for i=1 to length(thisControlIndexes) do
                    if find(thisControlIndexes[i][1], {"onClick","w32HClick"}) then
                        event = thisControlIndexes[i][3]    --now event is Events index
                        foundIt = w32True
                        exit
                    end if
                end for
            end if
        else
            thisControlIndexes = controlEventPairing[length(controlEventPairing)][2]
            for i=1 to length(thisControlIndexes) do
                if match("*", shortText) then
                    shortText = shortText[1..length(shortText)-2]
                end if
                if equal(thisControlIndexes[i][1], shortText) then
                    event = thisControlIndexes[i][3]    --now is Events index                   
                    found = w32False
                    testClass = {}
                    if equal(controls[index][Class], "Window") then
                        testClass = "Window"
                    elsif equal(controls[index][Class], "CWindow") then
                        testClass = "CWindow"
                    elsif equal(controls[editorSelectedControl][Class], "Timer") then
                        testClass = "Timer"
                    elsif find(controls[editorSelectedControl][Class], {"Menu","Submenu",
                                                                        "Sub2menu","Sub3menu"}) then
                        testClass = "Menu"
                    elsif find(controls[editorSelectedControl][Class], {"MenuItem","SubmenuItem",
                                                                        "Sub2menuItem","Sub3menuItem"}) then
                        testClass = "MenuItem"
                    elsif find(controls[editorSelectedControl][Class], {"Popup","Subpopup",
                                                                        "Sub2popup","Sub3popup"}) then
                        testClass = "Popup"
                    elsif find(controls[editorSelectedControl][Class], {"PopupItem","SubpopupItem",
                                                                        "Sub2popupItem","Sub3popupItem"}) then
                        testClass = "PopupItem"
                    else
                        for x=1 to length(ClassName) do
                            for y=1 to length(ClassName[x]) do
                                if equal(controls[editorSelectedControl][Class],ClassName[x][y]) then
                                    testClass = ClassName[x][1]
                                    found = w32True
                                    exit
                                end if
                            end for
                            if found then
                                exit
                            end if
                        end for
                    end if
                    for x=1 to length(EventsPerControlClass) do
                        if equal(tempEventsPerControlClass[x][1], testClass) then
                            for y=1 to length(tempEventsPerControlClass[x][2]) do
                                if match(tempEventsPerControlClass[x][2][y][1], shortText)
                                and tempEventsPerControlClass[x][2][y][2] then
                                    event = thisControlIndexes[i][3]    --now event is Events index
                                    foundIt = w32True
                                    exit
                                end if
                            end for
                            exit
                        end if
                    end for
                end if
            end for

            if not foundIt then
                --need to find onclick?
                for i=1 to length(thisControlIndexes) do
                    if find(thisControlIndexes[i][1], {"onClick","w32HClick"}) then
                        event = thisControlIndexes[i][3]    --now event is Events index
                        foundIt = w32True
                        exit
                    end if
                end for
            end if
        end if
        if foundIt then
            exit
        end if
    end for
    if not foundIt then
        event = 1 --default to General if can not match to any event
    end if
end procedure
--------------------------------------------------------------------------------
global procedure stockEditor(integer self)  --self is CodeControls or CodeEvents
sequence text,thisControlIndexes, EventsArgList, w32HName, shortText,
             ceName,eventtext,testText,testClass
integer index, at, controlEvent, header,found
atom hMem, Void
integer haveErrorEvent, showTopLine

    setEnable(CodeBaseMenuItemInCodeWin,w32True)
    index = getIndex(CodeControls)
    editorSelectedControl = index

     --user has removed all options for control change behavior so default
    if not isChecked(MenuFirstEvent)
    and not isChecked(MenuLastEvent)
    and not isChecked(MenuThisLastEvent) then
        setCheck(MenuLastEvent, w32True)
    end if
    testText = "w32HClick"

    if self=CodeControls
    and (isChecked(MenuFirstEvent) and not jumpId) then
        --if no event with code start with w32HClick
        event = w32findKey("onClick", Events)
        testText = Events[event][3]
        --if there is an event with code already, start there
        text = {}
        text = controls[editorSelectedControl][Code][22]
        if length(text) then
            event = 22
        end if
        if not length(text) then
            text = controls[editorSelectedControl][Code][20]
            if length(text) then
                event = 20
            end if
        end if
        if not length(text) then
            for i=1 to 19 do
                text = {}
                text = controls[editorSelectedControl][Code][i]
                if length(text) then
                    event = i
                    exit
                end if
            end for
        end if
        if not length(text) then
            for i=23 to 25 do
                text = {}
                text = controls[editorSelectedControl][Code][i]
                if length(text) then
                    event = i
                    exit
                end if
            end for
        end if
        if not length(text) then
            text = controls[editorSelectedControl][Code][21]
            if length(text) then
                event = 21
            end if
        end if
    end if

    if self=CodeControls
    and (isChecked(MenuThisLastEvent) and not jumpId) then
        --if no event with code start with w32HClick
        event = w32findKey("onClick", Events)
        --find last event coded for this control and select it 
        if controls[editorSelectedControl][LastEditorEvent] then
            event = controls[editorSelectedControl][LastEditorEvent]
        end if
    end if

    testText = Events[event][3]
    --check if the controlclass-event is permitted by user 
    --(this could be a project from someone else)
    --since permitted data is by major class when multiples, if this class is an optional
    --class need to find the primary
    found = w32False
    testClass = controls[editorSelectedControl][Class]
    for i=1 to length(ClassName) do
        for j=1 to length(ClassName[i]) do
            if equal(controls[editorSelectedControl][Class], ClassName[i][j]) then
                testClass = ClassName[i][1]
                found = w32True
                exit
            end if
        end for
        if found then
            exit
        end if
    end for

    ok = verifyClassEventPermitted(testClass, testText)
    if not ok then
        ok = displayErrorMessage(249,{})
        showEvent = 1
    end if

    haveErrorEvent = w32False
    if showEvent then
        event = showEvent
    end if

    if errorEvent then
        haveErrorEvent = w32True
        event = errorEvent
        showEvent = errorEvent
    end if

    if find(controls[editorSelectedControl][Class], {"Timer","Menu","TabControl","Group"}) then
        if equal(controls[editorSelectedControl][Class], "Menu")
        and match("!", controls[editorSelectedControl][Title]) then
            --find w32HClick in event               
            event = 3
            if not haveErrorEvent then
                showCol = 0
                showScroll = 2
            end if
        else
            text = {"--NOTE: Input will not be accepted for this control"} & {"end procedure"}
            event = 3
            controls[editorSelectedControl][Code][event] = text
            showCol = 0
            showScroll = 1
        end if
    else
        setFLEnable(CodeEvents, w32True)
    end if

    if equal(controls[editorSelectedControl][Class], "Menu")
    and match("!", controls[editorSelectedControl][Title]) then
        event = 3
        setFLEnable(CodeEvents, w32False)
    end if

    text = controls[editorSelectedControl][Code][event]

    setEnable(MenuEditRoutines, w32False)
    if event=General then
        --general can look at routines
        setEnable(MenuEditRoutines, w32True)
    end if

    if event!=General
    and event!=Begin
    and event!=Intro
    and event!=Final then
        if length(text)=0 then
            -- add end procedure for header
            text = append(text, "")
            text = append(text, "end procedure")
            if not showEvent
            and not errorEvent then
                showCol = 0
                showScroll = 2
                showEvent = w32True
            end if
        else
            if not showEvent
            and not errorEvent then
                --pop cursor at first line
                showCol = 0
                showScroll = 1
                showEvent = w32True
            end if
        end if
    end if

    -- attach procedure header if missing
    if event!=General
    and event!=Begin
    and event!=Intro
    and event!=Final then
        header = findIfHasHeader(text)
        if not header then
            -- header
            --header may be in onXXX or setHandler format
            EventsArgList = Events[event][2]

            EventsArgList = "(integer self, integer event, sequence params)"
            text = prepend(text, "procedure "
                            --use editorSelectedControl instead of selectedControl
                           & controls[editorSelectedControl][Name]
                           & "_"
                           & Events[event][1]       -- event name
                           & " "
                           & EventsArgList
                           & "--params is "
                           & Events[event][2])  -- event arg list            
        end if
    end if

    if event!=General
    and event!=Begin
    and event!=Intro
    and event!=Final then
        if not header then
            w32HName = "w32H"
            for i=3 to length(Events[event][1]) do
                w32HName = append(w32HName, Events[event][1][i])
            end for

            text = append(text, "setHandler( " & controls[editorSelectedControl][Name]
                          & ", " & w32HName
                          & ", routine_id(\""
                          & controls[editorSelectedControl][Name]
                          & "_"
                          & Events[event][1]
                          & "\"))")
        end if
    end if

    --show nothing in StatBar except when ex.err
    if event!=errorEvent then
        hMem = allocate_string(sprintf("%s",{" "}))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
        free(hMem)
    end if

    errorEvent = 0
    controlEvent = 0

    --find the event in controlEventsPairing and translate from Events to
    --the controls event
    at = w32False
    for i=1 to length(controlEventPairing) do
        if equal(controls[editorSelectedControl][Class],
                 controlEventPairing[i][1]) then
            thisControlIndexes = controlEventPairing[i][2]
            for j=1 to length(thisControlIndexes) do
                if event=thisControlIndexes[j][3] then
                    controlEvent = thisControlIndexes[j][2]
                    --however this is true only if control uses all events 
                    --if not need to find the event
                    for x=1 to getFLCount(CodeEvents) do
                        theSelectedItem = returnFLItem(CodeEvents,x)
                        eventtext = theSelectedItem[1]
                        if match("*",eventtext) then
                            eventtext = eventtext[1..length(eventtext)-2]
                        end if
                        if equal(eventtext, thisControlIndexes[j][1]) then
                            controlEvent = x
                            exit
                        end if
                    end for
                    at = w32True
                    exit
                end if
            end for
            if at then
                exit
            end if
        end if
    end for

    if not at then
        thisControlIndexes = controlEventPairing[length(controlEventPairing)][2]
        for j=1 to length(thisControlIndexes) do
            if event=thisControlIndexes[j][3] then
                controlEvent = thisControlIndexes[j][2]
                                        --however this is true only if control uses all events 
                --if not need to find the event
                for x=1 to getFLCount(CodeEvents) do
                    theSelectedItem = returnFLItem(CodeEvents,x)
                    eventtext = theSelectedItem[1]
                    if match("*",eventtext) then
                        eventtext = eventtext[1..length(eventtext)-2]
                    end if
                    if equal(eventtext, thisControlIndexes[j][1]) then
                        controlEvent = x
                        exit
                    end if
                end for
                exit
            end if
        end for
    end if

    if not controlEvent then
        ok = displayErrorMessage(19,{})
        controlEvent = thisControlIndexes[1][2]
    end if

    if find(controls[editorSelectedControl][Class], {"Timer","TabControl","Group"})
    or (equal(controls[editorSelectedControl][Class], {"Menu"})
        and not match("!",controls[editorSelectedControl][Class]))then
        setFLEnable(CodeEvents, w32False)
    end if

    setFLIndex(CodeEvents,controlEvent*-1)

    editorChanged = w32False

    if find(controls[editorSelectedControl][Class], {"Timer","TabControl","Group"})
    or (equal(controls[editorSelectedControl][Class], "Menu")
        and not match("!",controls[editorSelectedControl][Title])) then  --was Class --Josef
        --do nothing with ProjectView
    else
        --highlight entry, if it exists, in Project View
        addClassModuleToProjectView(controls[editorSelectedControl], event)
        findCurrentNode(controls[editorSelectedControl][Name])
    end if

    --pass control+event to syntax
    currentControlEvent = controls[editorSelectedControl][Name] & Events[event][1]

    -- put text in mle
    establishSyntax()
    setEnable(MenuUndo, w32False)--because establishSyntax empties undo buffer

    if length(text) then
        synInsertText(text)
    end if

    if find(controls[editorSelectedControl][Class], {"Timer","Group","TabControl"})
    or (equal(controls[editorSelectedControl][Class], "Menu")
        and not match("!",controls[editorSelectedControl][Title]))then
        controls[editorSelectedControl][Code][event] = {}
    end if

    --give control back to syntax
    setFocusSynInput()

    --establish where the text goes
    --is there a prior cursor position to return to?    
    theSelectedItem = returnFLItem(CodeEvents, 0) --getIndex(CodeEvents))
    shortText = theSelectedItem[1]
    if match("*",shortText) then
        shortText = shortText[1..length(shortText)-2]
    end if
    ceName = getItem(CodeControls, getIndex(CodeControls)) & Events[event][1]
    showTopLine = 0

    if not haveErrorEvent then
        for i=1 to length(openModuleAt) do
            if equal(ceName, openModuleAt[i][1]) then
                showCol = openModuleAt[i][2]
                showScroll = openModuleAt[i][3]
                showTopLine = openModuleAt[i][4]
                showEvent = w32True
                exit
            end if
        end for
    end if

    if showEvent then
        showEvent = 0
        --check text length
        if not length(text) then
            showScroll = 1
            showCol = 0
        elsif showScroll>length(text) then
            showScroll = length(text)
            showCol = 1
        end if
        if showTopLine then
            synGotoTopLine(showTopLine)
        end if
        synMoveCursorAbs(showCol, showScroll)
        hMem = allocate_string(sprintf("X:%d",{showCol}))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
        free(hMem)
        hMem = allocate_string(sprintf("Y:%d",{showScroll}))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
        free(hMem)

        if haveErrorEvent then
            synMoveCursorAbs(0,showScroll)--need to do this for change of X1 to X2 in syntax shiftview
            synHighlightLine(showScroll)
        end if
    else
        synMoveCursorAbs(0,1)
    end if

end procedure
--------------------------------------------------------------------------------
function findActualEvent(integer event)
sequence thisControlIndexes
integer at, k

    for i=1 to length(controlEventPairing)-1 do
        at = equal(controls[editorSelectedControl][Class], controlEventPairing[i][1])
        if at then
            thisControlIndexes = controlEventPairing[at][2]
            exit
        end if
    end for

    if not at then
        at = length(controlEventPairing)
        thisControlIndexes = controlEventPairing[at][2]
    end if

    k = 0
    if at then
        for j=1 to length(thisControlIndexes) do
                        --since Events dropdown may not include all possible events
                        --need to find the index for this event in the sequence which has all events
                        --and change index to that index.
            --controlEventPairing is in order of CodeEvents dropdown
            --slot 3 is the actual event for Events and Code[events]
            theSelectedItem = returnFLItem(CodeEvents, event)
            if equal(thisControlIndexes[j][1], theSelectedItem[1]) then
                k = thisControlIndexes[j][2]
                exit
            end if
        end for
    end if

    return k
end function
-------------------------------------------------------------------------------
global procedure Change_Code(integer Self, integer Event, sequence Params)
sequence testModule

    --close PopupWindow now
    closeWindow(PopupWindow)

    -- handle user selecting a different event or control
    -- this should save the old event code with the control,
    -- and retrieve the existing code (if any)

    if isModuleRoutine then
        testModule = isModule
        if synGetModified() then
            --ask to save what is currently in editor
            if not isChecked(MenuAutoSave) then
                ok = displayErrorMessage(30,{})
                if ok=IDYES then
                    if equal(isModule, "Unidentified.e") then
                        ok = invokeHandler(MenuCodeSaveAs, w32HClick ,{})
                    else
                        call_proc(saveTheModule_id,{0,0,{}})
                    end if
                elsif ok=IDCANCEL then
                    return
                end if
            else
                ok = invokeHandler(MenuCodeSave, w32HClick, {})
            end if
        else
            --we need these so titlebar gets swapped to new text
            isModuleRoutine = w32False
            isModule = {}
        end if
        establishSyntax()

        --remove Unidentified.e in CodeModule combo
        --this gets left there if New Module without data added and user
        --switches to a Control or Event
        if equal(testModule, "Unidentified.e") then
            for i=1 to getCount(CodeModules) do
                if equal(testModule,getItem(CodeModules,i)) then
                    ok = deleteItem(CodeModules,i)
                    ok = deleteItem(PathModules,i)
                    exit
                end if
            end for
            if not getCount(CodeModules) then
                setEnable(CodeModules,w32False)
            else
                --if present Unidentified.e would have been the last entry
                --so we can safely set the new last entry
                setIndex(CodeModules,getCount(CodeModules))
            end if
        end if
        localKeywords = {""}
    end if

    if Self=CodeControls then
        index = getIndex(CodeControls)
        if not index then
            return
        end if
        if find(controls[index][Class],{"SubMenu","Sub2menu","Sub3menu","TabControl","Group"})
        or (equal(controls[index][Class],"Menu")
            and not match("!",controls[index][Title])) then
            setFLEnable(CodeEvents, w32False)
        else
            setFLEnable(CodeEvents, w32True)
        end if
    elsif Self=CodeEvents then
        if not getIndex(CodeControls) then
            setIndex(CodeControls, TheWindow)
        end if
    end if

    if event then
        saveChangedCode()
        theSelectedItem = returnFLItem(CodeEvents, getFLIndex(CodeEvents))--getIndex(CodeEvents))  
        eventCaption = theSelectedItem[1]
    end if

    event = getFLIndex(CodeEvents)

    theSelectedItem = returnFLItem(CodeEvents,getFLIndex(CodeEvents)) --getIndex(CodeEvents)
    if equal(controls[TheWindow][Name] & "_General",theSelectedItem[1]) then
        for k=1 to getFLCount(CodeEvents) do
            theSelectedItem = returnFLItem(CodeEvents,k)
            if match("General",theSelectedItem[1]) then
                setFLIndex(CodeEvents,k*-1)
                Change_Code(CodeEvents,0,{})
                exit
            end if
        end for
        setIndex(CodeControls,TheWindow)
        Change_Code(CodeEvents,0,{})
    end if
    theSelectedItem = returnFLItem(CodeEvents,getFLIndex(CodeEvents)) --getIndex(CodeEvents))       
    if equal(controls[getIndex(CodeControls)][SeqParentName] & "_General",theSelectedItem[1]) then
        setFLIndex(CodeEvents,1*-1)
        Change_Code(CodeEvents,0,{})
        for k=1 to length(controls) do
            if equal(controls[k][Name], controls[getIndex(CodeControls)][SeqParentName]) then
                setIndex(CodeControls,k)
                Change_Code(CodeEvents,0,{})
            end if
        end for
    end if

    editorSelectedControl = getIndex(CodeControls)
    --find the actual file event occurance
    event = findActualEvent(event)

    buildNewEventCombo()
    findNextEvent()
    stockEditor(Self)
    synFileInEditor(w32False)

end procedure
--setHandler(CodeEvents, w32HChange, routine_id("Change_Code"))
setHandler(CodeControls, w32HClick, routine_id("Change_Code"))

procedure CodeEvents_onChange(integer Self, integer Events, sequence Params)
    Change_Code(CodeEvents,w32HChange,{})
end procedure

procedure CodeEvents_onClick(integer Self, integer Events, sequence Params)
--dummy routine to satisfy having onClick handler
    ?"CodeEvents_onClick"
end procedure

integer shortenby
shortenby = 4+statusBar[2]
CodeEvents = FList(CodeWin, {4,4,160,size[4]-shortenby,"",0,0,0,"",8,Normal,
        {0,routine_id("CodeEvents_onChange"),routine_id("CodeEvents_onClick"),
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},1})
--------------------------------------------------------------------------------
include includes\ide_orderEvents.ew              -- indicate which events to use for particular controls

procedure jumpWasFromModuleInstead()
    if not length(EscStack) then
        currentControlEvent = {}
        return
    end if
    EscStackItem = EscStack[1]--get first record which is the latest F1 pt

    jumpName = EscStackItem[1]
    jumpPos1 = EscStackItem[2]
    jumpPos2 = EscStackItem[3]
    jumpTopLine = EscStackItem[4]
    jumpId = EscStackItem[5]
    jumpEvent = EscStackItem[6]
    F1Name = EscStackItem[7]

    ----remove top entry from stack
    EscStack = EscStack[2..length(EscStack)]

    foundIt = w32False
    for y=1 to length(openModuleAt) do
        if equal(jumpName, openModuleAt[y][1]) then
            openModuleAt[y][2] = jumpPos1
            openModuleAt[y][3] = jumpPos2
            openModuleAt[y][4] = jumpTopLine
            foundIt = w32True
            exit
        end if
    end for
    if not foundIt then
        openModuleAt &= {{jumpName,jumpPos1,jumpPos2,jumpTopLine}}
    end if

    adjustEscLineNumber(w32False)
    if jumpId then
        setIndex(CodeControls,jumpId)
        Change_Code(0,0,{})
        for x=1 to getFLCount(CodeEvents) do
            theSelectedItem = returnFLItem(CodeEvents,x)
            if match(theSelectedItem[1],jumpEvent) then
                setFLIndex(CodeEvents,x*-1)
                jumpKey = "Esc"
                Change_Code(CodeEvents,w32HChange,{})
                exit
            end if
        end for
        jumpId = 0      --protect that do not do ESC followed by another ESC on same ESC pt.
        jumpKey = {}
    end if

end procedure
--------------------------------------------------------------------------------
procedure check_jump_rid()
--integer newEscPt
integer foundIt2 foundIt2 = w32False

    if jumpIsToModule then  --jumped from module to module; multiple Esc
        if not length(EscStack) then
            currentControlEvent = {}
            return
        end if
        EscStackItem = EscStack[1]--get first record which is the latest F1 pt
        jumpModule = EscStackItem[7]
        foundIt2 = w32False
        for i=1 to getCount(CodeModules) do
            if equal(getItem(CodeModules,i),jumpModule) then
                foundIt2 = w32True
                jumpToCol = EscStackItem[2]
                jumpToRow = EscStackItem[3]
                F1Name = EscStackItem[7]

                ----remove top entry from stack
                EscStack = EscStack[2..length(EscStack)]

                foundIt = w32False
                for y=1 to length(openModuleAt) do
                    if equal(jumpName, openModuleAt[y][1]) then
                        openModuleAt[y][2] = jumpToCol
                        openModuleAt[y][3] = jumpToRow
                        openModuleAt[y][4] = jumpTopLine
                        foundIt = w32True
                        exit
                    end if
                end for
                if not foundIt then
                    openModuleAt &= {{jumpName,jumpToCol,jumpToRow,jumpTopLine}}
                end if

                adjustEscLineNumber(w32False)
                currentControlEvent = {}
                setIndex(CodeModules, i)
                ok = invokeHandler(CodeModules,w32HChange,{})
                synMoveCursorAbs(jumpToCol,jumpToRow)
                exit
            end if
        end for
        if not foundIt2 then
            jumpWasFromModuleInstead()
        end if
        jumpId = 0      --protect that do not do ESC followed by another ESC on same ESC pt.
        jumpKey = {}

    elsif jumpIsFromModule then     --jumped from C_E pair to module; multiple Esc  

        if not length(EscStack) then
            currentControlEvent = {}
            return
        end if
        EscStackItem = EscStack[1]--get first record which is the latest F1 pt

        jumpName = EscStackItem[1]
        jumpPos1 = EscStackItem[2]
        jumpPos2 = EscStackItem[3]
        jumpTopLine = EscStackItem[4]
        jumpId = EscStackItem[5]
        jumpEvent = EscStackItem[6]
        F1Name = EscStackItem[7]

        ----remove top entry from stack
        EscStack = EscStack[2..length(EscStack)]

        foundIt = w32False
        for y=1 to length(openModuleAt) do
            if equal(jumpName, openModuleAt[y][1]) then
                openModuleAt[y][2] = jumpPos1
                openModuleAt[y][3] = jumpPos2
                openModuleAt[y][4] = jumpTopLine
                foundIt = w32True
                exit
            end if
        end for
        if not foundIt then
            openModuleAt &= {{jumpName,jumpPos1,jumpPos2,jumpTopLine}}
        end if

        adjustEscLineNumber(w32False)
        if jumpId then
            setIndex(CodeControls,jumpId)
            Change_Code(0,0,{})
            for x=1 to getFLCount(CodeEvents) do
                theSelectedItem = returnFLItem(CodeEvents,x)
                if match(theSelectedItem[1],jumpEvent) then
                    setFLIndex(CodeEvents,x*-1)
                    jumpKey = "Esc"
                    Change_Code(CodeEvents,w32HChange,{})
                    exit
                end if
            end for
            jumpId = 0      --protect that do not do ESC followed by another ESC on same ESC pt.
            jumpKey = {}
        end if
    else    --jumped from C_E pair to C_E pair; multiple Esc
        --use the top entry in the Esc Stack
        if not length(EscStack) then
            currentControlEvent = {}
            return
        end if
        EscStackItem = EscStack[1]--get first record which is the latest F1 pt

        jumpName = EscStackItem[1]
        jumpPos1 = EscStackItem[2]
        jumpPos2 = EscStackItem[3]
        jumpTopLine = EscStackItem[4]
        jumpId = EscStackItem[5]
        jumpEvent = EscStackItem[6]
        F1Name = EscStackItem[7]

        ----remove top entry from stack
        EscStack = EscStack[2..length(EscStack)]

        foundIt = w32False
        for y=1 to length(openModuleAt) do
            if equal(jumpName, openModuleAt[y][1]) then
                openModuleAt[y][2] = jumpPos1
                openModuleAt[y][3] = jumpPos2
                openModuleAt[y][4] = jumpTopLine
                foundIt = w32True
                exit
            end if
        end for
        if not foundIt then
            openModuleAt &= {{jumpName,jumpPos1,jumpPos2,jumpTopLine}}
        end if

        adjustEscLineNumber(w32False)
        if jumpId then
            setIndex(CodeControls,jumpId)
--                      Change_Code(0,0,{})                     
            for x=1 to getFLCount(CodeEvents) do
                theSelectedItem = returnFLItem(CodeEvents,x)
                if match(theSelectedItem[1],jumpEvent) then
                    setFLIndex(CodeEvents,x*-1)
                    jumpKey = "Esc"
                    Change_Code(CodeEvents,w32HChange,{})
                    exit
                end if
            end for
            jumpId = 0      --protect that do not do ESC followed by another ESC on same ESC pt.
            jumpKey = {}
        end if
    end if

end procedure
jump_rid = routine_id("check_jump_rid")
--------------------------------------------------------------------------------
constant LB_GETITEMHEIGHT = #01A1,
         LB_GETTOPINDEX  = #018E
integer codeControlsIndex
--------------------------------------------------------------------------------         
procedure RightClick_CodeControls(integer Self, integer Event, sequence Params)
atom flag,height,topindex,indexoffset

    if Params[1]=RightDown then
        height = sendMessage(CodeControls,LB_GETITEMHEIGHT,0,0)
        topindex = sendMessage(CodeControls,LB_GETTOPINDEX,0,0)
        indexoffset = floor(Params[3]/height)
        codeControlsIndex = indexoffset+topindex
        flag = sendMessage(CodeControls,LB_SETCURSEL,codeControlsIndex,0)
        codeControlsIndex += 1
        if codeControlsIndex>getCount(CodeControls) then
            codeControlsIndex = 0
        end if
        popup(popups, Params[2]+borderX,Params[3])--+titleBar+menuBar-(2*borderX))
    end if
end procedure
setHandler(CodeControls, w32HMouse, routine_id("RightClick_CodeControls"))
--------------------------------------------------------------------------------
procedure showEventsForControl(integer Self, integer Event, sequence Params)
sequence name, extent
integer controlnamelength

    controlnamelength = 0
    if not length(isModule) then
        setIndex(CodeControls, codeControlsIndex)
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if
    setText(PopupWindow,IDEText[782][1])    --"Events For:"
    setVisible(PopupDropDown, w32False)
    setVisible(PopupList, w32False)
    setVisible(PopupText, w32False)
    setVisible(PopupSearch, w32False)
    setVisible(PopupSortedList, w32True)
    setVisible(PickedControl, w32True)

    if codeControlsIndex then
        setText(PickedControl, controls[codeControlsIndex][Name])
        eraseItems(PopupSortedList)
        for i=1 to getFLCount(CodeEvents) do
            theSelectedItem = returnFLItem(CodeEvents,i)
            if match("*",theSelectedItem[1]) then
                --name=returnFLItem(CodeEvents,i)
                --name=name[1..length(name)-2]
                name = theSelectedItem[1][1..length(theSelectedItem[1])-2]
                addItem(PopupSortedList, name)
                if length(name)>controlnamelength then
                    controlnamelength = length(name)
                end if
            end if
        end for
        extent = getTextExtent(PopupSortedList, "M")
        controlnamelength *= extent[1]
        ok = sendMessage(PopupSortedList, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
        if getCount(PopupSortedList) then
            openWindow(PopupWindow, Normal)
        else
            ok = displayErrorMessage(169,{})    --"There are no other events with code for this control."
        end if
    else
        ok = displayErrorMessage(183,{})    --"Please click a control for this option"
    end if
end procedure
setHandler(popup1, w32HClick, routine_id("showEventsForControl"))
--------------------------------------------------------------------------------
procedure showSortedControls(integer Self, integer Event, sequence Params)
sequence extent
integer controlnamelength

    controlnamelength = 0
    setText(PopupWindow,IDEText[1029][1])   --"Sorted Controls"
    setText(PickedControl,"")
    setVisible(PopupDropDown, w32False)
    setVisible(PopupList, w32False)
    setVisible(PickedControl, w32True)
    setVisible(PopupSortedList, w32True)
    setVisible(PopupText, w32True)
    setVisible(PopupSearch, w32True)
    setText(PopupSearch,"")

    eraseItems(PopupSortedList)
    for i=1 to getCount(CodeControls) do
        addItem(PopupSortedList, getItem(CodeControls,i))
        if length(getItem(CodeControls,i))>controlnamelength then
            controlnamelength = length(getItem(CodeControls,i))
        end if
    end for
    extent = getTextExtent(PopupSortedList, "M")
    controlnamelength *= extent[1]
    ok = sendMessage(PopupSortedList, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    if getCount(PopupSortedList) then
        openWindow(PopupWindow, Normal)
    else
        ok = displayErrorMessage(184,{})    --"There are no controls in Code Editor."
    end if
end procedure
setHandler(popup2, w32HClick, routine_id("showSortedControls"))
--------------------------------------------------------------------------------
procedure changeSortedToNormal(integer Self, integer Event, sequence Params)
sequence item
    item = getItem(PopupSortedList, getIndex(PopupSortedList))
    for i=1 to getCount(CodeControls) do
        if equal(getItem(CodeControls,i), item) then
            setIndex(CodeControls, i)
            ok = invokeHandler(CodeControls, w32HClick, {0,0,{}})
            return
        end if
    end for
    for i=1 to getFLCount(CodeEvents) do
        theSelectedItem = returnFLItem(CodeEvents,i)
        if equal(theSelectedItem[1], item & " *") then
            setFLIndex(CodeEvents, i*-1)
            --ok=invokeHandler(CodeEvents, w32HChange, {0,0,{}})
            Change_Code(CodeEvents,w32HChange,{})
            exit
        end if
    end for
end procedure
setHandler(PopupSortedList, w32HChange, routine_id("changeSortedToNormal"))
--------------------------------------------------------------------------------
procedure showWindowControls(integer Self, integer Event, sequence Params)
    setText(PopupWindow,IDEText[1030][1])   --"Window Controls"     
    setVisible(PickedControl, w32False)
    setVisible(PopupSortedList, w32False)
    setVisible(PopupList, w32True)
    setVisible(PopupDropDown, w32True)
    setVisible(PopupText, w32True)
    setVisible(PopupSearch, w32True)

    setText(PopupSearch,"")
    if selectedWindow then
        windows[selectedWindow] = controls
    end if
    --set windows names in dropdown
    eraseItems(PopupDropDown)
    for i=1 to length(windows) do
        if i!=selectedWindow then
            addItem(PopupDropDown, windows[i][1][Name])
        end if
    end for
    eraseItems(PopupSortedList)
    eraseItems(PopupList)
    if getCount(PopupDropDown) then
        openWindow(PopupWindow, Normal)
    else
        ok = displayErrorMessage(185,{})--"There are no other windows in this project."         
        return
    end if
    setIndex(PopupDropDown, 1)
    setVisible(PickedControl, w32False)
    setVisible(PopupDropDown, w32True)
end procedure
setHandler(popup3, w32HClick, routine_id("showWindowControls"))
--------------------------------------------------------------------------------
procedure selectedWindowFromDropDown(integer Self, integer Event, sequence Params)
integer index, controlnamelength
sequence item, extent

    controlnamelength = 0

    index = getIndex(PopupDropDown)
    item = getItem(PopupDropDown, index)

    for i=1 to length(windows) do
        if equal(windows[i][1][Name],item) then
            index = i
            exit
        end if
    end for

    if isVisible(PopupList) then
        for i=1 to length(windows[index]) do
            addItem(PopupList,windows[index][i][Name])
            if length(windows[index][i][Name])>controlnamelength then
                controlnamelength = length(windows[index][i][Name])
            end if
        end for
        if not getCount(PopupList) then
            ok = displayErrorMessage(186,{})    --"There are no controls in window."
            return
        end if
        extent = getTextExtent(PopupList, "M")
        controlnamelength *= extent[1]
        ok = sendMessage(PopupList, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    else
        for i=1 to length(windows[index]) do
            addItem(PopupSortedList,windows[index][i][Name])
            if length(windows[index][i][Name])>controlnamelength then
                controlnamelength = length(windows[index][i][Name])
            end if
        end for
        if not getCount(PopupSortedList) then
            ok = displayErrorMessage(186,{})    --"There are no controls in window."                    
            return
        end if
        extent = getTextExtent(PopupSortedList, "M")
        controlnamelength *= extent[1]
        ok = sendMessage(PopupSortedList, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    end if
    openWindow(PopupWindow, Normal)
end procedure
setHandler(PopupDropDown, w32HChange, routine_id("selectedWindowFromDropDown"))
--------------------------------------------------------------------------------
procedure showSortedWindowControls(integer Self, integer Event, sequence Params)

    setText(PopupWindow,IDEText[1031][1])--"Sorted Window Controls"
    setVisible(PickedControl, w32False)
    setVisible(PopupList, w32False)
    setVisible(PopupSortedList, w32True)
    setVisible(PopupDropDown, w32True)
    setVisible(PopupText, w32True)
    setVisible(PopupSearch, w32True)

    setText(PopupSearch,"")
    --set windows names in dropdown
    if selectedWindow then
        windows[selectedWindow] = controls
    end if
    eraseItems(PopupDropDown)
    for i=1 to length(windows) do
        if i!=selectedWindow then
            addItem(PopupDropDown, windows[i][1][Name])
        end if
    end for
    eraseItems(PopupSortedList)
    eraseItems(PopupList)
    if getCount(PopupDropDown) then
        openWindow(PopupWindow, Normal)
    else
        ok = displayErrorMessage(185,{})--"There are no other windows in this project."         
        return
    end if
    setIndex(PopupDropDown, 1)
    setVisible(PickedControl, w32False)
    setVisible(PopupDropDown, w32True)
end procedure
setHandler(popup4, w32HClick, routine_id("showSortedWindowControls"))
--------------------------------------------------------------------------------
procedure findSearch(integer Self, integer Event, sequence Params)
    if isVisible(PopupSortedList) then
        for i=1 to getCount(PopupSortedList) do
            if length(getText(PopupSearch)) then
                if match(lower(getText(PopupSearch)), lower(getItem(PopupSortedList, i))) then
                    setIndex(PopupSortedList, i)
                    exit
                end if
            end if
        end for
    else
        for i=1 to getCount(PopupList) do
            if length(getText(PopupSearch)) then
                if match(lower(getText(PopupSearch)), lower(getItem(PopupList, i))) then
                    setIndex(PopupList, i)
                    exit
                end if
            end if
        end for
    end if
end procedure
setHandler(PopupSearch, w32HChange, routine_id("findSearch"))
--------------------------------------------------------------------------------
procedure resizePopupWindow(integer Self, integer Event, sequence Params)
sequence listRect, listSize, clientPopup

    listRect = getRect(PopupList)
    clientPopup = getClientRect(PopupWindow)
    setRect(PopupList, listRect[1], listRect[2], clientPopup[3], clientPopup[4]-40, w32True)
    setRect(PopupSortedList, listRect[1], listRect[2], clientPopup[3], clientPopup[4]-40, w32True)
    listSize = getCtlSize(PopupList)
    setRect(PopupText, listRect[1], listRect[2]+listSize[2], 44, 20, w32True)
    setRect(PopupSearch, 44, listRect[2]+listSize[2], clientPopup[3]-44, 20, w32True)
end procedure
setHandler(PopupWindow, w32HResize, routine_id("resizePopupWindow"))
----------------------------------------------------------------------------
procedure Change_Code_Editor()
    setIndex(CodeControls, editorSelectedControl)
    saveChangedCode()
    eventCaption = returnFLItem(CodeEvents,getFLIndex(CodeEvents))--getIndex(CodeEvents))
end procedure
syntaxCallCE_id = routine_id("Change_Code_Editor")
-----------------------------------------------------------------------------
global procedure forceCursor(integer x, integer y)
atom hMem,Void
    --called from ide.exw
    synMoveCursorAbs(x,y)
    hMem = allocate_string(sprintf("X:%d",{x}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
    free(hMem)
    hMem = allocate_string(sprintf("Y:%d",{y}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
    free(hMem)
    setFocus(Highlight)
end procedure
----------------------------------------------------------------------------
procedure Change_Module(integer Self, integer Event, sequence Params)
sequence path, module, priorModule

    priorModule = {}
    if isModuleRoutine then
        priorModule = isModule
    end if

    --get name from dropdown
    module = getItem(CodeModules, getIndex(CodeModules))
    path = getItem(PathModules, getIndex(CodeModules))
    if length(path) then
        if not equal("\\",path[length(path)]) then
            path &= "\\"
        end if
    end if
    haveFileName = path & module

    ok = invokeHandler(MenuCodeOpen, w32HClick, {})
    if length(haveFileName) then
        --User canceled save the module
        haveFileName = ""
        if length(priorModule) then
            for i=1 to getCount(CodeModules) do
                if equal(priorModule,getItem(CodeModules,i)) then
                    setIndex(CodeModules,i)
                    exit
                end if
            end for
        end if
    end if
end procedure
setHandler(CodeModules, w32HChange, routine_id("Change_Module"))
-----------------------------------------------------------------------------
procedure Resize_CodeWin(integer Self, integer Event, sequence Params)
--resize the editor to fit screen
integer style, cx, cy
integer ok
sequence size, size1
atom Void
atom hMem

    style   = Params[1]
    cx      = Params[2]
    cy      = Params[3]

    --move the event combo towards edge
    size = getClientRect(CodeWin)
    shortenby = 4+statusBar[2]
    setFLHeight(CodeEvents, size[4]-shortenby)
    setRect(CodeModules, size[3]-160-5, 4, 160, size[4]-4, w32True)
    if schoochOn then
        setRect(CodeControls, -100, -100, 100, size[4]-30, w32False)
        setRect(SchoochButton,2, 50, 7, size[4]-80, w32True)
    else
        setRect(CodeControls,0,30,100,size[4]-30,w32True)
        setRect(SchoochButton, 102,50,7,size[4]-80,w32True)
    end if

    --Don Phillips code
    --resize StatBar
    hMem = allocate(12)
    poke4(hMem, {size[3]-150, size[3]-75,-1})
    Void = w32Func(xSendMessage, {getHandle(StatBar), SB_SETPARTS,3,hMem})
    free(hMem)

    if style=SIZE_MINIMIZED then
        if not isChecked(Code_R1)               --if not always maximize when open
        and not isChecked(Code_R2) then --and not left IDE when maximized
            CodeWinWasMaxed = w32False
        end if

        doingHints = w32False
        closeWindow(HintWin)
        closeWindow(WinCodeBase)
        closeWindow(PopupWindow)
        if not length(isModule) then
            setIndex(CodeControls, editorSelectedControl)
            ok = invokeHandler(CodeControls,w32HClick,{})
        end if
    else
        if style=SIZE_MAXIMIZED then
            CodeWinWasMaxed = w32True
            CodeWinWasOpened = w32True
        else
            if not isChecked(Code_R1)               --if not always maximize
            and not isChecked(Code_R2) then --and not left IDE when maximized
                CodeWinWasMaxed = w32False
            end if
            CodeWinWasOpened = w32True
        end if
        --resize the hint to fit window
        size = getRect(HintWin)
        size1 = getRelRect(CodeWin, Screen)--getPosition( CodeWin )

        if length(hintLoc) then
            setPenPos(HintWin, hintLoc[1],hintLoc[2])
        else
            setRect(HintWin, size1[1], size1[2]+titleBar, cx-10, size[4]-size[2], w32True)
        end if
    end if
    size = getClientRect(CodeWin)
    if schoochOn then
        synSetRect(style, 10, 30, size[3]-10,size[4]-30)
    else
        synSetRect(style, 110, 30, size[3]-110, size[4]-30)
    end if
end procedure
setHandler(CodeWin, w32HResize, routine_id("Resize_CodeWin"))
--------------------------------------------------------------------------------
procedure click_SchoochButton(integer self,integer event,sequence params)
sequence size

    if schoochOn then
        schoochOn = w32False
    else
        schoochOn = w32True
    end if
    size = getCtlSize(CodeWin)
    Resize_CodeWin(CodeWin,w32HResize,{SIZE_RESTORED,size[1],size[2]})
end procedure
setHandler(SchoochButton,w32HClick,routine_id("click_SchoochButton"))
--------------------------------------------------------------------------------
procedure CodeWin_gotfocus(integer self,integer event,sequence params)
    if validId(Highlight) then
        if length(Actual) then
            CursorPos = synGetCursorPos()
            synMoveCursorAbs(CursorPos[1], CursorPos[2])
        end if
        setFocus(Highlight)
    end if
end procedure
setHandler(CodeWin, w32HGotFocus, routine_id("CodeWin_gotfocus"))
--------------------------------------------------------------------------------
procedure CodeWin_lostfocus(integer self,integer event,sequence params)
    CursorPos = synGetCursorPos()
end procedure
setHandler(CodeWin, w32HLostFocus, routine_id("CodeWin_lostfocus"))
------------------------------------------------------------------------------
global procedure openCodeWinStuff()
integer handle, controlnamelength
integer at, foundIt,index
object data1
sequence path, openFolder, extent, data, test

--check for changes to Module Routines (from adding a new module to project)
--so have words to colorize.
    data = synGetSavable()
    index = find("Module",data[1])
    if index then
        if length(otherKeywords) then
            if length(otherKeywords[1]) then
                data[2][index] = otherKeywords
            end if
        else
            --remove the keywords
            data[2][index] = {}
        end if

        --if i had modified synSetSavable and the file read to have GET_SUCCESS
        --in read, the Paint gets goofy...
        synSetSavableCorrected(data)
    else
        --make sure there is an entry for Module in order to color it
        if length(otherKeywords) then
            if length(otherKeywords[1]) then
                synAddWordList("Module",otherKeywords,#FF00FF)
            end if
        end if
    end if

    --set openFolder for module saveAs but if user changes after CodeWin open
    --saving configurations will reset it also in IDE_proj.ew
    if isChecked(CB_WantDefault)
    and length(getText(EditPrjDef)) then
        openFolder = getText(EditPrjDef)
    else
        openFolder = projectDir
    end if

    synSetCurrentFolder(openFolder)

    -- populate the controls combo box,
    -- load the onClick code
    -- load the include modules

    --check that there is not a module loaded
    editorChanged = w32False
    if isModuleRoutine then
        editorChanged = synGetModified()
    end if

    if isModuleRoutine
    and editorChanged then
        ok = displayErrorMessage(34,{})

        if ok=IDYES then
            if equal(isModule, "Unidentified.e") then
                ok = invokeHandler(MenuCodeSaveAs, w32HClick,{})
            else
                call_proc(saveTheModule_id,{0,0,{}})
            end if
        end if
    end if

    CodeWinOpen = w32True
    CodeWinWasOpened = w32True  --this tells us codewin was ever opened
    setEnable(MenuEditRoutines, w32False)
    editorChanged = w32False
    eraseItems(CodeControls)
    --set up for control and event
    controlnamelength = 0
    for i=1 to length(controls) do
        -- get the event name
        -- add the control name to the list

        --win32lib version .55 can not load zero length Name
        if not length(controls[i][Name]) then
            controls[i][Name] = " "
        end if

        addItem(CodeControls, controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    VOID = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    setIndex(CodeControls, TheWindow)

    --set up modules list
    eraseItems(CodeModules)
    eraseItems(PathModules)
    for i=1 to length(includeModules) do
        --file name may or may not have path; this is legal
        test = reverse(includeModules[i][1])
        at = match("\\", test)
        if at then
            test = test[1..at-1]
            test = reverse(test)
            addItem(CodeModules, test)
            path = includeModules[i][3]
            if path[length(path)]!='\\' then
                path = includeModules[i][3] & "\\"
            end if
            addItem(PathModules, path)
        else
            addItem(CodeModules, includeModules[i][1])
            addItem(PathModules, includeModules[i][3] & "\\")
        end if
    end for

    if not getCount(CodeModules) then
        setEnable(CodeModules, w32False)
    else
        setIndex(CodeModules, 1)
        setEnable(CodeModules, w32True)
    end if

    --open and load module
    isModuleRoutine = w32False

    if length(isModule)
    and not equal(isModule, "Unidentified.e") then
        isModuleRoutine = w32True
        moduleData = {}
        moduleRoutineLine = {}
        recordCnt = 0
        setEnable(MenuEditRoutines, w32True)

        --add path to module
        for i=1 to length(includeModules) do
            --includeModules may or may not have path; this is legal
            if match(isModule, includeModules[i][1])
            or match(includeModules[i][1],isModule) then
                if not match("\\",isModule) then
                    --attach path
                    isModule = includeModules[i][3] & "\\" & isModule
                end if
                exit
            end if
        end for

        handle = open(isModule, "r")

        if handle= -1 then
            ok = displayErrorMessage(31,{isModule})
            isModule = ""
            isModuleRoutine = w32False

            setEnable(MenuEditRoutines, w32False)

            editorSelectedControl = selectedControl

            -- default is selected item    
            setIndex(CodeControls, editorSelectedControl)

            return
        end if

        --remove path if came from ex.err but keep for save
        isModule = reverse(isModule)
        at = match("\\", isModule)
        if at then
            modulePath = isModule[at..length(isModule)] --was at+1
            isModule = isModule[1..at-1]
        end if
        isModule = reverse(isModule)
        modulePath = reverse(modulePath)

        --find module name in CodeModules and highlight it
        foundIt = w32False
        for i=1 to getCount(CodeModules) do
            if equal(isModule, getItem(CodeModules,i)) then
                setIndex(CodeModules, i)
                foundIt = w32True
                exit
            end if
        end for

        if not foundIt then
            --came from ex.err module not loaded into includes for project?
            addItem(CodeModules, isModule)
            addItem(PathModules, modulePath)
            setIndex(CodeModules, getCount(CodeModules))
        end if

        while w32True do
            data1 = gets(handle)
            if atom(data1) then
                --eof
                exit
            end if
            -- remove line feed        
            if data1[length(data1)]='\n' then
                data1 = data1[1..length(data1)-1]
            end if

            moduleData = append(moduleData, data1)
            recordCnt += 1

        end while
        close(handle)

        --be sure no event to jump to
        if errorEvent then
            synLoadFile(getItem(PathModules,getIndex(CodeModules)) &
                        getItem(CodeModules,getIndex(CodeModules)))
        end if

        --pass to syntax that file is in editor
        synFileInEditor(w32True)

        --put data in editor
        establishSyntax()
        synInsertText(moduleData)

        if errorEvent then
            synMoveCursorAbs(showCol, showScroll)
            synHighlightLine(showScroll)
        else
            synMoveCursorAbs(0, 1)
        end if
        return
    end if

    -- default is selected item
    setIndex(CodeControls, editorSelectedControl)
    moveZOrder(CodeWin, HWND_TOP)
end procedure
--------------------------------------------------------------------------------
sequence moduleBuffer
-------------------------------------------------------------------------------- 
function findIfValidLine(sequence line,sequence jumpToKeyword, integer linecnt)
integer wordat,commentat,cnt,at
    wordat = match(jumpToKeyword,line)
    commentat = match("--",line)
    if commentat then
        line = line[1..commentat-1]
    end if
    line = w32trim(line)
    if length(line) then
        wordat = match("procedure", line)
        if wordat then
            return w32True
        end if
        wordat = match("function",line)
        if wordat then
            return w32True
        end if
        --if didn't find procedure or function maybe on prior line?
        cnt = 0
        for k=linecnt-1 to 1 by -1 do
            commentat = match("--",moduleBuffer[k])
            if commentat then
                moduleBuffer[k] = moduleBuffer[k][1..commentat-1]
            end if
            at = match("global", moduleBuffer[k])
            if at then
                moduleBuffer[k] = moduleBuffer[k][1..at-1] &
                                  moduleBuffer[k][at+6..length(moduleBuffer[k])]
            end if
            at = match("export", moduleBuffer[k])
            if at then
                moduleBuffer[k] = moduleBuffer[k][1..at-1] &
                                  moduleBuffer[k][at+6..length(moduleBuffer[k])]
            end if
            moduleBuffer[k] = w32trim(moduleBuffer[k])
            if length(moduleBuffer[k]) then
                cnt += 1
            end if
            if cnt>1 then
                exit
            end if
            if match("procedure",moduleBuffer[k])
            and length(moduleBuffer[k])<10 then
                return w32True
            elsif match("function",moduleBuffer[k])
              and length(moduleBuffer[k])<9 then
                return w32True
            end if
        end for
        return w32False
    end if
    return w32False
end function
--------------------------------------------------------------------------------
function jumpToFileAndRoutine(sequence jumpToFilename,sequence jumpToKeyword)
integer handle,linecnt,at
object line
sequence fname

    moduleBuffer = {}
    --read file and parse for keyword, counting lines as we go
    handle = open(jumpToFilename, "r")
    if handle= -1 then
        return w32False
    end if
    linecnt = 0
    while w32True do
        line = gets(handle)
        if atom(line) then
            exit
        end if

        moduleBuffer &= {line}
        linecnt += 1

        if match(jumpToKeyword, line) then
            ok = findIfValidLine(line,jumpToKeyword,linecnt)
            jumpIsFromModule = w32True

            if ok then
                fname = reverse(jumpToFilename)
                at = match("\\",fname)
                if at then
                    fname = fname[1..at-1]
                end if
                fname = reverse(fname)
                at = match(jumpToKeyword,line)
                for i=1 to getCount(CodeModules) do
                    if equal(fname, getItem(CodeModules,i)) then
                        setIndex(CodeModules,i)
                        ok = invokeHandler(CodeModules, w32HChange, {})
                        synMoveCursorAbs(at,linecnt)
                        close(handle)
                        return w32True
                    end if
                end for
            end if
        end if
    end while
    close(handle)
    return w32False
end function
------------------------------------------------------------------------------
procedure F1CallBack(object Word)
    call_proc(HelpHtml_id,{Word})
end procedure
--------------------------------------------------------------------------------
integer matchedWord
--------------------------------------------------------------------------------
procedure lookForRoutineNames(object Word)
sequence pos,ceName,possibleline,text
integer foundIt,commentat,wordat,linect,cnt,at

    matchedWord = w32False

    if (length(localKeywords)
        or length(ceKeywords))
    and (find(Word, localKeywords)
         or find(Word,ceKeywords)) then
        if not isModuleRoutine then
            pos = synGetCursorPos()

            --what we want to do first is verify where we clicked F1 is not the routine definition line
            --(it has the word procedure or function in front of it)


            --if we are in controls-events then
            Change_Code(CodeEvents,w32HChange,{})   --save current control-event in case user has just coded routine
                                                        --reference but has not changed event or control which would "save"     

            --first check current control-event for routine name preceeded by function or procedure
            --if we find it we ignore because we want to find where press F1 on use of the routine not its 
            --declaration
            if pos[2]>length(controls[editorSelectedControl][Code][event]) then
                --this can happen when we F1 from a module instead of control-event
                pos[2] = length(controls[editorSelectedControl][Code][event])
            end if

            if pos[2] then
                possibleline = controls[editorSelectedControl][Code][event][pos[2]]
            end if

            --Look for routine definition   
            foundIt = w32False
            commentat = match(Word, possibleline)
            if commentat then
                if length(possibleline)>commentat+length(Word)-1 then
                    --make sure word is whole word or followed by (
                    if possibleline[commentat+length(Word)]=32
                    or possibleline[commentat+length(Word)]='(' then
                        if commentat>1 then
                            if possibleline[commentat-1]=32 then
                                                        --looks like good routne                                                        
                            else
                                commentat = w32False
                            end if
                        end if
                        --looks like good routine
                    else
                        commentat = w32False
                    end if
                end if
            end if

            if commentat then
                --check not comment and has function or procedure in text                               
                wordat = match("procedure",possibleline)
                if wordat then
                    foundIt = w32True
                else
                    wordat = match("function",possibleline)
                    if wordat then
                        foundIt = w32True
                    end if
                end if
                if foundIt
                and wordat<commentat then
                    return  --do not F1 a line with procedure and function
                end if
            end if
            if commentat
            and not foundIt then
                --maybe procedure or function is on a prior line
                cnt = 0
                --go back 1 active line looking for procedure or function after ignoring
                --comments
                --what we have to watch out for is:
                --procedure what(....)
                --followed by our routine
                text = controls[editorSelectedControl][Code][event]
                for k=pos[2]-1 to 1 by -1 do
                    at = match("--",text[k])
                    if at then
                        text[k] = text[k][1..at-1]
                    end if
                    at = match("global", text[k])
                    if at then
                        text[k] = text[k][1..at-1] &
                                  text[k][at+6..length(text[k])]
                    end if
                    at = match("export", text[k])
                    if at then
                        text[k] = text[k][1..at-1] &
                                  text[k][at+6..length(text[k])]
                    end if
                    text[k] = w32trim(text[k])
                    if length(text[k]) then
                        cnt += 1
                    end if
                    if cnt>1 then
                        --can't find procedure or function so F1 is ok to use
                        exit
                    end if
                    if match("end procedure",text[k]) then
                                        --is ok
                    elsif match("end function",text[k]) then
                                        --is ok                                                 
                    elsif match("procedure",text[k])
                      and length(text[k])<10 then
                        --not ok                                
                        return
                    elsif match("function",text[k])
                      and length(text[k])<9 then
                        --not ok                                
                        return
                    end if
                end for
            end if

            --now look for routine declaration in other control-events              
            for j=1 to length(controls) do
                for k=1 to length(controls[j][Code]) do
                    linect = 0
                    text = controls[j][Code][k]
                    for x=1 to length(controls[j][Code][k]) do
                        possibleline = controls[j][Code][k][x]
                        linect += 1
                        foundIt = w32False
                        wordat = match(Word,possibleline)
                        if wordat then
                            --check for whole word or followed by (
                            if length(possibleline)>wordat+length(Word)-1 then
                                if possibleline[wordat+length(Word)]=32
                                or possibleline[wordat+length(Word)]='(' then
                                    if wordat>1 then
                                        if possibleline[wordat-1]=32 then
                                                                        --good word
                                        else
                                            wordat = w32False
                                        end if
                                    end if
                                else
                                    wordat = w32False
                                end if
                            end if
                        end if
                        if wordat then
                            --check not comment and has function or procedure in text
                            commentat = match("--",possibleline)
                            if commentat
                            and commentat<wordat then
                                                --do nothing
                            else
                                wordat = match("procedure",possibleline)
                                if wordat then
                                    foundIt = w32True
                                else
                                    wordat = match("function",possibleline)
                                    if wordat then
                                        foundIt = w32True
                                    end if
                                end if
                                if not foundIt then
                                    cnt = 0
                                    --if didn't find procedure or function maybe on prior line?	
                                    for m=x-1 to 1 by -1 do
                                        at = match("--",text[m])
                                        if at then
                                            text[m] = text[m][1..at-1]
                                        end if
                                        at = match("global", text[m])
                                        if at then
                                            text[m] = text[m][1..at-1] &
                                                      text[m][at+6..length(text[m])]
                                        end if
                                        at = match("export", text[m])
                                        if at then
                                            text[m] = text[m][1..at-1] &
                                                      text[m][at+6..length(text[m])]
                                        end if
                                        text[m] = w32trim(text[m])
                                        if length(text[m]) then
                                            cnt += 1
                                        end if
                                        if cnt>1 then
                                            --can't find procedure or function so is not definition																																			
                                            return
                                        end if
                                        if match("procedure",text[m])
                                        and length(text[m])<10 then
                                            --is ok
                                            foundIt = w32True
                                            exit
                                        elsif match("function",text[m])
                                          and length(text[m])<9 then
                                            --is ok
                                            foundIt = w32True
                                            exit
                                        end if
                                    end for
                                end if

                                if foundIt then
                                    --trap last cursor position for next time this control-event is displayed
                                    --via ESC key                                                   
                                    foundIt = w32False
                                    ceName = controls[editorSelectedControl][Name] & Events[event][1]
                                    wordat = match(Word,possibleline)
                                    --store location where we pressed F1 in temporary vars which will
                                    --be used in check_jump_rid to place in the openModuleAt array                                                                                                                
                                    jumpName = ceName
                                    jumpPos1 = pos[1]--col
                                    jumpPos2 = pos[2]--line
                                    jumpTopLine = synGetTopLine()
                                    --set up ESC jump information                                           
                                    jumpId = editorSelectedControl
                                    jumpEvent = returnFLItem(CodeEvents,getFLIndex(CodeEvents))--getIndex(CodeEvents))
                                    --add jump stuff to ESC stack
                                    EscStackItem[1] = jumpName      --where routine used (when press F1)                                                    
                                    EscStackItem[2] = jumpPos1
                                    EscStackItem[3] = jumpPos2
                                    EscStackItem[4] = jumpTopLine
                                    EscStackItem[5] = jumpId
                                    EscStackItem[6] = jumpEvent[1]

                                    --set up jump to routine definition
                                    editorSelectedControl = j
                                    event = k
                                    ceName = controls[j][Name] & Events[k][1]
                                    --trap coding from controls-event                                                               
                                    wordat = match(Word,possibleline)
                                    if equal("F1",jumpKey) then
                                        F1Name = ceName
                                        EscStackItem[7] = F1Name    --where routine is defined      
                                        EscStack = {EscStackItem} & EscStack
                                        foundIt = w32False
                                        for y=1 to length(openModuleAt) do
                                            if equal(ceName, openModuleAt[y][1]) then
                                                openModuleAt[y][2] = wordat
                                                openModuleAt[y][3] = x
                                                openModuleAt[y][4] = synGetTopLine()
                                                foundIt = w32True
                                                exit
                                            end if
                                        end for
                                        if not foundIt then
                                            openModuleAt &= {{ceName,wordat,x,synGetTopLine()}}
                                        end if
                                        adjustEscLineNumber(w32False)
                                        currentControlEvent = {}
                                        if equal(jumpName,F1Name) then
                                            adjustEscLineNumber(w32True)
                                            currentControlEvent = jumpName
                                            --useEscLineNumber(pos[2])--the line where F1 is pressed
                                        end if
                                    end if

                                    jumpIsFromModule = w32False
                                    showEvent = k
                                    showCol = 1
                                    showScroll = 1
                                    selectedControl = j
                                    adjustEscLineNumber(w32False)
                                    ok = invokeHandler(PopUpDesign_CodeEditor,w32HClick,{})
                                    currentControlEvent = {}
                                    if equal(jumpName,F1Name) then
                                        currentControlEvent = jumpName
                                        adjustEscLineNumber(w32True)
                                    end if
                                    matchedWord = w32True
                                    return
                                end if
                            end if
                        end if
                    end for
                end for
            end for
        end if

        if matchedWord then
            return
        end if
    end if

    matchedWord = w32False
    --word that was F1 on is a routine in a module
    if length(jumpToKeywords) then
        for i=1 to length(jumpToKeywords) do
            for j=1 to length(jumpToKeywords[i][2]) do
                if equal(Word,jumpToKeywords[i][2][j]) then

                    pos = synGetCursorPos()
                    --need to check this line in EDITOR text and see if has 
                    --procedure or function before Word
                    text = synGetAllText()
                    wordat = match(Word,text[pos[2]])
                    if wordat then
                        if length(text)>wordat+length(Word)-1 then
                            if text[pos[2]][wordat+length(Word)]=32
                            or text[pos[2]][wordat+length(Word)]='(' then
                                if wordat>1 then
                                    if text[pos[2]][wordat-1]=32 then
                                                                        --good word
                                    else
                                        wordat = w32False
                                    end if
                                end if
                            else
                                wordat = w32False
                            end if
                        end if
                    end if
                    if wordat then
                        commentat = match("procedure", text[pos[2]])
                        if not commentat then
                            commentat = match("function", text[pos[2]])
                        end if
                        if commentat
                        and commentat<wordat then
                            --can not use F1 on procedure or function line                                                                          
                            return
                        end if
                        if not commentat then
                            --maybe procedure or function is on a prior line
                            cnt = 0
                            --go back 1 active line looking for procedure or function after ignoring
                            --comments
                            --what we have to watch out for is:
                            --procedure what(....)
                            --followed by our routine
                            for k=pos[2]-1 to 1 by -1 do
                                at = match("--",text[k])
                                if at then
                                    text[k] = text[k][1..at-1]
                                end if
                                at = match("global", text[k])
                                if at then
                                    text[k] = text[k][1..at-1] &
                                              text[k][at+6..length(text[k])]
                                end if
                                at = match("export", text[k])
                                if at then
                                    text[k] = text[k][1..at-1] &
                                              text[k][at+6..length(text[k])]
                                end if
                                text[k] = w32trim(text[k])
                                if length(text[k]) then
                                    cnt += 1
                                end if
                                if cnt>1 then
                                    --can't find procedure or function so F1 is ok to use
                                    exit
                                end if
                                if match("procedure",text[k])
                                and length(text[k])<10 then
                                    --not ok                                                                
                                    return
                                elsif match("function",text[k])
                                  and length(text[k])<9 then
                                    --not ok                                                                
                                    return
                                end if
                            end for
                        end if
                    end if

                    if not isModuleRoutine then     --c-e to module

                        saveChangedCode()
                        --trap last cursor position for next time this control-event is displayed
                        --via ESC key                                                   
                        ceName = controls[editorSelectedControl][Name] & Events[event][1]
                        --store location where we pressed F1 in temporary vars which will
                        --be used in check_jump_rid to place in the openModuleAt array                                                                                                                
                        jumpName = ceName
                        jumpPos1 = pos[1]--col
                        jumpPos2 = pos[2]--line
                        jumpTopLine = synGetTopLine()
                        --set up ESC jump information                                           
                        jumpId = editorSelectedControl
                        jumpEvent = returnFLItem(CodeEvents,0)--getIndex(CodeEvents))
                        --add jump stuff to ESC stack
                        EscStackItem[1] = jumpName
                        EscStackItem[2] = jumpPos1
                        EscStackItem[3] = jumpPos2
                        EscStackItem[4] = jumpTopLine
                        EscStackItem[5] = jumpId
                        EscStackItem[6] = jumpEvent[1]

                        --set up jump to routine definition                                     
                        if equal("F1",jumpKey) then
                            F1Name = isModule
                            EscStackItem[7] = isModule
                            EscStack = {EscStackItem} & EscStack
                        end if
                    end if

                    jumpIsToModule = w32False
                    jumpModule = {}
                                --if we came from a module and wish to jump to a routine in another module or same module then:                 
                    if isModuleRoutine then
                        jumpIsToModule = w32True
                        jumpToCol = pos[1]
                        jumpToRow = pos[2]

                        adjustEscLineNumber(w32False)
                        currentControlEvent = {}
                        jumpModule = getItem(CodeModules,getIndex(CodeModules))
                        --trap last cursor position for next time this module is displayed
                        --via ESC key                                                                                                                                                   
                        --store location where we pressed F1 in temporary vars which will
                        --be used in check_jump_rid to place in the openModuleAt array                                                                                                                
                        jumpName = jumpModule
                        jumpPos1 = pos[1]--col
                        jumpPos2 = pos[2]--line
                        jumpTopLine = synGetTopLine()

                        --add jump stuff to ESC stack
                        EscStackItem[1] = jumpName
                        EscStackItem[2] = jumpPos1
                        EscStackItem[3] = jumpPos2
                        EscStackItem[4] = jumpTopLine
                        EscStackItem[5] = 0     --place holder
                        EscStackItem[6] = {}        --place holder

                        --set up jump to routine definition                                     
                        if equal("F1",jumpKey) then
                            if equal(jumpToKeywords[i][1],isModule) then
                                adjustEscLineNumber(w32True)
                                currentControlEvent = isModule
                            end if
                            EscStackItem[7] = isModule
                            EscStack = {EscStackItem} & EscStack
                        end if
                    end if
                    --ok now go to the routine                      
                    foundIt = jumpToFileAndRoutine(jumpToKeywords[i][1],jumpToKeywords[i][2][j])
                    if foundIt then
                        matchedWord = w32True
                        return
                    end if
                end if
            end for
        end for
    end if

end procedure
-----------------------------------------------------------------------------
procedure displayHint(sequence hint)
sequence size, size1, size2

    setIndex(RichHint,{1,0})
    --per Derek: selecting Index first will allow putStream to replace data
    putStream(RichHint, StreamRTF, hint)

    size = getRelRect(CodeWin, Screen)
    size1 = getCtlSize(HintWin)
    size2 = getRect(HintWin)

    if length(hintLoc) then
        setPenPos(HintWin, hintLoc[1],hintLoc[2])
        setRect(HintWin, hintLoc[1],hintLoc[2], size1[1], size1[2], w32True)
    else
        setRect(HintWin, size[1], size[2]+titleBar, size1[1], size1[2], w32True)
    end if

    openWindow(HintWin, Normal)
    setFocus(Highlight)

end procedure
--------------------------------------------------------------------------
procedure buildTheHint(sequence hintWord, integer index)
sequence hint, args, pos, hintInStatus
atom hMem, Void
integer RGB, iTBlue, iTRed, iTGreen, iPBlue, iPRed, iPGreen

    --get hintcolor from synMain2.ini
    hintColors = synGetAutoSavable()
    setWindowBackColor(HintWin, Black)  --shows a Black 'grab handle'
    Void = w32Func(xSendMessage, {getHandle(RichHint),1091,0,hintColors[3][8]})
            -- (1091) EM_SETBKGNDCOLOR

    --break down hintcolor into red, green and blue
    --text color
    RGB = hintColors[3][9]
    iTBlue = floor(RGB/65536)
    iTRed = RGB-(iTBlue*65536)
    iTGreen = floor(iTRed/256)
    iTRed = iTRed-(iTGreen*256)

    --param color
    RGB = hintColors[3][10]
    iPBlue = floor(RGB/65536)
    iPRed = RGB-(iPBlue*65536)
    iPGreen = floor(iPRed/256)
    iPRed = iPRed-(iPGreen*256)

    hint=
    "{\\rtf1\\ansi\\deff0\\deftab720{\\fonttbl{\\f0\\fswiss MS Sans Serif;}"
    & "{\\f1\\froman\\fcharset2 Symbol;}{\\f2\\fmodern Courier New;}"
    & "{\\f3\\fswiss\\fprq2 MS Sans Serif;}"
    & "{\\f4\\fnil\\fcharset0 Times New Roman;}}"

    colorTable = sprintf("{\\colortbl;\\red%d\\green%d\\blue%d;\\red%d\\green%d\\blue%d;}",
                         {iTRed, iTGreen, iTBlue, iPRed, iPGreen, iPBlue})
    hint &= colorTable

            & "\\deflang1033\\pard"
            & "\\plain\\f4\\fs20\\cf1" --default text color

    hint &= HintList[index+2] & " " & hintWord & "("
    hintInStatus = HintList[index+2] & " " & hintWord & "("
    args = HintList[index+1]
    for i=1 to length(args) do
        if i=1 then
            hint &= "\\plain\\f4\\fs20\\cf2"
           --make it colored
        else
            --default color
            hint &= "\\plain\\f4\\fs20\\cf1"
        end if

        hint &= args[i] & "\\plain\\f4\\fs20\\cf1" & ","
        hintInStatus &= args[i] & ","
    end for

    if hint[length(hint)]!='(' then
        hint = hint[1..length(hint)-1]
    end if
    if not equal(hintInStatus[length(hintInStatus)],"(") then
        hintInStatus = hintInStatus[1..length(hintInStatus)-1]
    end if

    --default color
    hint &= "\\plain\\f4\\fs20\\cf1"
    hint &= ")"
    hintInStatus &= ")"
    HintWord = hintWord
    HintText = hint
    HintIndex = index
    --flag want to be looking at hints
    doingHints = w32True
    --store the current cursor pos
    pos = synGetCursorPos()
    HintCurY = pos[2]
    HintCurX = pos[1]

    --where does hint go?
    if isChecked(MenuHintsStatus) then
        --put hints only in status bar
        hMem = allocate_string(hintInStatus)
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
        free(hMem)
    else
        displayHint(hint)
    end if

end procedure
--------------------------------------------------------------------------
procedure modifyTheHint(integer commas)
sequence hint, args

    hint=
    "{\\rtf1\\ansi\\deff0\\deftab720{\\fonttbl{\\f0\\fswiss MS Sans Serif;}"
    & "{\\f1\\froman\\fcharset2 Symbol;}{\\f2\\fmodern Courier New;}"
    & "{\\f3\\fswiss\\fprq2 MS Sans Serif;}"
    & "{\\f4\\fnil\\fcharset0 Times New Roman;}}"
    & colorTable
    & "\\deflang1033\\pard"
    & "\\plain\\f4\\fs20\\cf1" --default text color

    hint &= HintList[HintIndex+2] & " " & HintList[HintIndex] & "("

    args = HintList[HintIndex+1]

    for i=1 to length(args) do
        --build the hint colors
        --use default text color except when the hint arg is active
        --then use arg color
        if commas=i then
            hint &= "\\plain\\f4\\fs20\\cf2"
            --make it colored
        else
            --default color
            hint &= "\\plain\\f4\\fs20\\cf1"
        end if
        hint &= args[i] & "\\plain\\f4\\fs20\\cf1" & ","
    end for
    if hint[length(hint)]!='(' then
        hint = hint[1..length(hint)-1]
    end if
    hint &= ")"

    displayHint(hint)
end procedure
modifyTheHint_id    = routine_id("modifyTheHint")
---------------------------------------------------------------------------
procedure Resize_Hint(integer Self, integer Event, sequence Params)
    --resize the RichEdit
    setRect(RichHint, 0, 0, Params[2]-20, Params[3], w32True)
    setFocus(Highlight)
end procedure
setHandler(HintWin, w32HResize, routine_id("Resize_Hint"))

----------------------------------------------------------------------------
procedure Event_Hint(integer Self, integer Event, sequence Params)
integer HitTest

--Don Phillips: to move the Hint window
    if Params[1]=#84 then -- WM_NCHITTEST
        HitTest = w32Func(xDefWindowProc, {getHandle(Self),Params[1],Params[2],Params[3]})
        if HitTest=1 then -- 1 = HTCLIENT
            returnValue(2) -- HTCAPTION
        end if
        setFocus(Highlight)
        hintLoc = getPosition(HintWin)
    end if
end procedure
setHandler(HintWin, w32HEvent, routine_id("Event_Hint"))
----------------------------------------------------------------------------
procedure Event_RichHint(integer Self, integer Event, sequence Params)
    --suggestion of Don Phillips from Topica to hide cursor
    if Params[1]=WM_SETFOCUS then
        returnValue(1)
    end if
end procedure
setHandler(RichHint, w32HEvent, routine_id("Event_RichHint"))
----------------------------------------------------------------------------
-- hint call back
procedure HintCallBack(object Word)
integer index
atom hMem, Void

    index = 0
    if sequence(Word) then
    --make sure Word is a valid Hint by looking in HintList
        for i=1 to length(HintList) by 3 do
            if equal(Word, HintList[i]) then
                index = i
                exit
            end if
        end for

        --save hint word in case user presses Ctrl+Space
        HintWord = Word

        if index
        and isChecked(MenuIgnoreHints) then
            buildTheHint(Word, index)
        end if
    else
        if Word=0 then
            -- ')' entered
            doingHints = w32False
            closeWindow(HintWin)
            if MenuHintsStatus then
                --remove hints in status bar
                hMem = allocate_string(" ")
                Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
                free(hMem)
            end if
        elsif Word=2
          and length(HintWord) then
            --Ctrl+space
            for i=1 to length(HintList) by 3 do
                if equal(HintWord, HintList[i]) then
                    index = i
                    exit
                end if
            end for
            buildTheHint(HintWord, index)
        end if
    end if
end procedure
----------------------------------------------------------------------------
global procedure Open_CodeWin(integer Self, integer Event, sequence Params)
atom Void
atom hMem
sequence Rect, dataPerControl, Data
integer hFile

--Don Phillips code
--set status bar initial position values
    Rect = getClientRect(CodeWin)
    hMem = allocate(12)
    poke4(hMem, {Rect[3]-150,Rect[3]-75, -1})
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETPARTS,3,hMem})
    free(hMem)
    --end Don

    synRestoreINIFile("\\Files\\OtherC.ini")

    --set F1 call back
    synSetF1CallBack(routine_id("F1CallBack"))

    --set hint callback
    synSetHintCallBack(routine_id("HintCallBack"))
    -- end Don

    exiting = w32False

    if translateNow then
        call_proc(translateCodeWin_id,{})
    end if

    CodeWinExists = w32True

    openCodeWinStuff()

    --build initial list
    for i=1 to length(ControlList) do
        dataPerControl = {{}, {}}
        if i=1 then
            dataPerControl[1] = "Window"
        else
            dataPerControl[1] = ControlList[i][4]
        end if
        dataPerControl[2] = repeat({{},0},length(Events))
        for j=1 to length(Events) do
            dataPerControl[2][j][1] = Events[j][3]
            if not equal(dataPerControl[1],"Window")
            and equal(dataPerControl[2][j][1],"(General)") then
                dataPerControl[2][j][1] = "(Control General)"
            end if
            dataPerControl[2][j][2] = w32True
        end for
        EventsPerControlClass &= {dataPerControl}
    end for
    --add Timer, Menu, MenuItem, Popup and PopupItem classes
    for i=1 to 5 do
        dataPerControl = {{}, {}}
        if i=1 then
            dataPerControl[1] = "Timer"
        elsif i=2 then
            dataPerControl[1] = "Menu"
        elsif i=3 then
            dataPerControl[1] = "MenuItem"
        elsif i=4 then
            dataPerControl[1] = "Popup"
        elsif i=5 then
            dataPerControl[1] = "PopupItem"
        end if
        dataPerControl[2] = repeat({{},0},length(Events))
        for j=1 to length(Events) do
            dataPerControl[2][j][1] = Events[j][3]
            if equal(dataPerControl[2][j][1],"(General)") then
                dataPerControl[2][j][1] = "(Control General)"
            end if
            dataPerControl[2][j][2] = w32True
        end for
        EventsPerControlClass &= {dataPerControl}
    end for

    -- update with events per Control file data
    tempEventsPerControlClass = {}
    hFile = open(the_current_dir & "\\Files\\Eventclass.dat" , "r")
    if hFile!= -1 then
        Data = get(hFile)
        close(hFile)
        if Data[1]=GET_SUCCESS then
            tempEventsPerControlClass = Data[2]
        end if
    end if

    --this list gets updated with user selections
    --the reason I do not just plop the input file onto top of EventsPerControlClass is
    --I may have added controls or events since user last wrote his file. So I use the
    --defaults established above and overlay only the matches by class
    if length(tempEventsPerControlClass) then
        for i=1 to length(tempEventsPerControlClass) do
            for j=1 to length(EventsPerControlClass) do
                --match control                         
                if equal(tempEventsPerControlClass[i][1],EventsPerControlClass[j][1]) then
                    --match event name
                    for k=1 to length(tempEventsPerControlClass[i][2]) do
                        for m=1 to length(EventsPerControlClass[j][2]) do
                            EventsPerControlClass[i][2][k][2] = w32False
                            if equal(tempEventsPerControlClass[i][2][k][1],
                                     EventsPerControlClass[i][2][m][1]) then
                                EventsPerControlClass[i][2][k][2] = tempEventsPerControlClass[i][2][m][2]
                                exit
                            end if
                        end for
                    end for
                    exit
                end if
            end for
        end for
    end if
    tempEventsPerControlClass = EventsPerControlClass

end procedure
setHandler(CodeWin, w32HOpen, routine_id("Open_CodeWin"))
-------------------------------------------------------------------------------
procedure Activate_CodeWin(integer Self, integer Event, sequence Params)
    hideTheGutter(isChecked(MenuHideGutter))
    setFocus(Highlight)
end procedure
setHandler(CodeWin, w32HActivate, routine_id("Activate_CodeWin"))
-------------------------------------------------------------------------------
global procedure closeCodeWinStuff()
integer ok
atom hMem, Void

-- save code
    if isModuleRoutine then
        ok = invokeHandler(MenuCodeClose,w32HClick,{})
        if abortClose then
            abortClose = w32False
            isModuleRoutine = w32True
            showWindow(CodeWin,SW_NORMAL)
            return
        end if
    else
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if

    stopMouse = w32False

    --Don Phillips code
    hMem = allocate_string(sprintf("%s",{" "}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
    free(hMem)

    CodeWinOpen = w32False

    ok = chdir(projectDir)

    --close Hints if still open
    doingHints = w32False
    --save Hint Window location
    hintLoc = getPosition(HintWin)
    if validId(HintWin) then
        closeWindow(HintWin)
    end if

    if validId(PopupWindow) then
        closeWindow(PopupWindow)
    end if

    closeWindow(TabWindow1)

    if cameFromMenuEditor then
        cameFromMenuEditor = w32False
        ok = invokeHandler(MenuMenuEditor,w32HClick,{})
    end if
    if cameFromPopupEditor then
        cameFromPopupEditor = w32False
        ok = invokeHandler(MenuPopupEditor,w32HClick,{})
    end if
    if cameFromTimerEditor then
        cameFromTimerEditor = w32False
        ok = invokeHandler(MenuTimerEditor,w32HClick,{})
    end if

end procedure
----------------------------------------------------------------------------
global procedure Close_CodeWin(integer Self, integer Event, sequence Params)
sequence data,size
integer index

    size = getCtlSize(CodeWin)
    codeLastSize = {0,0,0}
    codeLastSize[1] = size[1]
    codeLastSize[2] = size[2]
    if isMaximized(CodeWin) then
        codeLastSize[3] = 1
    end if
    if not closedUp then
        --closing code editor but not IDE
        showWindow(CodeWin,SW_HIDE)
        closeCodeWinStuff()
        returnValue(1)
        return
    end if

    data = synGetSavable()
    index = find("Module",data[1])
    if index then
        data[2][index] = {}
        synSetSavableCorrected(data)
    end if

    synSaveINIFile("\\Files\\OtherC.ini")  --Don Phillip's syntax

    exiting = w32True
    closeCodeWinStuff()

end procedure
setHandler(CodeWin, w32HClose, routine_id("Close_CodeWin"))
----------------------------------------------------------------------------
function findWinlibLinks(sequence winlibDocs)
integer handle,at,endat
object line
sequence buffer,link,keyword,result,data

    data = {"",""}

    handle = open(winlibDocs,"r")
    if handle= -1 then
        return {}
    end if

    buffer = {}
    while 1 do
        line = gets(handle)
        if atom(line) then
            exit
        end if
        buffer = append(buffer, line)
    end while
    close(handle)

    result = {}
    for i=1 to length(buffer) do
        buffer[i] = trimL(buffer[i])
        while w32True do
            at = find(' ', buffer[i])
            if not at then
                exit
            end if
            buffer[i] = buffer[i][1..at-1] & buffer[i][at+1..length(buffer[i])]
        end while
        link = {}
        keyword = {}
        at = match("<ahref=",buffer[i])
        if at then
            buffer[i] = buffer[i][at..length(buffer[i])]
            endat = match(">",buffer[i])
            if endat then
                link = buffer[i][9..endat-2]
                buffer[i] = buffer[i][endat+1..length(buffer[i])]
            end if
        end if
        if length(link) then
            at = match("<",buffer[i])
            if at then
                keyword = buffer[i][1..at-1]
            end if
        end if
        if length(keyword) then
            data[1] = keyword
            data[2] = link
            result &= {data}
        end if
    end for

    if not length(result) then
        return {}
    else
        return result
    end if
end function
-----------------------------------------------------------------------------
sequence link link = {}

procedure helpHtml(object word)
--Thanks to Dan Moyer and Kat for redirecting html
sequence helpDocs,goDocs,DummyFirst,DummyLast, data
integer handle, win32libIndex, libraryIndex, builtinsIndex, keywordsIndex, at
integer version

    if atom(word) then
        return
    end if

    if length(word) then
        jumpKey = "F1"
        lookForRoutineNames(word)
        if matchedWord then
            return
        end if
    end if

    --now get the catagories (win32lib, keywords, builtins, library) which
    --key word might be in
    data = synGetSavable()

    win32libIndex = find("Win32lib", data[1])
    if not win32libIndex then
        ok = displayErrorMessage(190,{"win32lib"})
        return
    end if
    win32lib = data[2][win32libIndex]

    libraryIndex = find("Library", data[1])
    if not libraryIndex then
        ok = displayErrorMessage(190,{"library"})
        return
    end if
    library = data[2][libraryIndex]

    builtinsIndex = find("Builtins", data[1])
    if not builtinsIndex then
        ok = displayErrorMessage(190,{"builtins"})
        return
    end if
    builtins = data[2][builtinsIndex]

    keywordsIndex = find("Keywords", data[1])
    if not keywordsIndex then
        ok = displayErrorMessage(190,{"keywords"})
        return
    end if
    keywords = data[2][keywordsIndex]

    if length(word) then
        --if word is on the win32lib list then search users
        --copy of win32lib.html links otherwise search RDS Library.html
        --links

        if find(upper(word), upper(win32lib)) then
            helpDocs = Win32libDocs
            if not length(helpDocs) then
                ok = displayErrorMessage(16,{})
                return
            end if
            --which version of win32lib is being used?
            version = (Win32LibVersion[1]*10000)+(Win32LibVersion[2]*100)+Win32LibVersion[3]
            if version<5710 then
                DummyFirst = "<html>\n<head>\n<meta http-equiv=refresh"
                             & " content=\"0;\nurl=file:///" & helpDocs
                goDocs = "#" & word
            elsif version>5804 then
                if not length(link) then
                    link = findWinlibLinks(helpDocs)
                end if
                goDocs = word
                for i=1 to length(link) do
                    if equal(word, link[i][1]) then
                        goDocs = link[i][2]
                        exit
                    end if
                end for
                helpDocs = reverse(helpDocs)
                at = find('\\', helpDocs)
                if at then
                    helpDocs = helpDocs[at..length(helpDocs)]
                end if
                helpDocs = reverse(helpDocs)
                DummyFirst = "<html>\n<head>\n<meta http-equiv=refresh"
                             & " content=\"0;\nurl=file:///" & helpDocs
            else
                --remove htm file name
                helpDocs = reverse(helpDocs)
                at = find('\\', helpDocs)
                if at then
                    helpDocs = helpDocs[at..length(helpDocs)]
                end if
                helpDocs = reverse(helpDocs)
                DummyFirst = "<html>\n<head>\n<meta http-equiv=refresh"
                             & " content=\"0;\nurl=file:///" & helpDocs
                goDocs = append("win32lib_", word[1])
                goDocs &= ".htm#"
                goDocs &= word
            end if
        --Roland Stowasser enhancement
        else
            helpDocs = whereEu
            helpDocs &= "/html"
            DummyFirst = "<html>\n<head>\n<meta http-equiv=refresh"
                         & " content=\"0;\nurl=file:///" & helpDocs --& "/"

            if find(word, keywords) then
                goDocs = "/refman_2.htm#"
                if equal(word, "and")
                or equal(word, "not")
                or equal(word, "or")
                or equal(word, "xor") then
                    goDocs &= "24"    --look at status bar when finding in Refman_htm
                elsif equal(word, "by")
                   or equal(word, "for")
                   or equal(word, "to") then
                    goDocs &= "for"
                elsif equal(word, "else")
                   or equal(word, "elsif")
                   or equal(word, "if")
                   or equal(word, "then") then
                    goDocs &= "if"
                elsif equal(word, "do")
                   or equal(word, "end") then
                    goDocs &= "5"
                elsif equal(word, "with")
                   or equal(word, "without") then
                    goDocs &= "62"
                elsif equal(word, "constant") then
                    goDocs &= "415"
                elsif equal(word, "exit") then
                    goDocs &= "exit"
                elsif equal(word, "function") then
                    goDocs &= "412"
                elsif equal(word, "global") then
                    goDocs &= "42"
                elsif equal(word, "include") then
                    goDocs &= "61"
                elsif equal(word, "procedure") then
                    goDocs &= "411"
                elsif equal(word, "return") then
                    goDocs &= "return"
                elsif equal(word, "type") then
                    goDocs &= "43"
                elsif equal(word, "while") then
                    goDocs &= "while"
                end if
            --end Roland enhancement

            elsif find(word, builtins)
               or find(word, library) then

                if equal(word, "int") then
                    word = "integer"
                end if
                if equal(word, "seq") then
                    word = "sequence"
                end if

                if equal(word[1..3],"db_") then
                    --added by Roland Stowasser
                    goDocs = "/database.htm#" & word
                elsif word[1]>='a' and word[1]<='b' then
                    goDocs = "/lib_a_b.htm#" & word
                elsif word[1]>='c' and word[1]<='d' then
                    goDocs = "/lib_c_d.htm#" & word
                elsif word[1]>='e' and word[1]<='g' then
                    goDocs = "/lib_e_g.htm#" & word
                elsif word[1]>='h' and word[1]<='o' then
                    goDocs = "/lib_h_o.htm#" & word
                elsif word[1]>='p' and word[1]<='r' then
                    goDocs = "/lib_p_r.htm#" & word
                elsif word[1]>='s' and word[1]<='t' then
                    goDocs = "/lib_s_t.htm#" & word
                elsif word[1]>='u' and word[1]<='z' then
                    goDocs = "/lib_u_z.htm#" & word
                end if
            else
                -- general help on language
                goDocs = "/refman_2.htm"
            end if
        end if

        DummyLast  = "\">\n</head>\n</html>"

        handle = open("redirect.htm", "w")
        puts(handle, DummyFirst & goDocs & DummyLast)
        close(handle)

        -- EXECUTE THE HTML REDIRECT FILE:
        shellExecute("open","redirect.htm",SW_SHOWNORMAL)

    end if
end procedure
HelpHtml_id = routine_id("helpHtml")
-----------------------------------------------------------------------------
procedure findAllRoutines(sequence data)
sequence routineName, moduleLine
integer at

    moduleLine = {"",0}

    data = trimL(data)
    data = trimR(data)

    if getFromNextLine then
        routineName = data[1..length(data)]
        at = match("(",routineName)
        if at then
            routineName = routineName[1..at-1]
            routineName = trimR(routineName)
        end if
        addItem(AllRoutines, routineName)
        moduleLine[1] = routineName
        moduleLine[2] = recordCnt-1
        moduleRoutineLine &= {moduleLine}
        getFromNextLine = w32False
    end if

    if match("procedure", data)
    or match("function", data)
    or match("global procedure", data)
    or match("global function", data)
    or match("export procedure", data)
    or match("export function", data) then
        if match("global procedure", data)=1
        or match("export procedure", data)=1 then
            if length(data)>17 then
                routineName = data[18..length(data)]
                routineName = trimL(routineName)
                at = match("(",routineName)
                if at then
                    routineName = routineName[1..at-1]
                    routineName = trimR(routineName)
                end if
                addItem(AllRoutines, routineName)
                moduleLine[1] = routineName
                moduleLine[2] = recordCnt
                moduleRoutineLine &= {moduleLine}
                getFromNextLine = w32False
            else
                getFromNextLine = w32True
            end if
        elsif match("global function", data)=1
           or match("export function", data)=1 then
            if length(data)>16 then
                routineName = data[17..length(data)]
                routineName = trimL(routineName)
                at = match("(",routineName)
                if at then
                    routineName = routineName[1..at-1]
                    routineName = trimR(routineName)
                end if
                addItem(AllRoutines, routineName)
                moduleLine[1] = routineName
                moduleLine[2] = recordCnt
                moduleRoutineLine &= {moduleLine}
                getFromNextLine = w32False
            else
                getFromNextLine = w32True
            end if
        elsif match("procedure", data)=1 then
            if length(data)>10 then
                routineName = data[11..length(data)]
                routineName = trimL(routineName)
                at = match("(",routineName)
                if at then
                    routineName = routineName[1..at-1]
                    routineName = trimR(routineName)
                end if
                addItem(AllRoutines, routineName)
                moduleLine[1] = routineName
                moduleLine[2] = recordCnt
                moduleRoutineLine &= {moduleLine}
                getFromNextLine = w32False
            else
                getFromNextLine = w32True
            end if
        elsif match("function", data)=1 then
            if length(data)>9 then
                routineName = data[10..length(data)]
                routineName = trimL(routineName)
                at = match("(",routineName)
                if at then
                    routineName = routineName[1..at-1]
                    routineName = trimR(routineName)
                end if
                addItem(AllRoutines, routineName)
                moduleLine[1] = routineName
                moduleLine[2] = recordCnt
                moduleRoutineLine &= {moduleLine}
                getFromNextLine = w32False
            else
                getFromNextLine = w32True
            end if
        end if
    end if
end procedure
findAllRoutines_id = routine_id("findAllRoutines")
-----------------------------------------------------------------------------
procedure open_Keys(integer Self, integer Event, sequence Params)
    setText(LText2, "Ctrl+A"
            & {13,10} & "Ctrl+B"
            & {13,10} & "Ctrl+C"
            & {13,10} & "Ctrl+D"
            & {13,10} & "Ctrl+F"
            & {13,10} & "Ctrl+G"
            & {13,10} & "Ctrl+O"
            & {13,10} & "Ctrl+S"
            & {13,10} & "Ctrl+V"
            & {13,10} & "Ctrl+X"
            & {13,10} & "Ctrl+Z"
            & {13,10} & "F1"
            & {13,10} & "F3"
            & {13,10} & "ESC"
            & {13,10} & "F4"
            & {13,10} & "F5"
            & {13,10} & "F6"
            & {13,10} & "Keyboard Keys"
            & {13,10} & "Ctrl+space"
           )
    setText(LText3, "Select All"
            & {13,10} & "Block Indent"
            & {13,10} & "Copy"
            & {13,10} & "Block Comment"
            & {13,10} & "Find/Replace"
            & {13,10} & "Find/Replace"
            & {13,10} & "GoTo Line"
            & {13,10} & "Open File"
            & {13,10} & "Save(As) File"
            & {13,10} & "Paste"
            & {13,10} & "Cut"
            & {13,10} & "UnDo"
            & {13,10} & "Documentation on Word"
            & {13,10} & "Find Next"
            & {13,10} & "Replace With"
            & {13,10} & "Generate Program"
            & {13,10} & "Generate Temporary Program"
            & {13,10} & "Various functions"
            & {13,10} & "Show Hint"
           )
end procedure
-------------------------------------------------------------------------
procedure click_ButClose(integer Self, integer Event, sequence Params)
    if validId(KeysCodeWin) then
        destroy(KeysCodeWin)
    end if
    KeysCodeWin = -1
end procedure
------------------------------------------------------------------------
procedure createKeysCodeWin()
    if KeysCodeWin= -1 then
                                            --"Control Keys"
        KeysCodeWin = createEx(Window, IDEText[471][1], CodeWin, Default, Default, 331, 389, {WS_DLGFRAME}, 0)
                                                    --"Close"
        ButClose    = createEx(DefPushButton, IDEText[472][1], KeysCodeWin, 210, 0, 90, 20, 0, 0)
        LText2      = createEx(LText, "", KeysCodeWin, 0, 40, 148, 290, 0, 0)
        LText3      = createEx(LText, "", KeysCodeWin, 148, 40, 148, 290, 0, 0)

        setWindowBackColor(KeysCodeWin,13553358)

        setHandler(KeysCodeWin, w32HOpen, routine_id("open_Keys"))
        setHandler(ButClose, w32HClick, routine_id("click_ButClose"))
    end if
end procedure
-------------------------------------------------------------------------------
procedure click_MenuCodeKeys(integer Self, integer Event, sequence Params)
    createKeysCodeWin()
    openWindow(KeysCodeWin, Normal)
end procedure
setHandler(MenuCodeKeys, w32HClick, routine_id("click_MenuCodeKeys"))
--------------------------------------------------------------------------------
procedure click_MenuEventsList(integer Self, integer Event, sequence Params)
    openWindow(TaylorEventsWin,Modal)
end procedure
setHandler(MenuEventsList, w32HClick, routine_id("click_MenuEventsList"))
-----------------------------------------------------------------------------
procedure click_MenuFirstEvent(integer Self, integer Event, sequence Params)
    if isChecked(MenuFirstEvent) then
        setCheck(MenuFirstEvent, w32False)
    else
        setCheck(MenuFirstEvent, w32True)
        if isChecked(MenuLastEvent) then
            setCheck(MenuLastEvent, w32False)
        end if
        if isChecked(MenuThisLastEvent) then
            setCheck(MenuThisLastEvent, w32False)
        end if
    end if
end procedure
setHandler(MenuFirstEvent, w32HClick, routine_id("click_MenuFirstEvent"))
----------------------------------------------------------------------------
procedure click_MenuLastEvent(integer Self, integer Event, sequence Params)
    if isChecked(MenuLastEvent) then
        setCheck(MenuLastEvent, w32False)
    else
        setCheck(MenuLastEvent, w32True)
        if isChecked(MenuFirstEvent) then
            setCheck(MenuFirstEvent, w32False)
        end if
        if isChecked(MenuThisLastEvent) then
            setCheck(MenuThisLastEvent, w32False)
        end if
    end if
end procedure
setHandler(MenuLastEvent, w32HClick, routine_id("click_MenuLastEvent"))
----------------------------------------------------------------------------
procedure click_MenuThisLastEvent(integer Self, integer Event, sequence Params)
    if isChecked(MenuThisLastEvent) then
        setCheck(MenuThisLastEvent, w32False)
    else
        setCheck(MenuThisLastEvent, w32True)
        if isChecked(MenuFirstEvent) then
            setCheck(MenuFirstEvent, w32False)
        end if
        if isChecked(MenuLastEvent) then
            setCheck(MenuLastEvent, w32False)
        end if
    end if
end procedure
setHandler(MenuThisLastEvent, w32HClick, routine_id("click_MenuThisLastEvent"))
-----------------------------------------------------------------------------
procedure click_MenuAutosaveOpts(integer Self, integer Event, sequence Params)
    openWindow(AutosaveOptions, Normal)
end procedure
setHandler(MenuAutosaveOpts, w32HClick, routine_id("click_MenuAutosaveOpts"))
--------------------------------------------------------------------------------
--contributed by Derek Parnell:
procedure click_toggle(integer self, integer event, sequence params)
    setCheck(self, not isChecked(self))
    if self=MenuAutoComplete then
        synAutoComplete(isChecked(self))
    end if
    if self=MenuHideGutter then
        hideTheGutter(isChecked(self))
    end if
    if self=MenuColorFile then
        EnableHL = not isChecked(MenuColorFile)
        if isChecked(MenuColorFile) then
            synSetColor(w32False)
            setEnable(MenuColorLocals, w32False)
        else
            setEnable(MenuColorLocals, w32True)
            if isChecked(MenuColorLocals) then
                synSetColor(w32True)
            end if
        end if
        repaintWindow(Highlight)
    end if
    if self=MenuColorLocals then
        synSetColor(isChecked(self))
        repaintWindow(Highlight)
    end if
    if self=MenuColorControlName then
        synSetNameColor(isChecked(self))
        repaintWindow(Highlight)
    end if
end procedure
setHandler({MenuHintsStatus, MenuIgnoreHints, MenuAutoComplete,MenuCodeBackUp,MenuHideGutter,
            MenuColorFile,MenuColorLocals,ChangeName,MenuColorControlName},
           w32HClick,routine_id("click_toggle"))
-----------------------------------------------------------------------------
global procedure saveTheModule(integer Self, integer Event, sequence Params)
--routine in MenuRun uses
integer foundIt
sequence openFolder, pos

    if not isModuleRoutine then
        ok = displayErrorMessage(28,{})
        return
    end if

    if equal(getItem(CodeModules, getIndex(CodeModules)), "Unidentified.e") then
        ok = invokeHandler(MenuCodeSaveAs, w32HClick,{})
        return
    end if

    if isChecked(MenuCodeBackUp) then
        ok = copyFile(getItem(PathModules,getIndex(CodeModules)) & getItem(CodeModules, getIndex(CodeModules)),
                      getItem(PathModules, getIndex(CodeModules)) & getItem(CodeModules,getIndex(CodeModules)) & ".BAK", w32False)
    end if

    --allow syn to save(as)
    if isChecked(CB_WantDefault)
    and length(getText(EditPrjDef)) then
        openFolder = getText(EditPrjDef)
    else
        openFolder = projectDir
    end if

    synSetCurrentFolder(openFolder)
    synSaveCurrentFile()

    pos = synGetCursorPos()
    --find existing record?
    foundIt = w32False
    if not errorEvent then
        for i=1 to length(openModuleAt) do
            if equal(getItem(CodeModules, getIndex(CodeModules)), openModuleAt[i][1]) then
                openModuleAt[i][2] = pos[1]
                openModuleAt[i][3] = pos[2]
                openModuleAt[i][4] = synGetTopLine()
                foundIt = w32True
                exit
            end if
        end for
        if not foundIt then
            openModuleAt &= {{getItem(CodeModules,getIndex(CodeModules)),
                              pos[1],pos[2],synGetTopLine()}}
        end if
    end if

    editorChanged = w32False

end procedure
saveTheModule_id = routine_id("saveTheModule")
setHandler(MenuCodeSave, w32HClick, routine_id("saveTheModule"))
-----------------------------------------------------------------------------
procedure click_MenuCodeNew(integer Self, integer Event, sequence Params)
atom hMem, Void, foundIt

--is there a module needing saving?
    editorChanged = w32False
    if isModuleRoutine then
        editorChanged = synGetModified()
    end if

    if isModuleRoutine
    and editorChanged  then
        if isChecked(MenuAutoSave) then
            call_proc(saveTheModule_id,{0,0,{}})
        else
            ok = displayErrorMessage(30,{})
            if ok=IDYES then
                if equal(isModule, "Unidentified.e") then
                    ok = invokeHandler(MenuCodeSaveAs, w32HClick ,{})
                    if equal(isModule,"Unidentified.e") then
                    --cancelled saveAs
                        return
                    end if
                else
                    call_proc(saveTheModule_id,{0,0,{}})
                end if
            elsif ok=IDCANCEL then
                return
            end if
        end if
    end if

    if not isModuleRoutine then
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if

    --allow writing a new project include file
    isModuleRoutine = w32True
    moduleData = {}
    moduleRoutineLine = {}
    localKeywords = {""}
    recordCnt = 0
    isModule = "Unidentified.e"
    synSetLocalCase(w32True)

    --pass to syntax that file is in editor
    synFileInEditor(w32True)

    --make sure it is not already there
    foundIt = w32False
    for i=1 to getCount(CodeModules) do
        if equal(getItem(CodeModules,i), isModule) then
            --have it
            foundIt = w32True
            setIndex(CodeModules,i)
            exit
        end if
    end for
    if not foundIt then
        addItem(CodeModules, isModule)
        addItem(PathModules, current_dir() & "\\")
        setIndex(CodeModules, getCount(CodeModules))
        setEnable(CodeModules, w32True)
    end if

    editorChanged = w32False

    setEnable(MenuEditRoutines, w32True)

    hMem = allocate_string(sprintf("%s",{" "}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
    free(hMem)

    setFocus(Highlight)
    establishSyntax()

end procedure
setHandler(MenuCodeNew, w32HClick, routine_id("click_MenuCodeNew"))
---------------------------------------------------------------------------
procedure getOpenFile(sequence haveFileName)
--when using ctrl+O need to find name of file user opened
sequence fName,fileName
integer at,foundIt,handle
atom hMem,Void

    fName = haveFileName
    fileName = haveFileName
    haveFileName = {}
    --find only name of module
    fName = reverse(fName)
    at = match("\\",fName)
    if at then
        modulePath = fName[at+1..length(fName)]
        fName = fName[1..at-1]
    end if
    fName = reverse(fName)
    modulePath = reverse(modulePath)
    isModule = fName

    --find if there is existing cursor positioning information
    moduleY = 0
    moduleX = 0
    moduleTopLine = 0
    for i=1 to length(openModuleAt) do
        if equal(fName, openModuleAt[i][1]) then
            moduleX = openModuleAt[i][2]
            moduleY = openModuleAt[i][3]
            moduleTopLine = openModuleAt[i][4]
            exit
        end if
    end for

    moduleData = {}
    moduleRoutineLine = {}
    recordCnt = 0
    editorChanged = w32False

    hMem = allocate_string(sprintf("%s",{" "}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
    free(hMem)

    --make sure it is not already there
    foundIt = w32False
    for i=1 to getCount(CodeModules) do
        if equal(getItem(CodeModules,i), isModule) then
            --have it
            foundIt = w32True
            exit
        end if
    end for
    if not foundIt then
        addItem(CodeModules, isModule)
        addItem(PathModules, modulePath & "\\")
        setIndex(CodeModules, getCount(CodeModules))
        setEnable(CodeModules, w32True)
    end if

    setEnable(MenuEditRoutines, w32True)

    -- to handle the case of no path, that is, file is in current directory
    if equal(modulePath,{}) then modulePath = "." end if
    -- if modulePath is empty, the open statement searchs for the file in the 
    -- wrong place (root directory!)
    handle = open(modulePath & "\\" & isModule, "r")

    if handle= -1 then
        ok = displayErrorMessage(35,{isModule})
        isModule = ""
        isModuleRoutine = w32False

        setEnable(MenuEditRoutines, w32False)

        -- default is selected item
        setIndex(CodeControls, editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})

        synMoveCursorAbs(CursorPos[1], CursorPos[2])
        hMem = allocate_string(sprintf("X: %d",{CursorPos[1]}))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
        free(hMem)
        hMem = allocate_string(sprintf("Y: %d",{CursorPos[2]}))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
        free(hMem)

        return
    end if
    close(handle)   --Josef

    if badFile then

        setEnable(MenuEditRoutines, w32False)

        if getCount(CodeModules) then
            --take out bad file entry in module dropdown
            ok = deleteItem(CodeModules,getCount(CodeModules))
            ok = deleteItem(PathModules,getCount(PathModules))
            setIndex(CodeModules,getCount(CodeModules))
            if not getCount(CodeModules) then
                setEnable(CodeModules, w32False)
            end if
        end if

        synFileInEditor(w32False)

        if isModuleRoutine then
            isModuleRoutine = w32False   --so will not ask to save former good file again
            ok = invokeHandler(CodeModules,w32HChange,{})
        else
            -- default is selected item
            setIndex(CodeControls, editorSelectedControl)
            ok = invokeHandler(CodeControls,w32HClick,{})
        end if
        ok = displayErrorMessage(35,{fileName})
        return
    end if
    isModuleRoutine = w32True

    for i=1 to getCount(CodeModules) do
        if equal(isModule, getItem(CodeModules, i)) then
            setIndex(CodeModules, i)
            exit
        end if
    end for
    moduleData = synGetAllText()

    if showAtRow
    or moduleY then
        if showAtRow then
            moduleY = showAtRow
            moduleX = 1
        end if
        --showAtRow comes from MenuFindProject; include file
        if moduleTopLine then
            synGotoTopLine(moduleTopLine)
        end if
        synMoveCursorAbs(moduleX,moduleY)--( 1, showAtRow)
        hMem = allocate_string(sprintf("X:%d",{moduleX}))--{1} ))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
        free(hMem)
        hMem = allocate_string(sprintf("Y:%d",{moduleY}))--showAtRow} ))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
        free(hMem)
        showAtRow = 0
    end if

end procedure
synOpenFileName_id = routine_id("getOpenFile")
-----------------------------------------------------------------------------
procedure click_MenuCodeOpen(integer Self, integer Event, sequence Params)

sequence fName, fileName
integer at, handle, foundIt
atom hMem, Void
sequence openFolder

    if not isModuleRoutine then
        setIndex(CodeControls,editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if

    --is there a module needing saving?
    editorChanged = w32False
    if isModuleRoutine then
        editorChanged = synGetModified()
    end if

    if isModuleRoutine
    and editorChanged then
        if isChecked(MenuAutoSave) then
            call_proc(saveTheModule_id,{0,0,{}})
        else
            ok = displayErrorMessage(30,{})
            if ok=IDYES then
                if equal(isModule, "Unidentified.e") then
                    ok = invokeHandler(MenuCodeSaveAs, w32HClick,{})
                    if equal(isModule, "Unidentified.e") then
                        --user cancelled saveAs
                        return
                    end if
                else
                    call_proc(saveTheModule_id,{0,0,{}})
                end if
            elsif ok=IDCANCEL then
                return
            end if
        end if
        establishSyntax() --Josef, add this, for prevent editorChanged if I answer NO save.     
    end if

    --find unidentified.e and remove it
    if equal(isModule,"Unidentified.e") then
        for i=1 to getCount(CodeModules) do
            if equal(isModule,getItem(CodeModules,i)) then
                ok = deleteItem(CodeModules,i)
                ok = deleteItem(PathModules,i)
                exit
            end if
        end for
        if getCount(CodeModules) then
            setIndex(CodeModules,getCount(CodeModules))
        else
            setEnable(CodeModules,w32False)
        end if
    end if

    if not length(haveFileName) then
        -- get the file name
        if isChecked(CB_WantDefault)
        and length(getText(EditPrjDef)) then
            openFolder = getText(EditPrjDef)
        else
            openFolder = projectDir
        end if

        fName = getOpenFileName(Form, openFolder & "\\*.*", OpenFileModules)
        if not length(fName) then
            setFocus(Highlight) --otherwise get releaseDC error
            return
        end if
        fileName = fName
    else
        fName = haveFileName
        fileName = haveFileName
        haveFileName = {}
    end if

    --find only name of module
    fName = reverse(fName)
    at = match("\\",fName)
    if at then
        modulePath = fName[at+1..length(fName)]
        fName = fName[1..at-1]
    end if
    fName = reverse(fName)
    modulePath = reverse(modulePath)
    isModule = fName

    --find if there is existing cursor positioning information
    moduleY = 0
    moduleX = 0
    moduleTopLine = 0
    for i=1 to length(openModuleAt) do
        if equal(fName, openModuleAt[i][1]) then
            moduleX = openModuleAt[i][2]
            moduleY = openModuleAt[i][3]
            moduleTopLine = openModuleAt[i][4]
            exit
        end if
    end for

    moduleData = {}
    moduleRoutineLine = {}
    recordCnt = 0
    editorChanged = w32False

    hMem = allocate_string(sprintf("%s",{" "}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
    free(hMem)

    --make sure it is not already there
    foundIt = w32False
    for i=1 to getCount(CodeModules) do
        if equal(getItem(CodeModules,i), isModule) then
            --have it
            foundIt = w32True
            modulePath = getItem(PathModules,i)
            if modulePath[length(modulePath)]='\\' then
                modulePath = modulePath[1..length(modulePath)-1]
            end if
            exit
        end if
    end for
    if not foundIt then
        addItem(CodeModules, isModule)
        addItem(PathModules, modulePath & "\\")
        setIndex(CodeModules, getCount(CodeModules))
        setEnable(CodeModules, w32True)
    end if

    setEnable(MenuEditRoutines, w32True)

    -- to handle the case of no path, that is, file is in current directory
    if equal(modulePath,{}) then modulePath = "." end if
    -- if modulePath is empty, the open statement searchs for the file in the 
    -- wrong place (root directory!)
    handle = open(modulePath & "\\" & isModule, "r")

    if handle= -1 then
        ok = displayErrorMessage(35,{modulePath & "\\" & isModule})
        isModule = ""
        isModuleRoutine = w32False

        setEnable(MenuEditRoutines, w32False)

        -- default is selected item
        setIndex(CodeControls, editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})

        synMoveCursorAbs(CursorPos[1], CursorPos[2])
        hMem = allocate_string(sprintf("X: %d",{CursorPos[1]}))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
        free(hMem)
        hMem = allocate_string(sprintf("Y: %d",{CursorPos[2]}))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
        free(hMem)

        return
    end if
    close(handle)   --Josef

    synSetLocalCase(w32True)
    --pass to syntax that file is in editor
    synFileInEditor(w32True)
    --put data in editor
    localKeywords = {}
    synLoadFile(modulePath & "\\" & isModule)
    if badFile then

        setEnable(MenuEditRoutines, w32False)

        if getCount(CodeModules) then
            --take out bad file entry in module dropdown
            ok = deleteItem(CodeModules,getCount(CodeModules))
            ok = deleteItem(PathModules,getCount(PathModules))
            setIndex(CodeModules,getCount(CodeModules))
            if not getCount(CodeModules) then
                setEnable(CodeModules, w32False)
            end if
        end if

        synFileInEditor(w32False)

        if isModuleRoutine then
            isModuleRoutine = w32False   --so will not ask to save former good file again
            ok = invokeHandler(CodeModules,w32HChange,{})
        else
            -- default is selected item
            setIndex(CodeControls, editorSelectedControl)
            ok = invokeHandler(CodeControls,w32HClick,{})
        end if
        ok = displayErrorMessage(35,{modulePath & "\\" & isModule})
        return
    end if

    isModuleRoutine = w32True

    for i=1 to getCount(CodeModules) do
        if equal(isModule, getItem(CodeModules, i)) then
            setIndex(CodeModules, i)
            exit
        end if
    end for
    moduleData = synGetAllText()

    if showAtRow
    or moduleY then
        if showAtRow then
            moduleY = showAtRow
            moduleX = 1
        end if
        --showAtRow comes from MenuFindProject; include file
        if moduleTopLine then
            synGotoTopLine(moduleTopLine)
        end if
        synMoveCursorAbs(moduleX,moduleY)--( 1, showAtRow)
        hMem = allocate_string(sprintf("X:%d",{moduleX}))--{1} ))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,1,hMem})
        free(hMem)
        hMem = allocate_string(sprintf("Y:%d",{moduleY}))--showAtRow} ))
        Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,2,hMem})
        free(hMem)
        showAtRow = 0
    end if

    findCurrentNode(isModule)
    setFocus(Highlight)
    setEnable(CodeBaseMenuItemInCodeWin,w32False)
end procedure
setHandler(MenuCodeOpen, w32HClick, routine_id("click_MenuCodeOpen"))
-----------------------------------------------------------------------------
procedure click_AllRoutines(integer Self, integer Event, sequence Params)
sequence text
atom hMem, Void

    if not getIndex(AllRoutines) then
        return
    end if

    text = synGetAllText()

    --update data from editor if Module?
    if isModuleRoutine then
        editorChanged = synGetModified()
    end if

    hMem = allocate_string(sprintf("%s",{" "}))
    Void = w32Func(xSendMessage, {getHandle(StatBar),SB_SETTEXT,0,hMem})
    free(hMem)

    --find the routine and place into editor
    if equal(getItem(AllRoutines, getIndex(AllRoutines)), ".." & "All Routines") then
           --show from top
        showScroll = 1
        showCol = 0
        showEvent = w32True
    else
        for i=1 to length(moduleRoutineLine) do
            if equal(getItem(AllRoutines, getIndex(AllRoutines)),
                     moduleRoutineLine[i][1]) then
                showScroll = moduleRoutineLine[i][2]
                showCol = 0
                showEvent = w32True
                exit
            end if
        end for
    end if

    closeWindow(ListRoutinesWindow)

    if showEvent then
        showEvent = 0
        synMoveCursorAbs(showCol, showScroll)
    end if

end procedure
--------------------------------------------------------------------------------
--procedure close_ListRoutinesWindow(integer Self, integer Event, sequence Params)
--  if Self or Event or sequence(Params) then end if
--  if validId(ListRoutinesWindow) then
--      destroy(ListRoutinesWindow)
--  end if
--  ListRoutinesWindow = -1
--  AllRoutines = -1
--  returnValue(-1)
--end procedure
--------------------------------------------------------------------------------
procedure resize_ListRoutinesWindow(integer Self, integer Event, sequence Params)
    setRect(AllRoutines, 0, 0, Params[2], Params[3], w32True)
end procedure
-----------------------------------------------------------------------------
procedure click_MenuEditRoutines(integer Self, integer Event, sequence Params)
sequence text

    if ListRoutinesWindow= -1 then
                                            --"Routines"
        ListRoutinesWindow = createEx(Window,IDEText[473][1],CodeWin, Default, Default,300,200,0,WS_EX_TOOLWINDOW)
        AllRoutines = createEx(SortedList,"",ListRoutinesWindow,0,0,w32Edge,w32Edge,0,0)
        setHandler(AllRoutines, w32HClick, routine_id("click_AllRoutines"))
        setHandler(ListRoutinesWindow, w32HResize, routine_id("resize_ListRoutinesWindow"))
    end if

    text = synGetAllText()

    eraseItems(AllRoutines)
    addItem(AllRoutines, ".." & IDEText[474][1])  --"All Routines")

    moduleRoutineLine = {}
    recordCnt = 0

    for i=1 to length(text) do
        recordCnt += 1
        if length(text[i]) then
            findAllRoutines(text[i])
        end if
    end for

    openWindow(ListRoutinesWindow, Normal)
end procedure
setHandler(MenuEditRoutines, w32HClick, routine_id("click_MenuEditRoutines"))
--------------------------------------------------------
procedure click_MenuAutoSave(integer Self, integer Event, sequence Params)
    if isChecked(MenuAutoSave) then
        setCheck(MenuAutoSave, w32False)
    else
        setCheck(MenuAutoSave, w32True)
    end if
end procedure
setHandler(MenuAutoSave, w32HClick, routine_id("click_MenuAutoSave"))
--------------------------------------------------------
procedure click_SaveToProject(integer Self, integer Event, sequence Params)
    if isChecked(SaveToProject) then
        setCheck(SaveToProject, w32False)
    else
        setCheck(SaveToProject, w32True)
        setCheck(AskSaveToProject, w32False)
    end if
end procedure
setHandler(SaveToProject, w32HClick, routine_id("click_SaveToProject"))
-----------------------------------------------------------------------------
procedure click_AskSaveToProject(integer Self, integer Event, sequence Params)
    if isChecked(AskSaveToProject) then
        setCheck(AskSaveToProject, w32False)
    else
        setCheck(AskSaveToProject, w32True)
        setCheck(SaveToProject, w32False)
    end if
end procedure
setHandler(AskSaveToProject, w32HClick, routine_id("click_AskSaveToProject"))
----------------------------------------------------------------------------
global procedure addModuleToProject(sequence fName)
integer addIt, at
sequence includeModulesData, text, data, path

    includeModulesData = {"","","",0}    --Josef Jindra added last two params

    --add to include Modules List
    --read and grab global routine names for keyword colorization
    call_proc(readModuleFile_id,{fName})

    --make sure not already loaded
    addIt = w32True
    for i=1 to length(includeModules) do
        --includeModule may or may not have path; this is legal
        --fName includes path
        if equal(fName, includeModules[i][1])
        or match(includeModules[i][1], fName) then
            addIt = w32False
            exit
        end if
    end for
    if addIt then
        IDE_Changed = w32True
        includeModulesData[1] = fName
        includeModulesData[2] = ""
        path = fName
        path = reverse(path)
        at = match("\\", path)
        if at then
            path = path[at+1..length(path)]
        else
            path = {} --should never happen!
        end if
        path = reverse(path)
        includeModulesData[3] = path
        includeModulesData[4] = 0          --Josef
        includeModules &= {includeModulesData}
        text = fName
        data = reverse(text)
        at = match("\\", data)

        if at then
            text = data[1..at-1]
            text = reverse(text)
            deleteTreeViewNode("", text)
            addTreeViewNode("Modules",text)
            theTreeModules &= {text}
        end if
    end if
end procedure
-----------------------------------------------------------------------------
procedure click_MenuCodeSaveAs(integer Self, integer Event, sequence Params)
sequence openFolder

    if not isModuleRoutine then
        ok = displayErrorMessage(29,{})
        return
    end if

    --allow syn to save(as)
    if isChecked(CB_WantDefault)
    and length(getText(EditPrjDef)) then
        openFolder = getText(EditPrjDef)
    else
        openFolder = projectDir
    end if

    synSetCurrentFolder(openFolder)
    synSaveCurrentFileAs()

end procedure
setHandler(MenuCodeSaveAs, w32HClick, routine_id("click_MenuCodeSaveAs"))
------------------------------------------------------------------------------
procedure getSavedFileName(sequence fName)
integer at,foundIt
sequence pos

    moduleData = synGetAllText()

    editorChanged = w32False

    --find only name of module
    fName = reverse(fName)
    at = match("\\",fName)
    if at then
        modulePath = fName[at+1..length(fName)]
        fName = fName[1..at-1]
    end if
    fName = reverse(fName)
    modulePath = reverse(modulePath)

    if length(fName) then
        if equal(isModule, "Unidentified.e") then
            --replace name in dropdown
            for i=1 to getCount(CodeModules) do
                if equal("Unidentified.e", getItem(CodeModules, i)) then
                    ok = deleteItem(PathModules, i)
                    ok = deleteItem(CodeModules, i)
                    exit
                end if
            end for

            isModule = fName
            addItem(CodeModules, isModule)
            addItem(PathModules, modulePath & "\\")
            setIndex(CodeModules, getCount(CodeModules))
            setEnable(CodeModules, w32True)
        end if

        if isChecked(SaveToProject) then
            --add to modules list and projectView
            addModuleToProject(modulePath & "\\" & isModule)
        elsif isChecked(AskSaveToProject) then
            foundIt = w32False
            for i=1 to length(includeModules) do
                --includeModules may or may not have path; this is legal
                if equal(modulePath & "\\" & fName, includeModules[i][1])
                or equal(fName, includeModules[i][1]) then
                    foundIt = w32True
                    exit
                end if
            end for
            if not foundIt then
                ok = displayErrorMessage(32,{})
                if ok=IDYES then
                    --add to modules list and projectView
                    addModuleToProject(modulePath & "\\" & isModule)
                end if
            end if
        end if

        --update module position
        --get last cursor position
        pos = synGetCursorPos()
        --make sure file does not already exist
        foundIt = w32False
        for i=1 to length(openModuleAt) do
            if equal(isModule, openModuleAt[i][1]) then
                openModuleAt[i][2] = pos[1]
                openModuleAt[i][3] = pos[2]
                openModuleAt[i][4] = synGetTopLine()
                foundIt = w32True
                exit
            end if
        end for
        if not foundIt then
            openModuleAt &= {{isModule,pos[1],pos[2],synGetTopLine()}}  --name,x,y
        end if

    end if
end procedure
synSaveAsFileName_id = routine_id("getSavedFileName")
-----------------------------------------------------------------------------
procedure noFileName()
    ok = invokeHandler(MenuSave,w32HClick,{})
end procedure
synNoFileName_id = routine_id("noFileName")
------------------------------------------------------------------------------
-- Euphoria HTML library docs
procedure Click_ButLibHtml(integer Self, integer Event, sequence Params)
sequence libDocs--,euDir

    euDir = whereEu
    libDocs = euDir & "\\html\\refman.htm"
    shellExecute("open",libDocs,5)

end procedure
setHandler(ButLibHtml, w32HClick, routine_id("Click_ButLibHtml"))
-----------------------------------------------------------------
-- Win32lib.ew HTML library docs
procedure Click_ButWinlibHtml(integer Self, integer Event, sequence Params)

    if not length(Win32libDocs) then
        ok = displayErrorMessage(37,{})
        return
    end if

    shellExecute("open",Win32libDocs,5)

end procedure
setHandler(ButWinlibHtml, w32HClick, routine_id("Click_ButWinlibHtml"))
----------------------------------------------------------------------------
procedure Click_ButCbHtml(integer Self, integer Event, sequence Params)

    if not length(CbDocs) then
        ok = displayErrorMessage(37,{})
        return
    end if

    shellExecute("open",CbDocs,5)

end procedure
setHandler(ButCbHtml, w32HClick, routine_id("Click_ButCbHtml"))
----------------------------------------------------------------------------
--ButWinCbHtml
procedure Event_CodeWin(integer Self, integer Event, sequence Params)
atom events, wParam, lParam
sequence info

    events  = Params[1]
    wParam = Params[2]
    lParam = Params[3]

    info = getControlInfo(CodeWin, {CONTROLINFO_closed})
    if info[1] then
        -- CodeWin closed
        return
    end if

    if events=WM_MOVE then
        CodeWinWasOpened = w32True
        --move the hint window along if open
        info = getControlInfo(HintWin, {CONTROLINFO_closed})
        if not info[1] then
            -- HintWin is open so show hint
            hintLoc = {}
            displayHint(HintText)
        end if
    elsif events=WM_NCACTIVATE then
        --martin to prevent deactiv. of TitleBar after menu dbl click
        if wParam=0 and MenuEditDoubleClick then-- being deactivated?
            returnValue(w32False) -- just say no :)
            MenuEditDoubleClick = w32False
        end if
    elsif events=#117 then
        if wParam=getHandle(MenuEdit) then
            if synCanUndo() then
                setEnable(MenuUndo, w32True)
            else
                setEnable(MenuUndo, w32False)
            end if
            if synHasSelection() then
                setEnable(MenuCut, w32True)
                setEnable(MenuCopy, w32True)
            else
                setEnable(MenuCut, w32False)
                setEnable(MenuCopy, w32False)
            end if
            if synCanPaste() then
                setEnable(MenuPaste, w32True)
            else
                setEnable(MenuPaste, w32False)
            end if
        end if
    end if
end procedure
setHandler(CodeWin, w32HEvent, routine_id("Event_CodeWin"))
---------------------------------------------------------------------------
-- edit menu options
procedure editorCut(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synCutText()
end procedure
setHandler(MenuCut, w32HClick, routine_id("editorCut"))
--------------------------------------------------------------------------------
procedure editorCopy(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synCopyText()
end procedure
setHandler(MenuCopy, w32HClick, routine_id("editorCopy"))
--------------------------------------------------------------------------------
procedure editorPaste(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synPasteText()
end procedure
setHandler(MenuPaste, w32HClick, routine_id("editorPaste"))
--------------------------------------------------------------------------------
procedure editorSelectAll(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synSelectAll()
end procedure
setHandler(MenuSelectAll, w32HClick, routine_id("editorSelectAll"))
--------------------------------------------------------------------------------
procedure editorBlkComment(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synSelectBlkComment()
end procedure
setHandler(MenuBlkComment, w32HClick, routine_id("editorBlkComment"))
--------------------------------------------------------------------------------
procedure editorBlkIndent(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synSelectBlkIndent()
end procedure
setHandler(MenuBlkIndent, w32HClick, routine_id("editorBlkIndent"))
--------------------------------------------------------------------------------
procedure editorBlkUnindent(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synUnindent()
end procedure
setHandler(MenuBlkUnindent, w32HClick, routine_id("editorBlkUnindent"))
--------------------------------------------------------------------------------
procedure editorUndo(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synUndoLast()
end procedure
setHandler(MenuUndo, w32HClick, routine_id("editorUndo"))
------------------------------------------------------------------------
procedure click_MenuFind(integer Self, integer Event, sequence Params)
    doingFind = w32True
    synShowFindRep()
end procedure
setHandler(MenuFind, w32HClick, routine_id("click_MenuFind"))
MenuFind_id = routine_id("click_MenuFind")
---------------------------------------------------------------------------
procedure click_MenuFindAll(integer Self, integer Event, sequence Params)
    createFindControlEventwin()
    if Self=MenuFindAll then
        setText(FindControlEventWin, IDEText[475][1])   --"Find String in Controls-Events")
    else
        setText(FindControlEventWin, IDEText[476][1])   --"Find String In Project")
    end if
    openWindow(FindControlEventWin, Normal)
end procedure
setHandler({MenuFindAll,MenuFindPrj}, w32HClick, routine_id("click_MenuFindAll"))
----------------------------------------------------------------------------
procedure Click_MenuGoTo(integer Self, integer Event, sequence Params)
    setFocus(Highlight)
    synShowGotoLine()
end procedure
setHandler(MenuGoTo, w32HClick, routine_id("Click_MenuGoTo"))
-----------------------------------------------------------------------------
procedure Click_MenuOptions(integer Self, integer Event, sequence Params)
    onClick_Options(Self, Event, Params)
end procedure
setHandler(MenuEditorOption, w32HClick, routine_id("Click_MenuOptions"))
-----------------------------------------------------------------------------
procedure click_MenuCodeRun(integer Self, integer Event, sequence Params)
    ok = invokeHandler(MenuRun,w32HClick,{})
end procedure
setHandler(MenuCodeRun, w32HClick, routine_id("click_MenuCodeRun"))
-----------------------------------------------------------------------------
procedure click_MenuCodeRunTemp(integer Self, integer Event, sequence Params)
    ok = invokeHandler(MenuRunTemp,w32HClick,{})
end procedure
setHandler(MenuCodeRunTemp, w32HClick, routine_id("click_MenuCodeRunTemp"))
------------------------------------------------------------------------------
procedure click_MenuCodeClose(integer Self, integer Event, sequence Params)
sequence pos
integer foundIt

    abortClose = w32False

    if length(isModule) then
        editorChanged = synGetModified()
    end if

    if length(isModule) then
        --remember current cursor position if not from ex.err
        if not errorEvent then
            --trap last cursor position for next time this control-event is displayed
            pos = synGetCursorPos()
            foundIt = w32False
            for i=1 to length(openModuleAt) do
                if equal(getItem(CodeModules, getIndex(CodeModules)), openModuleAt[i][1]) then
                    openModuleAt[i][2] = pos[1]
                    openModuleAt[i][3] = pos[2]
                    openModuleAt[i][4] = synGetTopLine()
                    foundIt = w32True
                    exit
                end if
            end for
            if not foundIt then
                openModuleAt &= {{isModule,pos[1],pos[2],synGetTopLine()}}
            end if
        end if
        if editorChanged then
            if isChecked(MenuAutoSave) then
                call_proc(saveTheModule_id,{0,0,{}})
            else
                ok = displayErrorMessage(30,{})
                if ok=IDYES then
                    call_proc(saveTheModule_id,{0,0,{}})
                    if abortClose then
                        --user cancelled saveAs
                        return
                    end if
                elsif ok=IDCANCEL then
                    abortClose = w32True
                    return
                end if
            end if
        end if

        --unless module is part of project, remove from combo
        foundIt = w32False
        for i=1 to length(includeModules) do
            if match(getItem(CodeModules,getIndex(CodeModules)),includeModules[i][1]) then
                foundIt = w32True
                exit
            end if
        end for
        if not foundIt then
            ok = deleteItem(PathModules, getIndex(CodeModules))
            ok = deleteItem(CodeModules, getIndex(CodeModules))
            setIndex(CodeModules, getCount(CodeModules))
            if not getCount(CodeModules) then
                setEnable(CodeModules, w32False)
            end if
        end if

        --always remove New, unsaved module
        if equal(isModule,"Unidentified.e") then
            for i=1 to getCount(CodeModules) do
                if equal(isModule,getItem(CodeModules,i)) then
                    ok = deleteItem(CodeModules,i)
                    ok = deleteItem(PathModules,i)
                    exit
                end if
            end for
            if getCount(CodeModules) then
                setIndex(CodeModules,getCount(CodeModules))
            else
                setEnable(CodeModules,w32False)
            end if
        end if
    end if

    if isModuleRoutine then

        isModuleRoutine = w32False
        isModule = ""
        modulePath = ""

        --pass to syntax that file is no longer in editor
        synFileInEditor(w32False)
        establishSyntax()

        --load current control-event
        setIndex(CodeControls,editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})

    end if

end procedure
setHandler(MenuCodeClose, w32HClick, routine_id("click_MenuCodeClose"))
--------------------------------------------------------------------------------
function cleanHotKeyText(sequence newText)
integer at
sequence outText, CrLf
    CrLf = {'\r','\n'}

    outText = {}
    while length(newText) do
        at = match(CrLf, newText)
        if at then
            outText &= {newText[1..at-1]}
            newText = newText[at+2..length(newText)]
        else
            outText &= {newText}
            exit
        end if
    end while
    return outText
end function
--------------------------------------------------------------------------------
procedure ChangeButton_onClick(integer self, integer event, sequence params)
sequence newText

    if not length(LVSelected) then
        return
    end if

    for i=1 to length(LVSelected) do
        newText = getText(EditAction)
        --break down into sequences of sequence based on finding CrLf
        --then put first one in LV
        newText = cleanHotKeyText(newText)
        HotKeyText[index] = newText
        setLVItemText(HotKeyLV, LVSelected[i], 2, newText[1])
        exit
    end for
end procedure
---------------------------------------------------------------------------------
procedure ChangeButton_onKeyPress(integer self, integer event, sequence params)
    if params[1]=13 then ChangeButton_onClick(ChangeButton, w32HClick, {}) end if
end procedure
---------------------------------------------------------------------------------
procedure DeleteButton_onClick(integer self, integer event, sequence params)

    if not length(LVSelected) then
        return
    end if

    for i=1 to length(LVSelected) do
        HotKeyText[index] = {{}}
        setLVItemText(HotKeyLV, LVSelected[i], 2, {})
        setText(EditAction,"")
        exit
    end for
    LVSelected = {}
end procedure
---------------------------------------------------------------------------------
procedure DeleteButton_onKeyPress(integer self, integer event, sequence params)
    if params[1]=13 then DeleteButton_onClick(DeleteButton, w32HClick, {}) end if
end procedure
--------------------------------------------------------------------------------
procedure OkButton_onClick(integer self, integer event, sequence params)
sequence HotKeys, FKey, theText
integer j

    j = 0
    FKey = {VK_F2,VK_F3,VK_F4,VK_F7,VK_F8,VK_F9,VK_F10,VK_F11,VK_F2,VK_F3,VK_F4,VK_F7,VK_F8,VK_F9,VK_F10,VK_F11}
    HotKeys = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

    --process the F keys and Data
    for i=1 to getLVCount(HotKeyLV) do
        theText = getLVAllText(HotKeyLV, i)
        if length(theText)>1 then
            j += 1
            HotKeys[j] = FKey[i]
        end if
    end for

    currentMakeDefault = isChecked(HotKeyMakeDefault)

    --send to editor
    setUserHotKeys(HotKeys, HotKeyText, currentHotKeyFileName, currentMakeDefault)

    if validId(RegisterHotKeyWin) then
        destroy(RegisterHotKeyWin)
    end if
    RegisterHotKeyWin = -1
end procedure
-------------------------------------------------------------------------------
procedure OkButton_onKeyPress(integer self, integer event, sequence params)
    if params[1]=13 then OkButton_onClick(OkButton, w32HClick, {}) end if
end procedure
--------------------------------------------------------------------------------
procedure CreateNewFileButton_onClick(integer self, integer event, sequence params)
sequence fName

--get savefile name
    fName = getOpenFileName(CodeWin, the_current_dir & "\\files\\",{"HotKeyData","*.dat"})

    if length(fName) then
        --place into currentFileName
        setText(HotKeyFileName,fName)

        currentHotKeyFileName = getText(HotKeyFileName)
        currentMakeDefault = w32False
        setCheck(HotKeyMakeDefault, currentMakeDefault)
    end if
end procedure
-------------------------------------------------------------------------------
procedure CreateNewFileButton_onKeyPress(integer self, integer event, sequence params)
    if params[1]=13 then CreateNewFileButton_onClick(CreateNewFileButton, w32HClick, {}) end if
end procedure
--------------------------------------------------------------------------------
procedure HotKeySearch_onClick(integer self, integer event, sequence params)
sequence fName,currentdirectory
integer ok

    currentdirectory = current_dir()

    --get openfile name
    fName = getOpenFileName(CodeWin, current_dir(),{})

    if length(fName) then
        --place into currentFileName
        setText(HotKeyFileName,fName)

        currentHotKeyFileName = getText(HotKeyFileName)
        currentMakeDefault = w32False
        setCheck(HotKeyMakeDefault, currentMakeDefault)

        --get the data from syntax
        processHotKeyFileName(currentHotKeyFileName)
    end if
    ok = chdir(currentdirectory)
end procedure
-------------------------------------------------------------------------------
procedure HotKeySearch_onKeyPress(integer self, integer event, sequence params)
    if params[1]=13 then HotKeySearch_onClick(HotKeySearch, w32HClick, {}) end if
end procedure
-------------------------------------------------------------------------------
procedure HotKeyFileName_onKeyPress(integer self, integer event, sequence params)
    if params[1]=13 then
        currentHotKeyFileName = getText(HotKeyFileName)
        currentMakeDefault = w32False
        setCheck(HotKeyMakeDefault, currentMakeDefault)
        --get the data from syntax
        processHotKeyFileName(currentHotKeyFileName)
    end if
end procedure
--------------------------------------------------------------------------------
procedure HotKeyLV_onClick(integer self, integer event, sequence params)
sequence outText

    outText = {}
    LVSelected = getLVSelected(HotKeyLV)
    if length(LVSelected)>0 then
        setText(EditKey, getLVItemText(HotKeyLV, LVSelected[1],1))
        LVDataIndex = getIndex(HotKeyLV)
        if not atom(LVDataIndex) and length(LVDataIndex)=0 then
            LVDataIndex = {1}
        end if
        index = LVDataIndex[1]
        if length(HotKeyText[index]) then
            for i=1 to length(HotKeyText[index]) do
                outText &= HotKeyText[index][i] & 13 & 10
            end for
        end if
        setText(EditAction, outText)
    else
        setText(EditKey,"")
        setText(EditAction, "")
    end if
end procedure
-------------------------------------------------------------------------------
procedure create_RegisterHotKeyWin()
                                      --"Register Hot Key Information"
    RegisterHotKeyWin = createEx(Window, IDEText[477][1], 0, Default, Default, 400, 430, {WS_DLGFRAME}, 0)
                                --"Current Hot Key File:"
    LText2FKey = createEx(LText, IDEText[478][1], RegisterHotKeyWin, 4, 0, 148, 20, 0, 0)
                                       --"IDE_HotKey.dat"
    HotKeyFileName = createEx(EditText, IDEText[479][1], RegisterHotKeyWin, 4, 20, 292, 20, 0, 0)
                                       --"Select"
    HotKeySearch = createEx(PushButton, IDEText[480][1], RegisterHotKeyWin, 300, 12, 88, 28, 0, 0)
                                          --"Make this the default"
    HotKeyMakeDefault = createEx(CheckBox, IDEText[481][1], RegisterHotKeyWin, 4, 48, 200, 20, 0, 0)
                                  --{"F Key","Text Inserted At Cursor"}
    HotKeyLV = createEx(ListView, {IDEText[40][1],IDEText[482][1]}, RegisterHotKeyWin, 4, 84, 388, 124, w32or_all({LVS_REPORT,LVS_SHOWSELALWAYS,LVS_NOSORTHEADER}), 0)
    EditAction = createEx(MleText, "", RegisterHotKeyWin, 155, 220, 235, 120, WS_HSCROLL, 0)
                                       --"Change"
    ChangeButton = createEx(PushButton, IDEText[483][1], RegisterHotKeyWin, 8, 268, 88, 28, 0, 0)
                                       --"Delete"
    DeleteButton = createEx(PushButton, IDEText[484][1], RegisterHotKeyWin, 8, 307, 88, 28, 0, 0)
                                              --"Create New File"
    CreateNewFileButton = createEx(PushButton, IDEText[485][1], RegisterHotKeyWin, 8, 350, 224, 28, 0, 0)
                                   --"OK"
    OkButton = createEx(PushButton, IDEText[486][1], RegisterHotKeyWin, 300, 350, 88, 28, 0, 0)
                               --"F Key :"
    LTextFKey = createEx(LText, IDEText[487][1], RegisterHotKeyWin, 4, 216, 120, 20, 0, 0)
    EditKey = createEx(LText, "", RegisterHotKeyWin, 24, 240, 100, 20, 0, 0)

    IDEok = setLVInsert(1)
    lvMask = w32or_all({LVS_EX_FULLROWSELECT})
    lvOk = sendMessage(HotKeyLV,LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)
    lvMask = w32or_all({LVS_EX_GRIDLINES})
    lvOk = sendMessage(HotKeyLV,LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)
    lvOk = sendMessage(HotKeyLV,LVM_SETCOLUMNWIDTH,0,100)
    lvOk = sendMessage(HotKeyLV,LVM_SETCOLUMNWIDTH,1,400)

    setHandler(ChangeButton, w32HClick, routine_id("ChangeButton_onClick"))
    setHandler(DeleteButton, w32HClick, routine_id("DeleteButton_onClick"))
    setHandler(CreateNewFileButton, w32HClick, routine_id("CreateNewFileButton_onClick"))
    setHandler(OkButton, w32HClick, routine_id("OkButton_onClick"))
    setHandler(ChangeButton, w32HKeyPress, routine_id("ChangeButton_onKeyPress"))
    setHandler(DeleteButton, w32HKeyPress, routine_id("DeleteButton_onKeyPress"))
    setHandler(CreateNewFileButton, w32HKeyPress, routine_id("CreateNewFileButton_onKeyPress"))
    setHandler(OkButton, w32HKeyPress, routine_id("OkButton_onKeyPress"))
    setHandler(HotKeyLV, w32HClick, routine_id("HotKeyLV_onClick"))
    setHandler(HotKeySearch, w32HClick, routine_id("HotKeySearch_onClick"))
    setHandler(HotKeySearch, w32HKeyPress, routine_id("HotKeySearch_onKeyPress"))
    setHandler(HotKeyFileName, w32HKeyPress, routine_id("HotKeyFileName_onKeyPress"))

    IDElvItems = {}
    IDElvData = {}
    IDElvData = {0,"F2",HotKeyText[1][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F3",HotKeyText[2][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F4",HotKeyText[3][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F7",HotKeyText[4][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F8",HotKeyText[5][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F9",HotKeyText[6][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F10",HotKeyText[7][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F11",HotKeyText[8][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F2",HotKeyText[9][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F3",HotKeyText[10][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F4",HotKeyText[11][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F7",HotKeyText[12][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F8",HotKeyText[13][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F9",HotKeyText[14][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F10",HotKeyText[15][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F11",HotKeyText[16][1]}
    IDElvItems &= {IDElvData}
    for i=1 to length(IDElvItems) do
        IDElvItemNo = addLVItem(HotKeyLV, IDElvItems[i][1], IDElvItems[i][2..length(IDElvItems[i])])
    end for

    if not length(currentHotKeyFileName) then
        currentHotKeyFileName = the_current_dir & "\\files\\IDE_HotKey.dat"
        currentMakeDefault = w32True
    end if

    setText(HotKeyFileName,currentHotKeyFileName)
    setCheck(HotKeyMakeDefault, currentMakeDefault)

end procedure
-------------------------------------------------------------------------------
procedure Click_MenuHotKeys(integer Self, integer Event, sequence Params)
    if RegisterHotKeyWin= -1 then
        create_RegisterHotKeyWin()
    end if
    openWindow(RegisterHotKeyWin, Modal)
end procedure
setHandler(MenuHotKeys, w32HClick, routine_id("Click_MenuHotKeys"))
-------------------------------------------------------------------------------
procedure setHotKeys(sequence hotKeys, sequence hotKeysText, sequence fName)
    --get HotKeys from syntax when it reads synMain2.ini and hotkeyfile
    HotKeyText = hotKeysText
    currentHotKeyFileName = fName
    if RegisterHotKeyWin= -1 then
        return
    end if

    setText(HotKeyFileName,currentHotKeyFileName)
    setText(EditAction,"")

    eraseItems(HotKeyLV)
    IDElvItems = {}
    IDElvData = {}
    IDElvData = {0,"F2",HotKeyText[1][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F3",HotKeyText[2][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F4",HotKeyText[3][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F7",HotKeyText[4][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F8",HotKeyText[5][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F9",HotKeyText[6][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F10",HotKeyText[7][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"F11",HotKeyText[8][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F2",HotKeyText[9][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F3",HotKeyText[10][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F4",HotKeyText[11][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F7",HotKeyText[12][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F8",HotKeyText[13][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F9",HotKeyText[14][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F10",HotKeyText[15][1]}
    IDElvItems &= {IDElvData}
    IDElvData = {0,"Shift+F11",HotKeyText[16][1]}
    IDElvItems &= {IDElvData}
    for i=1 to length(IDElvItems) do
        IDElvItemNo = addLVItem(HotKeyLV, IDElvItems[i][1], IDElvItems[i][2..length(IDElvItems[i])])
    end for

end procedure
sendUserHotKey_id = routine_id("setHotKeys")
--------------------------------------------------------------------------------
procedure click_MenuPrint(integer self, integer event, sequence params)
    if not isModuleRoutine then
        setIndex(CodeControls, editorSelectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})
    end if
    createPrintOptWin()
end procedure
setHandler(MenuPrint,w32HClick,routine_id("click_MenuPrint"))
--------------------------------------------------------------------------------
procedure click_MenuColorWheel(integer self, integer event, sequence params)
    openWindow(TabWindow1, Normal)
end procedure
setHandler(MenuColorwheel,w32HClick,routine_id("click_MenuColorWheel"))
--------------------------------------------------------------------------------    
global procedure translateCodeWin()
integer hintsChecked, hintStatusBarChecked,
          backupChecked, saveToPrjChecked, askToPrjChecked, hideGutter,
          controlsopt1, controlsopt2, controlsopt3,saveAutoComplete,
          changename,saveAutoSave,colorcontrolname,autosaveoptOnOff

    hintsChecked = isChecked(MenuIgnoreHints)
    hintStatusBarChecked = isChecked(MenuHintsStatus)
    backupChecked = isChecked(MenuCodeBackUp)
    saveToPrjChecked = isChecked(SaveToProject)
    askToPrjChecked = isChecked(AskSaveToProject)
    hideGutter = isChecked(MenuHideGutter)
    controlsopt1 = isChecked(MenuFirstEvent)
    controlsopt2 = isChecked(MenuLastEvent)
    controlsopt3 = isChecked(MenuThisLastEvent)
    saveAutoComplete = isChecked(MenuAutoComplete)
    changename = isChecked(ChangeName)
    saveAutoSave = isChecked(MenuAutoSave)
    colorcontrolname = isChecked(MenuColorControlName)
    autosaveoptOnOff = isChecked(AutosaveCheckbox)

    --translate window text and syntax
    setText(CodeWin, IDEText[430][1])
    setText(MenuCodeSaveModule, IDEText[431][1])
    setText(MenuCodeNew, IDEText[432][1])
    setText(MenuCodeOpen, IDEText[433][1])
    setText(MenuCodeSaveAs, IDEText[434][1])
    setText(MenuCodeSave, IDEText[435][1])
    setText(MenuCodeBackUp, IDEText[436][1])
    setText(MenuCodeClose, IDEText[437][1])
    setText(MenuPrintIt, IDEText[438][1])
    setText(MenuPrint, IDEText[439][1])
    setText(MenuEdit, IDEText[440][1])
    setText(MenuUndo, IDEText[441][1])
    setText(MenuCut, IDEText[442][1])
    setText(MenuCopy, IDEText[443][1])
    setText(MenuPaste, IDEText[444][1])
    setText(MenuSelectAll, IDEText[445][1])
    setText(MenuSearch, IDEText[446][1])
    setText(MenuFindWhere, IDEText[447][1])
    setText(MenuFind, IDEText[448][1])
    setText(MenuFindAll, IDEText[449][1])
    setText(MenuFindPrj, IDEText[450][1])
    setText(MenuGoTo, IDEText[451][1])
    setText(MenuList, IDEText[452][1])
    setText(MenuEditRoutines, IDEText[453][1])
    setText(MenuOpt, IDEText[454][1])
    setText(MenuHotKeys, IDEText[455][1])
    setText(MenuEditorOption, IDEText[456][1])
    setText(MenuIgnoreHints, IDEText[457][1])
    setText(MenuHintsStatus, IDEText[458][1])
    setText(MenuSaveOptions, IDEText[460][1])
    setText(SaveToProject, IDEText[461][1])
    setText(AskSaveToProject, IDEText[462][1])
    setText(MenuCodeRuns, IDEText[463][1])
    setText(MenuCodeRun, IDEText[464][1])
    setText(MenuCodeRunTemp, IDEText[465][1])
    setText(MenuHelp, IDEText[466][1])
    setText(ButLibHtml, IDEText[467][1])
    setText(ButWinlibHtml, IDEText[468][1])
    setText(MenuCodeKeys, IDEText[469][1])
    setText(MenuAutoComplete, IDEText[813][1])
    setText(MenuBlkIndent, IDEText[976][1])
    setText(MenuBlkComment, IDEText[977][1])
    setText(MenuHideGutter, IDEText[985][1])
    setText(CodeBaseMenuInCodeWin,IDEText[1000][1])
    setText(CodeBaseMenuItemInCodeWin,IDEText[1001][1])
    setText(MenuControlAction, IDEText[1013][1])
    setText(MenuFirstEvent, IDEText[1014][1])
    setText(MenuLastEvent, IDEText[1015][1])
    setText(MenuThisLastEvent, IDEText[1016][1])
    setText(MenuBlkUnindent, IDEText[1017][1])
    setText(ChangeName, IDEText[1024][1])
    setText(MenuAutoSave, IDEText[1027][1])
    setText(popup1, IDEText[776][1])
    setText(popup2, IDEText[777][1])
    setText(popup3, IDEText[779][1])
    setText(popup1, IDEText[780][1])
    setText(PopupWindow, IDEText[782][1])
    setText(PopupSearch, IDEText[783][1])
    setText(PopupWindow,IDEText[1029][1])
    setText(MenuEventsList, IDEText[1040][1])
    setText(TaylorEventsWin, IDEText[1038][1])
    setText(MenuColorFile, IDEText[1022][1])
    setText(MenuColorLocals, IDEText[1020][1])
    setText(MenuColorControlName, IDEText[1053][1])
    setText(MenuTool, IDEText[1095][1])
    setText(MenuColorwheel, IDEText[1096][1])
    setText(AutosaveOptions, IDEText[1166][1])
    setText(MenuAutosaveOpts, IDEText[1166][1])
    setText(AutosaveText, IDEText[1167][1])
    setText(AutosaveCheckbox, IDEText[1168][1])
    setText(AutoSaveOK,IDEText[44][1])
    translate_TaylorEvents()

    setHint(HintWin, IDEText[470][1])
    setHint(RichHint,IDEText[470][1])
    setHint(CodeControls, IDEText[1028][1])

    setCheck(MenuIgnoreHints,hintsChecked)
    setCheck(MenuHintsStatus,hintStatusBarChecked)
    setCheck(MenuCodeBackUp,backupChecked)
    setCheck(SaveToProject,saveToPrjChecked)
    setCheck(AskSaveToProject,askToPrjChecked)
    setCheck(MenuHideGutter,hideGutter)
    setCheck(MenuFirstEvent,controlsopt1)
    setCheck(MenuLastEvent,controlsopt2)
    setCheck(MenuThisLastEvent,controlsopt3)
    setCheck(MenuAutoComplete, saveAutoComplete)
    setCheck(ChangeName, changename)
    setCheck(MenuAutoSave,saveAutoSave)
    setCheck(MenuColorControlName,colorcontrolname)
    setCheck(AutosaveCheckbox,autosaveoptOnOff)

    translateSyntax()
end procedure
translateCodeWin_id = routine_id("translateCodeWin")
-------------------------------------------------------------------------------
global procedure RepaintEditorCaption()
--routine contributed by Josef Jindra
integer ic, ie, at
sequence tc, te

    if not length(isModule) then
        ic = getIndex(CodeControls)
        ie = getFLIndex(CodeEvents)
        if ic then
            tc = getItem(CodeControls, ic)
        else
            tc = ""
        end if
        if ie then
            theSelectedItem = returnFLItem(CodeEvents, ie)
            te = theSelectedItem[1]
            --judith: remove * in event name
            at = match("*",te)
            if at then
                te = te[1..at-1]
            end if
            --judith
        else
            te = ""
        end if
        setText(CodeWin , tc & " - " & te)
    else
        setText(CodeWin, isModule)
    end if
end procedure
RepaintEditorCaption_id = routine_id("RepaintEditorCaption")
------------------------------------------------------------------------------
procedure moduleIsInProject(sequence fName)
integer isIn, at

    isIn = w32False

    --strip path from filename
    fName = reverse(fName)
    at = match("\\",fName)
    if at then
        fName = fName[1..at-1]
    end if
    fName = reverse(fName)

    if match(lower(fName), "win32lib.ew") then
        isIn = w32True
    else
        for i=1 to length(includeModules) do
            if match(fName,includeModules[i][1]) then
                isIn = w32True
                exit
            end if
        end for
    end if

    ActiveModule = isIn --this is in syntax.ew

end procedure
moduleIsInProject_id = routine_id("moduleIsInProject")

