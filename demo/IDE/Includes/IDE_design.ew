--IDE_design.ew
--contains most of the control design and manipulation routines

integer ok,
        rejected        --addition of new control is rejected
object VOID

global integer
    toolBarSize,        -- how many rows of ToolRowCY pixels in toolbar
    toolCY              -- the CY of the FlatToolBar row

    toolBarSize = 0
    toolCY              = w32findKey("Flat Bar", ControlList)    --usually 48

sequence childrenList   childrenList = {}
integer cellwidth,cellheight
    cellwidth = 0
    cellheight = 0

------------------------------------------------------------------------------
global function inside(sequence control, integer x, integer y)

    -- return w32True if point is inside the control
    if control[ControlLayer]!=layerNumber then
        return 0
    end if

    -- hit test
    if x>control[X]
    and y>control[Y] then
        if x<control[X]+control[CX]-1
        and y<control[Y]+control[CY]-1 then
            return 1
        end if
    end if
    return 0

end function
------------------------------------------------------------------------------
function findTabItemParent(integer x, integer y)
--return index of the parent the point is in

integer flag

    flag = TheWindow
    -- scan all controls
    for i=1 to length(controls) do

        if  not equal(controls[i][Class], "Window")
        and controls[i][ControlLayer]=layerNumber
        and inside(controls[i], x, y) then

            --find the parent of the TabItem the point is in

            if equal(controls[i][Class], "TabControl")
            and controls[i][Active] then
                flag = i
            else
                if equal(controls[i][Class], "TabItem")
                and equal(controls[i][Name], selectedTabItem) then
                    flag = i
                end if
            end if

        end if
    end for

    return flag

end function
------------------------------------------------------------------------------
global procedure removeFromParentChildSeq(integer parentindex, sequence name)
integer at

    if not parentindex
    or parentindex=1 then
        --Window does not carry children
        return
    end if

    if length(controls[parentindex][SeqChildName]) then
        at = find(name, controls[parentindex][SeqChildName])
        if not at then
            return
        end if
        controls[parentindex][SeqChildName] = controls[parentindex][SeqChildName][1..at-1]
                                              & controls[parentindex][SeqChildName][at+1..length(controls[parentindex][SeqChildName])]
    end if
end procedure
--------------------------------------------------------------------------------
function copyControlProperties(sequence ctrls, sequence origCtrl)
    --copy from original control those attributes likely to be the same in new control
    ctrls[StyleType] = origCtrl[StyleType]
    ctrls[Active] = origCtrl[Active]
    ctrls[Visible] = origCtrl[Visible]
    ctrls[Checked] = origCtrl[Checked]
    ctrls[Upper] = origCtrl[Upper]
    ctrls[Lower] = origCtrl[Lower]
    ctrls[ReadOnly] = origCtrl[ReadOnly]
    ctrls[Pswd] = origCtrl[Pswd]
    ctrls[Limit] = origCtrl[Limit]
    ctrls[BkColor] = origCtrl[BkColor]
    ctrls[EnableC] = origCtrl[EnableC]
    ctrls[Numeric] = origCtrl[Numeric]
    ctrls[Multiline] = origCtrl[Multiline]
    ctrls[Hscrolls] = origCtrl[Hscrolls]
    ctrls[Vscrolls] = origCtrl[Vscrolls]
    ctrls[FontName] = origCtrl[FontName]
    ctrls[FontPts] = origCtrl[FontPts]
    ctrls[FontAttrib] = origCtrl[FontAttrib]
    ctrls[FontBold] = origCtrl[FontBold]
    ctrls[FontUnderline] = origCtrl[FontUnderline]
    ctrls[FontStrikeout] = origCtrl[FontStrikeout]
    ctrls[FontColor] = origCtrl[FontColor]
    ctrls[FontVarName] = origCtrl[FontVarName]
    ctrls[FontVarPts] = origCtrl[FontVarPts]
    ctrls[FontVarItalic] = origCtrl[FontVarItalic]
    ctrls[FontVarBold] = origCtrl[FontVarBold]
    ctrls[FontVarUnderline] = origCtrl[FontVarUnderline]
    ctrls[FontVarStrikeout] = origCtrl[FontVarStrikeout]
    ctrls[FontVarColor] = origCtrl[FontVarColor]
    ctrls[CreateEx] = origCtrl[CreateEx]
    ctrls[Showcap] = origCtrl[Showcap]
    ctrls[Local] = origCtrl[Local]
    ctrls[MultiSel] = origCtrl[MultiSel]
    ctrls[ExtendSel] = origCtrl[ExtendSel]
    ctrls[MinValue] = origCtrl[MinValue]
    ctrls[MaxValue] = origCtrl[MaxValue]
    ctrls[Clickable] = origCtrl[Clickable]
    ctrls[Integers] = origCtrl[Integers]
    ctrls[MCS_multiselect] = origCtrl[MCS_multiselect]
    ctrls[PBS_smooth] = origCtrl[PBS_smooth]
    ctrls[BS_flat] = origCtrl[BS_flat]
    ctrls[LineChg] = origCtrl[LineChg]
    ctrls[PageChg] = origCtrl[PageChg]
    ctrls[NoIntegralHeight] = origCtrl[NoIntegralHeight]
    ctrls[AdjCenter] = origCtrl[AdjCenter]
    ctrls[AdjRight] = origCtrl[AdjRight]
    ctrls[SetLayerOK] = origCtrl[SetLayerOK]
    ctrls[TxtColor] = origCtrl[TxtColor]
    ctrls[LastListHeight] = origCtrl[LastListHeight]
    ctrls[LabelExtent] = origCtrl[LabelExtent]
    ctrls[LabelSide] = origCtrl[LabelSide]
    ctrls[BkBarColor] = origCtrl[BkBarColor]
    ctrls[PB_Caption_Pos] = origCtrl[PB_Caption_Pos]
    ctrls[UpDownLeft] = origCtrl[UpDownLeft]
    ctrls[UpDownHorz] = origCtrl[UpDownHorz]
    ctrls[TabsBottom] = origCtrl[TabsBottom]
    ctrls[Style] = origCtrl[Style]
    ctrls[StyleType] = origCtrl[StyleType]
    --properties for Colored Buttons
    ctrls[cbColor] = origCtrl[cbColor]
    ctrls[cbCaptionColor] = origCtrl[cbCaptionColor]
    ctrls[cbThickness] = origCtrl[cbThickness]
    ctrls[cbPressColor] = origCtrl[cbPressColor]
    ctrls[cbPressCaptionColor] = origCtrl[cbPressCaptionColor]
    ctrls[cbCaptionPos] = origCtrl[cbCaptionPos]
    ctrls[cbGraphicPos] = origCtrl[cbGraphicPos]
    ctrls[TreatAsColorButton] = origCtrl[TreatAsColorButton]
    ctrls[cbMultiline] = origCtrl[cbMultiline]
    ctrls[cbFlat] = origCtrl[cbFlat]
    ctrls[cbCentVert] = origCtrl[cbCentVert]
    return ctrls
end function
------------------------------------------------------------------------------
procedure makeCopyControl(integer theX, integer theY, integer theCX,
                            integer theCY, sequence theClass,
                            sequence theName, sequence theTitle, sequence theOrigTitle,
                            sequence theIndexParent)

--copy of control or control and child controls Name and Title are now built
--from Name and Title without trailing numbers + next available counter

sequence control
integer attachCounter,
        quoteInTitle

    attachCounter = w32True
    quoteInTitle = w32False

    if sequence(theName) then end if

    control = repeat(0, ControlSize)

    counter += 1

    -- set values
    control[Id]     = counter
    control[AWindow] = 30
    control[X]      = theX
    control[Y]      = theY
    control[CX]     = theCX
    control[CY]     = theCY
    control[Class]  = theClass
    control[SubClass] = {}
    control[SeqParentName] = {}
    control[SeqChildName] = {}
    control[ControlLayer] = layerNumber
    control[GenFromName] = {}

    if equal(control[Class],"CWindow") then
        control[AWindow] = 4
    end if
    if find(control[Class],{"ToolBar","FlatToolBar","StatusBar"}) then
        control[AWindow] = 7
    end if
    if find(theClass, {"TabControl","TabItem"}) then
        control[AWindow] = 25
        control[SubClass] = control[Class]
    end if

    if isChecked(MenuTabAllUseLayer) then
        control[SetLayerOK] = w32True
    end if

    --trap if title had a quote as last character
    if not length(theTitle) then
        control[Title] = ""
    else
        quoteInTitle = w32False
        if equal('\"', theTitle[length(theTitle)]) then
            theTitle = theTitle[1..length(theTitle)-1]
            quoteInTitle = w32True
        end if

        if equal(theTitle, theOrigTitle) then
            theTitle = theClass
        end if
        control[Title] = theTitle

        attachCounter = w32True
        while w32True do
            if control[Title][length(control[Title])]='"'
            and equal(control[Class], "ListView") then
                attachCounter = w32False
                exit
            else
                if not length(control[Title]) then
                    exit
                end if
                if control[Title][length(control[Title])]>='0'
                and control[Title][length(control[Title])]<='9' then
                    control[Title] = control[Title][1..length(control[Title])-1]
                    if not length(control[Title]) then
                        exit
                    end if
                else
                    exit
                end if
            end if
        end while
        if attachCounter then
            control[Title] = control[Title] & sprint(counter)
        end if

        if length(control[Title]) then
            if quoteInTitle then
                control[Title] &= "\""
            end if
        end if
    end if

    if equal(control[Class], "LabelEdit") then
        control[ValueEdit] = control[Title]
    else
        control[ValueEdit] = {}
    end if

    control[Name] = sprintf(theClass & "%d", {counter}) --theTitle
    while w32True do
        if control[Name][length(control[Name])]>='0'
        and control[Name][length(control[Name])]<='9' then
            control[Name] = control[Name][1..length(control[Name])-1]
            if not length(control[Name]) then
                exit
            end if
        else
            exit
        end if
    end while
    control[Name] = sprintf(control[Name] & "%d", {counter})

    --add to sequence for colorization
    controlNameKeywords &= {control[Name]}
    control[ControlParent] = ""
    control[ParentClass] = ""
    control[Parent] = ""
    if find(control[Class], {"TabItem","TabControl"}) then
        control[Active] = 1
    end if
    control[Style] = {}
    control[StyleType] = {}
    control[Visible] = w32True
    control[EnableC] = w32True
    control[Buddy] = ""
    control[IcoFile] = ""
    control[TwoIcoFile] = ""
    control[TriIcoFile] = ""
    control[BitmapFile] = ""
    control[FontName] = ""
    control[HintFontName] = ""
    control[HintText] = ""
    control[ExStyle] = "0"
    counterInWindow += 1
    control[TabOrder] = counterInWindow
    control[XPM] = ""
    control[XPMmember] = ""
    control[XpmObject] = {}
    control[XpmDisableObject] = {}
    control[InitialVal] = {}
    control[SetEvent] = ""
    control[SetControl] = ""
    control[KillEvent] = ""
    control[KillControl] = ""
    control[CCWinStyle] = ""
    control[WidthTitle] = {}
    control[ExtExStyle] = {}
    control[SelectWidth] = {}
    control[SystemBkColor] = {}
    control[OutX] = {}
    control[OutY] = {}
    control[OutCX] = {}
    control[OutCY] = {}
    control[ControlComment] = {}
    control[DEFIndex] = {}
    control[SysTrayIcon] = {}
    control[SysTrayHint] = {}
    control[SysTrayText] = {}
    control[GridFormat] = {}
    control[WinOpenAtCtrl] = {}
    control[GridDataArrayName] = {}
    control[GridColListValues] = {}
    control[ClassDefaults] = {}
    control[ValueEdit] = {}
    control[OrigTitle] = control[Title]
    control[ControlPartners] = {}
    control[FontVarName] = {}
    control[FontVarPts] = {}
    control[FontVarItalic] = {}
    control[FontVarBold] = {}
    control[FontVarUnderline] = {}
    control[FontVarStrikeout] = {}
    control[HintFontVarName] = {}
    control[HintFontVarPts] = {}
    control[HintFontVarItalic] = {}
    control[HintFontVarBold] = {}
    control[HintFontVarUnderline] = {}
    control[HintFontVarStrikeout] = {}
    control[FontVarColor] = {}
    control[HintVarText] = {}
    control[cbCentVert] = w32True
    --colored button properties
    control[cbColor] = 0
    control[cbCaptionColor] = 0
    control[cbThickness] = 0
    control[cbPressColor] = 0
    control[cbPressCaptionColor] = 0
    control[cbCaptionPos] = 0
    control[cbGraphicPos] = 0
    control[TreatAsColorButton] = 0
    control[cbMultiline] = 0
    control[cbFlat] = 0

    if equal(control[Class], "EuGrid") then
        control[GridActiveHeaders] = w32True
        control[GridAllowColSort] = w32True
        control[GridAllowColResize] = w32True
        control[GridCellBorder] = w32True
        haveEuGrid += 1
    end if

    control[IndexParent] = theIndexParent

    if equal(control[Class], "ReBarBand") then
        control[RBBSBREAK] = w32True
    end if

    if isChecked(ClickLocal) then
        control[Local] = w32True
    end if

    control[Code]   = repeat({}, length(Events))

    --set style for specific control styles
    if equal(control[Class], "RichEdit") then
        control[Style] = "ES_NOHIDESEL"

    elsif equal(control[Class], "ListView") then
        control[Style] = "LVS_REPORT,LVS_SHOWSELALWAYS"

    elsif equal(control[Class], "TreeView") then
        control[Style] =
          "TVS_HASLINES,TVS_LINESATROOT,TVS_HASBUTTONS,TVS_SHOWSELALWAYS"

    elsif equal(control[Class], "UpDown") then
        control[Style] =
          "UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS"

    end if

    --ControlParent, ParentClass, Parent, SeqParentName and SeqChildName will be
    --assigned when we know where the control is copied to.

    -- add to controls list
    controls &= {control}

    IDE_Changed = w32True

    addItem(PropertyTitleBar, control[Name])

end procedure
------------------------------------------------------------------------------
function snap(integer i)
    -- position to closest nth pixel
    if GridDisable then
        return i
    else
        return floor(i/SnapSize)*SnapSize
    end if
end function
------------------------------------------------------------------------------
procedure deactivateChildren(integer index, sequence parent)
integer childCnt
    if sequence(parent) then end if
    childCnt = 0
    for i=index to length(controls) do
        if find(controls[i][Name],controls[index][SeqChildName]) then
            childCnt += 1
            if find(controls[i][Class], {"TabControl","TabItem"}) then
                controls[i][Active] = w32False
                if length(controls[i][SeqChildName]) then
                    deactivateChildren(i, controls[i][Name])
                end if
            end if

            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end if
    end for

end procedure
------------------------------------------------------------------------------
procedure newControl(integer index, integer x, integer y,
            sequence theControlParent, sequence theParentClass, integer theParentIndex)

-- add a new control to the controls list

integer tabItemCount, ok, rebarbandCounterCY, rebarbandCounter
integer toolBarSlot,childCnt,totalCX, at, foundIt, insideControl
sequence control, whoIs, extent, path, textLen
object exists

    rebarbandCounterCY = 0
    rebarbandCounter = 0
    rejected = w32False

    -- allocate space for a control
    control = repeat(0, ControlSize)

    -- increment counter
    counter += 1

    -- set values
    control[Id]     = counter
    control[AWindow] = 30
    control[X]      = x+WinX
    control[Y]      = y+WinY-(MenuY+TitleY)
    control[CX]     = snap(ControlList[index][ControlCX])
    control[SubClass] = {}
    control[SeqParentName] = {}
    control[SeqParentClass] = {}
    control[SeqChildName] = {}
    control[XPMmember] = {}
    control[XpmObject] = {}
    control[XpmDisableObject] = {}
    control[ControlLayer] = layerNumber
    control[GenFromName] = {}
    control[cbCentVert] = w32True

    if isChecked(MenuTabAllUseLayer) then
        control[SetLayerOK] = w32True
    end if

    if find(ControlList[index][ControlClass],
            {"ToolBar","FlatToolBar","StatusBar","ReBar","ReBarBand"}) then
        control[CY]     = ControlList[index][ControlCY]
    else
        control[CY]     = snap(ControlList[index][ControlCY])
    end if
    control[Class]  = ControlList[index][ControlClass]
    if equal(control[Class], "ColorButton") then
        control[Class] = "PushButton"
        control[TreatAsColorButton] = w32True
    end if

    if equal(control[Class],"CWindow") then
        control[AWindow] = 4
    end if
    if equal(control[Class],"ReBar") then
        control[AWindow] = 5
    end if
    if equal(control[Class],"ReBarBand") then
        control[AWindow] = 6
    end if
    if equal(control[Class],"StatusBar") then
        control[AWindow] = 6
    end if
    if find(control[Class], {"ToolBar","FlatToolBar"}) then
        control[ToolRowCY] = control[CY]
        control[AWindow] = 7
    end if
    if find(control[Class], {"TabControl","TabItem"}) then
        control[AWindow] = 25
        control[SubClass] = control[Class]
    end if
    control[Title]  = sprintf(ControlList[index][ControlTitle] & "%d", {counter})
    if equal(control[Class], "LabelEdit") then
        control[ValueEdit] = control[Title]
    else
        control[ValueEdit] = {}
    end if
    control[Name]   = sprintf(ControlList[index][ControlName] & "%d", {counter})

    --add to sequence for colorization
    controlNameKeywords &= {control[Name]}

    control[ControlParent] = theControlParent
    control[ParentClass] = theParentClass
    if find(control[ParentClass], {"ReBar","ReBarBand"})
    or equal(control[Class],"ReBar") then
        --when adding to rebar need to redraw it in DrawIt
        repaintWinResize = w32True
    end if

    control[Parent] = ""
    control[SeqParentName] = {}
    control[SeqParentClass] = {}
    whoIs = findDirectParent(control[X], control[Y], control[ControlParent], control[Name], 0)

    if whoIs[1]
    and equal(whoIs[2], "TabItem")
    and equal(control[Class], "TabItem") then
        --a TabItem may not be parented to a TabItem so find the TabControl
        at = findSeqParentName(whoIs[1])
        if at then
            whoIs[1] = at
            whoIs[2] = controls[at][Class]
        end if
    end if

    if whoIs[1] then
        if equal(whoIs[2],"EuGrid") then
            totalCX = controls[whoIs[1]][GridRowHeaderCX]+controls[whoIs[1]][X]
            if length(controls[whoIs[1]][SeqChildName]) then
                childCnt = 0
                for i=whoIs[1] to length(controls) do
                    if find(controls[i][Name],controls[whoIs[1]][SeqChildName]) then
                        childCnt += 1
                        totalCX += controls[i][CX]
                    end if
                    if childCnt>=length(controls[whoIs[1]][SeqChildName]) then
                        exit
                    end if
                end for
            end if
            --place this control next available slot and under the grid header
            control[X] = totalCX
            control[Y] = controls[whoIs[1]][Y]+controls[whoIs[1]][GridColHeaderCY]
            control[CY] = gridCellCY
            control[BkColor] = controls[whoIs[1]][GridBkColorRows]
            if control[X]>controls[whoIs[1]][X]+controls[whoIs[1]][CX] then
                ok = displayErrorMessage(231,{})
                rejected = w32True
                return
            end if
        end if

        if equal(whoIs[2], "Table") then
            control[Parent] = controls[whoIs[1]][Name]
            control[SeqParentName] = controls[whoIs[1]][Name]
            control[SeqParentClass] = controls[whoIs[1]][Class]
                        --will do addToParentChildSeq when know the cell designation
        else
            if equal(control[Class], "ReBarBand") then
                if equal(control[ParentClass], "ReBar") then
                    control[SeqParentName] = control[ControlParent]
                    control[SeqParentClass] = control[ParentClass]
                    addToParentChildSeq(theParentIndex,control[Name])
                elsif equal(whoIs[2],"ReBar") then
                    control[SeqParentName] = controls[whoIs[1]][Name]
                    control[SeqParentClass] = controls[whoIs[1]][Class]
                    addToParentChildSeq(whoIs[1],control[Name])
                end if
            else
                if not equal(control[Class], "TabItem") then
                    control[SeqParentName] = controls[whoIs[1]][Name]
                    control[SeqParentClass] = controls[whoIs[1]][Class]
                    addToParentChildSeq(whoIs[1],control[Name])
                end if
            end if

        end if
    end if

    if equal(control[Class], "TabItem") then
        control[SeqParentName] = control[ControlParent]
        control[SeqParentClass] = control[ParentClass]
        --update parent
        addToParentChildSeq(theParentIndex,control[Name])
    end if

    if length(control[ControlParent])
    and not length(control[SeqParentName]) then
        control[SeqParentName] = control[ControlParent]
        control[SeqParentClass] = control[ParentClass]
        --update parent
        addToParentChildSeq(theParentIndex,control[Name])
    end if

    if find(control[Class], {"TabControl","TabItem"}) then
        control[Active] = 1
    end if
    if equal(control[SeqParentClass],{"ReBarBand"}) then
        repaintWinResize = w32True
    end if
    if equal(control[SeqParentClass],{"ReBarBand"})
    and not find(control[Class],{"ToolBar","FlatToolBar"}) then
        control[AWindow] = 10
    end if

    control[Style] = {}
    control[StyleType] = {}
    control[Visible] = w32True
    control[EnableC] = w32True
    control[Buddy] = ""
    control[IcoFile] = ""
    control[TwoIcoFile] = ""
    control[TriIcoFile] = ""
    control[BitmapFile] = ""
    control[FontName] = theDefaultFont[1]--""
    control[HintFontName] = theDefaultFont[1]--""
    control[FontPts] = 8
    control[HintFontPts] = 8
    control[HintText] = ""
    control[ExStyle] = "0"
    control[XPM] = ""
    control[XPMmember] = ""
    control[XpmObject] = {}
    control[XpmDisableObject] = {}
    control[InitialVal] = {}
    control[SetEvent] = ""
    control[SetControl] = ""
    control[KillEvent] = ""
    control[KillControl] = ""
    control[CCWinStyle] = ""
    control[WidthTitle] = {}
    control[ExtExStyle] = {}
    control[SelectWidth] = {}
    control[SystemBkColor] = {}
    control[OutX] = {}
    control[OutY] = {}
    control[OutCX] = {}
    control[OutCY] = {}
    control[ControlComment] = {}
    control[DEFIndex] = {}
    control[SysTrayIcon] = {}
    control[SysTrayHint] = {}
    control[SysTrayText] = {}
    control[IndexParent] = {}
    control[GridFormat] = {}
    control[WinOpenAtCtrl] = {}
    control[GridDataArrayName] = {}
    control[GridColListValues] = {}
    control[ClassDefaults] = {}
    control[OrigTitle] = control[Title]
    control[ControlPartners] = {}
    control[FontVarName] = {}
    control[FontVarPts] = {}
    control[FontVarItalic] = {}
    control[FontVarBold] = {}
    control[FontVarUnderline] = {}
    control[FontVarStrikeout] = {}
    control[HintFontVarName] = {}
    control[HintFontVarPts] = {}
    control[HintFontVarItalic] = {}
    control[HintFontVarBold] = {}
    control[HintFontVarUnderline] = {}
    control[HintFontVarStrikeout] = {}
    control[FontVarColor] = {}
    control[HintVarText] = {}

    if equal(control[Class], "CWindow") then
        control[StyleType] = "w32or_all({...})"
    end if

    if equal(control[Class], "EuGrid") then
        control[GridActiveHeaders] = w32True
        control[GridAllowColSort] = w32True
        control[GridAllowColResize] = w32True
        control[GridCellBorder] = w32True
        haveEuGridControl += 1
    end if

    if equal(control[Class], "EuGrid") then
        haveEuGrid += 1
        control[GridRowHeaderCX] = gridCellCX
        control[GridColHeaderCY] = gridCellCY
        control[BkColor] = getSysColor(COLOR_BTNFACE)
        control[GridHeaderColor] = getSysColor(COLOR_BTNFACE)
        control[GridBkColorRows] = BrightWhite
        control[GridHeaderType] = 3

        foundIt = w32False
        for i=1 to length(euIncFiles) do
            exists = dir(euIncFiles[i] & "\\eugrid.ew")
            if atom(exists) then
                foundIt = w32False
            else
                foundIt = w32True
                path = euIncFiles[i]
                exit
            end if
        end for

        if not length(euIncFiles)
        or not foundIt then
            --look in Eu/Include folder
            euDir = whereEu
            exists = dir(euDir & "\\Include\\eugrid.ew")
            if atom(exists) then
                foundIt = w32False
            else
                foundIt = w32True
                path = euDir & "\\Include"
            end if
        end if

        if not foundIt then
            --look in project folder
            exists = projectDir & "\\eugrid.ew"
            --add to modules list and projectView
--          if atom(exists) then
--              foundIt=w32False
--          else
            foundIt = w32True
            path = projectDir
--          end if
        end if

        if not foundIt then
            --look in IDE folder
            exists = the_current_dir & "\\eugrid.ew"
            --add to modules list and projectView
--          if atom(exists) then
--              foundIt=w32False
--          else
            foundIt = w32True
            path = the_current_dir
--          end if
        end if

        if foundIt then
            addItem(CodeModules, "eugrid.ew")
            addItem(PathModules, path & "\\")
            setIndex(CodeModules, getCount(CodeModules))
            setEnable(CodeModules, w32True)
            addModuleToProject(path & "\\eugrid.ew")
        end if
    end if

    if equal(control[Class], "ReBarBand") then
        control[RBBSBREAK] = w32True
    end if

    if isChecked(ClickLocal) then
        control[Local] = w32True
    else
        control[Local] = w32False
    end if

    --if control is not a toolbar, statusbar, menu, menuitem, popup, popupitem, timer,
    --CWindow or child of ReBarBand
    --then increment the tab order counter
    if not find(control[Class], {"ToolBar","StatusBar",
                                 "FlatToolBar","ReBar","ReBarBand","CWindow"})
    and not equal(control[SeqParentClass],"ReBarBand") then
        counterInWindow += 1
        control[TabOrder] = counterInWindow
    end if

    control[Code]   = repeat({}, length(Events))

    if equal(control[Class], "StatusBar") then
        insideControl = w32False
        for i=1 to length(controls) do
            if equal(controls[i][Class],"CWindow")
            and inside(controls[i],control[X],control[Y]) then
                insideControl = i
                theParentClass = "CWindow"
                theControlParent = controls[i][Name]
                theParentIndex = i
                exit
            end if
        end for
        if not insideControl then
        --put at bottom of screen
            for i=1 to length(controls) do
                if equal(controls[i][Class], "StatusBar")
                and not length(controls[i][SeqParentName]) then
                    ok = displayErrorMessage(77,{})
                    rejected = w32True
                    return
                else
                    control[X] = 0
                    control[Y] = controls[TheWindow][CY]-ControlList[index][ControlCY]
                                 -(MenuY+WinY+titleBar+(2*borderX) )
                    control[CX] = controls[TheWindow][CX]
                end if
            end for
        else
            for i=1 to length(controls) do
                if equal(controls[i][Class], "StatusBar")
                and equal(controls[i][ControlParent],controls[insideControl][Name]) then
                    ok = displayErrorMessage(77,{})
                    rejected = w32True
                    return
                end if
            end for
            --didn't get rejected so must be good     			
            control[X] = controls[insideControl][X]
            control[Y] = (controls[insideControl][Y]+controls[insideControl][CY])
                         -(ControlList[index][ControlCY]+borderX)
            control[CX] = controls[insideControl][CX]
        end if
    end if

    --if the id picked is a TabItem then need to adjust them all for the
    --same x,y, cx,cy of the TabControl

    if equal(control[Class], "MleText") then
        control[Vscrolls] = w32True
    end if

    if equal(control[Class], "TabItem") then

        --line up with TabControl size
        for i=1 to length(controls) do
            if equal(control[ControlParent], controls[i][Name]) then
                control[X] = controls[i][X]
                control[Y] = controls[i][Y]
                control[CX] = controls[i][CX]
                control[CY] = controls[i][CY]
                exit
            end if
        end for

        --deactivate other tabItems in the TabControl container list
        --and make this one active
        childCnt = 0
        for i=theParentIndex to length(controls) do
            if find(controls[i][Name],controls[theParentIndex][SeqChildName]) then
                childCnt += 1
                controls[i][Active] = w32False
                --find any children of this control and make it inactive also
                if length(controls[i][SeqChildName]) then
                    deactivateChildren(i, controls[i][Name])
                end if
            end if
            if childCnt>=length(controls[theParentIndex][SeqChildName]) then
                exit
            end if
        end for

        --need to increment its combo box in the toolbar
        tabItemCount = getCount(TheTabItemCombo)
        tabItemCount += 1
        addItem(TheTabItemCombo,control[Name])
        setIndex(TheTabItemCombo, tabItemCount)
        --and set the selectedTabItem
        selectedTabItem = control[Name]

    end if

    if equal(control[Class], "ReBarBand") then
        repaintWinResize = w32True
        --are there other bands?
        rebarbandCounterCY = 0
        rebarbandCounter = 0
        for i=1 to length(controls) do
            if equal(controls[i][Class], "ReBarBand")
            and equal(controls[i][ControlParent], theControlParent) then
                --IF each parent is the same
                --if larger than the new rebarband, adjust new rebarband                
                if controls[i][CY]>control[CY] then
                    control[CY] = controls[i][CY]
                end if
                rebarbandCounterCY += controls[i][CY]
                rebarbandCounter += 1
            end if
        end for

        control[Y] = 3+(4*rebarbandCounter)+rebarbandCounterCY+controls[theParentIndex][Y]
        control[X] = 5+controls[theParentIndex][X]
        if equal(control[ParentClass],"CWindow") then
            control[Y] += titleBar
            control[CX] = controls[theParentIndex][CX]-5
        end if
        --now go back and change CY of rebar
        for i=1 to length(controls) do
            if equal(controls[i][Class], "ReBar")
            and equal(controls[i][Name], control[ControlParent]) then
                controls[i][CY] = control[Y]+control[CY]+4
                exit
            end if
        end for
    end if

    if equal(control[ParentClass], "ReBar") then
        whoIs = findDirectParent(control[X], control[Y], control[ControlParent],
                                 control[Name],0)
        if whoIs[1]
        and equal(controls[whoIs[1]][Class], "ReBarBand")
        and not equal(control[Class], "ReBarBand") then
            control[Y] = controls[whoIs[1]][Y]+1
            extent = getTextExtent(ControlBlit, controls[whoIs[1]][Title])
            control[X] = controls[whoIs[1]][X]+extent[1]+5
            repaintWinResize = w32True
        end if
    end if

    if find(control[Class], {"ToolBar","FlatToolBar","ReBar"}) then
        --when parent is ReBar or CWindow, then user controls X, Y, CX, CY; otherwise must be
        --at 0,0
        insideControl = w32False
        for i=1 to length(controls) do
            if find(controls[i][Class],{"CWindow","ReBarBand"})
            and inside(controls[i],control[X],control[Y]) then
                insideControl = i
                if not equal(controls[insideControl][Class], "CWindow") then
                    --look for ReBarBand
                    exit
                end if
            end if
        end for
        --when control is toolbar/ftb or rebar check initial placement
        if not insideControl then
            --set the x,y to 0,0 adjusted for placement in window
            control[X] = 0
            control[Y] = 0
            control[CX] = controls[TheWindow][CX]
        else
            if equal(controls[insideControl][Class], "CWindow") then
                control[Y] = controls[insideControl][Y]+titleBar+borderY
                control[X] = controls[insideControl][X]+borderX
                control[CX] = controls[insideControl][CX]-(2*borderX)
                if not isCWindowTitleBar(insideControl) then
                    control[X] = controls[insideControl][X]
                    control[Y] = controls[insideControl][Y]--+titleBar
                    control[CX] = controls[insideControl][CX]
                end if
            elsif equal(controls[insideControl][Class], "ReBarBand") then
                control[X] = controls[insideControl][X]+10
                control[Y] = controls[insideControl][Y]+3
                control[CX] = controls[insideControl][CX]
            end if
        end if

        if equal(control[Class], "ToolBar") then
            toolBarCY = control[CY]
            toolBarSubCY = toolBarCY-4
            toolBarOrigX = control[X]
            toolBarOrigY = control[Y]
            toolBarName  = control[Name]
            toolBarX     = control[X]
            toolBarY     = 1
            --just as a protection make sure there is not already entry for
            --toolbar in toolBarInfo data. If have it then delete
            for i=1 to length(toolBarInfo) do
                if equal(toolBarInfo[i][8], control[Name]) then
                    toolBarInfo = toolBarInfo[1..i-1]&toolBarInfo[i+1..length(toolBarInfo)]
                    exit
                end if
            end for
            toolBarInfo &= {toolBarCY&toolBarCY&toolBarSubCY&toolBarOrigX
                            &toolBarOrigY&toolBarX&toolBarY&{toolBarName}}
        end if

        if equal(control[Class], "FlatToolBar") then
            toolBarCY = control[CY]
            toolBarSubCY = toolBarCY-10
            toolBarOrigX = control[X]
            toolBarOrigY = control[Y]
            toolBarName  = control[Name]
            toolBarX     = control[X]
            toolBarY     = 1
            --just as a protection make sure there is not already entry for
            --flattoolbar in toolBarInfo data. If have it then delete
            for i=1 to length(toolBarInfo) do
                if equal(toolBarInfo[i][8], control[Name]) then
                    toolBarInfo = toolBarInfo[1..i-1]&toolBarInfo[i+1..length(toolBarInfo)]
                    exit
                end if
            end for
            --FlatToolBar does not have row information
            toolBarInfo &= {toolBarCY&toolBarCY&toolBarSubCY&toolBarOrigX
                            &toolBarOrigY&toolBarX&toolBarY&{toolBarName}}
        end if

    end if

    if equal(control[Class], "Table") then
        control[TableCols] = 1
        control[TableRows] = 1
        control[PreserveName] = 1
        control[FitToTable] = 1
    end if

    whoIs = findDirectParent(control[X],
                             control[Y],
                             control[ControlParent],
                             control[Name],0)

    if equal(theParentClass, "Table")
    or equal(whoIs[2], "Table") then
        control[Title]  = sprintf(ControlList[index][ControlTitle] & "%d"&"Cell"&sprint(1), {counter})
        control[Name]   = sprintf(ControlList[index][ControlName] & "%d"&"Cell"&sprint(1), {counter})
        control[TableCell]   = 1
        --update parent
        addToParentChildSeq(whoIs[1], control[Name])
        control[OrigTitle] = control[Title]
    end if

    --if adding into the ToolBar autoposition
    --find the direct parent  
    if find(whoIs[2], {"ToolBar","FlatToolBar"})
    or find(theParentClass, {"ToolBar","FlatToolBar"}) then
        --drop control at next available x. Increment toolBarX with the width
        --of the control. Be sure in moveDrag and moveResize routines to adjust
        --toolBarX.
        --find the next available x and y positions
        toolBarX = 0
        toolBarY = 1
        toolBarSlot = 0
        if find(whoIs[2], {"ToolBar","FlatToolBar"}) then
            for i=1 to length(toolBarInfo) do
                --find current data on this bar
                if equal(toolBarInfo[i][8], controls[whoIs[1]][Name]) then
                    toolBarX = toolBarInfo[i][6]
                    toolBarY = toolBarInfo[i][7]
                    toolBarCY = toolBarInfo[i][2]
                    toolBarSubCY = toolBarInfo[i][3]
                    toolBarOrigX = toolBarInfo[i][4]
                    toolBarOrigY = toolBarInfo[i][5]
                    toolBarSlot = i
                    exit
                end if
            end for
        else
            for i=1 to length(toolBarInfo) do
                --find all current data on this bar
                if equal(toolBarInfo[i][8], theControlParent) then
                    toolBarX = toolBarInfo[i][6]
                    toolBarY = toolBarInfo[i][7]
                    toolBarCY = toolBarInfo[i][2]
                    toolBarSubCY = toolBarInfo[i][3]
                    toolBarOrigX = toolBarInfo[i][4]
                    toolBarOrigY = toolBarInfo[i][5]
                    toolBarSlot = i
                    exit
                end if
            end for
        end if
        if toolBarSlot=0 then
            ok = displayErrorMessage(196,{})
            return
        end if
        if whoIs[1] then
            control[X] = toolBarX
            control[Y] = (( toolBarY*toolBarCY)-toolBarCY)+toolBarOrigY
            if whoIs[1]!=1 then
                control[SeqParentName] = controls[whoIs[1]][Name]
                control[SeqParentClass] = controls[whoIs[1]][Class]
                --update parent if have not already
                addToParentChildSeq(whoIs[1],control[Name])
            end if
        else
            control[X] = toolBarX
            control[Y] = ( toolBarY*toolBarCY)-toolBarCY
        end if

        if equal(control[Class], "PushButton") then
            if equal(theParentClass, "FlatToolBar")
            or equal(whoIs[2], "FlatToolBar") then
                if toolBarCY=48 then
                    control[CX] = toolBarCY-10
                    control[CY] = toolBarCY-10
                else
                    control[CX] = toolBarCY-4
                    control[CY] = toolBarCY-4
                end if
                control[Class] = "PictureButton"   --change to PushButton in Proj.
            else
                if toolBarCY<34 then
                    control[CX] = toolBarCY-2
                    control[CY] = toolBarCY-2
                else
                    control[CX] = toolBarCY-4
                    control[CY] = toolBarCY-4
                end if
                control[Class] = "TogglePicture"
            end if
        end if

        --how deep is the toolBar now?
        for i=1 to length(controls) do
            if find(controls[i][Class], {"ToolBar","FlatToolBar"}) then
                --how many rows are there in the ToolBar?
                toolBarSize = floor(controls[i][CY]/toolBarCY)
                exit
            end if
        end for

        if control[X]+control[CX]>controls[whoIs[1]][X]+controls[whoIs[1]][CX]
        and toolBarY+1>toolBarSize then
            ok = displayErrorMessage(50,{})
            return
        elsif control[X]+control[CX]>controls[whoIs[1]][X]+controls[whoIs[1]][CX] then
            --drop down to next bar?
            toolBarX = toolBarOrigX
            toolBarY += 1
            control[X] = toolBarX
            control[Y] = ((toolBarCY*toolBarY)-toolBarCY)+toolBarOrigY
            if equal(control[ParentClass], "ReBar") then
                if control[Y]=0 then
                    if whoIs[1] then
                        control[Y] = 4
                    else
                        control[Y] = 1
                    end if
                end if
            end if
        end if

        toolBarInfo[toolBarSlot][6] = toolBarX+control[CX]
        toolBarInfo[toolBarSlot][7] = toolBarY

        if not equal(control[Class], "TogglePicture") then
            control[CY] = toolBarSubCY
        end if

    end if

        --if adding into the StatusBar autoposition cy
    if whoIs[1] then
        if equal(whoIs[2], "StatusBar") then
            --adjust control cy to fit within the StatusBar cy
            for i=1 to ControlSize do
                if equal("StatusBar", ControlList[i][ControlClass])
                        then
                    control[CY] = ControlList[i][ControlCY]-5
                    control[Y] = controls[whoIs[1]][Y]+1
                    exit
                end if
            end for
        end if
    end if

    --set style for specific control styles
    if equal(control[Class], "RichEdit") then
        control[Style] = "ES_NOHIDESEL"

    elsif equal(control[Class], "ListView") then
        control[Style] = "LVS_REPORT,LVS_SHOWSELALWAYS"

    elsif equal(control[Class], "TreeView") then
        control[Style] =
          "TVS_HASLINES,TVS_LINESATROOT,TVS_HASBUTTONS,TVS_SHOWSELALWAYS"
        control[TwoIcoFile] = "clsdfold.ico"
        control[TriIcoFile] = "openfold.ico"

    elsif equal(control[Class], "UpDown") then
        control[Style] =
          "UDS_ALIGNRIGHT,UDS_SETBUDDYINT,UDS_ARROWKEYS" --,UDS_AUTOBUDDY"

    elsif equal(control[Class], "CWindow") then
        control[Style] = "WS_CHILD"
    end if

    -- add to controls list
    controls &= {control}
    if equal(controls[length(controls)][Class], "LabelEdit") then
        textLen = getTextExtent(length(controls),controls[length(controls)][Title])
        controls[length(controls)][LabelExtent] = snap(textLen[1])
    end if

    if equal(control[Class], "ReBar") then
        --used in DrawIt
        haveReBar += 1
    end if

    if equal(control[Class], "StatusBar") then
        --used in DrawIt
        haveStatusBar += 1
    end if

    if find(control[Class], {"ToolBar","FlatToolBar"}) then
        --used in DrawIt
        haveToolBar += 1
    end if

--CMB
    if equal(control[Class], "LText") and not equal(whoIs[2], "TabItem") then 
        --add a color property for labels 
        --puts(1, "LText added ") 
        --this adds the background colour of the label, to the same as the 
        --window colour - note this is a little different to th COLOR_WINDOW 
        --for some reason. If you are dropping a label on a tab, then handle this a  
        --little differently 
        control[BkColor] = getSysColor( COLOR_BTNFACE ) 
    end if 
 
    if equal(control[Class], "LText") and equal(whoIs[2], "TabItem") then 
        control[BkColor] = getSysColor( COLOR_WINDOW ) 
    end if 

    IDE_Changed = w32True

    if repaintWinResize then
        call_proc(drawIt_id,{})
    end if

    addItem(PropertyTitleBar, control[Name])

end procedure
-------------------------------------------------------------------------------
global procedure resetMultiDrop()
    --deselect the control in the button bar
    dropMultipleTimes = w32False
    picked = Pointer

    --toggle on checkmark OFF
    setCheck(MenuClick, w32True)
    setText(IconOff, IDEText[208][1])   --"Off"
end procedure
resetMultiDrop_id = routine_id("resetMultiDrop")
-----------------------------------------------------------------------------
function findButtonName(object key,sequence list)
    for i=1 to length(list)do
        if equal(list[i][9],key)then
            return i
        end if
    end for
    return 0
end function
-----------------------------------------------------------------------------
-- Control Design Actions
integer toggleIt
    toggleIt = 1

procedure toolButton_Click(integer Self, integer Event, sequence Params)

-- toggle a control selection
integer id, prevPicked

-- get the id of the button that was toggled
    id = getSelf()

    if selectedControl!=TheWindow then

        -- clear selection
        selectedControl = TheWindow

        -- repaint the window
        call_proc(drawIt_id,{})
        bitBlt(Design, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        end if
        if offsetActive then
            bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
        end if
        toggleIt = 1

    else
        -- unselect in design window?

        -- see if toggling control without clicking on DesignPad
        prevPicked = picked

        picked = findButtonName(id, MasterList)

        if id=TheMenu
        or id=ThePopup
        or id=TheTimer then
            --do nothing
        else
            if not picked then
                ok = displayErrorMessage(51,{})
                setCheck(id, w32False)
                resetMultiDrop()
                return
            end if
        end if

        if picked=prevPicked then

            --toggle the control button
            if toggleIt then
                toggleIt = 0
            else
                toggleIt = 1
            end if

            if id=TheMenu
            or id=ThePopup
            or id=TheTimer then
                setCheck(id, toggleIt)
                if not isChecked(id) then
                    picked = Pointer
                    setCheck(id, w32True)
                    return
                end if
            else
                setCheck(MasterList[prevPicked][ControlButton], toggleIt)
                if not isChecked(MasterList[prevPicked][ControlButton]) then
                    picked = Pointer
                    setCheck(MasterList[picked][ControlButton], w32True)
                    return
                end if
            end if

        else
            toggleIt = 1
            picked = prevPicked
            -- unselect prior
            if picked=TheMenu
            or picked=ThePopup
            or picked=TheTimer then
                setCheck(picked, w32False)
            else
                setCheck(MasterList[picked][ControlButton], w32False)
            end if
        end if

    end if

    -- get the index of the button in the control list
    picked = findButtonName(id, MasterList)

    if id=TheMenu then
        selectedControl = TheWindow
        setCheck(id, w32False)
        resetMultiDrop()

        -- open menu editor
        createMenuEditWindow()
        openWindow(MenuEditWindow, Modal)
    end if

    if id=ThePopup then
        selectedControl = TheWindow
        setCheck(id, w32False)
        resetMultiDrop()

        -- open popup editor
        createPopupEditWindow()
        openWindow(PopupEditWindow, Modal)
    end if

    if id=TheTimer then
        selectedControl = TheWindow
        setCheck(id, w32False)
        resetMultiDrop()

        -- open timer editor
        createTimerEditWindow()
        openWindow(TimerEditWindow, Modal)
    end if

    if not picked then
        ok = displayErrorMessage(52,{})
        setCheck(id, w32False)
        resetMultiDrop()
        return
    end if

end procedure
setHandler({TheBitmap,TheIcon,TheLText,TheEditText,TheMle,TheRichEdit,
            TheGroup,ThePushButton,TheCheckBox,TheRadio,TheCombo,TheList,
            TheHScroll,TheVScroll,TheCalendar,TheToolBar,TheNone,TheStatusBar,
            TheProgress,
            TheTabControl,TheTabItem,TheTreeView,TheListView,TheUpDown,TheTable,
            TheMenu,ThePopup,TheFlatBar,TheSepButton,TheReBar,TheReBarBand,TheTimer,
            TheChildWindow,TheEuGrid,TheLabelEdit,TheColoredButton},
           w32HClick, routine_id("toolButton_Click"))
------------------------------------------------------------------------------
function inResize(sequence control, integer x, integer y)

    -- return w32True if on control's resize
    -- assumes that the point is already in the control

    -- subtract offset from point
    x += WinX
    y = y+WinY-(MenuY+TitleY)

    if control[ControlLayer]!=layerNumber then
        return 0
    end if

    -- resize control is on lower right
    if x>control[X]+control[CX]-6
    and y>control[Y]+control[CY]-6 then
        return 1
    end if
    -- resize is on upper left
    if x<control[X]+6
    and y<control[Y]+6 then
        return 2
    end if
    --resize is on upper right
    if x>control[X]+control[CX]-6
    and y<control[Y]+6 then
        return 3
    end if
    --resize is on lower left
    if x<control[X]+6
    and y>control[Y]+control[CY]-6 then
        return 4
    end if
    --on right side
    if x>control[X]+control[CX]-6
    and x<control[X]+control[CX]
    and y>control[Y]
    and y<control[Y]+control[CY] then
        return 5
    end if
    --on left side
    if x<control[X]+6
    and x>=control[X]
    and y>control[Y]
    and y<control[Y]+control[CY] then
        return 6
    end if
    --on top
    if y>control[Y]
    and y<control[Y]+6
    and x>control[X]
    and x<control[X]+control[CX] then
        return 7
    end if
    --on bottom
    if y>control[Y]+control[CY]-6
    and y<control[Y]+control[CY]
    and x>control[X]
    and x<control[X]+control[CX] then
        return 8
    end if
    return 0

end function
-------------------------------------------------------------------------------
procedure buildChildrenList(integer index)
integer cnt

    cnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],controls[index][SeqChildName]) then
                childrenList &= {controls[i][Name]}
                if length(controls[i][SeqChildName]) then
                    buildChildrenList(i)
                end if
                cnt += 1
                if cnt>=length(controls[index][SeqChildName]) then
                    exit
                end if
            end if
        end for
    end if
end procedure
------------------------------------------------------------------------------
global function findHighestParent(integer x, integer y, integer index)
sequence name

-- x and y are from controls[i][X] and [Y] so do not need adjustment for
-- WinX or WinY-(MenuY+TitleY)
-- When called form LeftDown,Normal the x,y is adjusted prior to call

--find the highest parent (excluding the window) of the control being added

-- return the index of the highest parent the point is in
integer theControlParentIs
sequence theParentClassIs

    name = ""
    if index   --will be 0 for a new control
    and length(controls[index][SeqChildName]) then
        --build a list of children of this control & the childrens's children
        childrenList = {}
        buildChildrenList(index)
    end if
    if index then
        name = controls[index][Name]
    end if

    theControlParentIs = 0
    theParentClassIs = {}

    -- scan all controls
    for i=1 to length(controls) do

        --but there might be tabitems that the control is inside of that
        --supercede the tabcontrol.....
        --or tabcontrol was not found.....
        if  not find(controls[i][Class], {"Window","CWindow","TabControl"})
        and not find(controls[i][Name], childrenList)    --in a child
        and not equal(controls[i][Name], name)             --in itself
        and controls[i][ControlLayer]=layerNumber
        and inside(controls[i], x, y) then

            --if clicked in a tabitem check for the right one
            --remember they all occupy the same 'space' on a tabcontrol and only the
            --selectedTabItem Name or Title designates the currectly active one.
            if equal(controls[i][Class], "TabItem") then
                --is it the selectedtabItem
                if equal(controls[i][Name], selectedTabItem) then
                    theControlParentIs = i
                    theParentClassIs = controls[i][Class]
                end if
                --check if the tabitem is active
                if controls[i][Active] then
                    theControlParentIs = i
                    theParentClassIs = controls[i][Class]

                    --but check for another TabItem (from another TabControl) and
                    --see if it is also active. If so then it is the highest parent.
                    for j=1 to length(controls) do
                        if inside(controls[j], x, y)
                        and controls[j][ControlLayer]=layerNumber then
                            if find(controls[j][Class], {"TabControl","TabItem"}) then
                                if controls[j][Active] then
                                    theControlParentIs = j
                                    theParentClassIs = controls[j][Class]
                                end if
                            end if
                        end if
                    end for
                    return {theControlParentIs,theParentClassIs}
                end if

            elsif equal(controls[i][Class], "StatusBar")
               or equal(controls[i][Class], "Group")
               or equal(controls[i][Class], "ToolBar")
               or equal(controls[i][Class], "FlatToolBar")
               or equal(controls[i][Class], "ReBar")
               or equal(controls[i][Class], "Table")
               or equal(controls[i][Class], "CWindow")
               or equal(controls[i][Class], "EuGrid") then

                if equal(controls[i][ParentClass], "TabItem") then
                    --check if the tabitem is active
                    for j=1 to length(controls) do
                        if equal(controls[j][Name],
                                 controls[i][ControlParent])
                        and controls[j][Active] then
                            --this should apply only to groups, tables, tabcontrols on tabitem
                            theControlParentIs = i
                            theParentClassIs = controls[i][Class]
                            return {theControlParentIs,theParentClassIs}
                        end if
                    end for
                else
                    theControlParentIs = i
                    theParentClassIs = controls[i][Class]
                    return {theControlParentIs,theParentClassIs}
                end if

            end if

        end if

    end for

    return {theControlParentIs,theParentClassIs}
end function
------------------------------------------------------------------------------
sequence dropdown
integer litMenuItem

procedure lightDropdown(integer index, integer flag)


integer x1, y1, x2, y2, at
sequence newTitle

    -- skip zero index
    if index=0 then
        return
    end if

    -- get size
    x1 = dropdown[index][X]
    y1 = dropdown[index][Y]
    x2 = x1+dropdown[index][CX]
    y2 = y1+dropdown[index][CY]

    -- lit or unlit?
    if flag then
        setTextColor(ControlBlit, HighlightTextColor)
        setPenColor(ControlBlit, HighlightColor)
    else
        setTextColor(ControlBlit, TextColor)
        setPenColor(ControlBlit, MenuColor)
    end if

    -- background
    drawRectangle(ControlBlit, w32True, x1, y1, x2, y2)

    --draw arrow if a submenu
    if equal(dropdown[index][Class], "Submenu")
    or equal(dropdown[index][Class], "Sub2menu")
    or equal(dropdown[index][Class], "Sub3menu") then
        --draw a arrow mark
        setPenColor(ControlBlit, TextColor)
        if flag then
            setPenColor(ControlBlit, HighlightTextColor)
        end if
        drawLine(ControlBlit, x2-2, y1+7, x2-2, y1+12)
        drawLine(ControlBlit, x2-1, y1+8, x2-1, y1+11)
        drawLine(ControlBlit, x2, y1+9, x2,y1+8)
    end if

    -- display text
    setPenPos(ControlBlit, x1+16, y1+2)

    at = find(dropdown[index][Class], {"Submenu","Sub2menu","Sub3menu"})
    if at then
        setPenPos(ControlBlit, x1+16+(16*(at-1)), y1+2)
    end if

    at = find(dropdown[index][Class], {"SubmenuItem","Sub2menuItem","Sub3menuItem"})
    if at then
        setPenPos(ControlBlit, x1+16+(16*at), y1+2)
    end if

    newTitle = dropdown[index][Title]
    at = match("\\", newTitle)
    if at then
        newTitle = newTitle[1..at-1] &
                   " " & newTitle[at+2..length(newTitle)]
    end if
    wPuts(ControlBlit, newTitle)

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
    end if
end procedure
------------------------------------------------------------------------------
function inMenuBar(integer x, integer y)

-- returns w32True if click was in the menu bar
-- if w32True, builds a dropdown containing the menu items

integer x1, y1, x2, y2, hit, cx, cy, at
sequence extent, name

-- is there a menu?
    if MenuY=0 then
        return w32False
    end if

    -- extent of the menu
    x1 = 0
    y1 = TitleY-1
    x2 = x1+controls[TheWindow][CX]
    y2 = y1+MenuY-1



    -- missed the menu bar?
    if x<x1
    or x>x2
    or y<y1
    or y>y2 then
        -- outside menu bar
        return w32False
    end if

    -- what text item was hit?
    x1 += 8
    setMenuFont()
    hit = 0
    for i=1 to length(controls) do

        -- menu?
        if equal(controls[i][Class], "Menu")
        and controls[i][ControlLayer]=layerNumber then
            -- get size of text
            --first & is ignored by getTextExtent
            name = controls[i][Title]
            if find('&', name) then
                name &= "&"
            end if
            extent = getTextExtent(ControlBlit, name)
            x2 = x1+extent[1]

            -- in range?
            if  x>x1-4
            and x<x2+4 then
                -- hit!
                hit = i
                exit
            end if

            -- move ahead
            x1 += extent[1]+MenuSpacing

        end if
    end for

    -- no hit?
    if hit=0 then
        return w32False
    end if

    -- gather the menu items
    setMenuFont()

    cx = 0
    cy = 0
    dropdown = {}

    for i=hit+1 to length(controls) do

        if (equal(controls[i][Class], "MenuItem")
            or equal(controls[i][Class], "Submenu")
            or equal(controls[i][Class], "SubmenuItem")
            or equal(controls[i][Class], "Sub2menu")
            or equal(controls[i][Class], "Sub2menuItem")
            or equal(controls[i][Class], "Sub3menu")
            or equal(controls[i][Class], "Sub3menuItem"))
        and controls[i][ControlLayer]=layerNumber then

            -- add to list
            dropdown &= {controls[i]}

            --first & is ignored by getTextExtent
            name = controls[i][Title]
            if find('&', name) then
                name &= "&"
            end if

            -- get extent
            extent = getTextExtent(ControlBlit, name)

            -- largest so far?
            if find(controls[i][Class], {"Submenu","Sub2menu","Sub3menu"}) then
                --add 4 for possible arrow mark
                extent[1] += 4
            end if

            at = find(controls[i][Class], {"SubmenuItem","Sub2menuItem","Sub3menuItem"})
            if at then
                --add 16 for indentation
                extent[1] += 16*at
            end if

            if extent[1]>cx then
                cx = extent[1]
            end if

        else
            --keep reading menuitems and submenus
            if equal(controls[i][Class], "Menu") then
                -- finished with list
                exit
            end if
        end if
    end for

    -- no items?
    if length(dropdown)=0 then
        return w32False
    end if

    -- lit menu item color scheme
    setTextColor(ControlBlit, HighlightTextColor)
    setPenColor(ControlBlit, HighlightColor)

    -- light the text
    drawRectangle(ControlBlit, w32True, x1-4, y1+4, x2+4, y2)

    setPenPos(ControlBlit, x1, y1+4)
    wPuts(ControlBlit, controls[hit][Title])
    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
    end if

    -- calculate the size
    cy = length(dropdown)*(extent[2]+4)

    -- draw the dropdown
    drawButton(ControlBlit, x1-8, y2, cx+34, cy+8, w32False, MenuColor, 0, 0)

    -- render the dropdown, and save values
    x1 += 4
    y2 += 4

    for i=1 to length(dropdown) do

        -- save values
        dropdown[i][X] = x1-8
        dropdown[i][Y] = y2
        dropdown[i][CX] = cx+24
        dropdown[i][CY] = (extent[2]+4)

        -- move to next menu item
        y2 += extent[2]+4

    end for

    -- no item is lit
    litMenuItem = 0

    -- display the menu items
    for i=1 to length(dropdown) do
        lightDropdown(i, w32False)
    end for

    return w32True

end function
------------------------------------------------------------------------------
function inDropdown(integer x, integer y)
    -- returns index of dropdown point falls into, if any

    for i=1 to length(dropdown) do
        -- hit test
        if x>dropdown[i][X]
        and y>dropdown[i][Y] then
            if x<dropdown[i][X]+dropdown[i][CX]-1
            and y<dropdown[i][Y]+dropdown[i][CY]-1 then
                return i
            end if
        end if
    end for
    return w32False

end function
------------------------------------------------------------------------------
procedure checkIfAddedToText(sequence ctrl)
integer flag

    flag = inControl(ctrl[X], ctrl[Y])

    if find(controls[flag][Class], {"LText","RText","CText"})then
        if equal(ctrl[ControlParent], controls[flag][ControlParent]) then
            drawControl(ControlBlit, controls[flag], Borders,flag, 0)
        end if
    end if
end procedure
------------------------------------------------------------------------------
integer saveDragX,
        saveDragY,
        origX,
        origY,
        origCX,
        origCY,
        saveDragCX,
        saveDragCY,
        moveAndResize

    saveDragX = 0
    saveDragY = 0
    origX = 0
    origY = 0
    origCX = 0
    origCY = 0
    saveDragCX = 0
    saveDragCY = 0
    moveAndResize = 0

sequence reDrawTabItemControls, copyChildren
    copyChildren = {}

global integer MouseX, MouseY
integer ctrlMouse, tempControl, isCopyIndexed

ctrlMouse = w32False
----------------------------------------------------------------------------
procedure drawChildControls(integer index)
integer childCnt, withHatching
sequence OSControls2

    withHatching = w32False
    if hatchBackground
    and not GridHide then
        --hatch the menu bar
        withHatching = w32True
    end if

    childCnt = 0

    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],
                    controls[index][SeqChildName]) then
                childCnt += 1
                OSControls2 = controls[i]
                if OSControls2[X]<0 then
                    OSControls2[X] = dCX+controls[i][X]
                end if
                if OSControls2[Y]<0 then
                    OSControls2[Y] *= -1     --can't draw negative Y yet
                end if
                drawControl(OffScreenBlit, OSControls2, Normal,i, withHatching)
                if length(controls[i][SeqChildName]) then
                    drawChildControls(i)
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if
end procedure
----------------------------------------------------------------------------
procedure drawControlsInContainers(integer index)
integer childCnt, withHatching

    withHatching = w32False
    if hatchBackground
    and not GridHide then
        --hatch the menu bar
        withHatching = w32True
    end if

    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name], controls[index][SeqChildName]) then
                childCnt += 1
                if controls[i][ControlLayer]=controls[index][ControlLayer] then
                    if find(controls[i][Class],{"TabControl","TabItem"}) then
                        if controls[i][Active] then
                            drawControl(ControlBlit, controls[i], Normal, i, withHatching)
                        end if
                    else
                        if not controls[i][DontDraw] then
                            drawControl(ControlBlit, controls[i], Normal, i, withHatching)
                        end if
                        if find(controls[i][Class], {"LText","RText","CText"})
                        and length(controls[i][SeqChildName]) then
                            drawControl(ControlBlit, controls[i], Borders, i, withHatching)
                        end if
                    end if
                    if length(controls[i][SeqChildName]) then
                        drawControlsInContainers(i)
                    end if
                end if
                if childCnt>=length(controls[index][SeqChildName]) then
                    exit
                end if
            end if
        end for
    end if
end procedure
----------------------------------------------------------------------------
function walkSeqParentName(integer flag)
integer flag2

    if find(controls[flag][SeqParentClass], {"TabItem","TabControl"}) then
        flag2 = findSeqParentName(flag)
        if flag2 then
            if equal(controls[flag2][Name],getItem(TheTabItemCombo,getIndex(TheTabItemCombo))) then
                return w32True
            else
                --go up the SeqParentName string looking for a tabitem parent that matches the tabitem combo.
                ok = walkSeqParentName(flag2)
                if ok then
                    return w32True
                end if
            end if
        end if
    end if

    return w32False
end function
-----------------------------------------------------------------------------
integer userWantsResize userWantsResize = w32False
integer pasteX, pasteY
integer pasteControl--we need this because when right click in new location we might click into another
                                        --control which mouse_down will set to selected control.
integer rClickedControl, rSelectedWindow, rNewControl
sequence treedata
global procedure mouse_Design(integer Self, integer Event, sequence Params)
atom event, mouseX, mouseY, shift

integer flag, hit, x, y, inTitleBar, shiftMouse,
            winState, childCnt, flag2, controlnamelength, codestate
sequence whoIsStatus,
             whoIsParent,
             whoIsClass,
             whoIs, mouse, tmp, parent,name

sequence OSControls, OSControls2,sizeS,indexParent, extent, size1

    event = Params[1]
    mouseX = Params[2]
    mouseY = Params[3]
    shift = Params[4]

    textOrigName = ""

    if stopMouse then
        return
    end if

    reDrawTabItemControls = {}

    hit = 0
    treedata = {"",""}

    shiftMouse = w32False

    if event=LEFT_DOUBLECLICK then

        --deselect the control in the button bar
        -- unselect prior
        setCheck(MasterList[picked][ControlButton], w32False)

        dropMultipleTimes = w32False
        picked = Pointer

        --toggle on checkmark OFF
        setCheck(MenuClick, w32True)
        setText(IconOff, IDEText[208][1])   --"Off"

        -- what control got hit?
        x = mouseX+WinX
        y = mouseY+WinY-(MenuY+TitleY)

        selectedControl = inControl(x, y)

        --clear the backupControls for Undo
        backupControls = {}
        backupSelectedWindow = 1
        setEnable(MenuControlUndo, w32False)
        setEnable(PopUpDesign_Undo, w32False)
        setVisible(ToolUndo, w32False)
        setVisible(ToolUndoD, w32True)


        if not CodeWinOpen then
            codestate = HowOpenCodeWin()
            CodeWinOpen = w32True
            if codestate=0 then
                --some error
                showWindow(CodeWin, SW_RESTORE)
            elsif codestate=1 then
                showWindow(CodeWin, SW_MAXIMIZE)
            elsif codestate=2 then
                showWindow(CodeWin, SW_MINIMIZE)
            elsif codestate=3 then
                showWindow(CodeWin, SW_NORMAL)
                size1 = getRect(Controls)
                setRect(CodeWin, size1[1]+codePosition[1]+borderX,
                        size1[2]+codePosition[2]+titleBar+menuBar+borderX,
                        codePosition[3], codePosition[4], w32True)
            else
                showWindow(CodeWin, SW_NORMAL)
            end if
        elsif isMinimized(CodeWin) then
            showWindow(CodeWin, SW_RESTORE)
        end if
        setIndex(CodeControls,selectedControl)
        ok = invokeHandler(CodeControls,w32HClick,{})

    -- handle the event
    elsif  event=RIGHT_DOWN
      and state=Normal then

        -- what control got hit?
        x = mouseX+WinX
        y = mouseY+WinY-(MenuY+TitleY)

        if isEnabled(PopUpDesign_Paste) then
            pasteControl = inControl(x, y)
        end if

        if controls[selectedControl][ControlLayer]=layerNumber then
            drawControl(ControlBlit,controls[selectedControl],Normal,selectedControl, 0)
        end if

        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            call_proc(drawHiddenControls_id,{selectedControl})
        end if

        selectedControl = inControl(x, y)

        if find(controls[selectedControl][Class], {"Menu","MenuItem","Submenu","SubmenuItem",
                                                   "Sub2menu","Sub2menuItem","Sub3menu","Sub3menuItem",
                                                   "Popup","PopupItem","Subpopup","SubpopupItem","Sub2popup","Sub2popupItem",
                                                   "Sub3popup","Sub3popupItem","Timer"}) then
            return
        end if

        -- unselect prior
        setCheck(MasterList[picked][ControlButton], w32False)

        --deselect the control in the button bar
        dropMultipleTimes = w32False
        picked = Pointer

        --toggle on checkmark OFF
        setCheck(MenuClick, w32True)
        setText(IconOff, IDEText[208][1])   --"Off"

        if and_bits(shift, ShiftMask)
        or and_bits(shift, ControlMask)  then
            --do nothing
        else

            --if selected control is a tabitem, did user click on a title?
            if equal(controls[selectedControl][Class], "TabItem") then

                -- is there a menu?
                for i=1 to length(controls) do
                    if equal(controls[i][Class], "Menu") then
                        y += MenuY
                        exit
                    end if
                end for


                for i=1 to length(tabItemCoordinates) do
                    if x>=tabItemCoordinates[i][1] and x<tabItemCoordinates[i][3]
                    and y>=tabItemCoordinates[i][2] and y<tabItemCoordinates[i][4] then
                        for k=1 to length(controls) do
                            if equal(tabItemCoordinates[i][5], controls[k][Name]) then
                                --got a hit so update tabItemCombo if different
                                if equal(tabItemCoordinates[i][5], selectedTabItem) then
                                    exit
                                else
                                    for j=1 to getCount(TheTabItemCombo) do
                                        if equal(tabItemCoordinates[i][5], getItem(TheTabItemCombo, j)) then
                                            setIndex(TheTabItemCombo, j)
                                            ok = invokeHandler(TheTabItemCombo,w32HChange,{})
                                            exit
                                        end if
                                    end for
                                end if
                                exit
                            end if
                        end for
                        exit
                    end if
                end for
            end if

            --save mouse x and y for Popup display
            MouseX = mouseX
            MouseY = mouseY

            mouse = getPointerRelPos(Design)

            if find(controls[selectedControl][Class], {"Window","CWindow"}) then
                setText(PopUpDesign_Styles, IDEText[717][1])--"Window Styles Explorer")
                setEnable(PopUpDesign_Styles, w32True)
            elsif equal(controls[selectedControl][Class], "ListView") then
                setText(PopUpDesign_Styles, IDEText[1049][1])--"ListView Styles Explorer")
                setEnable(PopUpDesign_Styles, w32True)
            else
                setText(PopUpDesign_Styles, IDEText[1050][1])--"Unavailable")
                setEnable(PopUpDesign_Styles, w32False)
            end if

            --show which tabcontrol or control
            if equal(controls[selectedControl][Class], "TabItem")
            or equal(controls[selectedControl][Class], "TabControl") then
                setEnable(PopUpDesign_DeleteCtrl, w32False)
                setEnable(PopUpDesign_DeleteTabControl, w32True)
                setEnable(PopUpDesign_DeleteTabItem, w32True)
                setEnable(PopUpDesign_Table, w32False)
                setEnable(PopUpDesign_FullSize, w32False)
            else
                setEnable(PopUpDesign_DeleteCtrl, w32True)
                setEnable(PopUpDesign_DeleteTabControl, w32False)
                setEnable(PopUpDesign_DeleteTabItem, w32False)
                setEnable(PopUpDesign_FullSize, w32False)
                setEnable(PopUpDesign_Table, w32False)

                if equal(controls[selectedControl][Class], "Table") then
                    --dont show Table specs on popup unless there is at least
                    --one sub for the table
                    for i=selectedControl to length(controls) do
                        if find(controls[i][Name],
                                controls[selectedControl][SeqChildName]) then
                            setEnable(PopUpDesign_Table, w32True)
                            if not controls[selectedControl][FitToTable] then
                                setEnable(PopUpDesign_FullSize, w32True)
                            end if
                            exit
                        end if
                    end for

                elsif find(controls[selectedControl][Class],{"StatusBar","ToolBar",
                                                             "FlatToolBar","ReBar","ReBarBand"}) then
                    if isEnabled(PopUpDesign_Move) then
                        setEnable(PopUpDesign_Move, w32False)
                        setEnable(PopUpDesign_Copy, w32False)
                        setEnable(PopUpDesign_Paste, w32False)
                    end if

                elsif controls[selectedControl][TableCell] then
                    if isEnabled(PopUpDesign_Move) then
                        setEnable(PopUpDesign_Move, w32True)
                        setEnable(PopUpDesign_Copy, w32False)
                        setEnable(PopUpDesign_Paste, w32False)
                    end if

                elsif equal(controls[selectedControl][Class], "Window") then
                    setEnable(PopUpDesign_DeleteCtrl,w32False)
                    setEnable(PopUpDesign_Layers, w32False)
                    if isEnabled(PopUpDesign_Move) then
                        setEnable(PopUpDesign_Move, w32False)
                        setEnable(PopUpDesign_Copy, w32False)
                        setEnable(PopUpDesign_Paste, w32False)
                    end if


                    --check if have offscreen controls
                    haveOffscreen = w32False
                    for i=1 to length(controls) do
                        if controls[i][X]<0 then
                            haveOffscreen = w32True
                            exit
                        end if
                    end for

                    if not showActive then
                        setEnable(PopUpDesign_FullSize, w32True)
                    end if
                    if haveOffscreen then
                        setEnable(PopUpDesign_OffScreen, w32True)

                        if offsetActive then
                            setEnable(PopUpDesign_OffScreen, w32False)
                        end if
                    else
                        setEnable(PopUpDesign_OffScreen, w32False)
                    end if
                    if length(layerTabItemSeq)>1
                    and layerNumber!=0
                    and layerNumber!= -1 then
                        setEnable(PopUpDesign_Layers, w32True)
                    end if
                end if
            end if

            --save mouse position for paste routine
            pasteX = mouse[1]
            pasteY = mouse[2]

            setEnable(PopUpDesign_CodeEditor, w32True)
            popup(PopUpDesign, mouse[1], mouse[2])
        end if

    elsif event=LEFT_DOWN
      and   state=Normal
      and   inMenuBar(mouseX, mouseY) then
        -- click was in menu bar
        state = MenuPick

    elsif  event=LEFT_DOWN
      and    state=Normal
      and    picked!=Pointer then

        -- unselect the current control
        if selectedControl!=TheWindow
        and controls[selectedControl][ControlLayer]=layerNumber then

            -- draw it as normal
            if controls[selectedControl][X]>=0
            and controls[selectedControl][Y]>=0 then
                drawControl(ControlBlit, controls[selectedControl], Normal,selectedControl, 0)
                if length(controls[selectedControl][SeqChildName]) then
                    drawControlsInContainers(selectedControl)
                end if
                if thelayerNumber           --drawing layer 1..n
                and (find(0,showBackLayer)  --with base layer as background
                     or backgroundlayer=0) then
                    --does layer 1..n have controls hiding layer 0 control?
                    call_proc(drawHiddenControls_id,{selectedControl})
                end if
            end if

            -- nothing selected
            selectedControl = TheWindow
        else
            selectedControl = TheWindow
        end if

        -- add the new control
        -- what control got hit?

        x = mouseX+WinX
        y = mouseY+WinY-(MenuY+TitleY)

        if y>controls[TheWindow][CY]
        or x>controls[TheWindow][CX] then
            ok = displayErrorMessage(77,{})
            if dropMultipleTimes=w32False then
                -- unselect prior
                setCheck(MasterList[picked][ControlButton], w32False)
            end if
            resetMultiDrop()
            return
        end if

        --statusbar must be dropped onto Window or Cwindow
        if equal(ControlList[picked][ControlClass], "StatusBar") then
            flag = inControl(x,y)
            if flag!=1
            and not equal(controls[flag][Class], "CWindow") then
                ok = displayErrorMessage(253,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if
        end if

        if equal(ControlList[picked][ControlClass], "StatusBar") then
            for i=1 to length(controls) do
                if equal(controls[i][Class], "StatusBar") then
                    flag = inControl(x,y)
                    if flag then
                        if equal(controls[flag][Class], "Window")
                        and not length(controls[i][SeqParentName])
                        and controls[i][ControlLayer]=layerNumber then
                            ok = displayErrorMessage(55,{})
                            if dropMultipleTimes=w32False then
                                -- unselect prior
                                setCheck(MasterList[picked][ControlButton], w32False)
                            end if
                            resetMultiDrop()
                            return
                        elsif equal(controls[flag][Class], "CWindow")
                          and equal(controls[i][SeqParentName],controls[flag][Name])
                          and controls[i][ControlLayer]=layerNumber then
                            ok = displayErrorMessage(55,{})
                            if dropMultipleTimes=w32False then
                                -- unselect prior
                                setCheck(MasterList[picked][ControlButton], w32False)
                            end if
                            resetMultiDrop()
                            return
                        end if
                    end if
                end if
            end for
        end if

        whoIsStatus = findHighestParent(x, y, 0)
        whoIsParent = ""
        whoIsClass = ""

        --Window or CWindow was found as highest parent:
        if not whoIsStatus[1] then
            --check for errors for special controls:

            if equal(ControlList[picked][ControlClass], "None") then
                ok = displayErrorMessage(161,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(ControlList[picked][ControlClass], "SepButton") then
                ok = displayErrorMessage(162,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(ControlList[picked][ControlClass], "TabItem") then
                flag = findTabItemParent(x,y)
                if not flag
                or not find(controls[flag][Class], {"TabControl","TabItem"}) then
                    --must drop tabitem on a tabcontrol or another tabitem
                    ok = displayErrorMessage(56,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
                whoIsStatus = {flag,"TabControl"}
            end if

            --maybe dropping something other than TabItem on the TabControl
            if not equal(ControlList[picked][ControlClass], "TabItem")
            and not equal(ControlList[picked][ControlClass], "TabControl") then
                flag = findTabItemParent(x,y)
                if flag
                and flag!=1 then
                    --this is an error
                    ok = displayErrorMessage(57,{ControlList[picked][ControlClass]})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            end if

            if equal(ControlList[picked][ControlClass], "TabControl") then
                flag = inControl(x,y)
                if flag
                and find(controls[flag][Class], {"Window","TabItem","CWindow"}) then
                    -- ok
                else
                    --must drop tabcontrol on the window, CWindow or tabItem
                    ok = displayErrorMessage(58,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            end if

            if equal(ControlList[picked][ControlClass], "ReBarBand") then
                --must drop on a rebar
                ok = displayErrorMessage(59,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(ControlList[picked][ControlClass], "ReBar") then
                flag = inControl(x,y)
                if flag
                and find(controls[flag][Class], {"Window","CWindow"}) then
                    -- ok
                else
                    --must drop Rebar on the window
                    ok = displayErrorMessage(60,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            end if

        end if

        --A control was found as highest parent:
        if whoIsStatus[1] then

            whoIsParent = controls[whoIsStatus[1]][Name]
            whoIsClass = whoIsStatus[2]

            if equal(ControlList[picked][ControlClass], "None")
            and not equal(controls[whoIsStatus[1]][Class], "ToolBar") then
                ok = displayErrorMessage(161,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(ControlList[picked][ControlClass], "SepButton")
            and not equal(controls[whoIsStatus[1]][Class], "FlatToolBar") then
                ok = displayErrorMessage(162,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if


            if equal(controls[whoIsStatus[1]][Class], "TabItem")
            and equal(ControlList[picked][ControlClass], "TabItem") then
                --set whoIsStatus[1] to TabItem Parent
                flag = findSeqParentName(whoIsStatus[1])
                if flag then
                    whoIsStatus[1] = flag
                    whoIsStatus[2] = "TabControl"
                end if
            end if

            if equal(ControlList[picked][ControlClass], "StatusBar")
            and find(whoIsClass,{"ReBar","ReBarBand"}) then
                ok = displayErrorMessage(62,{ControlList[picked][ControlClass]})

                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(ControlList[picked][ControlClass], "CWindow")
            and not equal(whoIsClass, "CWindow") then
                ok = displayErrorMessage(43,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(ControlList[picked][ControlClass], "ReBarBand")
            and not find(whoIsStatus[2], {"ReBar","CWindow"})  then
                --must drop Rebar on the window
                ok = displayErrorMessage(59,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(ControlList[picked][ControlClass], "TabControl") then
                --after first tabControl on Window, all others are on a TabItem
                --and it is the selectedTabItem
                whoIsParent = selectedTabItem
                whoIsClass = "TabItem"
            end if

            --make sure if parent is TabControl, this control being added is
            --a TabItem
            if equal(whoIsStatus[2], "TabControl")
            and not equal(ControlList[picked][ControlClass], "TabItem") then
                ok = displayErrorMessage(61,{ControlList[picked][ControlClass],
                                             controls[whoIsStatus[1]][Name]})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(whoIsStatus[2], "FlatToolBar")
            and not find(ControlList[picked][ControlClass], {"PushButton",
                                                             "TogglePicture","PictureButton","SepButton"}) then
                ok = displayErrorMessage(65,{ControlList[picked][ControlClass]})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(whoIsStatus[2], "Table")
            and equal(ControlList[picked][ControlClass], "Table") then
                ok = displayErrorMessage(66,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if equal(whoIsStatus[2], "Table")
            and equal(ControlList[picked][ControlClass], "Group") then
                ok = displayErrorMessage(67,{})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            whoIs = findDirectParent(x, y, controls[whoIsStatus[1]][Name],
                                     "1",0) --no Name yet

            if whoIs[1] then
                if equal(whoIs[2],"ReBar")
                and not equal(ControlList[picked][ControlClass], "ReBarBand") then
                    ok = displayErrorMessage(59,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            end if
            if whoIs[1] then
                if equal(whoIs[2], "Table")
                and equal(ControlList[picked][ControlClass], "Table") then
                    ok = displayErrorMessage(68,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            end if

            if whoIs[1] then
                if equal(whoIs[2], "Table") then
                    --if there are cells other than 1, this is an error
                    if controls[whoIs[1]][TableCols]>1
                    or controls[whoIs[1]][TableRows]>1 then
                        ok = displayErrorMessage(69,{})
                        if dropMultipleTimes=w32False then
                            -- unselect prior
                            setCheck(MasterList[picked][ControlButton], w32False)
                        end if
                        resetMultiDrop()
                        return
                    end if
                end if
            end if

            if whoIs[1] and equal(whoIs[2], "FlatToolBar")
            and not find(ControlList[picked][ControlClass], {"PushButton",
                                                             "TogglePicture","PictureButton","SepButton"}) then
                ok = displayErrorMessage(65,{ControlList[picked][ControlClass]})
                if dropMultipleTimes=w32False then
                    -- unselect prior
                    setCheck(MasterList[picked][ControlButton], w32False)
                end if
                resetMultiDrop()
                return
            end if

            if find(ControlList[picked][ControlClass], {"ToolBar","FlatToolBar"}) then
                --multiple toolbars are allowed but only if on rebar and CWindow
                for i=1 to length(controls) do
                    if find(controls[i][Class], {"ToolBar","FlatToolBar"})
                    and equal(controls[whoIs[1]][Name], controls[i][ControlParent]) then
                        ok = displayErrorMessage(70,{})
                        if dropMultipleTimes=w32False then
                            -- unselect prior
                            setCheck(MasterList[picked][ControlButton], w32False)
                        end if
                        resetMultiDrop()
                        return
                    end if
                end for
            end if

            if equal(ControlList[picked][ControlClass], "StatusBar") then
                for i=1 to length(controls) do
                    if equal(controls[i][Class], "StatusBar")
                    and equal(controls[whoIs[1]][Name], controls[i][ControlParent]) then
                        ok = displayErrorMessage(71,{})
                        if dropMultipleTimes=w32False then
                            -- unselect prior
                            setCheck(MasterList[picked][ControlButton], w32False)
                        end if
                        resetMultiDrop()
                        return
                    end if
                end for
            end if

            --make sure if this is a tabItem being added we dont
            --assign its parent to anything other than a tabControl
            if equal(ControlList[picked][ControlClass], "TabItem") then
                --was the highest parent a tabItem:
                if equal(whoIsStatus[2], "TabItem") then
                    --go get the parent name from the existing tabItem
                    flag = findTabItemParent(x,y)
                    if equal(controls[flag][Class], "TabControl") then
                        whoIsStatus[1] = flag
                        whoIsStatus[2] = controls[flag][Class]
                        whoIsParent = controls[flag][Name]
                        whoIsClass = controls[flag][Class]
                    else
                        whoIsParent = controls[whoIsStatus[1]][ControlParent]
                        whoIsClass = controls[whoIsStatus[1]][ParentClass]
                    end if
                else
                    --First tab on tab control.....
                    flag = findTabItemParent(x,y)
                    if equal(controls[flag][Class], "TabControl") then
                        if equal(controls[flag][ControlParent], selectedTabItem) then
                            whoIsStatus[1] = flag
                            whoIsParent = controls[flag][Name]
                            whoIsStatus[2] = "TabControl"
                            whoIsClass = "TabControl"
                        else
                            whoIsParent = controls[flag][Name]
                            whoIsClass = controls[flag][Class]
                        end if
                    elsif equal(controls[flag][Class], "TabItem")
                      and equal(controls[flag][Name], selectedTabItem) then
                        whoIsParent = controls[flag][ControlParent]
                        whoIsClass = controls[flag][ParentClass]
                    end if
                end if

                --if highest parent was not tabcontrol or tabitem then an error
                if not find(whoIsStatus[2], {"TabControl","TabItem","CWindow"}) then
                    --dont assign a parent
                    ok = displayErrorMessage(72,{whoIsStatus[2]})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if

            --if ToolBar is being added to any container except ReBarBand or CWindow,
            --flag as an error
            elsif find(ControlList[picked][ControlClass], {"ToolBar","FlatToolBar"}) then
                if find(whoIsStatus[2], {"ReBar","CWindow"})
                and whoIs[1] and find(whoIs[2], {"ReBarBand","CWindow"}) then
                    whoIsParent = controls[whoIsStatus[1]][Name]
                    whoIsClass = whoIsStatus[2]
                else
                    ok = displayErrorMessage(73,{whoIsStatus[2]})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if

            elsif equal(ControlList[picked][ControlClass], "TabControl") then
                --highest parent of tabcontol has to be Window or a TabItem
                if not find(whoIsStatus[2], {"Window","TabItem","CWindow"}) then
                    ok = displayErrorMessage(74,{whoIsStatus[2]})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            elsif not find(ControlList[picked][ControlClass], validEuGridChild)
              and equal(whoIsStatus[2], "EuGrid") then
                --an exception to this is selected List which is immediately converted to DropDownList
                if equal(ControlList[picked][ControlClass], "List") then
                    --ok
                else
                    ok = displayErrorMessage(232,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            elsif not find(ControlList[picked][ControlClass], validEuGridChild)
              and equal(whoIs[2], "EuGrid") then
                --an exception to this is selected List which is immediately converted to DropDownList
                if equal(ControlList[picked][ControlClass], "List") then
                    --ok
                else
                    ok = displayErrorMessage(232,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            else
                if whoIs[1]
                and equal(controls[whoIs[1]][SeqParentClass], "EuGrid") then
                    ok = displayErrorMessage(233,{})
                    if dropMultipleTimes=w32False then
                        -- unselect prior
                        setCheck(MasterList[picked][ControlButton], w32False)
                    end if
                    resetMultiDrop()
                    return
                end if
            end if

        end if

        --backup controls for undo or restore
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)

        newControl(picked, snap(mouseX), snap(mouseY), whoIsParent,
                   whoIsClass,whoIsStatus[1])

        if rejected then
            if dropMultipleTimes=w32False then
                -- unselect prior
                setCheck(MasterList[picked][ControlButton], w32False)
                resetMultiDrop()
            end if
            return
        end if

        --if added a TabControl, automatically create first tab
        if equal(controls[length(controls)][Class], "TabControl") then
            --first add to ProjectView
            if length(controls[length(controls)][SeqParentName]) then
                parent = controls[length(controls)][SeqParentName]
                addTreeViewNode(parent,
                                controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}
            else
                addTreeViewNode(controls[1][Name],
                                controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}
            end if
            --now add tabitem
            newControl(picked+1, snap(mouseX+1), snap(mouseY+1),
                       controls[length(controls)][Name],"TabControl", length(controls))
        end if

                --if added a ReBar, automatically create first ReBarBand
        if equal(controls[length(controls)][Class], "ReBar") then
            --first add to ProjectView
            if length(controls[length(controls)][SeqParentName]) then
                parent = controls[length(controls)][SeqParentName]
                addTreeViewNode(parent,
                                controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}
            else
                addTreeViewNode(controls[1][Name],
                                controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}
            end if
            --now add tabitem
            newControl(picked+1, snap(mouseX+1), snap(mouseY+1),
                       controls[length(controls)][Name],"ReBar", length(controls))
        end if

        if equal(controls[length(controls)][Class], "List")
        and equal(controls[length(controls)][SeqParentClass], "EuGrid") then
            controls[length(controls)][Class] = "DropDownList"
        end if

        -- draw it
        drawControl(ControlBlit, controls[length(controls)], Normal,
                    length(controls), 0)

        inTitleBar = isInCWindowTitleBar(controls, length(controls))
        if inTitleBar then
            ok = displayErrorMessage(251,{})
        end if
        --if this control was dropped onto Text then draw Text with Borders
        checkIfAddedToText(controls[length(controls)])

        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            call_proc(drawHiddenControls_id,{length(controls)})
        end if

        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)

        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        if offsetActive then
            bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        -- update properties
        notifyNewControl = w32True      --03-19                
        selectedControl = TheWindow
        call_proc(updateProperties_id,{})
        notifyNewControl = w32False     --03-19

        --Test if icon multiple drop is on or off
        if dropMultipleTimes=w32False then
            -- unselect prior
            setCheck(MasterList[picked][ControlButton], w32False)
            resetMultiDrop()
        end if

        if length(controls[length(controls)][ControlParent])
        or length(controls[length(controls)][SeqParentName]) then
            parent = controls[length(controls)][SeqParentName]
            addTreeViewNode(parent,
                            controls[length(controls)][Name])
            treedata[1] = controls[length(controls)][Name]
            treedata[2] = controls[length(controls)][Class]
            theTreeForm &= {treedata}
        else
            addTreeViewNode(controls[1][Name],
                            controls[length(controls)][Name])
            treedata[1] = controls[length(controls)][Name]
            treedata[2] = controls[length(controls)][Class]
            theTreeForm &= {treedata}
        end if

        --insure control in Code Editor stays in sync with controls sequence after sort
        name = getItem(CodeControls,getIndex(CodeControls))
        controls = sort(controls)

        --reload CodeControls
        eraseItems(CodeControls)
        controlnamelength = 0
        for i=1 to length(controls) do
            addItem(CodeControls, controls[i][Name])
            if length(controls[i][Name])>controlnamelength then
                controlnamelength = length(controls[i][Name])
            end if
        end for
        extent = getTextExtent(CodeControls, "M")
        controlnamelength *= extent[1]
        VOID = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)

        for i=1 to getCount(CodeControls) do
            if equal(name, getItem(CodeControls,i)) then
                setIndex(CodeControls,i)
                editorSelectedControl = i
                exit
            end if
        end for

    elsif event=LEFT_DOWN
      and   state=Normal
      and   picked=Pointer then

        setEnable(PopUpDesign_Move, w32True)
        setEnable(PopUpDesign_Copy, w32True)
        setEnable(PopUpDesign_Paste, w32False)
        -- mouse down flag
        mouseDown = 1

        -- what control got hit?
        x = mouseX+WinX
        y = mouseY+WinY-(MenuY+TitleY)
        flag = inControl(x, y)

        if selectedControl=flag then
            -- is there a menu?
            for i=1 to length(controls) do
                if equal(controls[i][Class], "Menu") then
                    y += MenuY
                    exit
                end if
            end for

            --if selected control is a tabitem, did user click on a title?
            if equal(controls[selectedControl][Class], "TabItem") then
                for i=1 to length(tabItemCoordinates) do
                    if x>=tabItemCoordinates[i][1] and x<tabItemCoordinates[i][3]
                    and y>=tabItemCoordinates[i][2] and y<tabItemCoordinates[i][4] then
                        --got a hit so update tabItemCombo if different
                        if equal(tabItemCoordinates[i][5], selectedTabItem) then
                            exit
                        else
                            for j=1 to getCount(TheTabItemCombo) do
                                if equal(tabItemCoordinates[i][5], getItem(TheTabItemCombo, j)) then
                                    --make sure the parent of this tab is active since an
                                    --underlaying tab might be right under the click point
                                    for k=1 to length(controls) do
                                        if equal(controls[k][Name], getItem(TheTabItemCombo, j)) then
                                            if not length(controls[k][ControlParent])
                                            or equal(controls[k][ParentClass],"CWindow") then
                                                --Window was parent
                                                setIndex(TheTabItemCombo, j)
                                                ok = invokeHandler(TheTabItemCombo,w32HChange,{})
                                                return
                                            end if

                                            for m=1 to length(controls) do
                                                if equal(controls[k][ControlParent], controls[m][Name]) then
                                                    setIndex(TheTabItemCombo, j)
                                                    ok = invokeHandler(TheTabItemCombo,w32HChange,{})
                                                    return
                                                end if
                                            end for
                                            exit
                                        end if
                                    end for
                                end if
                            end for
                        end if
                    end if
                end for
            end if

        end if

        if selectedControl!=flag then
            --if selected control is a tabitem, did user click on a title?
            if equal(controls[flag][Class], "TabItem") then
                for i=1 to length(tabItemCoordinates) do
                    if x>=tabItemCoordinates[i][1] and x<tabItemCoordinates[i][3]
                    and y>=tabItemCoordinates[i][2] and y<tabItemCoordinates[i][4] then
                        for k=1 to length(controls) do
                            if equal(tabItemCoordinates[i][5], controls[k][Name]) then
                                --got a hit so update tabItemCombo if different
                                if equal(tabItemCoordinates[i][5], selectedTabItem) then
                                    exit
                                else
                                    for j=1 to getCount(TheTabItemCombo) do
                                        if equal(tabItemCoordinates[i][5], getItem(TheTabItemCombo, j)) then
                                            setIndex(TheTabItemCombo, j)
                                            ok = invokeHandler(TheTabItemCombo,w32HChange,{})
                                            return
                                        end if
                                    end for
                                end if
                            end if
                        end for
                    end if
                end for
            end if


            --if control clicked (flag) is a TabItem is it the correct one?
            if equal(controls[flag][Class], "TabItem") then
                if not equal(controls[flag][Name],getItem(TheTabItemCombo,getIndex(TheTabItemCombo))) then
                    mouseDown = 0
                    return
                end if
            end if

            --if control clicked (flag) has TabItem for parent, then check that it is right tabitem
            if equal(controls[flag][SeqParentClass], "TabItem") then
                flag2 = findSeqParentName(flag)
                if flag2 then
                    if not equal(controls[flag2][Name],getItem(TheTabItemCombo,getIndex(TheTabItemCombo))) then
                        --but go up the SeqParentName string looking for a tabitem parent that matches the tabitem combo.
                        ok = walkSeqParentName(flag2)

                        --if not found then bail out
                        if not ok then
                            mouseDown = 0
                            return
                        end if
                    end if
                end if
            elsif equal(controls[flag][ParentClass], "TabItem") then
                --this is a control inside a control on a tabitem
                for i=1 to length(controls) do
                    if equal(controls[flag][ControlParent], controls[i][Name]) then
                        if not equal(controls[i][Name],getItem(TheTabItemCombo,getIndex(TheTabItemCombo))) then
                            --check its parent for tab that matches tabitem combo
                            ok = walkSeqParentName(i)
                            --if not found then bail out
                            if not ok then
                                mouseDown = 0
                                return
                            end if
                        end if
                        exit
                    end if
                end for
            end if

            -- draw selected control as normal
            if controls[selectedControl][X]>=0
            and controls[selectedControl][Y]>=0
            and selectedControl!=TheWindow
            and controls[selectedControl][ControlLayer]=layerNumber then
                drawControl(ControlBlit, controls[selectedControl], Normal,selectedControl, 0)
                if length(controls[selectedControl][SeqChildName]) then
                    if find(controls[selectedControl][Class], {"LText","RText","CText"}) then
                        drawControl(ControlBlit, controls[selectedControl], Borders, selectedControl, 0)
                    end if
                    --draw any controls in the selected containers
                    drawControlsInContainers(selectedControl)
                end if
                if thelayerNumber           --drawing layer 1..n
                and (find(0,showBackLayer)  --with base layer as background
                     or backgroundlayer=0) then
                    --does layer 1..n have controls hiding layer 0 control?
                    call_proc(drawHiddenControls_id,{selectedControl})
                end if
            end if

            -- select
            selectedControl = flag

            if equal(controls[selectedControl][Class], "PictureButton") then
                if downButton=13 and length(controls[selectedControl][XpmObject]) then
                    drawControl(ControlBlit, controls[selectedControl], Normal,selectedControl,0)
                elsif downButton=14 and length(controls[selectedControl][XpmDisableObject]) then
                    drawControl(ControlBlit, controls[selectedControl], Normal,selectedControl,0)
                else
                    downButton = 1
                end if
            end if

            -- is there a menu?
            for i=1 to length(controls) do
                if equal(controls[i][Class], "Menu") then
                    y += MenuY
                    exit
                end if
            end for

            if selectedControl!=TheWindow then
                drawControl(ControlBlit, controls[selectedControl], Selected,selectedControl,0)
                if length(controls[selectedControl][SeqChildName]) then
                    if find(controls[selectedControl][Class], {"LText","RText","CText"}) then
                        drawControl(ControlBlit, controls[selectedControl], Borders,selectedControl,0)
                    end if
                    --draw any controls in the selected containers
                    drawControlsInContainers(selectedControl)
                    if thelayerNumber           --drawing layer 1..n
                    and (find(0,showBackLayer)  --with base layer as background
                         or backgroundlayer=0) then
                        --does layer 1..n have controls hiding layer 0 control?
                        call_proc(drawHiddenControls_id,{selectedControl})
                    end if
                end if
            end if

            --if selected control is a tabitem, did user click on a title?
            if equal(controls[selectedControl][Class], "TabItem") then
                for i=1 to length(tabItemCoordinates) do
                    if x>=tabItemCoordinates[i][1] and x<tabItemCoordinates[i][3]
                    and y>=tabItemCoordinates[i][2] and y<tabItemCoordinates[i][4] then
                        for k=1 to length(controls) do
                            if equal(tabItemCoordinates[i][5], controls[k][Name]) then
                                --got a hit so update tabItemCombo if different
                                if equal(tabItemCoordinates[i][5], selectedTabItem) then
                                    exit
                                else
                                    for j=1 to getCount(TheTabItemCombo) do
                                        if equal(tabItemCoordinates[i][5], getItem(TheTabItemCombo, j)) then
                                            setIndex(TheTabItemCombo, j)
                                            ok = invokeHandler(TheTabItemCombo,w32HChange,{})
                                            return
                                        end if
                                    end for
                                end if
                            end if
                        end for
                    end if
                end for
            end if
        end if

        call_proc(updateProperties_id,{})

        if flag=TheWindow then
            if hasPopup then
                selectedControl = TheWindow
                call_proc(drawIt_id,{})
            end if

            if getIndex(PropertyTitleBar)!=TheWindow then
                call_proc(updateProperties_id,{})
            end if
            mouseDown = 0
        end if

        if not userWantsResize then
            setMousePointer(Design, SizeAllPointer)--doesnt seem to work until leftUp on Win98SE
        end if
        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)

        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        if offsetActive then
            bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

    elsif event=MOUSE_MOVE
      and   state=Normal
      and   mouseDown
      and   inResize(controls[selectedControl], mouseX, mouseY) then
        if length(controls[selectedControl][SeqParentName])
        and equal(controls[selectedControl][SeqParentClass],"FlatToolBar") then
            ok = displayErrorMessage(48,{})
            mouseDown = 0
            return
        end if

        captureMouse(Design)
        if showActive then
            releaseMouse()
            captureMouse(Show)
        end if

        if offsetActive then
            releaseMouse()
            captureMouse(OffScreen)
        end if

        moveAndResize = w32False
        if inResize(controls[selectedControl], mouseX, mouseY)=1 then
            setMousePointer(Design, SizeNWSEPointer)
            if showActive then
                setMousePointer(Show, SizeNWSEPointer)
            end if
        elsif inResize(controls[selectedControl], mouseX, mouseY)=2 then
            setMousePointer(Design, SizeNWSEPointer)
            if showActive then
                setMousePointer(Show, SizeNWSEPointer)
            end if
            moveAndResize = 2
        elsif inResize(controls[selectedControl],mouseX,mouseY)=3 then
            setMousePointer(Design, SizeNESWPointer)
            if showActive then
                setMousePointer(Show, SizeNESWPointer)
            end if
            moveAndResize = 3
        elsif inResize(controls[selectedControl],mouseX,mouseY)=4 then
            setMousePointer(Design, SizeNESWPointer)
            if showActive then
                setMousePointer(Show, SizeNESWPointer)
            end if
            moveAndResize = 4
        elsif inResize(controls[selectedControl],mouseX,mouseY)=5 then
            setMousePointer(Design, SizeWEPointer)
            if showActive then
                setMousePointer(Show, SizeWEPointer)
            end if
            moveAndResize = 5
        elsif inResize(controls[selectedControl],mouseX,mouseY)=6 then
            setMousePointer(Design, SizeWEPointer)
            if showActive then
                setMousePointer(Show, SizeWEPointer)
            end if
            moveAndResize = 6
        elsif inResize(controls[selectedControl],mouseX,mouseY)=7 then
            setMousePointer(Design, SizeNSPointer)
            if showActive then
                setMousePointer(Show, SizeNSPointer)
            end if
            moveAndResize = 7
        elsif inResize(controls[selectedControl],mouseX,mouseY)=8 then
            setMousePointer(Design, SizeNSPointer)
            if showActive then
                setMousePointer(Show, SizeNSPointer)
            end if
            moveAndResize = 8
        end if

        --save back of controls
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)

        -- start of resize drag
        state = ResizeDrag
        dragCX      = controls[selectedControl][CX]-mouseX
        dragCY      = controls[selectedControl][CY]-mouseY
        origCX   = controls[selectedControl][CX]-mouseX
        saveDragCX = controls[selectedControl][CX]
        saveDragCY = controls[selectedControl][CY]

        --save start of moveAndResize
        if moveAndResize then
            dragX = controls[selectedControl][X]-mouseX
            dragY = controls[selectedControl][Y]-mouseY

            --save starting position of control for moving subcontrols
            --or replacing to original position if move is later denied
            --   in LEFT_UP
            saveDragX = controls[selectedControl][X]
            saveDragY = controls[selectedControl][Y]
            origX  = controls[selectedControl][X]
            origY  = controls[selectedControl][Y]
            origCX = controls[selectedControl][CX]
            origCY = controls[selectedControl][CY]
        end if

    elsif event=MOUSE_MOVE
      and   state=Normal
      and   mouseDown then

        rSelectedWindow = selectedWindow

        if userWantsResize then
            return
        end if

        captureMouse(Design)
        if showActive then
            releaseMouse()
            captureMouse(Show)
        end if

        if offsetActive then
            releaseMouse()
            captureMouse(OffScreen)
        end if

        setMousePointer(Design, SizeAllPointer)
        if showActive then
            setMousePointer(Show, SizeAllPointer)
        end if

        --backup controls
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)
        -- start of move drag
        state = MoveDrag
        dragX = controls[selectedControl][X]-mouseX
        dragY = controls[selectedControl][Y]-mouseY

        --save starting position of control for moving subcontrols
        --or replacing to original position if move is later denied
        --   in LEFT_UP
        saveDragX = controls[selectedControl][X]
        saveDragY = controls[selectedControl][Y]
        origX  = controls[selectedControl][X]
        origY  = controls[selectedControl][Y]
        saveDragCX = controls[selectedControl][CX]
        saveDragCY = controls[selectedControl][CY]
        origCX = controls[selectedControl][CX]
        origCY = controls[selectedControl][CY]

        isCopyIndexed = w32False
        --was ctrl key held down when move was made?
        if and_bits(shift, ControlMask) then
            -- ctrl is held down

            --if control is not a container then ask if it is to be indexed to the copy from control
            indexParent = {}
            if not length(controls[selectedControl][IndexParent])
            and not equal(controls[selectedControl][ParentClass], "Table") then
                if copyIndexSw
                and not find(controls[selectedControl][Class], {"ToolBar","FlatToolBar","ReBar","ReBarBand",
                                                                "StatusBar","Table"}) then
                    if not length(controls[selectedControl][IndexParent]) then
                        ok = displayErrorMessage(208,{})
                        if ok=IDYES then
                            controls[selectedControl][Indexed] = w32True
                            indexParent = controls[selectedControl][Name]
                            isCopyIndexed = w32True
                        end if
                    end if
                end if
            end if
            ctrlMouse = w32True

            --hold original control for moving subs
            tempControl = selectedControl

            --check for valid coping
            if equal(controls[selectedControl][Class], "ToolBar")
            or equal(controls[selectedControl][Class], "StatusBar")
            or equal(controls[selectedControl][Class], "FlatToolBar")
            or equal(controls[selectedControl][Class], "ReBar")
            or equal(controls[selectedControl][Class], "ReBarBand") then
                ok = displayErrorMessage(75,{})
                state = Normal
                mouseDown = 0
                --reset pointer
                setMousePointer(Design, NULL)
                if showActive then
                    setMousePointer(Show, NULL)
                end if
                return
            end if

            --may not copy a cell of Table
            if controls[selectedControl][TableCell] then
                ok = displayErrorMessage(76,{})
                state = Normal
                mouseDown = 0
                setMousePointer(Design, NULL)
                if showActive then
                    setMousePointer(Show, NULL)
                end if
                return
            end if

            if equal(controls[selectedControl][Class], "TabItem") then
                ok = displayErrorMessage(181,{})
                if ok=IDNO then
                    --want tabControl and all tabitems
                    for i=selectedControl to 1 by -1 do
                        if equal(controls[i][Name], controls[selectedControl][ControlParent]) then
                            selectedControl = i
                            tempControl = i
                            if isCopyIndexed then
                                controls[selectedControl][Indexed] = w32True
                                indexParent = controls[selectedControl][Name]
                            end if
                            exit
                        end if
                    end for
                end if
            end if

            --create new control, if later find we couldn't copy it then it gets
            --deleted
            makeCopyControl(controls[selectedControl][X], controls[selectedControl][Y],
                            controls[selectedControl][CX], controls[selectedControl][CY],
                            controls[selectedControl][Class],
                            controls[selectedControl][Name],
                            controls[selectedControl][Title], controls[selectedControl][OrigTitle],
                            indexParent) --for IndexParent                    

            if equal(controls[selectedControl][Class], "TabItem")
            and ok=IDYES then
                --add tabitem title to tabitem combo
                addItem(TheTabItemCombo, controls[length(controls)][Title])
                setIndex(TheTabItemCombo, getCount(TheTabItemCombo))
            end if

            if equal(controls[selectedControl][Class], "EuGrid") then
                controls[length(controls)][BkColor] = controls[selectedControl][BkColor]
                controls[length(controls)][GridHeaderColor] = controls[selectedControl][GridHeaderColor]
                controls[length(controls)][GridColHeaderCY] = controls[selectedControl][GridColHeaderCY]
                controls[length(controls)][GridRowHeaderCX] = controls[selectedControl][GridRowHeaderCX]
                controls[length(controls)][GridHeaderType] = controls[selectedControl][GridHeaderType]
            end if

            controls[length(controls)] = copyControlProperties(controls[length(controls)], controls[selectedControl])

            if length(controls[length(controls)][ControlParent]) then
                addTreeViewNode(controls[length(controls)][SeqParentName],
                                controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}
            else
                addTreeViewNode(controls[1][Name],
                                controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}
            end if

            --use new index for selectedControl in verification tests
            selectedControl = length(controls)
        else
            ctrlMouse = w32False
        end if

    elsif event=MOUSE_MOVE
      and   state=MoveDrag then

        if isChecked(MenuFormLock)
        and not ctrlMouse then
            state = Normal
            mouseDown = 0
            --reset pointer
            setMousePointer(Design, NULL)
            if showActive then
                setMousePointer(Show, NULL)
            end if
        elsif find(controls[selectedControl][Class], {"ReBar","ReBarBand"}) then
            ok = displayErrorMessage(78,{})
            call_proc(updateProperty_id,{"Row"})
            state = Normal
            mouseDown = 0
            --reset pointer
            setMousePointer(Design, NULL)
            if showActive then
                setMousePointer(Show, NULL)
            end if
        else
            -- mask the prior control
            drawControl(ControlBlit, controls[selectedControl], Dragging,selectedControl,0)

            -- drag the control
            controls[selectedControl][X] = (dragX+mouseX)
            controls[selectedControl][Y] = (dragY+mouseY)

            -- snap to grid
            controls[selectedControl][X] = snap(controls[selectedControl][X])
            controls[selectedControl][Y] = snap(controls[selectedControl][Y])


            --was the control being moved the ReBar?
            if equal(controls[selectedControl][Class], "ReBar") then
                controls[selectedControl][X] = 0
                controls[selectedControl][Y] = 0
            end if

            -- display it
            drawControl(ControlBlit, controls[selectedControl], Dragging,selectedControl,0)

            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
            if showActive then
                bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
            end if

            if offsetActive then
                bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
            end if

        end if

    elsif event=MOUSE_MOVE
      and   state=ResizeDrag then

        -- mask the prior control
        drawControl(ControlBlit, controls[selectedControl], Dragging,selectedControl,0)

        if moveAndResize=2 then
            controls[selectedControl][X] = dragX+mouseX
            controls[selectedControl][Y] = dragY+mouseY
            -- snap to grid
            controls[selectedControl][X] = snap(controls[selectedControl][X])
            controls[selectedControl][Y] = snap(controls[selectedControl][Y])
            controls[selectedControl][CX] = (origX-controls[selectedControl][X])+origCX
            controls[selectedControl][CY] = (origY-controls[selectedControl][Y])+origCY
        end if
        if moveAndResize=3 then
            controls[selectedControl][Y] = dragY+mouseY
            controls[selectedControl][Y] = snap(controls[selectedControl][Y])
            controls[selectedControl][CX] = ((dragX+mouseX)-origX)+origCX
            controls[selectedControl][CY] = (origY-(controls[selectedControl][Y]))+origCY
        end if
        if moveAndResize=4 then
            controls[selectedControl][X] = dragX+mouseX
            controls[selectedControl][X] = snap(controls[selectedControl][X])
            controls[selectedControl][CX] = (origX-controls[selectedControl][X])+origCX
            controls[selectedControl][CY] = ((dragY+mouseY)-origY)+origCY
        end if
        if moveAndResize=5 then
            controls[selectedControl][CX] = ((dragX+mouseX)-origX)+origCX
        end if
        if moveAndResize=6 then
            controls[selectedControl][X] = dragX+mouseX
            controls[selectedControl][X] = snap(controls[selectedControl][X])
            controls[selectedControl][CX] = (origX-controls[selectedControl][X])+origCX
        end if
        if moveAndResize=7 then
            controls[selectedControl][Y] = dragY+mouseY
            controls[selectedControl][Y] = snap(controls[selectedControl][Y])
            controls[selectedControl][CY] = (origY-controls[selectedControl][Y])+origCY
        end if
        if moveAndResize=8 then
            controls[selectedControl][CY] = ((dragY+mouseY)-origY)+origCY
        end if
        if not moveAndResize then
            -- drag the control
            controls[selectedControl][CX] = (dragCX+mouseX)

            --may not resize rebar and band CY
            if not find(controls[selectedControl][Class], {"ReBar","ReBarBand"}) then
                controls[selectedControl][CY] = (dragCY+mouseY)
            end if
        end if

        -- minimum x size
        if controls[selectedControl][CX]<10 then
            controls[selectedControl][CX] = 10
        end if

        -- minimum y size
        -- may not resize rebar and band CY
        if not find(controls[selectedControl][Class], {"ReBar","ReBarBand"}) then
            if controls[selectedControl][CY]<10 then
                controls[selectedControl][CY] = 10
            end if
        end if

        if controls[selectedControl][CX]+controls[selectedControl][X]>=controls[TheWindow][CX] then
            controls[selectedControl][CX] = controls[TheWindow][CX]-controls[selectedControl][X]
        else
            -- snap to grid
            controls[selectedControl][CX] = snap(controls[selectedControl][CX])
        end if

        if controls[selectedControl][CY]+controls[selectedControl][Y]>=controls[TheWindow][CY] then
            controls[selectedControl][CY] = controls[TheWindow][CY]-controls[selectedControl][Y]
        else
            --may not resize rebar and band CY
            if not find(controls[selectedControl][Class], {"ReBar","ReBarBand"}) then
                controls[selectedControl][CY] = snap(controls[selectedControl][CY])
            end if
        end if

        -- display it
        drawControl(ControlBlit, controls[selectedControl], Dragging,selectedControl,0)

        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        if offsetActive then
            bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
        end if


    elsif event=LEFT_UP
      and (state=MoveDrag or state=ResizeDrag) then

        userWantsResize = w32False
        --reset pointer
        setMousePointer(Design, NULL)
        if showActive then
            setMousePointer(Show, NULL)
        end if

        --doing all the parenting thing here instead of in the move so that all
        --the subcontrols, if any, get moved only once.

        --was shift key held down when move was made?
        if and_bits(shift, ShiftMask) then
            -- shift is held down
            shiftMouse = w32True
        end if

        -- unselect
        tmp = controls[selectedControl][Name]
        if state=ResizeDrag
        and moveAndResize then
            call_proc(check_MoveDrag_id,{saveDragX,saveDragY,origX,origY,
                                         origCX,origCY,shiftMouse,ctrlMouse})
            call_proc(check_ResizeDrag_id,{origCX, origCY})
        elsif state=ResizeDrag then
            call_proc(check_ResizeDrag_id,{origCX, origCY})
        elsif state=MoveDrag then
            call_proc(check_MoveDrag_id,{saveDragX,saveDragY,origX,origY,
                                         origCX,origCY,shiftMouse,ctrlMouse})
        end if

        --insure control in Code Editor stays in sync with controls sequence after sort
        name = getItem(CodeControls,getIndex(CodeControls))
        controls = sort(controls)
        --reload CodeControls
        eraseItems(CodeControls)
        controlnamelength = 0
        for i=1 to length(controls) do
            addItem(CodeControls, controls[i][Name])
            if length(controls[i][Name])>controlnamelength then
                controlnamelength = length(controls[i][Name])
            end if
        end for
        extent = getTextExtent(CodeControls, "M")
        controlnamelength *= extent[1]
        VOID = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
        for i=1 to getCount(CodeControls) do
            if equal(name, getItem(CodeControls,i)) then
                setIndex(CodeControls,i)
                editorSelectedControl = i
                exit
            end if
        end for

        -- re-assign selectedControl
        for i=1 to length(controls) do
            if equal(controls[i][Name], tmp) then
                selectedControl = i
                tempControl = i
                exit
            end if
        end for

        if equal(getItem(PropertyTitleBar,getIndex(PropertyTitleBar)),
                 controls[selectedControl][Name]) then
            if state=MoveDrag then
                if controls[selectedControl][X]!=origX
                and controls[selectedControl][Y]!=origY then
                    call_proc(updateProperty_id,{"Column"})
                elsif controls[selectedControl][X]!=origX then
                    call_proc(updateProperty_id,{"Column"})
                else
                    call_proc(updateProperty_id,{"Row"})
                end if
                if equal(controls[selectedControl][Class], "StatusBar") then
                    if controls[selectedControl][CX]!=origCX then
                        call_proc(updateProperty_id,{"Width"})
                    end if
                end if
            else
                if controls[selectedControl][CX]!=saveDragCX
                and controls[selectedControl][CY]!=saveDragCY then
                    call_proc(updateProperty_id,{"Height"})
                    if controls[selectedControl][CY]<controls[selectedControl][ToolRowCY] then
                        controls[selectedControl][ToolRowCY] = controls[selectedControl][CY]
                        call_proc(updateProperty_id,{"Row Height"})
                    end if
                elsif controls[selectedControl][CX]!=saveDragCX then
                    call_proc(updateProperty_id,{"Width"})
                else
                    call_proc(updateProperty_id,{"Height"})
                    if controls[selectedControl][CY]<controls[selectedControl][ToolRowCY] then
                        controls[selectedControl][ToolRowCY] = controls[selectedControl][CY]
                        call_proc(updateProperty_id,{"Row Height"})
                    end if
                end if
            end if
        else
            call_proc(updateProperties_id,{})
        end if

        if find(controls[selectedControl][Class],{"TabControl","TabItem"}) then
            for i=1 to getCount(PropertyTitleBar) do
                if equal(getItem(PropertyTitleBar,i),getItem(TheTabItemCombo,getIndex(TheTabItemCombo))) then
                    setIndex(PropertyTitleBar, i)
                    exit
                end if
            end for
        end if

        inTitleBar = isInCWindowTitleBar(controls, selectedControl)
        if inTitleBar then
            ok = displayErrorMessage(251,{})
        end if

        sizeS = getRect(Screen)

        --reset pointer
        setMousePointer(Design, NULL)
        if showActive then
            setMousePointer(Show, NULL)
        end if

        -- end of drag
        state = Normal

        -- clear mouse down flag
        mouseDown = 0

        -- repaint the window
        tempControl = selectedControl
        selectedControl = TheWindow
        call_proc(drawIt_id,{})
        selectedControl = tempControl

        drawControl(ControlBlit, controls[selectedControl], Selected,selectedControl,0)
        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            call_proc(drawHiddenControls_id,{selectedControl})
        end if

        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        if offsetActive then
            bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        --check if control went off screen
        if controls[selectedControl][X]<0 then
            haveOffscreen = w32True
            OSControls = controls[selectedControl]

            if OSControls[X]<0 then
                OSControls[X] = dCX+controls[selectedControl][X]
            end if
            if OSControls[Y]<0 then
                OSControls[Y] *= -1  --can't draw negative Y yet
            end if
            copyBlt(OffScreenBlit, 0, 0, GridBlit)

            drawControl(OffScreenBlit, OSControls, Normal,selectedControl,0)

            --did it have children?
            childCnt = 0
            if length(controls[selectedControl][SeqChildName]) then
                for i=selectedControl to length(controls) do
                    if find(controls[i][Name],
                            controls[selectedControl][SeqChildName]) then
                        childCnt += 1
                        OSControls2 = controls[i]
                        if OSControls2[X]<0 then
                            OSControls2[X] = dCX+controls[i][X]
                        end if
                        if OSControls2[Y]<0 then
                            OSControls2[Y] *= -1     --can't draw negative Y yet
                        end if
                        drawControl(OffScreenBlit, OSControls2, Normal,i,0)
                        if length(controls[i][SeqChildName]) then
                            drawChildControls(i)
                        end if
                    end if
                    if childCnt>=length(controls[selectedControl][SeqChildName]) then
                        exit
                    end if
                end for
            end if
        end if
        --check that labeledit caption is inside bounds of parent
        if equal(controls[selectedControl][Class], "LabelEdit") then
            if length(controls[selectedControl][SeqParentName]) then
                if testLabelEditCaption(selectedControl) then
                    ok = displayErrorMessage(252,{})
                end if
            end if
        end if

    elsif event=MOUSE_MOVE
      and   state=MenuPick then

        userWantsResize = w32False
        -- what menu item was selected?
        flag = inDropdown(mouseX, mouseY)
        if flag!=litMenuItem then

            -- unlight the old menu
            lightDropdown(litMenuItem, w32False)

            -- light the new menu
            litMenuItem = flag
            lightDropdown(litMenuItem, w32True)

        end if

    elsif event=LEFT_UP
      and   state=MenuPick then

        -- clear the state
        state = Normal

        mouseDown = 0

        -- what menu item was selected?
        flag = inDropdown(mouseX, mouseY)
        if flag then

            -- choose the menu item
            selectedControl = w32findKeyAny(dropdown[flag][Id], controls, Id)

            -- clear the dropdown sequence
            dropdown = {}
            call_proc(drawIt_id,{})

            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
            if showActive then
                bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
            end if

            if offsetActive then
                bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
            end if

            --do not allow submenu control to use editor
            if not find(controls[selectedControl][Class],{"Submenu","Sub2menu",
                                                          "Sub3menu"}) then
                -- open the code window
                winState = SW_NORMAL    --Normal

                --clear backup
                backupControls = {}
                backupSelectedWindow = 1
                setEnable(MenuControlUndo, w32False)
                setEnable(PopUpDesign_Undo, w32False)
                setVisible(ToolUndo, w32False)
                setVisible(ToolUndoD, w32True)
                if not CodeWinOpen then
                    codestate = HowOpenCodeWin()
                    CodeWinOpen = w32True
                    if codestate=0 then
                        --some error
                        showWindow(CodeWin, SW_RESTORE)
                    elsif codestate=1 then
                        showWindow(CodeWin, SW_MAXIMIZE)
                    elsif codestate=2 then
                        showWindow(CodeWin, SW_MINIMIZE)
                    elsif codestate=3 then
                        showWindow(CodeWin, SW_NORMAL)
                        size1 = getRect(Controls)
                        setRect(CodeWin, size1[1]+codePosition[1],
                                size1[2]+codePosition[2]+titleBar+menuBar+borderX-toolBar,
                                codePosition[3], codePosition[4], w32True)
                    else
                        showWindow(CodeWin, SW_NORMAL)
                    end if
                end if
                setIndex(CodeControls, selectedControl)
                ok = invokeHandler(CodeControls,w32HClick,{})
            end if
        else
            --lift up outside of dropdown.
            -- clear the dropdown sequence
            dropdown = {}
            call_proc(drawIt_id,{})

            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
            if showActive then
                bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
            end if

            if offsetActive then
                bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
            end if

        end if

    elsif event=MOUSE_MOVE then

        x = mouseX+WinX
        y = mouseY+WinY-(MenuY+TitleY)

        if inResize(controls[selectedControl], mouseX, mouseY)=1
        --lower right
        and x<controls[selectedControl][X]+controls[selectedControl][CX]
        and y<controls[selectedControl][Y]+controls[selectedControl][CY] then
            setMousePointer(Design, SizeNWSEPointer)
            if showActive then
                setMousePointer(Show, SizeNWSEPointer)
            end if
            userWantsResize = w32True
        elsif inResize(controls[selectedControl], mouseX, mouseY)=2
        --upper left
          and x>controls[selectedControl][X]
          and y>controls[selectedControl][Y] then
            setMousePointer(Design, SizeNWSEPointer)
            if showActive then
                setMousePointer(Show, SizeNWSEPointer)
            end if
            userWantsResize = w32True
        elsif inResize(controls[selectedControl], mouseX, mouseY)=3
        --upper right
          and x<controls[selectedControl][X]+controls[selectedControl][CX]
          and y>controls[selectedControl][Y] then
            setMousePointer(Design, SizeNESWPointer)
            if showActive then
                setMousePointer(Show, SizeNESWPointer)
            end if
            userWantsResize = w32True
        elsif inResize(controls[selectedControl], mouseX, mouseY)=4
        --lower left
          and x>controls[selectedControl][X]
          and y<controls[selectedControl][Y]+controls[selectedControl][CY] then
            setMousePointer(Design, SizeNESWPointer)
            if showActive then
                setMousePointer(Show, SizeNESWPointer)
            end if
            userWantsResize = w32True
        elsif inResize(controls[selectedControl],mouseX,mouseY)=5 then
        --right side
            setMousePointer(Design,SizeWEPointer)
            if showActive then
                setMousePointer(Show, SizeWEPointer)
            end if
            userWantsResize = w32True
        elsif inResize(controls[selectedControl],mouseX,mouseY)=6 then
        --left side
            setMousePointer(Design,SizeWEPointer)
            if showActive then
                setMousePointer(Show, SizeWEPointer)
            end if
            userWantsResize = w32True
        elsif inResize(controls[selectedControl],mouseX,mouseY)=7 then
        --top side
            setMousePointer(Design,SizeNSPointer)
            if showActive then
                setMousePointer(Show, SizeNSPointer)
            end if
            userWantsResize = w32True
        elsif inResize(controls[selectedControl],mouseX,mouseY)=8 then
        --bottom side
            setMousePointer(Design,SizeNSPointer)
            if showActive then
                setMousePointer(Show, SizeNSPointer)
            end if
            userWantsResize = w32True
        else
            setMousePointer(Design, NULL)
            if showActive then
                setMousePointer(Show, NULL)
            end if
            userWantsResize = w32False
        end if


    elsif event=LEFT_UP
      and   state=Normal then

        userWantsResize = w32False
        --reset pointer
        setMousePointer(Design, NULL)
        if showActive then
            setMousePointer(Show, NULL)
        end if
        -- mouse up flag
        mouseDown = 0

    end if

    releaseMouse()

end procedure
setHandler({Design,Form,Controls}, w32HMouse, routine_id("mouse_Design"))
-----------------------------------------------------------------------------
procedure check_ResizeDrag(integer origCX, integer origCY)

integer saveCX, saveCY, extra, childCnt, flag, totCX, cnt

    if equal(controls[selectedControl][Class], "StatusBar") then
        controls[selectedControl][CX] = origCX
        controls[selectedControl][CY] = origCY
        return
    end if

    if equal(controls[selectedControl][Class], "Table") then
        cnt = 0
        if controls[selectedControl][CX]<origCX
        or controls[selectedControl][CY]<origCY then
            --find all cells whose X+CX or Y+CY are beyond size of Table
            for i=selectedControl to length(controls) do
                if find(controls[i][Name],controls[selectedControl][SeqChildName]) then
                    if controls[i][X]+controls[i][CX]>controls[selectedControl][X]+controls[selectedControl][CX]
                    or controls[i][Y]+controls[i][CY]>controls[selectedControl][Y]+controls[selectedControl][CY] then
                        if controls[i][TableCell]=1 then
                            --must not hide cell 1 controls
                            controls[i][DontDraw] = w32False
                        else
                            controls[i][DontDraw] = w32True
                        end if
                    end if
                end if
                cnt += 1
                if cnt>length(controls[selectedControl][SeqChildName]) then
                    exit
                end if
            end for
        end if
        if controls[selectedControl][CX]>origCX
        or controls[selectedControl][CY]>origCY then
            for i=selectedControl to length(controls) do
                if find(controls[i][Name],controls[selectedControl][SeqChildName]) then
                    if controls[i][X]+controls[i][CX]<=controls[selectedControl][X]+controls[selectedControl][CX]
                    and controls[i][Y]+controls[i][CY]<=controls[selectedControl][Y]+controls[selectedControl][CY] then
                        controls[i][DontDraw] = w32False
                    end if
                end if
                cnt += 1
                if cnt>length(controls[selectedControl][SeqChildName]) then
                    exit
                end if
            end for
        end if
    end if

    if equal(controls[selectedControl][SeqParentClass], "EuGrid") then
        --make sure didn't push a control out of grid
        flag = findSeqParentName(selectedControl)
        if flag then
            childCnt = 0
            totCX = 0
            for i=flag to length(controls) do
                if find(controls[i][Name], controls[flag][SeqChildName]) then
                    childCnt += 1
                    totCX += controls[i][CX]
                end if
                if childCnt>=length(controls[flag][SeqChildName]) then
                    exit
                end if
            end for
            if controls[flag][X]+controls[flag][GridRowHeaderCX]+totCX>controls[flag][X]+
            controls[flag][CX] then
                controls[selectedControl][CX] -= ((controls[flag][GridRowHeaderCX]
                                                   +totCX+controls[flag][X])-(controls[flag][X]+controls[flag][CX]))
            end if
        end if
    end if

    if equal(controls[selectedControl][Class], "TabControl") then

        --ok now go back and resize the Cx and Cy based
        --on the selected one for all TabItems.

        saveCX = controls[selectedControl][CX]
        saveCY = controls[selectedControl][CY]

        childCnt = 0
        if length(controls[selectedControl][SeqChildName]) then
            for i=selectedControl to length(controls) do
                if equal(controls[i][Class], "TabItem")
                and find(controls[i][Name],
                         controls[selectedControl][SeqChildName]) then
                    controls[i][CX] = saveCX
                    controls[i][CY] = saveCY
                    childCnt += 1
                end if
                if childCnt>=length(controls[selectedControl][SeqChildName]) then
                    exit
                end if
            end for
        end if
    end if

    if equal(controls[selectedControl][Class], "TabItem") then
        --ok now go back and resize the Cx and Cy based
        --on the selected one for all TabItems.

        saveCX = controls[selectedControl][CX]
        saveCY = controls[selectedControl][CY]
        childCnt = 0
        --find parent to determine the tabs need to investigate
        flag = findSeqParentName(selectedControl)
        if flag then
            for i=flag to length(controls) do
                if find(controls[i][Class], {"TabItem","TabControl"})
                and find(controls[i][Name],
                         controls[flag][SeqChildName]) then
                    controls[i][CX] = saveCX
                    controls[i][CY] = saveCY
                    childCnt += 1
                end if
                if childCnt>=length(controls[flag][SeqChildName]) then
                    exit
                end if
            end for
            controls[flag][CX] = saveCX
            controls[flag][CY] = saveCY
        end if

    end if

    if find(controls[selectedControl][Class], {"ToolBar", "FlatToolBar"}) then

        --force the ToolBar CY to be multiples of ToolRowCY
        toolBarCY = controls[selectedControl][ToolRowCY]

        extra = remainder(controls[selectedControl][CY], toolBarCY)

        controls[selectedControl][CY] =
            floor(controls[selectedControl][CY]/toolBarCY)*toolBarCY

        if extra then
            controls[selectedControl][CY] += toolBarCY
        end if

    elsif length(controls[selectedControl][ControlParent])
      and find(controls[selectedControl][SeqParentClass], {"ToolBar","FlatToolBar"}) then
        forceRedraw = w32True
        repaintWinResize = w32True

    elsif length(controls[selectedControl][ControlParent])
      and find(controls[selectedControl][ParentClass], {"ReBar","ReBarBand"}) then
        repaintWinResize = w32True

    elsif equal(controls[selectedControl][Class], "MonthCalendar") then
        -- keep calendar control at recommended size
        controls[selectedControl][CX] = origCX  --250
        controls[selectedControl][CY] = origCY  --200
    end if

    if equal(controls[selectedControl][Class],"CWindow")
    or equal(controls[selectedControl][SeqParentClass], "CWindow") then
        forceRedraw = w32True
        repaintWinResize = w32True
    end if

    IDE_Changed = w32True

end procedure
check_ResizeDrag_id = routine_id("check_ResizeDrag")
-------------------------------------------------------------------------------
procedure copySubTheCopyControl(integer index, integer index2, sequence highParentName, sequence highParentClass)
integer childCnt
sequence indexParent, whoIs, treedata
    if sequence(highParentName) or sequence(highParentClass) then end if
    copyChildren = {}
    childCnt = 0
    treedata = {"",""}
    if length(controls[index][SeqChildName]) then
        for i=tempControl+1 to length(controls) do
            if find(controls[i][Name], controls[index][SeqChildName]) then
                indexParent = {}
                childCnt += 1
                if isCopyIndexed then
                    controls[i][Indexed] = w32True
                    indexParent = controls[i][Name]
                end if

                --copy it
                makeCopyControl(controls[i][X]-controls[index][X]
                                +controls[index2][X],
                                controls[i][Y]-controls[index][Y]
                                +controls[index2][Y],
                                controls[i][CX], controls[i][CY],
                                controls[i][Class],
                                controls[i][Name],
                                controls[i][Title], controls[i][OrigTitle],
                                indexParent)

                whoIs = findDirectParent(controls[length(controls)][X],
                                         controls[length(controls)][Y],
                                         controls[length(controls)][ControlParent],
                                         controls[length(controls)][Name],
                                         length(controls))
                if whoIs[1] then
                    controls[length(controls)][ControlParent] =
                            controls[whoIs[1]][Name]
                    controls[length(controls)][ParentClass] = controls[whoIs[1]][Class]
                    controls[length(controls)][SeqParentName]=
                        controls[whoIs[1]][Name]
                    controls[length(controls)][SeqParentClass]=
                        controls[whoIs[1]][Class]
                    addToParentChildSeq(whoIs[1],controls[length(controls)][Name])
                else
                    controls[length(controls)][ControlParent] =
                        controls[index2][Name]
                    controls[length(controls)][ParentClass]=
                        controls[index2][Class]
                    controls[length(controls)][SeqParentName]=
                        controls[index2][Name]
                    controls[length(controls)][SeqParentClass]=
                        controls[index2][Class]
                    addToParentChildSeq(index2,controls[length(controls)][Name])
                end if

                if equal(controls[length(controls)][SeqParentName],"ReBarBand") then
                    if find(controls[length(controls)][Class],{"ToolBar","FlatToolBar"}) then
                        controls[length(controls)][AWindow] = 7
                    else
                        controls[length(controls)][AWindow] = 10
                    end if

                    if controls[length(controls)][TabOrder] then
                        if counterInWindow then
                            counterInWindow -= 1
                        end if
                        controls[length(controls)][TabOrder] = 0
                    end if
                end if

                controls[length(controls)] = copyControlProperties(controls[length(controls)],controls[i])

                --if control is TabItem need to add to TheTabItemCombo
                if equal(controls[length(controls)][Class], "TabItem") then
                    addItem(TheTabItemCombo, controls[length(controls)][Name])
                    setIndex(TheTabItemCombo, getCount(TheTabItemCombo))
                end if

                --create Project View entry
                addTreeViewNode(controls[length(controls)][SeqParentName], controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}

                copyChildren &= {controls[length(controls)][Name]}
                if length(controls[i][SeqChildName]) then
                    copySubTheCopyControl(i, length(controls), controls[length(controls)][ControlParent],
                                          controls[length(controls)][ParentClass])
                end if
            end if
        end for

    end if

    IDE_Changed = w32True
end procedure
--------------------------------------------------------------------------------
integer movepartner_rid
sequence partnerSeq     partnerSeq = {}
--------------------------------------------------------------------------------
procedure movePartnerChildren(integer index, integer saveDragX, integer saveDragY)
integer childCnt

    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],controls[index][SeqChildName]) then
                childCnt += 1
                controls[i][X] += saveDragX
                controls[i][Y] += saveDragY

                --assign parenting in treeview
                addTreeViewNode(controls[index][Name],
                                controls[i][Name])

                if length(controls[i][SeqChildName]) then
                    movePartnerChildren(i, saveDragX, saveDragY)
                end if
                if length(controls[i][ControlPartners]) then
                    call_proc(movepartner_rid, {i, saveDragX, saveDragY})
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if

end procedure
--------------------------------------------------------------------------------
procedure movePartner(integer index, integer saveDragX, integer saveDragY)
integer childCnt

    childCnt = 0
    if length(controls[index][ControlPartners]) then
        for i=1 to length(controls) do
            if not find(controls[i][Name],partnerSeq)
            and find(controls[i][Name],controls[index][ControlPartners]) then
                partnerSeq &= {controls[i][Name]}
                childCnt += 1
                controls[i][X] += saveDragX
                controls[i][Y] += saveDragY

                if length(controls[i][ControlPartners]) then
                    movePartner(i, saveDragX, saveDragY)
                end if
                if length(controls[i][SeqChildName]) then
                    movePartnerChildren(i,saveDragX,saveDragY)
                end if
            end if
            if childCnt>=length(controls[index][ControlPartners]) then
                exit
            end if
        end for
    end if

end procedure
movepartner_rid = routine_id("movePartner")
--------------------------------------------------------------------------------
procedure moveMiscChildren(integer index, integer saveDragX, integer saveDragY)
integer childCnt

    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],controls[index][SeqChildName]) then
                childCnt += 1
                controls[i][X] += saveDragX
                controls[i][Y] += saveDragY

                --assign parentint in treeview
                addTreeViewNode(controls[index][Name],
                                controls[i][Name])

                if length(controls[i][SeqChildName]) then
                    moveMiscChildren(i, saveDragX, saveDragY)
                end if
                if length(controls[i][ControlPartners]) then
                    movePartner(i, saveDragX, saveDragY)
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if

end procedure
--------------------------------------------------------------------------------
procedure addChildToNode(integer index)
integer childCnt

    if length(controls[index][SeqChildName]) then
        childCnt = 0
        for i=index to length(controls) do
            if find(controls[i][Name], controls[index][SeqChildName]) then
                childCnt += 1
                addTreeViewNode(controls[index][Name], controls[i][Name])
                if length(controls[i][SeqChildName]) then
                    addChildToNode(i)
                end if
            end if
            if childCnt>=length(controls[index][SeqChildName]) then
                exit
            end if
        end for
    end if
end procedure
-------------------------------------------------------------------------------
procedure check_MoveDrag(integer saveDragX, integer saveDragY,
                          integer origX, integer origY, integer origCX,
                          integer origCY, integer shiftMouse, integer ctrlMouse)

sequence parent1, parent2
integer it,flag,childCnt

    if controls[selectedControl][Y]<0 then
        controls[selectedControl][Y] = origY
        controls[selectedControl][X] = origX
        --nothing should change
        ok = displayErrorMessage(219,{})
        return
    end if

    if ctrlMouse then
        if not find(controls[selectedControl][Class],
                    {"TabControl","TabItem","ToolBar","FlatToolBar","ReBar","StatusBar",
                     "ReBarBand"}) then
                --will do TabItem and TabControl copy inside tabItemStuff routine
            copySubTheCopyControl(tempControl,selectedControl,controls[selectedControl][Name],
                                  controls[selectedControl][Class])
        end if
    end if

    if not controls[selectedControl][ParentIsFrozen] then

        call_proc(ToolBarStuff_id,{saveDragX,saveDragY, origX, origY, ctrlMouse})

        call_proc(TabItemStuff_id,{saveDragX,saveDragY,origX,origY,
                                   origCX,origCY,shiftMouse,ctrlMouse})

        call_proc(GroupStuff_id,{saveDragX,saveDragY,origX,origY,ctrlMouse})

        if not find(controls[selectedControl][Class], {"ToolBar","FlatToolBar","ReBar",
                                                       "ReBarBand","TabItem","TabControl","Group","StatusBar","Table",
                                                       "EuGrid","CWindow"}) then
            call_proc(MiscStuff_id,{origX,origY,ctrlMouse})
        end if

        --controls parented by ReBarBand are AWindow 10
        --if they were 10 and are no longer parented by ReBarBand change to general classification
        if equal(controls[selectedControl][SeqParentName],"ReBarBand")
        and not find(controls[selectedControl][Class],{"ToolBar","FlatToolBar"}) then
            controls[selectedControl][AWindow] = 10
        elsif controls[selectedControl][AWindow]=10 then
            if not controls[selectedControl][TabOrder] then
                counterInWindow += 1
                controls[selectedControl][TabOrder] = counterInWindow
            end if
            controls[selectedControl][AWindow] = 30
        end if
    else
        if length(controls[selectedControl][SeqChildName]) then
                        --move child controls   
            --how much drag did we do?
            saveDragX = controls[selectedControl][X]-origX
            saveDragY = controls[selectedControl][Y]-origY
            moveMiscChildren(selectedControl,saveDragX, saveDragY)
        end if
    end if

    if length(controls[selectedControl][IndexParent]) then
        --check that direct parent of selected control and direct parent of
        --IndexParent are the same.
        parent1 = controls[selectedControl][SeqParentName]

        it = 1
        for i=1 to length(controls) do
            if equal(controls[i][Name],controls[selectedControl][IndexParent]) then
                parent2 = controls[i][SeqParentName]
                it = i
                exit
            end if
        end for

        --if different then remove empty IndexParent on selectedControl.
        if not equal(parent1, parent2)
        or not equal(controls[selectedControl][ControlParent], controls[it][ControlParent]) then    --to catch on Tabs
            controls[selectedControl][IndexParent] = {}
        end if
    end if

    if not length(controls[selectedControl][ParentClass]) then
        controls[selectedControl][ParentClass] = controls[selectedControl][SeqParentClass]
        controls[selectedControl][ControlParent] = controls[selectedControl][SeqParentName]
    end if

    if equal(controls[selectedControl][Class], "TabItem") then
        ok = invokeHandler(TheTabItemCombo,w32HChange,{})
    end if

    if find(controls[selectedControl][ParentClass], {"ReBar","ReBarBand"}) then
        repaintWinResize = w32True
    end if

    call_proc(updateProperty_id,{"Parent"})
    if controls[selectedControl][ParentIsFrozen]
    and length(parentList)=1 then
        flag = findSeqParentName(selectedControl)
        controls[selectedControl][ControlParent] = ""
        controls[selectedControl][ParentClass] = ""
        controls[selectedControl][SubClass] = ""
        controls[selectedControl][SeqParentName] = ""
        controls[selectedControl][SeqParentClass] = ""
        controls[selectedControl][Parent] = ""
        removeFromParentChildSeq(flag,controls[selectedControl][Name])
        deleteTreeViewNode("", controls[selectedControl][Name])
        addTreeViewNode(controls[1][Name], controls[selectedControl][Name])
        addChildToNode(selectedControl)
    end if

    if length(controls[selectedControl][ControlPartners])
    and not ctrlMouse then
        partnerSeq = {controls[selectedControl][Name]}
        childCnt = 0
        for i=1 to length(controls) do
            if find(controls[i][Name], controls[selectedControl][ControlPartners]) then
                childCnt += 1
                movePartner(selectedControl,controls[selectedControl][X]-origX,
                            controls[selectedControl][Y]-origY)
                if childCnt>=length(controls[selectedControl][ControlPartners]) then
                    exit
                end if
            end if
        end for
    end if

    if find(controls[selectedControl][Name], partnerSeq) then
        flag = findSeqParentName(selectedControl)
        controls[selectedControl][ControlParent] = ""
        controls[selectedControl][ParentClass] = ""
        controls[selectedControl][SubClass] = ""
        controls[selectedControl][SeqParentName] = ""
        controls[selectedControl][SeqParentClass] = ""
        controls[selectedControl][Parent] = ""
        removeFromParentChildSeq(flag,controls[selectedControl][Name])
        deleteTreeViewNode("", controls[selectedControl][Name])
        addTreeViewNode(controls[1][Name], controls[selectedControl][Name])
        addChildToNode(selectedControl)
        call_proc(updateProperty_id,{"Parent"})
    end if

end procedure
check_MoveDrag_id = routine_id("check_MoveDrag")
-----------------------------------------------------------------------------
integer badCopy badCopy = w32False      --used in popupDesign_paste
--------------------------------------------------------------------------------
procedure deleteTheCopyControl()
    badCopy = w32True
    if length(copyChildren) then
        for i=length(copyChildren) to 1 by -1 do
            deleteTreeViewNode("",copyChildren[i])
            if equal(controls[length(controls)][Name], copyChildren[i]) then
                if equal(controls[length(controls)][Class], "TabItem") then
                    for j=1 to getCount(TheTabItemCombo) do
                        if equal(controls[length(controls)][Name],
                                 getItem(TheTabItemCombo, j)) then
                            ok = deleteItem(TheTabItemCombo, j)
                            exit
                        end if
                    end for
                end if
                --delete it
                controls = controls[1..length(controls)-1]
            end if
        end for
    end if

    deleteTreeViewNode("",controls[length(controls)][Name])
    for i=1 to getCount(PropertyTitleBar) do
        if equal(getItem(PropertyTitleBar,i),controls[length(controls)][Name]) then
            VOID = deleteItem(PropertyTitleBar,i)
            exit
        end if
    end for
    for i=1 to getCount(TheTabItemCombo) do
        if equal(controls[length(controls)][Name], getItem(TheTabItemCombo, i)) then
            ok = deleteItem(TheTabItemCombo, i)
            setIndex(TheTabItemCombo,getCount(TheTabItemCombo))
            exit
        end if
    end for

    --delete it
    controls = controls[1..length(controls)-1]

    --select the control copied from
    selectedControl = tempControl

end procedure
------------------------------------------------------------------------------
procedure toolBarStuff(integer saveDragX, integer saveDragY,
                        integer origX, integer origY, integer ctrlMouse)

integer hit, saveX, saveY, childCnt
integer flag, flag2, holdX, holdY
sequence the, whoIsStatus, whoIs, onToolBar

    --was the control being moved the ToolBar? If so it can only be
    --at 0,0 location unless in ReBar or CWindow

    forceRedraw = w32False   --tells DrawIt about redrawing toolbar/flattoolbar

    whoIs = findDirectParent(controls[selectedControl][X],controls[selectedControl][Y],
                             controls[selectedControl][ControlParent], controls[selectedControl][Name],
                             selectedControl)

    if whoIs[1] then
        flag = whoIs[1]
    else
        flag = TheWindow
    end if

    if flag=TheWindow then
                --was the control being moved the ToolBar? If so it can only be
        --at 0,0 location unless in ReBar
        if find(controls[selectedControl][Class], {"ToolBar","FlatToolBar"})
        and not length(controls[selectedControl][SeqParentName]) then
            if controls[selectedControl][X]!=0 then
                controls[selectedControl][X] = 0
            end if
            if controls[selectedControl][Y]!=0 then
                controls[selectedControl][Y] = 0
            end if
        end if
    end if

    if find(controls[selectedControl][Class], {"ToolBar","FlatToolBar"})
    and not equal(controls[selectedControl][SeqParentClass], "ReBarBand") then
        if equal(controls[flag][Class],"CWindow") then
            if controls[selectedControl][X]!=controls[flag][X]
            or controls[selectedControl][Y]!=controls[flag][Y] then
                controls[selectedControl][X] = controls[flag][X]
                controls[selectedControl][Y] = controls[flag][Y]
            end if
            controls[selectedControl][CX] = controls[flag][CX]
            if isCWindowTitleBar(flag) then
                controls[selectedControl][Y] = controls[flag][Y]+titleBar+borderY
                controls[selectedControl][X] += borderX
                controls[selectedControl][CX] = controls[flag][CX]-(2*borderX)
                origY = controls[flag][Y]+titleBar+borderY
            else
                origY = controls[flag][Y]
            end if
            call_proc(updateProperty_id,{"Col"})
            call_proc(updateProperty_id,{"Width"})
--                      return              
        else
        --if not on CWindow must be positioned at 0,0           
            controls[selectedControl][X] = 0
            controls[selectedControl][Y] = 0
            controls[selectedControl][CX] = controls[flag][CX]
            --nothing changes
            origY = 0
            call_proc(updateProperty_id,{"Row"})
            call_proc(updateProperty_id,{"Width"})
--                      return        
        end if
    elsif find(controls[selectedControl][Class], {"ToolBar","FlatToolBar"}) then
        --was on ReBarBand
        toolBarOrigX = controls[selectedControl][X]
        toolBarOrigY = controls[selectedControl][Y]
        --save the ending position
        --protect that do not move from positioning x,y within parent

        --if moved out of ReBarBand then put back
        if whoIs[1]
        and equal(controls[selectedControl][SeqParentClass], "ReBarBand") then
            --check where it is now
            flag = findSeqParentName(selectedControl)
            if flag then
                if controls[selectedControl][Y]!=controls[flag][Y]+1 then
                    controls[selectedControl][Y] = controls[flag][Y]+1
                    origY = controls[flag][Y]+1
                    forceRedraw = w32True
                    repaintWinResize = w32True
                    call_proc(updateProperty_id,{"Row"})
                end if
            else
                flag = TheWindow
            end if
        end if
        saveX = controls[selectedControl][X]
        saveY = controls[selectedControl][Y]
        if not whoIs[1] then
            --put it back
            controls[selectedControl][X] = origX
            controls[selectedControl][Y] = origY
            flag = findSeqParentName(selectedControl)
            forceRedraw = w32True
            repaintWinResize = w32True
            call_proc(updateProperty_id,{"Row"})
            return
        end if

        if whoIs[1] then
            if not equal(controls[whoIs[1]][Name], controls[selectedControl][SeqParentName]) then
                --put it back
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
                forceRedraw = w32True
                repaintWinResize = w32True
                call_proc(updateProperty_id,{"Row"})
            else
                --move its controls also
                --temporarily use original x and y values
                holdX = controls[selectedControl][X]
                holdY = controls[selectedControl][Y]
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY

                --how much drag did we do?
                saveDragX = saveX-saveDragX
                saveDragY = saveY-saveDragY
                childCnt = 0
                for i=selectedControl to length(controls) do
                    if find(controls[i][Name], controls[selectedControl][SeqChildName]) then
                        childCnt += 1
                        --move them
                        controls[i][X] = (saveDragX+controls[i][X])
                        controls[i][Y] = (saveDragY+controls[i][Y])
                        if childCnt>=length(controls[selectedControl][SeqChildName]) then
                            exit
                        end if
                    end if
                end for
                --now replace with actual movement
                controls[selectedControl][X] = holdX
                controls[selectedControl][Y] = holdY
            end if
        end if
    end if
    if find(controls[selectedControl][Class], {"ToolBar","FlatToolBar"}) then
        if equal(controls[flag][Class], "Window") then
            removeFromParentChildSeq(flag,controls[selectedControl][Name])
            controls[selectedControl][ControlParent] = ""
            controls[selectedControl][ParentClass] = ""
            controls[selectedControl][SubClass] = ""
            controls[selectedControl][SeqParentName] = ""
            controls[selectedControl][SeqParentClass] = ""
            controls[selectedControl][SeqChildName] = ""
            deleteTreeViewNode("", controls[selectedControl][Name])
            addTreeViewNode(controls[1][Name], controls[selectedControl][Name])
        elsif equal(controls[flag][Class], "CWindow") then
            addToParentChildSeq(flag,controls[selectedControl][Name])
            controls[selectedControl][ControlParent] = controls[flag][Name]
            controls[selectedControl][ParentClass] = controls[flag][Class]
            controls[selectedControl][SubClass] = ""
            controls[selectedControl][SeqParentName] = controls[flag][Name]
            controls[selectedControl][SeqParentClass] = controls[flag][Class]
            deleteTreeViewNode("", controls[selectedControl][Name])
            addTreeViewNode(controls[flag][Name], controls[selectedControl][Name])
        end if
        forceRedraw = w32True
        repaintWinResize = w32True

                --done with moving toolbar
        return
    end if

    --was the control moved already a member of the ToolBar?
    if length(controls[selectedControl][SeqParentName]) then
        --if in toolbar/ftb and Y < 0 then force to parent x and y
        if find(controls[selectedControl][SeqParentClass], {"ToolBar","FlatToolBar"}) then
            flag = findSeqParentName(selectedControl)
            if controls[selectedControl][Y]<0 then
                if flag then
                    controls[selectedControl][Y] = controls[flag][Y]
                else
                    controls[selectedControl][Y] = 0
                end if
            end if
            if controls[selectedControl][X]<0 then
                if flag then
                    controls[selectedControl][X] = controls[flag][X]
                else
                    controls[selectedControl][X] = 0
                end if
            end if
        end if

        if equal(controls[selectedControl][Class], "StatusBar")
        and equal(controls[selectedControl][SeqParentClass], "CWindow") then
            --take care of control in other routines
            return
        end if

        if find(controls[selectedControl][ParentClass], {"Group","Table","TabItem",
                                                         "TabControl","ReBarBand","CWindow","CText","RText","LText",
                                                         "StatusBar","EuGrid"}) then
            --take care of control in other routines            
            return
        end if

        if find(controls[selectedControl][SeqParentClass], {"ToolBar","FlatToolBar"})
        and controls[selectedControl][Y]=controls[flag][Y] then
            --do nothing; keep same parent
        elsif equal(controls[flag][Class], "Window") then
            --moved out so remove parenting
            --need to reduce toolBarInfo for the width of selected control
            --find the toolBarInfo data
            flag2 = findSeqParentName(selectedControl)
            if flag2 then
                onToolBar = controls[flag2][Name]
                for i=1 to length(toolBarInfo) do
                    if equal(onToolBar, toolBarInfo[i][8]) then
                        toolBarInfo[i][6] -= controls[selectedControl][CX]
                        exit
                    end if
                end for
                removeFromParentChildSeq(flag2,controls[selectedControl][Name])
            end if

            controls[selectedControl][ControlParent] = ""
            controls[selectedControl][ParentClass] = ""
            controls[selectedControl][SubClass] = ""
            controls[selectedControl][SeqParentName] = ""
            controls[selectedControl][SeqParentClass] = ""
            deleteTreeViewNode("", controls[selectedControl][Name])
            addTreeViewNode(controls[1][Name], controls[selectedControl][Name])
            forceRedraw = w32True
            repaintWinResize = w32True
        end if

        if not whoIs[1]
        and find(controls[selectedControl][SeqParentClass], {"ToolBar","FlatToolBar"}) then
            --moved out of prior parent so remove parenting
            --need to reduce toolBarInfo for the width of selected control
            --find the toolBarInfo data
            flag2 = findSeqParentName(selectedControl)
            if flag2 then
                onToolBar = controls[flag2][Name]
                for i=1 to length(toolBarInfo) do
                    if equal(onToolBar, toolBarInfo[i][8]) then
                        toolBarInfo[i][6] -= controls[selectedControl][CX]
                        exit
                    end if
                end for
                removeFromParentChildSeq(flag2,controls[selectedControl][Name])
            end if

            controls[selectedControl][ControlParent] = ""
            controls[selectedControl][ParentClass] = ""
            controls[selectedControl][SubClass] = ""
            controls[selectedControl][SeqParentName] = ""
            controls[selectedControl][SeqParentClass] = ""
            deleteTreeViewNode("", controls[selectedControl][Name])
            addTreeViewNode(controls[1][Name], controls[selectedControl][Name])
            forceRedraw = w32True
            repaintWinResize = w32True
        elsif whoIs[1]
          and find(controls[whoIs[1]][Class], {"ToolBar","FlatToolBar"}) then
            flag2 = findSeqParentName(selectedControl)
            if flag2 then
                onToolBar = controls[flag2][Name]
                for i=1 to length(toolBarInfo) do
                    if equal(onToolBar, toolBarInfo[i][8]) then
                        toolBarInfo[i][6] -= controls[selectedControl][CX]
                        exit
                    end if
                end for
                removeFromParentChildSeq(flag2,controls[selectedControl][Name])
            end if
            addToParentChildSeq(whoIs[1],controls[selectedControl][Name])
            controls[selectedControl][ControlParent] = controls[whoIs[1]][Name]
            controls[selectedControl][ParentClass] = controls[whoIs[1]][Class]
            controls[selectedControl][SubClass] = ""
            controls[selectedControl][SeqParentName] = controls[whoIs[1]][Name]
            controls[selectedControl][SeqParentClass] = controls[whoIs[1]][Class]
            deleteTreeViewNode("", controls[selectedControl][Name])
            addTreeViewNode(controls[whoIs[1]][Name], controls[selectedControl][Name])
        end if

        if find(controls[selectedControl][ParentClass], {"ReBar","ReBarBand","ToolBar","FlatToolBar"}) then
            --set flag for DrawIt
            forceRedraw = w32True
        end if

        if find(controls[selectedControl][SeqParentClass], {"ToolBar","FlatToolBar"})
        or find(controls[flag][Class], {"ToolBar","FlatToolBar"}) then
            if not find(controls[selectedControl][Class], {"PushButton","PictureButton",
                                                           "TogglePicture","SepButton","None","Group",
                                                           "Combo"}) then
                if not ctrlMouse then
                    ok = displayErrorMessage(79,{controls[selectedControl][Class]})
                    if rSelectedWindow!=selectedWindow then
                        badCopy = w32True
                        return
                    end if
                    --move back to original position
                    controls[selectedControl][X] = origX
                    controls[selectedControl][Y] = origY
                else
                    ok = displayErrorMessage(109,{"ToolBar"})
                    deleteTheCopyControl()
                end if
                state = Normal
                -- clear mouse down flag
                mouseDown = 0
                return
            else
                if equal(controls[selectedControl][ParentClass], "ReBar")
                or equal(controls[flag][Class], "ToolBar") then
                    if equal(controls[selectedControl][SeqParentClass], "ReBarBand") then
                        --moved toolbar to rebarband
                        flag2 = findSeqParentName(selectedControl)
                        if flag2 then
                            if controls[selectedControl][Y]!=controls[flag2][Y]+4 then
                                controls[selectedControl][Y] = controls[flag2][Y]+4
                            end if
                        end if
                    end if

                    --get the toolbar name for compare to toolBarInfo
                    if equal(controls[selectedControl][ParentClass], "ToolBar") then
                        flag2 = findSeqParentName(selectedControl)
                        if flag2 then
                            onToolBar = controls[flag2][Name]
                        end if
                    else
                        onToolBar = controls[flag][Name]
                    end if

                    if controls[selectedControl][Y]=0 then
                        --do nothing; keep parent
                    else
                        whoIsStatus = findHighestParent(controls[selectedControl][X],
                                                        controls[selectedControl][Y],
                                                        selectedControl)
                        if whoIsStatus[1] then
                            controls[selectedControl][ControlParent] = controls[whoIsStatus[1]][Name]
                            controls[selectedControl][ParentClass] = controls[whoIsStatus[1]][Class]
                            deleteTreeViewNode("", controls[selectedControl][Name])
                            if length(controls[selectedControl][ControlParent]) then
                                addTreeViewNode(controls[selectedControl][ControlParent],
                                                controls[selectedControl][Name])
                            else
                                addTreeViewNode(controls[1][Name],
                                                controls[selectedControl][Name])
                            end if
                        end if
                        forceRedraw = w32True
                    end if
                end if

                if equal(controls[selectedControl][ParentClass], "FlatToolBar")
                or equal(controls[flag][Class], "FlatToolBar") then
                    if equal(controls[selectedControl][ParentClass], "FlatToolBar") then
                        flag2 = findSeqParentName(selectedControl)
                        if flag2 then
                            onToolBar = controls[flag2][Name]
                        end if
                    else
                        onToolBar = controls[flag][Name]
                    end if

                    --change to PushButton
                    if not equal(controls[selectedControl][Class], "SepButton") then
                        controls[selectedControl][Class] = "PictureButton"
                    end if

                    if controls[selectedControl][Y]=0 then
                        --do nothing; keep parent
                    else
                        whoIsStatus = findHighestParent(controls[selectedControl][X],
                                                        controls[selectedControl][Y],
                                                        selectedControl)
                        if whoIsStatus[1] then
                            controls[selectedControl][ControlParent] = controls[whoIsStatus[1]][Name]
                            controls[selectedControl][ParentClass] = controls[whoIsStatus[1]][Class]
                            deleteTreeViewNode("", controls[selectedControl][Name])
                            if length(controls[selectedControl][ControlParent]) then
                                addTreeViewNode(controls[selectedControl][ControlParent],
                                                controls[selectedControl][Name])
                            else
                                addTreeViewNode(controls[1][Name],
                                                controls[selectedControl][Name])
                            end if
                        end if
                    end if
                    forceRedraw = w32True
                end if
            end if

            --if the control moved was already a member of the Toolbar
            --we have to delete and insert controls so that the squishing
            --works correctly.
            --why? when controls are on the extra ToolBar rows their X and Y
            --are not relative to the other rows. I can't automate moving
            --them around otherwise.

            if whoIs[1] and not find(whoIs[2], {"ToolBar","FlatToolBar"}) then
                flag = findSeqParentName(selectedControl)
                if flag then
                    removeFromParentChildSeq(flag,controls[selectedControl][Name])
                    deleteTreeViewNode("",controls[selectedControl][Name])
                    controls[selectedControl][SeqParentName] = controls[whoIs[1]][Name]
                    controls[selectedControl][SeqParentClass] = controls[whoIs[1]][Class]
                    addToParentChildSeq(whoIs[1],controls[selectedControl][Name])
                    addTreeViewNode(controls[whoIs[1]][Name],controls[selectedControl][Name])
                    controls[selectedControl][ControlParent] = controls[whoIs[1]][Name]
                    controls[selectedControl][ParentClass] = controls[whoIs[1]][Class]

                    --moved out do remove parenting
                    --need to reduce toolBarInfo for the width of selected control
                    --find the toolBarInfo data
                    onToolBar = controls[flag][Name]
                    for i=1 to length(toolBarInfo) do
                        if equal(onToolBar, toolBarInfo[i][8]) then
                            toolBarInfo[i][6] -= controls[selectedControl][CX]
                            exit
                        end if
                    end for
                    forceRedraw = w32True
                    repaintWinResize = w32True
                    --we will get it again in miscstuff
                    return
                end if
            end if

            --save the control so we can find it for deleting later
            the = controls[selectedControl]

            if find(controls[selectedControl][ParentClass], {"ToolBar","FlatToolBar"})
            or find(controls[flag][Class], {"ToolBar","FlatToolBar"}) then
                if find(controls[selectedControl][SeqParentClass], {"ToolBar","FlatToolBar"}) then
                    flag2 = findSeqParentName(selectedControl)
                    if flag2 then
                        toolCY = controls[flag2][ToolRowCY]
                        if equal(the[ParentClass], "FlatToolBar") then
                            the[CX] = toolCY-4
                            the[CY] = toolCY-4
                            if controls[flag2][ToolRowCY]=48 then
                                the[CX] = 38
                                the[CY] = 38
                            end if
                        end if
                    end if
                end if
            end if

            --find out which row the control is on and set y to top of that row
            for i=1 to toolBarSize do
                if the[Y]>(toolCY*i)-toolCY and the[Y]<(toolCY*i)+1 then
                    the[Y] = (toolCY*i)-toolCY
                end if
            end for

            if the[Y]<toolBarOrigY then
                the[Y] = toolBarOrigY
            end if

            --now delete it
            controls = controls[1..selectedControl-1]
                       & controls[selectedControl+1..length(controls)]

            --if the[Y] is still within rows of the toolbar, find its new
            --toolbar position

            hit = 0

            if the[Y]<=toolBarCY then
                --find its spot in the ToolBar controls
                for i=1 to length(controls) do
                    if length(controls[i][ControlParent]) then
                        if find(controls[i][ParentClass], {"ToolBar","FlatToolBar"})
                        or find(controls[flag][Class], {"ToolBar","FlatToolBar"}) then

                            if the[Y]=controls[i][Y] then
                                if the[X]<controls[i][X] then

                                    --same row prior insertion
                                    controls = controls[1..i-1] & {the}
                                               & controls[i..length(controls)]
                                    hit = 1
                                    exit
                                end if
                            end if
                        end if
                    end if
                end for
                if hit then
                    for i=1 to length(controls) do
                        if equal(the[Name], controls[i][Name]) then
                            selectedControl = i
                            exit
                        end if
                    end for
                end if
            else
                --was no longer part of toolbar
                --remove parenting
                the[ControlParent] = ""
                the[ParentClass] = ""
                the[SubClass] = ""
                the[SeqParentName] = ""
                the[SeqParentClass] = ""
                addTreeViewNode(controls[1][Name], the[Name])
            end if

            if hit=0 then
                --didn't find it; must go at end
                controls = controls & {the}
                selectedControl = length(controls)
            end if

            forceRedraw = w32True
            repaintWinResize = w32True
            IDE_Changed = w32True
        end if
    end if

    IDE_Changed = w32True

end procedure
ToolBarStuff_id = routine_id("toolBarStuff")
-------------------------------------------------------------------------------
procedure moveThisControlSubs(sequence parent, integer saveDragX,
                        integer saveDragY, integer startAt)
integer childCnt
    if parent then end if
    childCnt = 0
    for i=startAt to length(controls) do
        if find(controls[i][Name], controls[startAt][SeqChildName]) then
            childCnt += 1
            if equal(controls[i][Class], "TabItem") then
                controls[i][Active] = w32True
            end if
            --move them
            if not ctrlMouse then
                controls[i][X] = (saveDragX+controls[i][X])
                controls[i][Y] = (saveDragY+controls[i][Y])
            end if

            --if cell of Table do not adjust
            if not controls[i][TableCell]
            and not find(controls[i][SeqParentClass], {"ToolBar","FlatToolBar"}) then
                -- snap to grid
                controls[i][X] = snap(controls[i][X])
                controls[i][Y] = snap(controls[i][Y])
            end if

            --if a tabControl or tabItem then move its subs also
            if find(controls[i][Class], {"TabControl","TabItem"}) then
                if ctrlMouse
                and equal(controls[i][Class], "TabItem") then
                    addItem(TheTabItemCombo, controls[i][Name])
                    setIndex(TheTabItemCombo, getCount(TheTabItemCombo))
                end if
            end if

            addTreeViewNode(controls[startAt][Name], controls[i][Name])
            if length(controls[i][SeqChildName]) then
                moveThisControlSubs(controls[i][Name], saveDragX, saveDragY, i)
            end if

            if childCnt>=length(controls[startAt][SeqChildName]) then
                exit
            end if
        end if
    end for

end procedure
------------------------------------------------------------------------------
procedure moveThisControlSubsAndChgHighParent(sequence parent, integer saveDragX,
                        integer saveDragY, integer startAt,sequence chgControlParentTo,
                        sequence chgParentClassTo)
integer childCnt
    if parent then end if
    childCnt = 0
    for i=startAt to length(controls) do
        if find(controls[i][Name], controls[startAt][SeqChildName]) then
            childCnt += 1
            controls[i][ControlParent] = chgControlParentTo
            controls[i][ParentClass] = chgParentClassTo
            if equal(controls[i][Class], "TabItem") then
                controls[i][Active] = w32True
            end if
            --move them
            if not ctrlMouse then
                controls[i][X] = (saveDragX+controls[i][X])
                controls[i][Y] = (saveDragY+controls[i][Y])
            end if

            --if cell of Table do not adjust
            if not controls[i][TableCell]
            and not find(controls[i][SeqParentClass], {"ToolBar","FlatToolBar"}) then
                -- snap to grid
                controls[i][X] = snap(controls[i][X])
                controls[i][Y] = snap(controls[i][Y])
            end if

            --if a tabControl or tabItem then move its subs also
            if find(controls[i][Class], {"TabControl","TabItem"}) then
                if ctrlMouse
                and equal(controls[i][Class], "TabItem") then
                    addItem(TheTabItemCombo, controls[i][Name])
                    setIndex(TheTabItemCombo, getCount(TheTabItemCombo))
                end if
            end if

            addTreeViewNode(controls[startAt][Name], controls[i][Name])
            if length(controls[i][SeqChildName]) then
                moveThisControlSubsAndChgHighParent(controls[i][Name],
                                                    saveDragX, saveDragY, i, chgControlParentTo, chgParentClassTo)
            end if

            if childCnt>=length(controls[startAt][SeqChildName]) then
                exit
            end if
        end if
    end for

end procedure
------------------------------------------------------------------------------
procedure addChildToPV(integer index)
integer childCnt

    childCnt = 0
    if length(controls[index][SeqChildName]) then
        for i=index to length(controls) do
            if find(controls[i][Name],controls[index][SeqChildName]) then
                childCnt += 1
                if i!=selectedControl then
                    deleteTreeViewNode("", controls[i][Name])
                    addTreeViewNode(controls[index][Name],
                                    controls[i][Name])
                    if length(controls[i][SeqChildName]) then
                        addChildToPV(i)
                    end if
                end if
                if childCnt>=length(controls[index][SeqChildName]) then
                    exit
                end if
            end if
        end for
    end if
end procedure
------------------------------------------------------------------------------
procedure tabItemStuff(integer saveDragX, integer saveDragY,
                        integer origX, integer origY, integer origCX,
                        integer origCY, integer shiftMouse, integer ctrlMouse)

integer saveX, saveY, saveCX, saveCY, childCnt,picked, lastOrder,skipBuildNew
integer flag, diffX, diffY, testCX, testCY, flag2,flag3,holdcontrol
sequence whoIsStatus, treedata

    reDrawTabItemControls = {}
    testCX = 0
    testCY = 0
    holdcontrol = 0

    treedata = {"",""}

    if equal(controls[selectedControl][Class], "TabItem") then

        --save the ending position
        saveX = controls[selectedControl][X]
        saveY = controls[selectedControl][Y]

        --reset saveCX and saveCY
        saveCX = controls[selectedControl][CX]
        saveCY = controls[selectedControl][CY]

        --how much drag did we do?
        saveDragX = saveX-saveDragX
        saveDragY = saveY-saveDragY

        --first check where the tabItem (and tabControl?) were moved to.

        --new Parent must be the window or another tabitem's parent

        if not shiftMouse
        and not ctrlMouse then
            --gather list of children
            childrenList = {}
            if length(controls[selectedControl][SeqChildName]) then
                buildChildrenList(selectedControl)
            end if

            --want to move or copy tab control and all tab items
            flag = inControl(controls[selectedControl][X],
                             controls[selectedControl][Y])

            if find(controls[flag][Name], childrenList)
            or flag=selectedControl then
                if length(controls[selectedControl][ControlParent]) then
                    flag = findSeqParentName(selectedControl)
                else
                    flag = TheWindow
                end if
            end if

            if flag!=TheWindow
            and not find(controls[flag][Class], {"TabItem","CWindow"})
            and not equal(controls[flag][Name],
                          controls[selectedControl][ControlParent]) then
                --can't move to anything besides the window or itself or
                --a Tab Item
                if not ctrlMouse then
                    ok = displayErrorMessage(80,{controls[flag][Class]})
                    if rSelectedWindow!=selectedWindow then
                        badCopy = w32True
                        return
                    end if
                    --move back to original position
                    controls[selectedControl][X] = origX
                    controls[selectedControl][Y] = origY

                else
                    ok = displayErrorMessage(109,{controls[flag][Class]})
                    deleteTheCopyControl()
                end if
                state = Normal
                -- clear mouse down flag
                mouseDown = 0
                return
            end if

            --ok now move or copy all the tabitems and their controls to new
            --location

            --change all tabitems in this tabControl to the
            --new x,y and cx,cy

            flag2 = findSeqParentName(selectedControl)
            if flag2 then
                childCnt = 0
                for i=flag2 to length(controls) do
                    if equal(controls[i][Class], "TabItem")
                    and find(controls[i][Name],
                             controls[flag2][SeqChildName]) then
                        childCnt += 1

                        --put at same location as other tabs
                        controls[i][X] = saveX
                        controls[i][Y] = saveY

                        controls[i][CX] = saveCX
                        controls[i][CY] = saveCY
                        controls[i][Active] = w32True

                        --now move the controls within the tabItem
                        --could be tabControl as well
                        if length(controls[i][SeqChildName]) then
                            moveThisControlSubs(controls[i][Name], saveDragX, saveDragY, i)
                        end if
                        if childCnt>=length(controls[flag2][SeqChildName]) then
                            exit
                        end if
                    end if
                end for

                --now move the TabControl
                controls[flag2][X] = saveX
                controls[flag2][Y] = saveY
                controls[flag2][CX] = saveCX
                controls[flag2][CY] = saveCY
                if flag!=TheWindow
                and flag!=flag2 then
                    if not equal(controls[flag2][ControlParent], controls[flag][Name]) then
                        deleteTreeViewNode("", controls[flag2][Name])
                        addTreeViewNode(controls[flag][Name],
                                        controls[flag2][Name])
                    end if
                    controls[flag2][ControlParent] = controls[flag][Name]
                    controls[flag2][ParentClass] = controls[flag][Class]
                    flag3 = findSeqParentName(flag2)
                    if flag3 then
                        removeFromParentChildSeq(flag3,controls[flag2][Name])
                    end if
                    controls[flag2][SeqParentName] = controls[flag][Name]
                    controls[flag2][SeqParentClass] = controls[flag][Class]
                    addToParentChildSeq(flag, controls[flag2][Name])
                elsif flag=TheWindow then
                    if length(controls[flag2][ControlParent])then
                        deleteTreeViewNode("", controls[flag2][Name])
                        addTreeViewNode(controls[1][Name],
                                        controls[flag2][Name])
                    end if
                    controls[flag2][ControlParent] = ""
                    controls[flag2][ParentClass] = ""
                    controls[flag2][Parent] = ""
                    flag3 = findSeqParentName(flag2)
                    if flag3 then
                        removeFromParentChildSeq(flag3,controls[flag2][Name])
                    end if
                    controls[flag2][SeqParentName] = ""
                    controls[flag2][SeqParentClass] = ""
                end if
                --re add other tabs on the tabcontrol
                if length(controls[flag2][SeqChildName]) then
                    childCnt = 0
                    for i=flag2 to length(controls) do
                        if find(controls[i][Name],controls[flag2][SeqChildName]) then
                            childCnt += 1
                            deleteTreeViewNode("", controls[i][Name])
                            addTreeViewNode(controls[flag2][Name],
                                            controls[i][Name])
                            if length(controls[i][SeqChildName]) then
                                addChildToPV(i)
                            end if
                            if childCnt>=length(controls[flag2][SeqChildName]) then
                                exit
                            end if
                        end if
                    end for
                end if
            end if

            IDE_Changed = w32True

            --and get out
            return
        end if

        --ctrlMouse or shiftMouse held down during move

        --if shift was held down in move, then the TabItem is moved
        --and its subs
        --and the new parent must be a TabControl or another tabitem.

        if ctrlMouse then
            --gather list of children
            childrenList = {}
            if length(controls[tempControl][SeqChildName]) then
                buildChildrenList(tempControl)
            end if
        else
            --gather list of children
            childrenList = {}
            if length(controls[selectedControl][SeqChildName]) then
                buildChildrenList(selectedControl)
            end if
        end if

        --where did TabItem move to?
        whoIsStatus = findHighestParent(controls[selectedControl][X],
                                        controls[selectedControl][Y],
                                        selectedControl)
        --it should be on the window or another tabitem
        if whoIsStatus[1]=0 then
            --if this was the only TabItem on the prior TabControl, then
            --move the TabControl now and do not create a new one....
            skipBuildNew = w32False
            flag = findSeqParentName(selectedControl)
            if flag then
                if length(controls[flag][SeqChildName])=1 then
                    controls[flag][X] = controls[selectedControl][X]
                    controls[flag][Y] = controls[selectedControl][Y]
                    skipBuildNew = w32True
                    --but need to remove this tabcontrol from prior parent
                    flag2 = findSeqParentName(flag)
                    if flag2 then
                        removeFromParentChildSeq(flag2,controls[flag][Name])
                    end if
                    --in any event the tabcontrol has no parenting
                    controls[flag][ControlParent] = ""
                    controls[flag][ParentClass] = ""
                    controls[flag][Parent] = ""
                    controls[flag][SeqParentName] = ""
                    deleteTreeViewNode("", controls[flag][Name])
                    addTreeViewNode(controls[1][Name],
                                    controls[flag][Name])
                end if
            end if

            if not skipBuildNew then
                --create a tabcontrol now?
                picked = findButtonName(TheTabControl, MasterList)
                newControl(picked, snap(controls[selectedControl][X]),
                           snap(controls[selectedControl][Y]),"","",0)

                --add to ProjectView
                addTreeViewNode(controls[1][Name],
                                controls[length(controls)][Name])
                treedata[1] = controls[length(controls)][Name]
                treedata[2] = controls[length(controls)][Class]
                theTreeForm &= {treedata}
                --move the new control before the existing selectedControl (TabItem)
                controls = controls[1..selectedControl-1] & {controls[length(controls)]}
                           & controls[selectedControl..length(controls)-1]

                flag = selectedControl  --new tabcontrol is now indexed where the selectedControl was
                --increment selectedcontrol
                selectedControl += 1
                if flag>1 then
                    lastOrder = controls[flag-1][TabOrder]
                    for i=flag to length(controls) do
                        --increment taborder because of inserting tabControl
                        lastOrder += 1
                        controls[i][TabOrder] = lastOrder
                    end for
                end if
            end if
            --save the difference between the tabControl x,y and the
            --moved tabItem for adjustment in moving the tabItems
            --sub controls.
            diffX = 0
            diffY = 0
            --adjust the TabControl's cx, cy to match the tabitem
            controls[flag][CX] = controls[selectedControl][CX]
            controls[flag][CY] = controls[selectedControl][CY]

            --change the active tab on the priorTabControl
            for i=1 to length(controls) do
                --is it the same parent as the selectedtabItem?
                if equal(controls[i][ControlParent],
                         controls[selectedControl][ControlParent]) then

                    --is this tabItem the same as the selectedTabItem?
                    if equal(controls[i][Name],
                             controls[selectedControl][Name]) then
                        --this is the current one do nothing
                    else
                        --now turn on the next tabitem for this parent
                        controls[i][Active] = 1
                        exit
                    end if
                end if
            end for

            --assign the new parent
            flag2 = findSeqParentName(selectedControl)
            if flag2 then
                removeFromParentChildSeq(flag2, controls[selectedControl][Name])
            end if
            controls[selectedControl][ControlParent] =
                            controls[flag][Name]
            controls[selectedControl][ParentClass] =
                            controls[flag][Class]
            controls[selectedControl][SeqParentName] = controls[flag][Name]
            controls[selectedControl][SeqParentClass] = controls[flag][Class]
            addToParentChildSeq(flag,controls[selectedControl][Name])

            deleteTreeViewNode("", controls[selectedControl][Name])
            if length(controls[selectedControl][ControlParent]) then
                addTreeViewNode(controls[selectedControl][ControlParent],
                                controls[selectedControl][Name])
            else
                addTreeViewNode(controls[1][Name],
                                controls[selectedControl][Name])
            end if

            --change the active tab on THIS tabControl
            controls[selectedControl][Active] = w32True

            --move controls from selected control
            if length(controls[selectedControl][SeqChildName]) then
                moveThisControlSubs(controls[selectedControl][Name],
                                    saveDragX-diffX,saveDragY-diffY, selectedControl)
            end if

            if ctrlMouse then
                --copy sub controls of the copied control
                copySubTheCopyControl(tempControl,selectedControl,controls[selectedControl][Name],
                                      controls[selectedControl][Class])
            end if

        elsif whoIsStatus[1] then
            --it must be dropped on a tabItem
            if equal(whoIsStatus[2], "TabItem") then
                flag = findTabItemParent(controls[selectedControl][X],
                                         controls[selectedControl][Y])
                if flag
                and equal(controls[flag][Class], "TabItem") then
                    flag = findSeqParentName(flag)
                end if

                if not equal(controls[flag][Class], "TabControl") then
                    if not ctrlMouse then
                        ok = displayErrorMessage(82,{whoIsStatus[2]})
                        if rSelectedWindow!=selectedWindow then
                            badCopy = w32True
                            return
                        end if
                        --move back to original position
                        controls[selectedControl][X] = origX
                        controls[selectedControl][Y] = origY
                    else
                        ok = displayErrorMessage(109,{controls[flag][Class]})
                        deleteTheCopyControl()
                    end if
                    state = Normal

                    -- clear mouse down flag
                    mouseDown = 0
                    return
                end if
            else
                if not ctrlMouse then
                    ok = displayErrorMessage(83,{whoIsStatus[2]})
                    --move back to original position
                    controls[selectedControl][X] = origX
                    controls[selectedControl][Y] = origY
                else
                    ok = displayErrorMessage(109,{controls[whoIsStatus[1]][Class]})
                    deleteTheCopyControl()
                end if
                state = Normal

                -- clear mouse down flag
                mouseDown = 0
                return
            end if

            --clear the redraw sequence
            reDrawTabItemControls = {}

            diffX = controls[selectedControl][X]-controls[whoIsStatus[1]][X]
            diffY = controls[selectedControl][Y]-controls[whoIsStatus[1]][Y]

            --move it to tabControl x, y
            controls[selectedControl][X] = controls[whoIsStatus[1]][X]
            controls[selectedControl][Y] = controls[whoIsStatus[1]][Y]

            --adjust the Tab's cx, cy to match the current tab control
            controls[selectedControl][CX] = controls[whoIsStatus[1]][CX]
            controls[selectedControl][CY] = controls[whoIsStatus[1]][CY]

            --change the active tab on the TabControl's TabItems came from
            flag2 = findSeqParentName(selectedControl)
            if flag2 then
                if length(controls[flag2][SeqChildName]) then
                    if length(controls[flag2][SeqChildName])=1 then
                        --this is the control we are moving; so do nothing now
                    else
                        for i=flag2 to length(controls) do
                            if find(controls[i][Name], controls[flag2][SeqChildName])
                            and i!=selectedControl then
                                controls[i][Active] = w32True
                                exit
                            end if
                        end for
                    end if
                end if
                removeFromParentChildSeq(flag2, controls[selectedControl][Name])

                if not length(controls[flag2][SeqChildName]) then
                    --later want to delete this TabControl when no children
                    holdcontrol = flag2
                end if
            end if

            --assign the new parent            
            controls[selectedControl][ControlParent] = controls[flag][Name]
            controls[selectedControl][ParentClass] = controls[flag][Class]
            controls[selectedControl][SeqParentName] = controls[flag][Name]
            controls[selectedControl][SeqParentClass] = controls[flag][Class]
            addToParentChildSeq(flag, controls[selectedControl][Name])
            deleteTreeViewNode("", controls[selectedControl][Name])
            if length(controls[selectedControl][ControlParent]) then
                addTreeViewNode(controls[selectedControl][ControlParent],
                                controls[selectedControl][Name])
            else
                addTreeViewNode(controls[1][Name],
                                controls[selectedControl][Name])
            end if

            if ctrlMouse then
                --create Project View entry
                addTreeViewNode(controls[selectedControl][SeqParentName], controls[selectedControl][Name])
                treedata[1] = controls[selectedControl][Name]
                treedata[2] = controls[selectedControl][Class]
                theTreeForm &= {treedata}
                --copy sub controls of the copied control
                copySubTheCopyControl(tempControl,selectedControl,controls[selectedControl][Name],
                                      controls[selectedControl][Class])
            end if

            --remove the active tab on existing tabs for this tabcontrol
            childCnt = 0
            for i=flag to length(controls) do
                if find(controls[i][Name],controls[flag][SeqChildName]) then
                    childCnt += 1
                    if i=selectedControl then
                        controls[i][Active] = w32True
                    else
                        controls[i][Active] = w32False
                    end if
                    if childCnt>=length(controls[flag][SeqChildName]) then
                        exit
                    end if
                end if
            end for

            --find the largest tab cx, cy
            childCnt = 0
            for i=flag to length(controls) do
                if find(controls[i][Name], controls[flag][SeqChildName]) then
                    childCnt += 1
                    if controls[i][CX]>testCX then
                        testCX = controls[i][CX]
                    end if
                    if controls[i][CY]>testCY then
                        testCY = controls[i][CY]
                    end if
                    if childCnt>=length(controls[flag][SeqChildName]) then
                        exit
                    end if
                end if
            end for

            --resize the controls
            childCnt = 0
            for i=flag to length(controls) do
                if find(controls[i][Name], controls[flag][SeqChildName]) then
                    childCnt += 1
                    controls[i][CX] = testCX
                    controls[i][CY] = testCY
                    if childCnt>=length(controls[flag][SeqChildName]) then
                        exit
                    end if
                end if
            end for

            --ok now lets move the controls within the particular tabItem moved
            if not ctrlMouse then
                if length(controls[selectedControl][SeqChildName]) then
                    moveThisControlSubs(controls[selectedControl][Name],
                                        saveDragX-diffX, saveDragY-diffY, selectedControl)
                end if
            end if
            if holdcontrol then
                selectedControl = holdcontrol
                call_proc(deleteTheControl_id,{})
            end if
        end if

    elsif equal(controls[selectedControl][Class], "TabControl") then
        tempControl = selectedControl
        --gather list of children
        childrenList = {}
        if length(controls[tempControl][SeqChildName]) then
            buildChildrenList(tempControl)
        end if

        --save the ending position
        saveX = controls[selectedControl][X]
        saveY = controls[selectedControl][Y]
        flag2 = findSeqParentName(selectedControl)
        if flag2 then
            removeFromParentChildSeq(flag2, controls[selectedControl][Name])
        end if

        --check that not moved onto another control not window or tabitem
        flag = inControl(saveX, saveY)

        if find(controls[flag][Name], childrenList)
        or flag=tempControl then
            if length(controls[tempControl][ControlParent]) then
                flag = findSeqParentName(tempControl)
            else
                flag = TheWindow
            end if
        end if

        if find(controls[flag][Class], {"Window","TabItem","CWindow"}) then
            --we are ok
            --assign tabItem as parent of tabControl but not Window
            if equal(controls[flag][Class], "Window") then
                controls[selectedControl][ControlParent] = ""
                controls[selectedControl][ParentClass] = ""
                controls[selectedControl][SeqParentName] = ""
                controls[selectedControl][SeqParentClass] = ""
                deleteTreeViewNode("", controls[selectedControl][Name])
                addTreeViewNode(controls[1][Name],
                                controls[selectedControl][Name])
            else
                controls[selectedControl][SeqParentName] = controls[flag][Name]
                controls[selectedControl][SeqParentClass] = controls[flag][Class]
                addToParentChildSeq(flag, controls[selectedControl][Name])
                controls[selectedControl][ControlParent] = controls[flag][Name]
                controls[selectedControl][ParentClass] = controls[flag][Class]
                deleteTreeViewNode("", controls[selectedControl][Name])
                addTreeViewNode(controls[flag][Name],
                                controls[selectedControl][Name])
            end if

            --reset saveCX and saveCY
            saveCX = controls[selectedControl][CX]
            saveCY = controls[selectedControl][CY]

            --how much drag did we do?
            saveDragX = saveX-saveDragX
            saveDragY = saveY-saveDragY

            if ctrlMouse then
                copySubTheCopyControl(tempControl, selectedControl, controls[selectedControl][Name],
                                      controls[selectedControl][Class])
            end if

            --now move the Tabitems and their Subs
            --change all tabitems in this tabControl to the
            --new x,y and cx,cy
            for i=1 to length(controls) do
                if equal(controls[i][Class], "TabItem")
                and equal(controls[i][ControlParent],
                          controls[selectedControl][Name]) then
                    controls[i][X] = saveX
                    controls[i][Y] = saveY

                    controls[i][CX] = saveCX
                    controls[i][CY] = saveCY

                    --now move the controls within the tabItem
                    if not ctrlMouse then
                        if length(controls[i][SeqChildName]) then
                            moveThisControlSubs(controls[i][Name], saveDragX, saveDragY, i)
                        end if
                    end if
                end if
            end for

        else
            if not ctrlMouse then
                ok = displayErrorMessage(84,{controls[flag][Class]})
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                ok = displayErrorMessage(109,{controls[flag][Class]})
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if
    end if

    IDE_Changed = w32True

end procedure
TabItemStuff_id = routine_id("tabItemStuff")
----------------------------------------------------------------------------
procedure groupStuff(integer saveDragX, integer saveDragY, integer origX,
                        integer origY, integer ctrlMouse)

integer saveX, saveY, childCnt
integer flag, priorDirectParent, totalCX, index
sequence whoIsStatus, priorParent, whoIs, extent, priorParentForPV,
        chgControlParentTo, chgParentClassTo, statusBarChildCnt

    --note: everywhere see word "Group" also assume works the same way for
    --"Table", "EuGrid", "CWindwo", "ReBar" and "ReBarBand"

    reDrawTabItemControls = {}
    whoIsStatus = {}
    priorParent = {}
    priorDirectParent = 0
    statusBarChildCnt = {}


    --if control being moved is a group then move its controls also.
    if find(controls[selectedControl][Class], {"Group","Table","ReBarBand",
                                               "CWindow","RText","CText","LText","EuGrid","StatusBar"}) then

        --did it previously have a high parent?
        priorParent = controls[selectedControl][ControlParent]
        -- find the new highest parent, if any

        whoIsStatus = findHighestParent(controls[selectedControl][X],
                                        controls[selectedControl][Y],
                                        selectedControl)

        --did it previously have a direct parent?              
        priorDirectParent = findSeqParentName(selectedControl)

        --gather list of children
        childrenList = {}
        if length(controls[selectedControl][SeqChildName]) then
            buildChildrenList(selectedControl)
        end if

        flag = inControl(controls[selectedControl][X],controls[selectedControl][Y])

        if equal(controls[selectedControl][Class], "StatusBar") then
            for jj=1 to length(ControlList) do
                if equal(ControlList[jj][ControlClass], "StatusBar") then
                    index = jj
                    exit
                end if
            end for

            --must be moved to Window or CWindow
            if equal(controls[flag][Class], "CWindow")
            or flag=TheWindow then
                --is good
                --since user may left up anywhere in the parent, must set X at parent's
                --border. Y is set in drawitall.
                if flag=1 then
                    controls[selectedControl][X] = controls[TheWindow][X]
                    controls[selectedControl][Y] = controls[TheWindow][CY]
                                                   -ControlList[index][ControlCY]-(MenuY+WinY+titleBar+(2*borderX))
                    controls[selectedControl][CX] = controls[TheWindow][CX]
                else
                    controls[selectedControl][X] = controls[flag][X]+borderX
                    controls[selectedControl][Y] = controls[flag][CY]
                                                   -(ControlList[index][ControlCY]-controls[flag][Y]-titleBar-borderX)-(MenuY+WinY+titleBar+(2*borderX))
                    controls[selectedControl][CX] = controls[flag][CX]
                end if
            else
                --move back to original position                                
                ok = displayErrorMessage(253,{})
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
                state = Normal
                -- clear mouse down flag
                mouseDown = 0
                return
            end if

            --check if there are other status bars for window where moved
            if flag>1 then
                if length(controls[flag][SeqChildName]) then
                    for x=flag to length(controls) do
                        if find(controls[x][Name], controls[flag][SeqChildName])
                        and equal(controls[x][Class], "StatusBar") then
                            if x!=selectedControl then
                                ok = displayErrorMessage(55,{})
                                if rSelectedWindow!=selectedWindow then
                                    badCopy = w32True
                                    return
                                end if
                            end if
                            --move back to original position                                                        
                            controls[selectedControl][X] = origX
                            controls[selectedControl][Y] = origY
                            state = Normal
                            -- clear mouse down flag
                            mouseDown = 0
                            return
                        end if
                    end for
                end if
            else
                --check window1                                                 
                for x=1 to length(controls) do
                    if equal(controls[x][Class], "StatusBar")
                    and not length(controls[x][SeqParentName]) then
                        if not equal(controls[x][Name],controls[selectedControl][Name]) then
                            ok = displayErrorMessage(55,{})
                            if rSelectedWindow!=selectedWindow then
                                badCopy = w32True
                                return
                            end if
                                                        --move back to original position
                            controls[selectedControl][X] = origX
                            controls[selectedControl][Y] = origY
                            state = Normal
                            -- clear mouse down flag
                            mouseDown = 0
                            return
                        end if
                    end if
                end for
            end if

            --build child controls X offset from StatusBar X so can rebuild statusBar children at same X offset
            if length(controls[selectedControl][SeqChildName]) then
                statusBarChildCnt = {}
                childCnt = 0
                for x=selectedControl to length(controls) do
                    if find(controls[x][Name], controls[selectedControl][SeqChildName]) then
                        statusBarChildCnt &= {controls[x][X]-origX}
                        childCnt += 1
                    end if
                    if childCnt>=length(controls[selectedControl][SeqChildName]) then
                        exit
                    end if
                end for
            end if
        end if

        if find(controls[flag][Name], childrenList)
        or flag=selectedControl then
            flag = TheWindow    --it will get fixed later....
        end if

        if equal(controls[flag][Class], "TabControl") then
            if not ctrlMouse then
                ok = displayErrorMessage(85,{controls[selectedControl][Class]})
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                ok = displayErrorMessage(109,{controls[flag][Class]})
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        if (equal(whoIsStatus[2], "Table")
            or equal(controls[flag][Class], "Table"))
        and find(controls[selectedControl][Class], {"Table","Group","TabItem","CWindow"}) then
            if not ctrlMouse then
                ok = displayErrorMessage(86,{controls[selectedControl][Class]})
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                ok = displayErrorMessage(109,{whoIsStatus[2]})
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        --can not move ReBarBand outside of ReBar
        if whoIsStatus[1]=0
        and equal(controls[selectedControl][Class], "ReBarBand") then
            if not ctrlMouse then
                ok = displayErrorMessage(92,{})
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                ok = displayErrorMessage(110,{})
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        --can not move ReBarBand outside of ReBar
        if whoIsStatus[1]
        and not equal(whoIsStatus[2], "ReBar")
        and equal(controls[selectedControl][Class], "ReBarBand") then
            if not ctrlMouse then
                ok = displayErrorMessage(93,{})
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                ok = displayErrorMessage(110,{})
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        --can not move anything but Rebarband inside of ReBar
        if whoIsStatus[1]
        and equal(whoIsStatus[2], "ReBar")
        and not equal(controls[selectedControl][Class], "ReBarBand") then
            whoIs = findDirectParent(controls[selectedControl][X],
                                     controls[selectedControl][Y],
                                     controls[selectedControl][ControlParent],
                                     controls[selectedControl][Name],
                                     selectedControl)
            if whoIs[1] and equal(whoIs[2], "ReBarBand") then
                --ok
            else
                if whoIs[1] and not find(whoIs[2], {"ReBar","ReBarBand"}) then
                    ok = displayErrorMessage(89,{controls[selectedControl][Class]})
                    if rSelectedWindow!=selectedWindow then
                        badCopy = w32True
                        return
                    end if
                else
                    ok = displayErrorMessage(94,{})
                    if rSelectedWindow!=selectedWindow then
                        badCopy = w32True
                        return
                    end if
                end if
                if not ctrlMouse then
                    --move back to original position
                    controls[selectedControl][X] = origX
                    controls[selectedControl][Y] = origY
                else
                    deleteTheCopyControl()
                end if
                state = Normal

                -- clear mouse down flag
                mouseDown = 0
                return
            end if
        end if

        if equal(controls[flag][Class], "ReBar")
        and not equal(controls[selectedControl][Class], "ReBarBand") then
            if not ctrlMouse then
                ok = displayErrorMessage(87,{controls[selectedControl][Class]})
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                ok = displayErrorMessage(109,{whoIs[2]})
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        if equal(controls[flag][Class], "ReBarBand")
        --can only have 1 control in a ReBarBand
        and length(controls[flag][SeqChildName]) then
            ok = displayErrorMessage(88,{controls[flag][Name]})
            if not ctrlMouse then
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                deleteTheCopyControl()
            end if
            state = Normal
            -- clear mouse down flag
            mouseDown = 0
            return
        end if
        if equal(controls[flag][Class], "ReBarBand")
        and equal(controls[selectedControl][Class], "CWindow") then
            ok = displayErrorMessage(265,{controls[selectedControl][Class]})
            if rSelectedWindow!=selectedWindow then
                badCopy = w32True
                return
            end if
                --move back to original position
            controls[selectedControl][X] = origX
            controls[selectedControl][Y] = origY
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        if (whoIsStatus[1] and find(whoIsStatus[2], {"FlatToolBar","ToolBar"}))
        or find(controls[flag][Class], {"FlatToolBar","ToolBar"}) then
            ok = displayErrorMessage(89,{controls[selectedControl][Class]})
            if rSelectedWindow!=selectedWindow then
                badCopy = w32True
                return
            end if
            if not ctrlMouse then
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        if equal(controls[flag][Class], "ReBarBand") then
            repaintWinResize = w32True
            controls[selectedControl][Y] = controls[flag][Y]+1
            extent = getTextExtent(ControlBlit, controls[flag][Title])
            controls[selectedControl][X] = controls[flag][X]+extent[1]+5
        end if

        if whoIsStatus[1] then
            controls[selectedControl][ControlParent] =
                        controls[whoIsStatus[1]][Name]
            controls[selectedControl][ParentClass] =
                        whoIsStatus[2]
        else
            controls[selectedControl][ControlParent] = {}
            controls[selectedControl][ParentClass] = {}
        end if

        whoIs = findDirectParent(controls[selectedControl][X],
                                 controls[selectedControl][Y],
                                 controls[selectedControl][ControlParent],
                                 controls[selectedControl][Name],
                                 selectedControl)

        --control moved into EuGrid
        if whoIs[1]
        and equal(whoIs[2],"EuGrid") then
            totalCX = controls[whoIs[1]][GridRowHeaderCX]+controls[whoIs[1]][X]
            if length(controls[whoIs[1]][SeqChildName]) then
                childCnt = 0
                for i=whoIs[1] to length(controls) do
                    if find(controls[i][Name],controls[whoIs[1]][SeqChildName]) then
                        childCnt += 1
                        totalCX += controls[i][CX]
                    end if
                    if childCnt>=length(controls[whoIs[1]][SeqChildName]) then
                        exit
                    end if
                end for
            end if
            --place this control next available slot and under the grid header
            controls[selectedControl][X] = totalCX
            controls[selectedControl][Y] = controls[whoIs[1]][Y]+controls[whoIs[1]][GridColHeaderCY]
            controls[selectedControl][CY] = gridCellCY
            controls[selectedControl][BkColor] = controls[whoIs[1]][GridBkColorRows]
            if controls[selectedControl][X]>controls[whoIs[1]][X]+controls[whoIs[1]][CX] then
                ok = displayErrorMessage(234,{})
                if not ctrlMouse then
                    if rSelectedWindow!=selectedWindow then
                        badCopy = w32True
                        return
                    end if
                    --move back to original position
                    controls[selectedControl][X] = origX
                    controls[selectedControl][Y] = origY
                else
                    deleteTheCopyControl()
                end if
                state = Normal
                -- clear mouse down flag
                mouseDown = 0
                return
            end if
        end if

        priorParentForPV = controls[selectedControl][SeqParentName]

        if whoIs[1] then
            if priorDirectParent then
                removeFromParentChildSeq(priorDirectParent, controls[selectedControl][Name])
            end if
            controls[selectedControl][SeqParentName] = controls[whoIs[1]][Name]
            controls[selectedControl][SeqParentClass] = controls[whoIs[1]][Class]
            addToParentChildSeq(whoIs[1],controls[selectedControl][Name])
        else
            if priorDirectParent then
                removeFromParentChildSeq(priorDirectParent, controls[selectedControl][Name])
            end if
            controls[selectedControl][SeqParentName] = ""
            controls[selectedControl][SeqParentClass] = ""
        end if

        if priorDirectParent
        and equal(controls[priorDirectParent][Class], "EuGrid") then
            repaintWinResize = w32True
        end if

        if whoIs[1]
        and equal(controls[whoIs[1]][Class], "EuGrid") then
            repaintWinResize = w32True
        end if

        if not length(controls[selectedControl][SeqParentName])
        and whoIsStatus[1] then
            if priorDirectParent then
                removeFromParentChildSeq(priorDirectParent, controls[selectedControl][Name])
            end if
            controls[selectedControl][SeqParentName] = controls[whoIsStatus[1]][Name]
            controls[selectedControl][SeqParentClass] = controls[whoIsStatus[1]][Class]
            addToParentChildSeq(whoIsStatus[1],controls[selectedControl][Name])
        end if

        --end of validations
        if not equal(priorParentForPV, controls[selectedControl][SeqParentName]) then
            deleteTreeViewNode("", controls[selectedControl][Name])
            if length(controls[selectedControl][SeqParentName]) then
                addTreeViewNode(controls[selectedControl][SeqParentName],
                                controls[selectedControl][Name])
            else
                addTreeViewNode(controls[1][Name],controls[selectedControl][Name])
            end if
        end if

        --save the ending position
        saveX = controls[selectedControl][X]
        saveY = controls[selectedControl][Y]

        --how much drag did we do?
        saveDragX = saveX-saveDragX

        saveDragY = saveY-saveDragY

        if length(controls[selectedControl][SeqChildName]) then
            childCnt = 0
            for i=selectedControl to length(controls) do
                if find(controls[i][Name],
                        controls[selectedControl][SeqChildName]) then
                    childCnt += 1
                    deleteTreeViewNode("",controls[i][Name])
                    addTreeViewNode(controls[i][SeqParentName],controls[i][Name])

                    -- adjust the x,y for the drag for all sub controls when move but not when copy
                    if not ctrlMouse then
                        if equal(controls[selectedControl][Class], "StatusBar") then
                            controls[i][X] = statusBarChildCnt[childCnt]
                            if length(controls[selectedControl][SeqParentName]) then
                                controls[i][X] += controls[selectedControl][X]
                            end if
                        else
                            controls[i][X] += saveDragX
                        end if
                        controls[i][Y] += saveDragY
                    end if

                    --dont adjust cells of a Table,ReBar,ReBarBand,ToolBar or FlatToolBar
                    if not controls[i][TableCell]
                    and not find(controls[i][Class], {"ToolBar","FlatToolBar",
                                                      "ReBar","RebarBand"})
                    and not find(controls[i][SeqParentName],{"ToolBar","FlatToolBar"}) then
                        -- snap to grid
                        controls[i][X] = snap(controls[i][X])
                        controls[i][Y] = snap(controls[i][Y])
                    end if

                    if length(controls[selectedControl][ControlParent]) then
                        controls[i][ControlParent] = controls[selectedControl][ControlParent]
                        controls[i][ParentClass] = controls[selectedControl][ParentClass]
                    end if

                    if length(controls[i][SeqChildName]) then
                        --if this control has children they should have the same highest parent as this one
                        --unless there is no high parent, in which case, high parent is this control
                        if length(controls[i][ControlParent]) then
                            chgControlParentTo = controls[i][ControlParent]
                            chgParentClassTo = controls[i][ParentClass]
                        else
                            chgControlParentTo = controls[i][Name]
                            chgParentClassTo = controls[i][Class]
                        end if
                        moveThisControlSubsAndChgHighParent(controls[i][Name], saveDragX, saveDragY, i,
                                                            chgControlParentTo,chgParentClassTo)
                    end if
                    if childCnt>=length(controls[selectedControl][SeqChildName]) then
                        exit
                    end if
                end if
            end for
        end if
    end if

    IDE_Changed = w32True
end procedure
GroupStuff_id = routine_id("groupStuff")
------------------------------------------------------------------------------
global sequence tables     --this is a temporary place for storing all the table cells
                    --for a table *in order*. replace the cells in controls with
                    --this one, unless there is an error
tables = {}
------------------------------------------------------------------------------
procedure miscStuff(integer origX, integer origY, integer ctrlMouse)
sequence whoIsStatus, whoIs, whoIsAgain, moveCells,
                whoIs2, extent
integer flag, badMove, saveX, saveY, saveDragX, saveDragY, sDragX, sDragY,
            cnt, cntControl, toolBarIndex, oldParent, childCnt, gotCell,totalCX
sequence oldHighParent, parentForPV

    whoIs = {0,""}
    moveCells = {}

    if find(controls[selectedControl][ParentClass], {"ToolBar","FlatToolBar","ReBar"}) then
        --took care of these in ToolBarStuff above
        return
    end if

    if find(controls[selectedControl][Class],{"RText","CText","LText"})
    and length(controls[selectedControl][SeqChildName]) then
        --took care of these in groupstuff above
        return
    end if


    --reported ability to move Menu, but I don't know how that happens!
    --anyway, keep it from moving here
    if find(controls[selectedControl][Class], {"Menu","MenuItem","Submenu","SubmenuItem",
                                               "Sub2menu","Sub2menuItem","Sub3menu","Sub3menuItem",
                                               "Popup","PopupItem","Subpopup","SubpopupItem","Sub2popup","Sub2popupItem",
                                               "Sub3popup","Sub3popupItem","Timer"}) then
        --move back to original position       
        controls[selectedControl][X] = origX
        controls[selectedControl][Y] = origY

        state = Normal

        -- clear mouse down flag
        mouseDown = 0
        return
    end if

    --get old high parent
    oldHighParent = controls[selectedControl][ControlParent]

    --check who the high parent is now
    whoIsStatus = findHighestParent(controls[selectedControl][X],
                                    controls[selectedControl][Y],
                                    selectedControl)

    --get old direct parent
    oldParent = findSeqParentName(selectedControl)

    --check who is direct parent now
    whoIs = findDirectParent(controls[selectedControl][X],
                             controls[selectedControl][Y],
                             controls[selectedControl][ControlParent],
                             controls[selectedControl][Name],
                             selectedControl)
    parentForPV = controls[selectedControl][SeqParentName]

    if whoIsStatus[1]
    and not whoIs[1] then
        --when move a control onto TabItem this case may happen
        if equal(whoIsStatus[2], "TabItem") then
            whoIs2 = findDirectParent(controls[selectedControl][X],
                                      controls[selectedControl][Y],
                                      controls[whoIsStatus[1]][Name],
                                      controls[selectedControl][Name],
                                      selectedControl)
            if whoIs2[1] then
                whoIs[1] = whoIs2[1]
                whoIs[2] = whoIs2[2]
            else
                whoIs[1] = whoIsStatus[1]
                whoIs[2] = whoIsStatus[2]
            end if
        else
            whoIs[1] = whoIsStatus[1]
            whoIs[2] = whoIsStatus[2]
        end if
    end if

    if whoIs[1] then
        if not find(controls[selectedControl][Class], validEuGridChild)
        and equal(controls[whoIs[1]][Class],"EuGrid") then
            ok = displayErrorMessage(235,{})
            if not ctrlMouse then
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        if equal(controls[whoIs[1]][SeqParentClass], "EuGrid") then
            ok = displayErrorMessage(236,{})
            if not ctrlMouse then
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if

        if equal(whoIs[2], "Table")
        and not controls[selectedControl][TableCell] then
            ok = displayErrorMessage(95,{})
            if not ctrlMouse then
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if
    end if

    --tests only for Table and its controls:
    badMove = w32False
    if not whoIs[1] then
        badMove = w32True
    else
        if not equal(whoIs[2], "Table") then
            badMove = w32True
        end if
    end if
    if badMove
    and controls[selectedControl][TableCell] then
        ok = displayErrorMessage(96,{})
        if not ctrlMouse then
            if rSelectedWindow!=selectedWindow then
                badCopy = w32True
                return
            end if
            --move back to original position                            
            controls[selectedControl][X] = origX
            controls[selectedControl][Y] = origY
        else
            deleteTheCopyControl()
        end if
        state = Normal

        -- clear mouse down flag
        mouseDown = 0
        return
    end if

    --a table cell must stay inside its parent table
    if whoIsStatus[1]
    and equal(controls[selectedControl][ParentClass], "Table") then
        flag = inControl(controls[selectedControl][X],
                         controls[selectedControl][Y])
        --check that it stayed inside the Table
        if equal(controls[selectedControl][ControlParent],
                 controls[whoIsStatus[1]][Name])
        or equal(controls[selectedControl][ControlParent],
                 controls[flag][Name]) then
                    --good move
        else
            ok = displayErrorMessage(97,{})
            if not ctrlMouse then
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position                      
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if
    end if

    --control is in table, then move other cells related to this control
    if controls[selectedControl][TableCell]=1 then
        --move all the other cells for this control
        cnt = 0  --determine if only 1 control in cell 1
        cntControl = 0 --determine if other cells
        flag = findSeqParentName(selectedControl)
        if not flag then
            ok = displayErrorMessage(220,{})
            if rSelectedWindow!=selectedWindow then
                badCopy = w32True
                return
            end if
            return
        end if
        childCnt = 0
        for i=flag to length(controls) do
            if find(controls[i][Name], controls[flag][SeqChildName]) then
                childCnt += 1
                --other controls for cell 1?
                if controls[i][TableCell]=1 then
                    if i!=selectedControl then
                        cnt += 1
                    end if
                else
                    cntControl += 1
                end if
                if childCnt>=length(controls[flag][SeqChildName]) then
                    exit
                end if
            end if
        end for

        if cnt=0
        and cntControl=0 then
            --no other cells for this control and only 1 control in cell 1
            return
        end if

        --save the ending position
        saveX = controls[selectedControl][X]
        saveY = controls[selectedControl][Y]

        --how much drag did we do?
        saveDragX = saveX-origX
        saveDragY = saveY-origY

        if cnt and cntControl then
            --more than one control and other cells
            ok = displayErrorMessage(98,{})
        elsif cnt and not cntControl then
            ok = displayErrorMessage(99,{})
        else
            --only one control but other cells
            ok = IDYES
        end if
        if ok=IDCANCEL then
            controls[selectedControl][X] = origX
            controls[selectedControl][Y] = origY
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        elsif ok=IDNO then
            --move all the cells for this control
            badMove = w32False
            childCnt = 0
            for i=flag to length(controls) do
                --other cells for this control?
                if not find(controls[i][Name], controls[flag][SeqChildName]) then
                        --skip. Its not a member of this table
                elsif i=selectedControl then
                    childCnt += 1
                    --do nothing we already moved it
                else
                    childCnt += 1
                    --move it
                    -- add its name to the redraw sequence
                    if not controls[i][DontDraw] then
                        reDrawTabItemControls &= i
                    end if
                    -- adjust the x,y for the drag
                    controls[i][X] = (saveDragX+controls[i][X])
                    controls[i][Y] = (saveDragY+controls[i][Y])

                    --add to cells moved
                    moveCells &= i

                    --is it still in the Table
                    if not controls[i][DontDraw] then
                        --did moving other cells move them outside of table?
                        whoIsAgain = findDirectParent(controls[i][X], controls[i][Y],
                                                      controls[i][ControlParent],controls[i][Name],i)
                        if whoIsAgain[1] then
                            if equal(controls[whoIsAgain[1]][Name], controls[i][SeqParentName]) then
                                    --move was ok
                            else
                                ok = displayErrorMessage(100,{})
                                badMove = w32True
                                if rSelectedWindow!=selectedWindow then
                                    badCopy = w32True
                                    return
                                end if
                                --not same parent put it back
                                controls[selectedControl][X] -= saveDragX
                                controls[selectedControl][Y] -= saveDragY
                                for j=1 to length(moveCells) do
                                    controls[moveCells[j]][X] -= saveDragX
                                    controls[moveCells[j]][Y] -= saveDragY
                                end for
                                return
                            end if
                        end if
                    end if
                end if
                if childCnt>=length(controls[flag][SeqChildName]) then
                    exit
                end if
            end for
            --adjust the Table control for this cell
            if not badMove then
                childCnt = 0
                --need to adjust the right side to fit the rightmost control
                --need to adjust the botom for the bottommost control
                for i=flag to length(controls) do
                    if find(controls[i][Name], controls[flag][SeqChildName]) then
                        childCnt += 1
                        if controls[i][TableCell] then
                            if not controls[i][DontDraw] then
                                if controls[i][X]+controls[i][CX]+8>controls[flag][X]+controls[flag][CX] then
                                    controls[flag][CX] += (controls[i][X]+controls[i][CX])-
                                                          (controls[flag][X]+controls[flag][CX])+8
                                end if
                                if controls[i][Y]+controls[i][CY]+8>controls[flag][Y]+controls[flag][CY] then
                                    controls[flag][CY] += (controls[i][Y]+controls[i][CY])-
                                                          (controls[flag][Y]+controls[flag][CY])+8
                                end if
                            end if
                        end if
                        if childCnt>=length(controls[flag][SeqChildName]) then
                            exit
                        end if
                    end if
                end for
            end if

            IDE_Changed = w32True
            return
        else
            --move only the selected control's cells
            childCnt = 0
            gotCell = w32False
            for i=flag to length(controls) do
                --other cells for this control?
                if find(controls[i][Name],controls[flag][SeqChildName]) then
                    childCnt += 1
                    if controls[i][TableCell]=1 then
                        if i!=selectedControl then
                            --must be the next control's cell1 for this cell
                            --exit if found cell 1 for selected control
                            if gotCell then
                                exit
                            end if
                        elsif i=selectedControl then
                            gotCell = w32True
                        end if
                    else
                        --move it
                        if i!=selectedControl
                        and gotCell then
                            -- add its name to the redraw sequence
                            if not controls[i][DontDraw] then
                                reDrawTabItemControls &= i
                            end if
                            -- adjust the x,y for the drag
                            controls[i][X] = (saveDragX+controls[i][X])
                            controls[i][Y] = (saveDragY+controls[i][Y])
                        end if
                    end if
                    if childCnt>=length(controls[flag][SeqChildName]) then
                        exit
                    end if
                end if

            end for
            --adjust the Table control for this cell

            --need to adjust the right side to fit the rightmost control
            --need to adjust the bottom for the bottommost control
            childCnt = 0
            for i=flag to length(controls) do
                if not find(controls[i][Name], controls[flag][SeqChildName]) then
                        --not part of table
                else
                    childCnt += 1
                    if not controls[i][DontDraw] then
                        if controls[i][X]+controls[i][CX]+8>controls[whoIs[1]][X]+controls[whoIs[1]][CX] then
                            controls[whoIs[1]][CX] += (controls[i][X]+controls[i][CX])-
                                                      (controls[whoIs[1]][X]+controls[whoIs[1]][CX])+8
                        end if
                        if controls[i][Y]+controls[i][CY]+8>controls[whoIs[1]][Y]+controls[whoIs[1]][CY] then
                            controls[whoIs[1]][CY] += (controls[i][Y]+controls[i][CY])-
                                                      (controls[whoIs[1]][Y]+controls[whoIs[1]][CY])+8
                        end if
                    end if
                    if childCnt>=length(controls[flag][SeqChildName]) then
                        exit
                    end if
                end if
            end for
        end if

        IDE_Changed = w32True
        return
    end if
    --through with Table control and its cells.

    if whoIs[1]
    and oldParent!=whoIs[1] then
        --control moved into EuGrid
        if equal(whoIs[2],"EuGrid") then
            totalCX = controls[whoIs[1]][GridRowHeaderCX]+controls[whoIs[1]][X]
            if length(controls[whoIs[1]][SeqChildName]) then
                childCnt = 0
                for i=whoIs[1] to length(controls) do
                    if find(controls[i][Name],controls[whoIs[1]][SeqChildName])
                    and i!=selectedControl then
                        childCnt += 1
                        totalCX += controls[i][CX]
                    end if
                    if childCnt>=length(controls[whoIs[1]][SeqChildName]) then
                        exit
                    end if
                end for
            end if
            --place this control next available slot and under the grid header
            controls[selectedControl][X] = totalCX
            controls[selectedControl][Y] = controls[whoIs[1]][Y]+controls[whoIs[1]][GridColHeaderCY]
            controls[selectedControl][CY] = gridCellCY
            controls[selectedControl][BkColor] = controls[whoIs[1]][GridBkColorRows]
            if controls[selectedControl][X]>controls[whoIs[1]][X]+controls[whoIs[1]][CX] then
                ok = displayErrorMessage(234,{})
                if not ctrlMouse then
                    if rSelectedWindow!=selectedWindow then
                        badCopy = w32True
                        return
                    end if
                    --move back to original position
                    controls[selectedControl][X] = origX
                    controls[selectedControl][Y] = origY
                else
                    deleteTheCopyControl()
                end if
                state = Normal
                -- clear mouse down flag
                mouseDown = 0
                return
            end if
        end if
    else
        if equal(whoIs[2], "EuGrid") then
            --Y must not change
            controls[selectedControl][Y] = origY
        end if
    end if

    if oldParent
    and equal(controls[oldParent][Class], "EuGrid") then
        repaintWinResize = w32True
    end if

    if whoIs[1]
    and equal(controls[whoIs[1]][Class], "EuGrid") then
        repaintWinResize = w32True
    end if

    if whoIs[1] and equal(whoIs[2], "ReBarBand") then
        --can only have 1 control in a ReBarBand
        if length(controls[whoIs[1]][SeqChildName])
        and not find(controls[selectedControl][Name],controls[whoIs[1]][SeqChildName]) then
            ok = displayErrorMessage(102,{controls[whoIs[1]][Name]})
            if not ctrlMouse then
                if rSelectedWindow!=selectedWindow then
                    badCopy = w32True
                    return
                end if
                --move back to original position
                controls[selectedControl][X] = origX
                controls[selectedControl][Y] = origY
            else
                deleteTheCopyControl()
            end if
            state = Normal

            -- clear mouse down flag
            mouseDown = 0
            return
        end if
        repaintWinResize = w32True
        forceRedraw = w32True
        controls[selectedControl][Y] = controls[whoIs[1]][Y]+1
        extent = getTextExtent(ControlBlit, controls[whoIs[1]][Title])
        controls[selectedControl][X] = controls[whoIs[1]][X]+extent[1]+5
    end if

    if (whoIs[1] and equal(whoIs[2], "FlatToolBar"))
    and not find(controls[selectedControl][Class], {"PushButton",
                                                    "PictureButton","TogglePicture","SepButton"}) then
        ok = displayErrorMessage(103,{})
        if not ctrlMouse then
            if rSelectedWindow!=selectedWindow then
                badCopy = w32True
                return
            end if
            --move back to original position
            controls[selectedControl][X] = origX
            controls[selectedControl][Y] = origY
        else
            deleteTheCopyControl()
        end if
        state = Normal

        -- clear mouse down flag
        mouseDown = 0
        return
    end if

    if (whoIs[1] and equal(whoIs[2], "FlatToolBar"))
    and find(controls[selectedControl][Class], {"PushButton",
                                                "PictureButton","TogglePicture"}) then
        --change to PictureButton
        controls[selectedControl][Class] = "PictureButton"
        --change cx,cy to 38 if parent is 48 otherwise reduce by 4 to fit
        if controls[whoIs[1]][CY]=48 then
            controls[selectedControl][CX] = 38
            controls[selectedControl][CY] = 38
        else
            controls[selectedControl][CX] = controls[whoIs[1]][CY]-4
            controls[selectedControl][CY] = controls[whoIs[1]][CY]-4
        end if
        forceRedraw = w32True
        repaintWinResize = w32True
        controls[selectedControl][X] = controls[whoIs[1]][X]
        controls[selectedControl][Y] = controls[whoIs[1]][Y]
    end if

    if (whoIs[1] and equal(whoIs[2], "ToolBar"))
    and find(controls[selectedControl][Class], {"PushButton",
                                                "PictureButton","TogglePicture"}) then
        repaintWinResize = w32True
        forceRedraw = w32True
    end if

    if find(whoIs[2], {"ToolBar","FlatToolBar"}) then
        --be sure CY is not more than ToolBar CY
        if controls[selectedControl][CY]>toolBarCY then
            controls[selectedControl][CY] = toolBarCY
        end if

        controls[selectedControl][X] = toolBarX+controls[whoIs[1]][X]
        controls[selectedControl][Y] = (( toolBarY*toolBarCY)
                                        -toolBarCY)+controls[whoIs[1]][Y]

    elsif equal(whoIsStatus[2], "StatusBar") then
        --snap to fit
        --adjust control cy to fit within the StatusBar cy
        for i=1 to ControlSize do
            if equal("StatusBar",
                     ControlList[i][ControlClass]) then
                controls[selectedControl][CY] =
                                    ControlList[i][ControlCY]-5
                controls[selectedControl][Y] = controls[whoIsStatus[1]][Y]+1
                exit
            end if
        end for
    elsif equal(controls[selectedControl][SeqParentClass], "StatusBar") then
        --snap to fit
        --adjust control cy to fit within the StatusBar cy
        for i=1 to ControlSize do
            if equal("StatusBar",
                     ControlList[i][ControlClass]) then
                controls[selectedControl][CY] =
                                    ControlList[i][ControlCY]-5
                controls[selectedControl][Y] = controls[whoIs[1]][Y]+1
                exit
            end if
        end for
    end if

    --can not move anything but Rebarband inside of ReBar
    if whoIs[1]
    and equal(whoIs[2], "ReBar")
    and not equal(controls[selectedControl][Class], "ReBarBand") then
        ok = displayErrorMessage(105,{})
        if not ctrlMouse then
            if rSelectedWindow!=selectedWindow then
                badCopy = w32True
                return
            end if
            --move back to original position
            controls[selectedControl][X] = origX
            controls[selectedControl][Y] = origY
        else
            deleteTheCopyControl()
        end if
        state = Normal

        -- clear mouse down flag
        mouseDown = 0
        return
    end if

    if whoIs[1] and find(whoIs[2], {"ToolBar","FlatToolBar"}) then
            --find location
        for i=1 to length(toolBarInfo) do
            if equal(toolBarInfo[i][8], controls[whoIs[1]][Name]) then
                toolBarX = toolBarInfo[i][6]
                toolBarY = toolBarInfo[i][7]
                toolBarCY = toolBarInfo[i][3]
                toolBarIndex = i
            end if
        end for

        controls[selectedControl][X] = toolBarX+controls[whoIs[1]][X]
        controls[selectedControl][Y] = (( toolBarY*toolBarCY)-toolBarCY)
                                       +controls[whoIs[1]][Y]
        if controls[selectedControl][CY]>toolBarCY then
            controls[selectedControl][CY] = toolBarCY
        end if
        toolBarInfo[toolBarIndex][6] += controls[selectedControl][CX]
        forceRedraw = w32True
    end if

    --assign parenting (ControlParent and SeqParentName)
    --assign child to its parent
    --update ProjectView

    if oldParent
    and oldParent!=whoIs[1] then
        removeFromParentChildSeq(oldParent,controls[selectedControl][Name])
        if equal(controls[oldParent][Class], "EuGrid") then
            repaintWinResize = w32True
        end if
    end if

    if whoIs[1] then
        controls[selectedControl][SeqParentName] = controls[whoIs[1]][Name]
        controls[selectedControl][SeqParentClass] = controls[whoIs[1]][Class]
    else
        controls[selectedControl][SeqParentName] = ""
        controls[selectedControl][SeqParentClass] = ""
    end if


    if not equal(parentForPV, controls[selectedControl][SeqParentName]) then
        deleteTreeViewNode("", controls[selectedControl][Name])
        if whoIs[1] then
            addTreeViewNode(controls[whoIs[1]][Name],
                            controls[selectedControl][Name])
            addToParentChildSeq(whoIs[1],controls[selectedControl][Name])
        else
            addTreeViewNode(controls[TheWindow][Name],
                            controls[selectedControl][Name])
        end if
    end if
    if whoIsStatus[1] then
        controls[selectedControl][ControlParent] = controls[whoIsStatus[1]][Name]
        controls[selectedControl][ParentClass] = controls[whoIsStatus[1]][Class]
    else
        controls[selectedControl][ControlParent] = ""
        controls[selectedControl][ParentClass] = ""
    end if

        --if moved control has been parented by override to other controls move them now
    --how much drag did we do?
    sDragX = controls[selectedControl][X]-origX
    sDragY = controls[selectedControl][Y]-origY
    if not ctrlMouse then
        if length(controls[selectedControl][SeqChildName]) then
            --how much drag did we do?                      
            moveMiscChildren(selectedControl,sDragX, sDragY)
        end if
    end if
end procedure
MiscStuff_id = routine_id("miscStuff")
--------------------------------------------------------------------------------
procedure click_PopUpDesign_Move(integer Self, integer Event, sequence Params)
    rClickedControl = selectedControl
    rSelectedWindow = selectedWindow
    ctrlMouse = w32False
    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Paste, w32True)
end procedure
setHandler(PopUpDesign_Move,w32HClick,routine_id("click_PopUpDesign_Move"))
--------------------------------------------------------------------------------
sequence wantToCopy     wantToCopy = {}
sequence indexParent indexParent = {}
procedure click_PopUpDesign_Copy(integer Self, integer Event, sequence Params)

    setEnable(PopUpDesign_Move, w32False)
    setEnable(PopUpDesign_Copy, w32False)
    setEnable(PopUpDesign_Paste, w32True)

    isCopyIndexed = w32False
    wantToCopy = controls[selectedControl][Name]
    rSelectedWindow = selectedWindow
    --if control is not a container then ask if it is to be indexed to the copy from control
    indexParent = {}
    if not length(controls[selectedControl][IndexParent])
    and not equal(controls[selectedControl][ParentClass], "Table") then
        if copyIndexSw
        and not find(controls[selectedControl][Class], {"ToolBar","FlatToolBar","ReBar","ReBarBand",
                                                        "StatusBar","Table"}) then
            if not length(controls[selectedControl][IndexParent]) then
                ok = displayErrorMessage(208,{})
                if ok=IDYES then
                    controls[selectedControl][Indexed] = w32True
                    indexParent = controls[selectedControl][Name]
                    isCopyIndexed = w32True
                end if
            end if
        end if
    end if
    ctrlMouse = w32True

    --hold original control for moving subs
    tempControl = selectedControl

    if equal(controls[selectedControl][Class], "TabItem") then
        ok = displayErrorMessage(181,{})
        if ok=IDNO then
            --want tabControl and all tabitems
            for i=selectedControl to 1 by -1 do
                if equal(controls[i][Name], controls[selectedControl][ControlParent]) then
                    selectedControl = i
                    tempControl = i
                    if isCopyIndexed then
                        controls[selectedControl][Indexed] = w32True
                        indexParent = controls[selectedControl][Name]
                    end if
                    exit
                end if
            end for
        end if
    end if

end procedure
setHandler(PopUpDesign_Copy,w32HClick,routine_id("click_PopUpDesign_Copy"))
--------------------------------------------------------------------------------
integer childXdif,childYdif
procedure getMoreChildren(integer parentIndex)
    for i=1 to length(controls[parentIndex][SeqChildName]) do
        for j=1 to length(windows[rSelectedWindow]) do
            if equal(windows[rSelectedWindow][j][Name],controls[parentIndex][SeqChildName][i]) then
                --find diffX and diffY between controls[selectedControl][X] and 
                --controls[selectedControl][SeqChildName][i][X]                         
                windows[rSelectedWindow][j][X] += childXdif
                windows[rSelectedWindow][j][Y] += childYdif

                windows[selectedWindow] &= {windows[rSelectedWindow][j]}
                controls = windows[selectedWindow]

                addItem(PropertyTitleBar, controls[length(controls)][Name])

                --does this child have children?
                if length(controls[length(controls)][SeqChildName]) then
                    getMoreChildren(length(controls))
                end if
                exit
            end if
        end for
    end for
end procedure
--------------------------------------------------------------------------------
procedure buildChildTree(integer selectedControl)
    for j=1 to length(controls[selectedControl][SeqChildName]) do
        addTreeViewNode(controls[selectedControl][Name],controls[selectedControl][SeqChildName][j])
        treedata[1] = controls[selectedControl][SeqChildName][j]
        for i=1 to length(controls) do
            if equal(controls[i][Name],controls[selectedControl][SeqChildName][j]) then
                treedata[2] = controls[i][Class]
                exit
            end if
        end for
        theTreeForm &= {treedata}
        if length(controls[selectedControl][SeqChildName][j]) then
            for k=1 to length(controls) do
                if equal(controls[k][Name],controls[selectedControl][SeqChildName][j]) then
                    buildChildTree(k)
                    exit
                end if
            end for
        end if
    end for

end procedure
--------------------------------------------------------------------------------
procedure click_PopUpDesign_Paste(integer Self, integer Event, sequence Params)
integer controlnamelength,inTitleBar,childCnt,origControl,saveDragX,saveDragY,shiftMouse,tmpControl
sequence name,extent,sizeS,OSControls,OSControls2,tmp,assignedparent,assignedclass,afterSort
integer flag, holdWindow, holdControl

    badCopy = w32False
    if rSelectedWindow=selectedWindow then
                --backup controls
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)
    end if
    --create new control, if later find we couldn't copy it then it gets
    --deleted
    --make sure desired copy from control still exists
    if ctrlMouse then
        if rSelectedWindow!=getIndex(WinList) then
            VOID = displayErrorMessage(266,{})
            return
        end if
        tmpControl = 0
        for i=1 to length(controls) do
            if equal(wantToCopy, controls[i][Name]) then
                tmpControl = i
                exit
            end if
        end for
        if tmpControl=0 then
            --control was deleted or renamed?
            return
        end if
        selectedControl = tmpControl
        makeCopyControl(controls[selectedControl][X], controls[selectedControl][Y],
                        controls[selectedControl][CX], controls[selectedControl][CY],
                        controls[selectedControl][Class],
                        controls[selectedControl][Name],
                        controls[selectedControl][Title],controls[selectedControl][OrigTitle],
                        indexParent) --for IndexParent                    

        if equal(controls[selectedControl][Class], "TabItem")
        and ok=IDYES then
            --add tabitem title to tabitem combo
            addItem(TheTabItemCombo, controls[length(controls)][Title])
            setIndex(TheTabItemCombo, getCount(TheTabItemCombo))
        end if

        if equal(controls[selectedControl][Class], "EuGrid") then
            controls[length(controls)][BkColor] = controls[selectedControl][BkColor]
            controls[length(controls)][GridHeaderColor] = controls[selectedControl][GridHeaderColor]
            controls[length(controls)][GridColHeaderCY] = controls[selectedControl][GridColHeaderCY]
            controls[length(controls)][GridRowHeaderCX] = controls[selectedControl][GridRowHeaderCX]
            controls[length(controls)][GridHeaderType] = controls[selectedControl][GridHeaderType]
        end if

        controls[length(controls)] = copyControlProperties(controls[length(controls)], controls[selectedControl])

        if length(controls[length(controls)][ControlParent]) then
            addTreeViewNode(controls[length(controls)][SeqParentName],
                            controls[length(controls)][Name])
            treedata[1] = controls[length(controls)][Name]
            treedata[2] = controls[length(controls)][Class]
            theTreeForm &= {treedata}
        else
            addTreeViewNode(controls[1][Name],
                            controls[length(controls)][Name])
            treedata[1] = controls[length(controls)][Name]
            treedata[2] = controls[length(controls)][Class]
            theTreeForm &= {treedata}
        end if

        --use new index for selectedControl in verification tests
        rNewControl = length(controls)
        rClickedControl = selectedControl
        rSelectedWindow = selectedWindow
    end if

    if rSelectedWindow!=selectedWindow then
        if equal(windows[rSelectedWindow][rClickedControl][Class], "TabItem") then
            --get the parent tabControl instead
            controls = windows[rSelectedWindow]
            flag = findSeqParentName(rClickedControl)
            if equal(controls[flag][Class],"TabControl") then
                rClickedControl = flag
                tempControl = flag
            end if
        end if
        --add the control to the new window             
        windows[selectedWindow] &= {windows[rSelectedWindow][rClickedControl]}
        windows[selectedWindow][length(windows[selectedWindow])][ParentIsFrozen] = 0
        windows[selectedWindow][length(windows[selectedWindow])][IndexParent] = {}
        windows[selectedWindow][length(windows[selectedWindow])][ControlPartners] = {}

        afterSort = windows[selectedWindow][length(windows[selectedWindow])][Name]
        windows[selectedWindow] = sort(windows[selectedWindow])

        for m=1 to length(windows[selectedWindow]) do
            if equal(afterSort, windows[selectedWindow][m][Name]) then
                selectedControl = m
            end if
        end for
        controls = windows[selectedWindow]

        --find difference in 'from' and 'to' x,y values of parent and add that to child x and y
        childXdif = snap(pasteX)-controls[selectedControl][X]
        childYdif = snap(pasteY)-controls[selectedControl][Y]

        controls[selectedControl][X] = snap(pasteX) --pasteX and Y is where we clicked to MOVE TO
        controls[selectedControl][Y] = snap(pasteY)
        windows[selectedWindow] = controls

        --validate
        toolBarStuff(pasteX,pasteY, pasteX, pasteY, 0)

        tabItemStuff(pasteX,pasteY,pasteX,pasteY,
                     controls[selectedControl][CX],controls[selectedControl][CY],
                     0,0)

        groupStuff(pasteX,pasteY,pasteX,pasteY,0)

        if not find(controls[selectedControl][Class], {"ToolBar","FlatToolBar","ReBar",
                                                       "ReBarBand","TabItem","TabControl","Group","StatusBar","Table",
                                                       "EuGrid","CWindow"}) then
            miscStuff(pasteX,pasteY,0)
        end if

        if badCopy then
            call_proc(deleteTheControl_id,{})
            setEnable(PopUpDesign_Move, w32True)
            setEnable(PopUpDesign_Copy, w32True)
            setEnable(PopUpDesign_Paste, w32False)
        end if

        --controls parented by ReBarBand are AWindow 10
        --if they were 10 and are no longer parented by ReBarBand change to general classification
        if equal(controls[selectedControl][SeqParentName],"ReBarBand")
        and not find(controls[selectedControl][Class],{"ToolBar","FlatToolBar"}) then
            controls[selectedControl][AWindow] = 10
        elsif controls[selectedControl][AWindow]=10 then
            if not controls[selectedControl][TabOrder] then
                counterInWindow += 1
                controls[selectedControl][TabOrder] = counterInWindow
            end if
            controls[selectedControl][AWindow] = 30
        end if

        if not length(controls[selectedControl][ParentClass]) then
            controls[selectedControl][ParentClass] = controls[selectedControl][SeqParentClass]
            controls[selectedControl][ControlParent] = controls[selectedControl][SeqParentName]
        end if

        if equal(controls[selectedControl][Class], "TabItem") then
            ok = invokeHandler(TheTabItemCombo,w32HChange,{})
        end if

        if find(controls[selectedControl][ParentClass], {"ReBar","ReBarBand"}) then
            repaintWinResize = w32True
        end if

        assignedparent = controls[selectedControl][SeqParentName]
        assignedclass = controls[selectedControl][SeqParentClass]
        call_proc(updateProperty_id,{"Parent"})

        addItem(PropertyTitleBar, controls[selectedControl][Name])
        --if control has children add them too
        if length(controls[selectedControl][SeqChildName]) then
            for i=1 to length(controls[selectedControl][SeqChildName]) do
                for j=1 to length(windows[rSelectedWindow]) do
                    if equal(windows[rSelectedWindow][j][Name],controls[selectedControl][SeqChildName][i]) then
                        --find diffX and diffY between controls[selectedControl][X] and 
                        --controls[selectedControl][SeqChildName][i][X]                         
                        windows[rSelectedWindow][j][X] += childXdif
                        windows[rSelectedWindow][j][Y] += childYdif

                        windows[selectedWindow] &= {windows[rSelectedWindow][j]}
                        controls = windows[selectedWindow]

                        --addItem( PropertyTitleBar, controls[selectedControl][Name] )                                  
                        addItem(PropertyTitleBar, controls[length(controls)][Name])

                        --does this child have children?
                        if length(controls[length(controls)][SeqChildName]) then
                            getMoreChildren(length(controls))
                        end if
                        exit
                    end if
                end for
            end for
        end if

        dontdraw = w32True      --to control flicker when changing windows      
        --draw the new control
        drawControl(ControlBlit, controls[selectedControl], Normal, selectedControl,0)

        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            call_proc(drawHiddenControls_id,{selectedControl})
        end if

        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)

        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        if offsetActive then
            bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        holdControl = selectedControl

        call_proc(updateProperties_id,{})

        setEnable(PopUpDesign_Move, w32True)
        setEnable(PopUpDesign_Copy, w32True)
        setEnable(PopUpDesign_Paste, w32False)

        windows[selectedWindow] = controls

        if not ctrlMouse then
            --save the to control
            holdWindow = selectedWindow

            --switch back to prior window and control where we moved from
            selectedWindow = rSelectedWindow
            controls = windows[selectedWindow]
            selectedControl = rClickedControl
            for j=1 to getCount(WinList) do
                if equal(getItem(WinList, j), windows[selectedWindow][TheWindow][Name]) then
                    setIndex(WinList,j)
                    VOID = invokeHandler(WinList, w32HChange,{})
                    exit
                end if
            end for

            --delete the from control
            selectedControl = rClickedControl
            if badCopy then
                --build ProjectView tree
                if length(controls[selectedControl][SeqParentName]) then
                    addTreeViewNode(controls[selectedControl][SeqParentName],controls[selectedControl][Name])
                else
                    addTreeViewNode(controls[TheWindow][Name],controls[selectedControl][Name])
                end if
                treedata[1] = controls[selectedControl][Name]
                treedata[2] = controls[selectedControl][Class]
                theTreeForm &= {treedata}
                buildChildTree(selectedControl)
            else
                call_proc(deleteTheControl_id,{})
            end if

            --now switch back to move to window
            selectedWindow = holdWindow
            controls = windows[selectedWindow]
            selectedControl = holdControl
            if badCopy then
                --delete the control                            
                call_proc(deleteTheControl_id,{})
            end if

            controls[selectedControl][SeqParentName] = assignedparent
            controls[selectedControl][SeqParentClass] = assignedclass

            for j=1 to getCount(WinList) do
                if equal(getItem(WinList, j), windows[selectedWindow][TheWindow][Name]) then
                    setIndex(WinList,j)
                    VOID = invokeHandler(WinList, w32HChange,{})
                    exit
                end if
            end for

            dontdraw = w32False
            selectedWindow = holdWindow
            controls = windows[selectedWindow]
            selectedControl = holdControl
        end if

        if not badCopy then
            if length(controls[selectedControl][SeqParentName]) then
                addTreeViewNode(controls[selectedControl][SeqParentName],controls[selectedControl][Name])
                treedata[1] = controls[selectedControl][Name]
                treedata[2] = controls[selectedControl][Class]
                theTreeForm &= {treedata}
            else
                addTreeViewNode(controls[TheWindow][Name],controls[selectedControl][Name])
                treedata[1] = controls[selectedControl][Name]
                treedata[2] = controls[selectedControl][Class]
                theTreeForm &= {treedata}
            end if
            buildChildTree(selectedControl)
        end if
        tmpControl = selectedControl
        selectedControl = TheWindow
        if find(controls[tmpControl][SeqParentClass], {"ReBar","ReBarBand"}) then
            repaintWinResize = w32True
        end if
        call_proc(drawIt_id,{})
        selectedControl = tmpControl

        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            call_proc(drawHiddenControls_id,{selectedControl})
        end if
        bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
        if showActive then
            bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
        end if

        if offsetActive then
            bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
        end if
        return
    end if

    if rSelectedWindow=selectedWindow then
        if ctrlMouse then
            --Copy          
            tempControl = selectedControl
            tmpControl = selectedControl
            origControl = rClickedControl--the control we rclicked in we want to copy   
            tmp = controls[origControl][Name]
            saveDragX = controls[origControl][X]
            saveDragY = controls[origControl][Y]
            tempControl = origControl
            selectedControl = length(controls)
            controls[selectedControl][X] = snap(pasteX)     --pasteX and Y is where we clicked to MOVE TO
            controls[selectedControl][Y] = snap(pasteY)
            call_proc(check_MoveDrag_id,{saveDragX,saveDragY,
                                         saveDragX,saveDragY,controls[origControl][CX],
                                         controls[origControl][CY],0,ctrlMouse})
            if badCopy then --didn't pass validations so return x and y to original values
                controls[origControl][X] = saveDragX
                controls[origControl][Y] = saveDragY
            end if
        else
                        --move
            tempControl = selectedControl
            tmpControl = selectedControl
            origControl = rClickedControl--the control we rclicked in we want to move
            shiftMouse = w32False--why? for moving only tabitem?      
            tmp = controls[origControl][Name]
            saveDragX = controls[origControl][X]
            saveDragY = controls[origControl][Y]
            controls[origControl][X] = snap(pasteX) --pasteX and Y is where we clicked to MOVE TO
            controls[origControl][Y] = snap(pasteY)
            selectedControl = origControl

            call_proc(check_MoveDrag_id,{saveDragX,saveDragY,
                                         saveDragX,saveDragY,controls[origControl][CX],
                                         controls[origControl][CY],shiftMouse,0})
        end if

        if ctrlMouse then
            tmp = controls[selectedControl][Name]
        end if
    end if

    --insure control in Code Editor stays in sync with controls sequence after sort
    name = getItem(CodeControls,getIndex(CodeControls))
    controls = sort(controls)
    --reload CodeControls
    eraseItems(CodeControls)
    controlnamelength = 0
    for i=1 to length(controls) do
        addItem(CodeControls, controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    VOID = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
    for i=1 to getCount(CodeControls) do
        if equal(name, getItem(CodeControls,i)) then
            setIndex(CodeControls,i)
            editorSelectedControl = i
            exit
        end if
    end for
    if selectedWindow=rSelectedWindow then
        -- re-assign selectedControl  
        for i=1 to length(controls) do
            if equal(controls[i][Name], tmp) then
                selectedControl = i
                tmpControl = i
                exit
            end if
        end for
    end if
    if equal(getItem(PropertyTitleBar,getIndex(PropertyTitleBar)),
             controls[selectedControl][Name]) then
        call_proc(updateProperty_id,{"Column"})
    else
        call_proc(updateProperties_id,{})
    end if

    if find(controls[selectedControl][Class],{"TabControl","TabItem"}) then
        for i=1 to getCount(PropertyTitleBar) do
            if equal(getItem(PropertyTitleBar,i),getItem(TheTabItemCombo,getIndex(TheTabItemCombo))) then
                setIndex(PropertyTitleBar, i)
                exit
            end if
        end for
    end if

    inTitleBar = isInCWindowTitleBar(controls, selectedControl)
    if inTitleBar then
        ok = displayErrorMessage(251,{})
    end if

    sizeS = getRect(Screen)

    if showActive then
        setMousePointer(Show, NULL)
    end if

    -- repaint the window
    tmpControl = selectedControl
    selectedControl = TheWindow
    call_proc(drawIt_id,{})
    selectedControl = tmpControl

    drawControl(ControlBlit, controls[selectedControl], Selected, selectedControl,0)
    if thelayerNumber           --drawing layer 1..n
    and (find(0,showBackLayer)  --with base layer as background
         or backgroundlayer=0) then
        --does layer 1..n have controls hiding layer 0 control?
        call_proc(drawHiddenControls_id,{selectedControl})
    end if

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0, 0, gridX,gridY, SRCCOPY)
    end if

    if offsetActive then
        bitBlt(OffScreen, 0, 0, OffScreenBlit,0, 0, gridX,gridY, SRCCOPY)
    end if

    --check if control went off screen
    if controls[selectedControl][X]<0 then
        haveOffscreen = w32True
        OSControls = controls[selectedControl]

        if OSControls[X]<0 then
            OSControls[X] = dCX+controls[selectedControl][X]
        end if
        if OSControls[Y]<0 then
            OSControls[Y] *= -1  --can't draw negative Y yet
        end if
        copyBlt(OffScreenBlit, 0, 0, GridBlit)

        drawControl(OffScreenBlit, OSControls, Normal,selectedControl,0)

        --did it have children?
        childCnt = 0
        if length(controls[selectedControl][SeqChildName]) then
            for i=selectedControl to length(controls) do
                if find(controls[i][Name],
                        controls[selectedControl][SeqChildName]) then
                    childCnt += 1
                    OSControls2 = controls[i]
                    if OSControls2[X]<0 then
                        OSControls2[X] = dCX+controls[i][X]
                    end if
                    if OSControls2[Y]<0 then
                        OSControls2[Y] *= -1     --can't draw negative Y yet
                    end if
                    drawControl(OffScreenBlit, OSControls2, Normal,i,0)
                    if length(controls[i][SeqChildName]) then
                        drawChildControls(i)
                    end if
                end if
                if childCnt>=length(controls[selectedControl][SeqChildName]) then
                    exit
                end if
            end for
        end if
    end if
    --check that labeledit caption is inside bounds of parent
    if equal(controls[selectedControl][Class], "LabelEdit") then
        if length(controls[selectedControl][SeqParentName]) then
            if testLabelEditCaption(selectedControl) then
                ok = displayErrorMessage(252,{})
            end if
        end if
    end if

    setEnable(PopUpDesign_Move, w32True)
    setEnable(PopUpDesign_Copy, w32True)
    setEnable(PopUpDesign_Paste, w32False)
end procedure
setHandler(PopUpDesign_Paste,w32HClick,routine_id("click_PopUpDesign_Paste"))
------------------------------------------------------------------------------
sequence table
--------------------------------------------------------------------------------
procedure copyTableControl(integer theX, integer theY, integer theCX,
                            integer theCY, sequence theClass,
                            sequence theName, sequence theTitle,
                            sequence theStyle, integer theLabelExtent,
                            sequence cell1Title, sequence cell1OrigTitle,
                            integer theTreatAsColorButton)

    table = repeat(0, ControlSize)

    counter += 1
    counterInWindow += 1


    -- set values
    table[Id]     = counter
    table[AWindow] = 30
    table[X]      = theX
    table[Y]      = theY
    table[CX]     = theCX
    table[CY]     = theCY
    table[Class]  = theClass
    table[SubClass] = {}
    table[Title]  = theTitle
    table[TreatAsColorButton] = theTreatAsColorButton
    if equal(table[Class], "LabelEdit") then
        table[ValueEdit] = table[Title]
        table[LabelExtent] = theLabelExtent
    else
        table[ValueEdit] = {}
    end if
    table[Name]   = theName

    --add to sequence for colorization
    controlNameKeywords &= {table[Name]}

    table[Style]  = theStyle
    table[ControlLayer] = layerNumber

    if isChecked(MenuTabAllUseLayer) then
        table[SetLayerOK] = w32True
    end if

    table[ControlParent] = ""
    table[ParentClass] = ""
    table[Parent] = ""
    table[Active] = 1
    table[StyleType] = {}
    table[Visible] = w32True
    table[EnableC] = w32True
    table[Buddy] = ""
    table[IcoFile] = ""
    table[TwoIcoFile] = ""
    table[TriIcoFile] = ""
    table[BitmapFile] = ""
    table[FontName] = ""
    table[HintFontName] = ""
    table[HintText] = ""
    table[ExStyle] = "0"
    table[TabOrder] = counterInWindow
    table[XPM] = ""
    table[XPMmember] = ""
    table[XpmObject] = {}
    table[XpmDisableObject] = {}
    table[InitialVal] = {}
    table[SetEvent] = ""
    table[SetControl] = ""
    table[KillEvent] = ""
    table[KillControl] = ""
    table[CCWinStyle] = ""
    table[WidthTitle] = {}
    table[ExtExStyle] = {}
    table[SelectWidth] = {}
    table[SystemBkColor] = {}
    table[OutX] = {}
    table[OutY] = {}
    table[OutCX] = {}
    table[OutCY] = {}
    table[ControlComment] = {}
    table[DEFIndex] = {}
    table[SysTrayIcon] = {}
    table[SysTrayHint] = {}
    table[SysTrayText] = {}
    table[IndexParent] = {}
    table[SeqParentName] = {}
    table[SeqParentClass] = {}
    table[SeqChildName] = {}
    table[GridFormat] = {}
    table[WinOpenAtCtrl] = {}
    table[GridDataArrayName] = {}
    table[GridColListValues] = {}
    table[ClassDefaults] = {}
    table[OrigTitle] = table[Title]
    table[FontVarName] = {}
    table[FontVarPts] = {}
    table[FontVarItalic] = {}
    table[FontVarBold] = {}
    table[FontVarUnderline] = {}
    table[FontVarStrikeout] = {}
    table[HintFontVarName] = {}
    table[HintFontVarPts] = {}
    table[HintFontVarItalic] = {}
    table[HintFontVarBold] = {}
    table[HintFontVarUnderline] = {}
    table[HintFontVarStrikeout] = {}
    table[FontVarColor] = {}
    table[HintVarText] = {}
    table[GenFromName] = {}
    table[cbCentVert] = w32True

    if not equal(cell1Title,cell1OrigTitle) then
        --if cell 1 capition was changed then do not want to use the c-x-y naming when gen
        --in exw
        table[OrigTitle] = {}
    end if
    table[ControlPartners] = {}


    if isChecked(ClickLocal) then
        table[Local] = w32True
    else
        table[Local] = w32False
    end if

    table[Code]   = repeat({}, length(Events))

    IDE_Changed = w32True
end procedure
------------------------------------------------------------------------------
global procedure buildNewTable(integer cols, integer rows, integer colsSpace,
                        integer rowsSpace, sequence renameTableCells,
                        integer preserveNames, integer resizeTable)

integer theX, theY, holdGrid, docols, dorows,cntr, testX, testY, maxX, maxY,
                minX, minY, leftOffset, rightOffset, topOffset, bottomOffset,
                cnt, topMargin, leftMargin, hit, already, quoteInTitle,
                wasTruncated, controlNumber, matchName, testcntr,flag,
                allowableCols,theTreatAsColorButton,
                trialCol, trialRow,controlswidth,controlsheight,controlsX,controlsY,
                controlsCX,controlsCY
sequence the, theName, theTitle, newTitle, newStyle, newName, newCellNames,
                newCellTitles

    theX = 0
    theY = 0

    quoteInTitle = w32False

    if cols=1
    and rows=1 then
        --only one cell
        return
    end if

    --temporarily turn off grid
    holdGrid = GridDisable
    GridDisable = w32True

    --backup controls
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)
    --walk through the controls and find the most outside and inside cx and cy
    --for cell one in this table which is all we have at this point.
    maxX = 0
    maxY = 0
    minX = 0
    minY = 0
    cnt = 0
    allowableCols = 0

    tables = {}
    newCellNames = {}
    newCellTitles = {}

    cellheight = 0
    cellwidth = 0

    controlswidth = 0
    controlsheight = 0
    controlsX = -1
    controlsCX = 0
    controlsY = -1
    controlsCY = 0
    damagedFlag = w32False
    for k=1 to length(controls) do
        if controls[k][TableCell]=1
        and equal(controls[k][SeqParentName], controls[selectedControl][Name]) then
            the = controls[k]

            cnt += 1

            if cnt=1 then
                minX = the[X]
                minY = the[Y]
            end if

            testX = the[X]+the[CX]
            testY = the[Y]+the[CY]

            if testX>maxX then
                maxX = testX
            end if
            if testY>maxY then
                maxY = testY
            end if

            testX = the[X]
            testY = the[Y]

            if testX<minX then
                minX = testX
            end if
            if testY<minY then
                minY = testY
            end if
            --find limits of all controls in cell 1
            if controlsX= -1 then
                controlsX = the[X]
            end if
            if the[X]<controlsX then
                controlsX = the[X]
            end if
            if (the[X]+the[CX])>controlsCX then
                controlsCX = the[X]+the[CX]
            end if
            if controlsY= -1 then
                controlsY = the[Y]
            end if
            if the[Y]<controlsY then
                controlsY = the[Y]
            end if
            if (the[Y]+the[CY])>controlsCY then
                controlsCY = the[Y]+the[CY]
            end if
        end if
    end for
    controlswidth = controlsCX-controlsX
    controlsheight = controlsCY-controlsY


    cellwidth = controlswidth+colsSpace

    cellheight = controlsheight+rowsSpace

    --figure top margin and left margin for use in adjusting Table pad
    topMargin = minY-controls[selectedControl][Y]
    leftMargin = minX-controls[selectedControl][X]

    trialCol = floor((controls[TheWindow][CX]-controls[selectedControl][X]-leftMargin-borderX)/cellwidth)
    trialRow = floor((controls[TheWindow][CY]-controls[selectedControl][Y]-topMargin-titleBar-borderX)/cellheight)

    if trialCol<cols then
        cols = trialCol
        damagedFlag = w32True
    end if
    if trialRow<rows then
        rows = trialRow
        damagedFlag = w32True
    end if
    --make sure the margins leave room for the Table grab handle
    if topMargin<10 then
        topMargin = 10
    end if
    if leftMargin<10 then
        leftMargin = 10
    end if

    controlNumber = 0

    --walk through the controls for cell one and make new cells
    for k=1 to length(controls) do
        if controls[k][TableCell]=1 then
            if equal(controls[k][SeqParentName], controls[selectedControl][Name]) then
                controlNumber += 1
                controls[k][CommonSetHandler] = controls[selectedControl][CommonSetHandler]
                controls[k][CommonRow] = 1  --the current row
                controls[k][CommonCol] = 1  --the current column
                controls[k][GenFromName] = controls[k][Name]
                if find(controls[k][Class],{"PushButton","PictureButton","ToggleButton","TogglePicture",
                                            "DefPushButton","CancelButton"}) then
                    controls[k][TableButtonAllColor] = controls[selectedControl][TableButtonAllColor]
                    controls[k][TableButtonAllCopy] = controls[selectedControl][TableButtonAllCopy]
                end if

                the = controls[k]
                theTreatAsColorButton = the[TreatAsColorButton]

                tables &= {controls[k]}

                --find the left and right offset from min and max to the control
                leftOffset = the[X]-minX
                rightOffset = maxX-(the[X]+the[CX])
                topOffset = the[Y]-minY
                bottomOffset = maxY-(the[Y]+the[CY])

                if the[Name][length(the[Name])]>='0'
                and the[Name][length(the[Name])]<='9' then
                    theName = the[Name][1..length(the[Name])-1]
                else
                    theName = the[Name]
                end if

                if length(the[Title]) then
                    quoteInTitle = w32False
                    if equal('\"',the[Title][length(the[Title])]) then
                        quoteInTitle = w32True
                    end if
                end if

                wasTruncated = w32False
                if length(the[Title]) then
                    if the[Title][length(the[Title])]>='0'
                    and the[Title][length(the[Title])]<='9' then
                        theTitle = the[Title][1..length(the[Title])-1]
                        wasTruncated = w32True
                    else
                        theTitle = the[Title]
                    end if
                else
                    theTitle = {}
                end if

                cntr = 1
                --duplicate each control in cell 1 col/row times
                dorows = 1
                for j=dorows to rows do
                    docols = 2  --start with second cell since already have cell1 for row 1
                    if j=1 then
                        theX = maxX+leftOffset+colsSpace
                        theY = minY+topOffset
                        allowableCols = 0
                    end if
                    if j>1 then
                        docols = 1 --on rest of the rows start with cell 1
                        theX = the[X]
                    end if

                    --when multiple rows we know the allowable number of columns
                    if j>1 then
                        cols = allowableCols+1  --need to add 1 because now doing col1
                    end if
                    for i=docols to cols do
                        cntr += 1

                        if preserveNames then
                            if j<=length(renameTableCells)
                            and i<=length(renameTableCells[j]) then
                                newName = renameTableCells[j][i][controlNumber][1]
                                newTitle = renameTableCells[j][i][controlNumber][2]
                            else
                                newName = theName&sprint(cntr)

                                --check that name not used before
                                testcntr = cntr
                                while w32True do
                                    matchName = w32False
                                    for p=1 to length(renameTableCells) do
                                        for q=1 to length(renameTableCells[p]) do
                                            for r=1 to controlNumber do
                                                if equal(newName, renameTableCells[p][q][r][1]) then
                                                    --increment and try again
                                                    testcntr += 1
                                                    newName = theName&sprint(testcntr)
                                                    matchName = w32True
                                                    exit
                                                end if
                                            end for
                                        end for
                                    end for
                                    if matchName=w32False then
                                        for p=1 to length(newCellNames) do
                                            if equal(newName, newCellNames[p]) then
                                                testcntr += 1
                                                newName = theName&sprint(testcntr)
                                                matchName = w32True
                                                exit
                                            end if
                                        end for
                                        if matchName=w32False then
                                            --add to newcell names for tests
                                            newCellNames &= {newName}
                                        end if
                                        if matchName=w32False then
                                            exit
                                        end if
                                    end if
                                end while

                                if length(theTitle) then
                                    newTitle = theTitle&sprint(cntr)
                                else
                                    if wasTruncated then
                                        newTitle = theTitle & sprint(cntr)
                                    else
                                        newTitle = {}
                                    end if
                                end if

                                --check that Title not used before
                                testcntr = cntr
                                while w32True do
                                    matchName = w32False
                                    for p=1 to length(renameTableCells) do
                                        for q=1 to length(renameTableCells[p]) do
                                            for r=1 to controlNumber do
                                                if equal(newTitle, renameTableCells[p][q][r][2]) then
                                                    --increment and try again
                                                    testcntr += 1
                                                    newTitle = theTitle&sprint(testcntr)
                                                    matchName = w32True
                                                    exit
                                                end if
                                            end for
                                        end for
                                    end for
                                    if matchName=w32False then
                                        for p=1 to length(newCellTitles) do
                                            if equal(newTitle, newCellTitles[p]) then
                                                testcntr += 1
                                                newTitle = theTitle&sprint(testcntr)
                                                matchName = w32True
                                                exit
                                            end if
                                        end for
                                        if matchName=w32False then
                                            --add to newcell titles for tests
                                            newCellTitles &= {newTitle}
                                        end if
                                        if matchName=w32False then
                                            exit
                                        end if
                                    end if
                                end while

                                if length(theTitle) then
                                    if quoteInTitle then
                                        newTitle &= "\""
                                    end if
                                end if
                            end if
                        else
                            newName = theName&sprint(cntr)

                            if length(theTitle) then
                                newTitle = theTitle&sprint(cntr)
                            else
                                if wasTruncated then
                                    newTitle = theTitle & sprint(cntr)
                                else
                                    newTitle = {}
                                end if
                            end if
                            if length(theTitle) then
                                if quoteInTitle then
                                    newTitle &= "\""
                                end if
                            end if
                        end if

                        if find(the[Class], {"ListView","TreeView","RichEdit","List",
                                             "UpDown"}) then
                            newStyle = the[Style]
                        else
                            newStyle = ""
                        end if

                        copyTableControl(theX, theY, the[CX],
                                         the[CY], the[Class],
                                         newName, newTitle, newStyle, the[LabelExtent], the[Title],
                                         the[OrigTitle],theTreatAsColorButton)
                        --fix the control just built
                        table[ParentClass]=
                        controls[k][ParentClass]
                        table[ControlParent]=
                            controls[k][ControlParent]
                        table[Parent] = controls[selectedControl][Name]
                        table[SeqParentName] = table[Parent]
                        table[SeqParentClass] = controls[selectedControl][Class]
                        table[CommonSetHandler] = the[CommonSetHandler]
                        table[CommonRow] = j    --the current row
                        table[CommonCol] = i    --the current column                    
                        table[GenFromName] = the[Name]
                        table[TreatAsColorButton] = the[TreatAsColorButton]--make colored button                      

                        if the[TableButtonAllCopy] then
                            --do this here for painting Design with color and also at F5/F6
                            table[cbColor] = the[cbColor]
                            table[cbPressColor] = the[cbPressColor]
                            table[cbCaptionColor] = the[cbCaptionColor]
                            table[cbPressCaptionColor] = the[cbPressCaptionColor]
                            table[cbThickness] = the[cbThickness]
                            table[cbGraphicPos] = the[cbGraphicPos]
                            table[cbCaptionPos] = the[cbCaptionPos]
                        end if

                        table = copyControlProperties(table, controls[k])

                        flag = findSeqParentName(k)
                        if flag then
                            addToParentChildSeq(flag, table[Name])
                        end if
                        table[TableCell] = cntr
                        tables &= {table}
                        theX += (rightOffset+the[CX]+leftOffset+colsSpace )
                        if j=1 then
                            allowableCols += 1
                        end if
                    end for
                    theY += (bottomOffset+the[CY]+topOffset+rowsSpace)
                    if resizeTable then
                        --make sure Table still surrounds all the controls
                        if damagedFlag then
                            controls[selectedControl][CX] = (tables[length(tables)][X]+
                                                             tables[length(tables)][CX]+leftMargin)--tables[length(tables)][CX]-controls[selectedControl][X])
                            controls[selectedControl][CX] -= controls[selectedControl][X]

                            controls[selectedControl][CY] = (tables[length(tables)][Y]+
                                                             tables[length(tables)][CY]+topMargin)--tables[length(tables)][CY]-controls[selectedControl][Y])
                            controls[selectedControl][CY] -= controls[selectedControl][Y]
                        else
                            if controls[selectedControl][CX]!=(tables[length(tables)][X]+tables[length(tables)][CX]+leftMargin) then
                                controls[selectedControl][CX] = (tables[length(tables)][X]+
                                                                 tables[length(tables)][CX]+leftMargin)
                                controls[selectedControl][CX] -= controls[selectedControl][X]
                            end if

                            if controls[selectedControl][CY]!=(tables[length(tables)][Y]+tables[length(tables)][CY]+topMargin) then
                                controls[selectedControl][CY] = (tables[length(tables)][Y]+
                                                                 tables[length(tables)][CY]+topMargin)
                                controls[selectedControl][CY] -= controls[selectedControl][Y]
                            end if
                        end if
                    end if
                end for
            end if
        end if
    end for
    if damagedFlag then
        ok = displayErrorMessage(247,{controls[TheWindow][Name]})
    end if

    --ensure Table control has correct number of rows and col
    controls[selectedControl][TableCols] = cols
    controls[selectedControl][TableRows] = rows

    --add title to combo if not already there
    already = w32False

    for x=1 to length(tables) do
        already = w32False
        for m=1 to getCount(PropertyTitleBar) do
            if equal(getItem(PropertyTitleBar, m), tables[x][Name]) then--table[Name]) then
                already = w32True
                exit
            end if
        end for
        if not already then
            addItem(PropertyTitleBar, tables[x][Name])--table[Name] )
        end if
    end for

    --remove cells now and replace with the tables. we do this so all cells
    --are together in the controls sequence
    while w32True do
        hit = w32False
        for i=selectedControl to length(controls) do
            if controls[i][TableCell] then
                if equal(controls[i][SeqParentName], controls[selectedControl][Name]) then
                    controls = controls[1..i-1] & controls[i+1..length(controls)]
                    hit = w32True
                    exit
                end if
            end if
        end for
        if not hit then
            exit
        end if
    end while

    GridDisable = holdGrid

end procedure
buildNewTable_Id = routine_id("buildNewTable")
-----------------------------------------------------------------------------
global procedure rebuildTableNow(integer cols, integer rows, integer colsSpace,
                        integer rowsSpace, sequence renameTableCells,
                        integer preserveNames, integer resizeTable, integer theLabelExtent)

integer foundIt
    if theLabelExtent then end if
    while w32True do
        foundIt = w32False
        for i=selectedControl to length(controls) do
            if controls[i][TableCell] then
                if equal(controls[i][SeqParentName], controls[selectedControl][Name]) then
                    if controls[i][TableCell]!=1 then
                        for j=1 to getCount(PropertyTitleBar) do
                            if equal(controls[i][Name], getItem(PropertyTitleBar,j)) then
                                ok = deleteItem(PropertyTitleBar, j)
                                exit
                            end if
                        end for
                        deleteTreeViewNodeAndCode("", controls[i][Name])
                        removeFromParentChildSeq(selectedControl,controls[i][Name])
                        deleteTreeViewNode("",controls[i][Name])
                        controls = controls[1..i-1] & controls[i+1..length(controls)]
                        foundIt = w32True
                        exit
                    end if
                end if
            end if
            if foundIt then
                exit
            end if
        end for
        if not foundIt then
            exit
        end if
    end while

    buildNewTable(cols, rows, colsSpace, rowsSpace, renameTableCells, preserveNames, resizeTable)

end procedure
-------------------------------------------------------------------------------
procedure deleteControlsFromChildren(integer index)
integer foundIt
    foundIt = w32False

    if length(controls[index][SeqChildName]) then
        while w32True do
            for i=index to length(controls) do
                if find(controls[i][Name], controls[index][SeqChildName]) then
                    foundIt = w32True --we needed to add this when child control
                    if find(controls[i][Class],{"Bitmap","PictureButton","TogglePicture"}) then
                        if equal(controls[i][Class],"Bitmap") then
                            deleteResource(controls[i][Name],controls[i][BitmapFile])
                        else
                            if length(controls[i][BitmapFile]) then
                                deleteResource(controls[i][Name],controls[i][BitmapFile])
                            else
                                deleteResource(controls[i][Name],controls[i][XPM])
                            end if
                        end if
                    end if
                    deleteTreeViewNodeAndCode("", controls[i][Name])
                    for j=1 to length(theTreeForm) do
                        if equal(theTreeForm[j][1], controls[i][Name]) then
                            theTreeForm = theTreeForm[1..j-1]
                                          & theTreeForm[j+1..length(theTreeForm)]
                            exit
                        end if
                    end for
                    removeFromParentChildSeq(index,controls[i][Name])

                    for j=1 to getCount(PropertyTitleBar) do
                        if equal(controls[i][Name], getItem(PropertyTitleBar,j)) then
                            ok = deleteItem(PropertyTitleBar, j)
                            exit
                        end if
                    end for

                    --get rid of any ico files on buttons
                    for j=1 to length(iconStrings) do
                        iconData = iconStrings[j]
                        if equal(controls[i][Name], iconData[1]) then
                            if validId(iconData[2]) then
                                destroy(iconData[2])
                                iconStrings = iconStrings[1..j-1]
                                              & iconStrings[j+1..length(iconStrings)]
                            end if
                            exit
                        end if
                    end for

                    if equal(controls[i][Class], "TabItem") then
                        --need to remove from theTabitemCombo
                        for k=1 to getCount(TheTabItemCombo) do
                            if equal(controls[i][Name], getItem(TheTabItemCombo, k)) then
                                ok = deleteItem(TheTabItemCombo, k)
                                exit
                            end if
                        end for
                    end if

                    if controls[index][Indexed] then
                    --this is the copyFrom record for indexed copies.
                    --find the first index for this Name as IndexParent
                    --and make it the indexed record.
                    --the record may be prior to this one....
                        for j=1 to length(controls) do
                            if equal(controls[j][IndexParent], controls[index][Name]) then
                                controls[j][IndexParent] = {}
                                controls[j][Indexed] = w32True
                                for k=1 to length(controls) do
                                    if equal(controls[k][IndexParent], controls[index][Name]) then
                                        controls[k][IndexParent] = controls[j][Name]
                                        exit
                                    end if
                                end for
                                exit
                            end if
                        end for
                    end if

                    --delete this controls children
                    if length(controls[i][SeqChildName]) then
                        deleteControlsFromChildren(i)
                    end if

                    --now delete the child
                    controls = controls[1..i-1] & controls[i+1..length(controls)]
                    exit
                end if
            end for
            if not length(controls[index][SeqChildName])
            or not foundIt then
                exit
            end if
        end while
    end if
end procedure
-----------------------------------------------------------------------------
global procedure deleteTheControl()

integer ok, flag, foundIt, temp_saved,
            toolBarIndex, childCnt,parentIndex, newflag, controlnamelength, at
sequence presentComboSelection, extent

    ignoreChange = w32True   --bypass onChange of TreeView for duration of delete routine

    if find(controls[selectedControl][Class], {"Menu","MenuItem","Submenu","SubmenuItem",
                                               "Sub2menu","Sub2menuItem","Sub3menu","Sub3menuItem",
                                               "Popup","PopupItem","Subpopup","SubpopupItem","Sub2popup","Sub2popupItem",
                                               "Sub3popup","Sub3popupItem","Timer","Window"}) then
        return
    end if

    IDE_Changed = w32True

    --backup controls
    windows[selectedWindow] = controls
    backupControls = windows
    toolBarInfoBack = toolBarInfo
    controlResourceBack = controlResource
    backupSelectedWindow = selectedWindow
    backupLayerTabItemSeq = layerTabItemSeq
    backupLayerCaptionSeq = layerCaptionSeq
    setEnable(MenuControlUndo, w32True)
    setEnable(PopUpDesign_Undo, w32True)
    setVisible(ToolUndo, w32True)
    setVisible(ToolUndoD, w32False)

    if find(controls[selectedControl][Class], {"ToolBar","FlatToolBar"}) then
        --first remove the toolbar info entry
        for j=1 to length(toolBarInfo) do
            if equal(toolBarInfo[j][8], controls[selectedControl][Name]) then
                toolBarInfo = toolBarInfo[1..j-1]&toolBarInfo[j+1..length(toolBarInfo)]
                exit
            end if
        end for
        forceRedraw = w32True
        haveToolBar -= 1
    end if

    if find(controls[selectedControl][SeqParentClass], {"ReBar","ReBarBand"}) then
        repaintWinResize = w32True
    end if

    if equal(controls[selectedControl][Class], "ReBar") then
        haveReBar -= 1
    elsif equal(controls[selectedControl][Class], "StatusBar") then
        haveStatusBar -= 1
    elsif equal(controls[selectedControl][Class], "EuGrid") then
        haveEuGrid -= 1
        haveEuGridControl -= 1
        if not haveEuGrid then
            deleteTreeViewNode("", "eugrid.ew")
            for i=1 to length(includeModules) do
                if match("eugrid.ew",includeModules[i][1]) then
                    includeModules = includeModules[1..i-1] & includeModules[i+1..length(includeModules)]
                end if
            end for
            for i=1 to getCount(CodeModules) do
                if equal("eugrid.ew", getItem(CodeModules,i)) then
                    ok = deleteItem(CodeModules,i)
                    ok = deleteItem(PathModules,i)
                    exit
                end if
            end for
            if not getCount(CodeModules) then
                setEnable(CodeModules, w32False)
            end if
        end if
    end if

    if find(controls[selectedControl][Class],{"Bitmap","PictureButton","TogglePicture"}) then
        if equal(controls[selectedControl][Class],"Bitmap") then
            deleteResource(controls[selectedControl][Name],controls[selectedControl][BitmapFile])
        else
            if length(controls[selectedControl][BitmapFile]) then
                deleteResource(controls[selectedControl][Name],controls[selectedControl][BitmapFile])
            else
                deleteResource(controls[selectedControl][Name],controls[selectedControl][XPM])
            end if
        end if
    end if

    if length(controls[selectedControl][SeqChildName]) then
        --now delete any children of selectedControl       
        deleteControlsFromChildren(selectedControl)
    end if

    if controls[selectedControl][Indexed] then
        --this is the copyFrom record for indexed copies.
        --find the first index for this Name as IndexParent
        --and make it the indexed record.
        --the record may be prior to this one....
        for j=1 to length(controls) do
            if equal(controls[j][IndexParent], controls[selectedControl][Name]) then
                controls[j][IndexParent] = {}
                controls[j][Indexed] = w32True
                for k=1 to length(controls) do
                    if equal(controls[k][IndexParent], controls[selectedControl][Name]) then
                        controls[k][IndexParent] = controls[j][Name]
                        exit
                    end if
                end for
                exit
            end if
        end for
    end if

    parentIndex = 0
    --was the control deleted part of the Tabs, ReBar or ToolBar?
    if length(controls[selectedControl][SeqParentName]) then
        flag = findSeqParentName(selectedControl)
        if flag then
            --was the control a TabItem. If so save the parent for reseting other tabitems active status.
            if equal(controls[flag][Class], "TabControl") then
                --if only one tabitem delete the tabcontrol instead
                if length(controls[flag][SeqChildName])=1 then
                    selectedControl = flag
                    deleteTheControl()
                    return
                else
                    parentIndex = flag
                end if
            end if

            if equal(controls[selectedControl][Class], "TabControl") then
                --control was on a tabitem but need tabitem's parent
                newflag = findSeqParentName(flag)
                if newflag then
                    parentIndex = newflag
                end if
            end if

            --was the toolbar on Rebar?
            if find(controls[flag][Class], {"ReBar","ReBarBand"}) then
                repaintWinResize = w32True
            end if

            if find(controls[flag][Class], {"ToolBar","FlatToolBar"}) then
                forceRedraw = w32True
                repaintWinResize = w32True
                toolBarIndex = 0
                --find the toolbar info record
                for j=1 to length(toolBarInfo) do
                    if equal(toolBarInfo[j][8], controls[flag][Name]) then
                        toolBarIndex = j
                        if length(controls[flag][SeqChildName])=1 then
                            --deleting one and only control on toolbar
                            toolBarInfo[j][4] = 0
                            toolBarIndex = 0
                        end if
                        toolBarX = 0    --toolBarInfo[j][4]
                        toolBarY = 1
                        exit
                    end if
                end for
                if toolBarIndex then
                    --what we have to do is find the LAST subcontrol x+cx
                    --find other controls in the toolbar
                    childCnt = 0
                    for i=flag to length(controls) do
                        if find(controls[i][Name], controls[flag][SeqChildName]) then
                            childCnt += 1
                            if not equal(controls[i][Name], controls[selectedControl][Name]) then
                                --first squish them up
                                if toolBarX+controls[i][CX]>controls[TheWindow][CX] then
                                    toolBarX = toolBarInfo[toolBarIndex][4]
                                    toolBarY += 1
                                end if
                                controls[i][X] = toolBarX
                                controls[i][Y] = ((toolBarY*toolBarCY)-toolBarCY)+toolBarInfo[toolBarIndex][5]
                                --recalculate toolBarX
                                toolBarX += controls[i][CX]
                                toolBarInfo[toolBarIndex][6] = toolBarX
                                toolBarInfo[toolBarIndex][7] = toolBarY
                            end if
                            if childCnt>=length(controls[flag][SeqChildName]) then
                                exit
                            end if
                        end if
                    end for
                end if
            end if
            --remove from its children
            removeFromParentChildSeq(flag, controls[selectedControl][Name])
        end if
    end if

    deleteTreeViewNodeAndCode("", controls[selectedControl][Name])

    for j=1 to length(theTreeForm) do
        if equal(theTreeForm[j][1], controls[selectedControl][Name]) then
            theTreeForm = theTreeForm[1..j-1]
                          & theTreeForm[j+1..length(theTreeForm)]
            exit
        end if
    end for

    -- delete the control from property dropdown
    for j=1 to getCount(PropertyTitleBar) do
        if equal(controls[selectedControl][Name], getItem(PropertyTitleBar,j)) then
            ok = deleteItem(PropertyTitleBar, j)
            exit
        end if
    end for

    --delete from colorization sequence
    for j=1 to length(controlNameKeywords) do
        if equal(controls[selectedControl][Name],controlNameKeywords[j]) then
            controlNameKeywords = controlNameKeywords[1..j-1]
                                  & controlNameKeywords[j+1..length(controlNameKeywords)]
            exit
        end if
    end for

    --get rid of any ico on buttons
    for j=1 to length(iconStrings) do
        iconData = iconStrings[j]
        if equal(controls[selectedControl][Name], iconData[1]) then
            if validId(iconData[2]) then
                destroy(iconData[2])
                iconStrings = iconStrings[1..j-1]
                              & iconStrings[j+1..length(iconStrings)]
            end if
            exit
        end if
    end for

    --get rid of any Esc Stack control
    for j=1 to length(EscStack) do
        if equal(controls[selectedControl][Name], EscStack[j][1][1])
        or equal(controls[selectedControl][Name], EscStack[j][1][7]) then
            EscStack[j] = EscStack[1..j-1] & EscStack[j+1..length(EscStack)]
        end if
    end for

    if equal(controls[selectedControl][Class], "TabItem") then
        --need to remove from theTabitemCombo
        for k=1 to getCount(TheTabItemCombo) do
            if equal(controls[selectedControl][Name], getItem(TheTabItemCombo, k)) then
                ok = deleteItem(TheTabItemCombo, k)
                exit
            end if
        end for
    end if

    if parentIndex then
        --need to set the current tabitemcombo and selectedTabItem
        for i=parentIndex to length(controls) do
            --is it the same parent as the selectedtabItem?
            if equal(controls[i][SeqParentName], controls[parentIndex][Name]) then
                --is this tabItem the same as the selectedTabItem?
                if equal(controls[i][Name], selectedTabItem) then
                        --this is the one that will be deleted
                        --do nothing
                else
                    --now turn on the next tabitem for this parent
                    controls[i][Active] = 1
                    selectedTabItem = controls[i][Name]

                    --highlight this tab in combo
                    for k=1 to getCount(TheTabItemCombo) do
                        if equal(controls[i][Name], getItem(TheTabItemCombo, k)) then
                            setIndex(TheTabItemCombo, k)
                            exit
                        end if
                    end for
                    exit
                end if
            end if
        end for
    else
        if not getCount(TheTabItemCombo) then
            setIndex(TheTabItemCombo, 0)
            selectedTabItem = {}
        end if
    end if

    --if a ControlPartner to other controls remove from their list
    for i=1 to length(controls) do
        at = find(controls[selectedControl][Name],controls[i][ControlPartners])
        if at then
            controls[i][ControlPartners] = controls[i][ControlPartners][1..at-1]
                                           & controls[i][ControlPartners][at+1..length(controls[i][ControlPartners])]
        end if
    end for

    controls = controls[1..selectedControl-1]
               & controls[selectedControl+1..length(controls)]

    -- unselect it
    selectedControl = TheWindow

    --protect counter
    if counterInWindow<0 then
        counterInWindow = 0
    end if

    --reorder the controls
    temp_saved = IDE_Changed
    call_proc(openReorder_id,{})
    call_proc(savetheReorder_id,{})

    IDE_Changed = temp_saved
    call_proc(updateProperties_id,{})

    -- repaint the window
    call_proc(drawIt_id,{})
    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if offsetActive then
        bitBlt(OffScreen, 0, 0, OffScreenBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    --rebuild editor controls combo
    --save the highlighted selection
    if getCount(CodeControls) then
        presentComboSelection = getItem(CodeControls,getIndex(CodeControls))

        --code from IDE_code.ew
        eraseItems(CodeControls)
        controlnamelength = 0
        for i=1 to length(controls) do
            -- get the event name
            -- add the control name to the list

            --win32lib version .55 can not load zero length Name
            if not length(controls[i][Name]) then
                controls[i][Name] = " "
            end if

            addItem(CodeControls, controls[i][Name])
            if length(controls[i][Name])>controlnamelength then
                controlnamelength = length(controls[i][Name])
            end if
        end for
        extent = getTextExtent(CodeControls, "M")
        controlnamelength *= extent[1]
        VOID = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)
        -- default is selected item 
        setIndex(CodeControls, 1)
        editorSelectedControl = 1
        foundIt = w32False
        for i=1 to getCount(CodeControls) do
            if equal(presentComboSelection, getItem(CodeControls, i)) then
                setIndex(CodeControls, i)
                editorSelectedControl = i
                foundIt = w32True
                exit
            end if
        end for
        if not foundIt then
            -- no event to save
            event = 0

            -- populate
            Change_Code(0,0,{})
        end if
    end if
    ignoreChange = w32False
end procedure
deleteTheControl_id = routine_id("deleteTheControl")
------------------------------------------------------------------------------
procedure moveCursorKeysChildren(integer index)
integer childCnt

    childCnt = 0
    --draw any controls within the parent
    for i=index to length(controls) do
        if find(controls[i][Name], controls[index][SeqChildName]) then
            childCnt += 1
            if equal(controls[i][ParentClass], "TabControl")
            and controls[i][Active]
            and not controls[i][DontDraw] then
                drawControl(ControlBlit, controls[i], Normal,i,0)
                if length(controls[i][SeqChildName]) then
                    moveCursorKeysChildren(i)
                end if
            elsif not equal(controls[i][ParentClass], "TabControl") then
                if not controls[i][DontDraw] then
                    drawControl(ControlBlit, controls[i], Normal,i,0)
                    if length(controls[i][SeqChildName]) then
                        moveCursorKeysChildren(i)
                    end if
                end if
            end if
            if thelayerNumber           --drawing layer 1..n
            and (find(0,showBackLayer)  --with base layer as background
                 or backgroundlayer=0) then
                --does layer 1..n have controls hiding layer 0 control?
                call_proc(drawHiddenControls_id,{i})
            end if
        end if
        if childCnt>=length(controls[index][SeqChildName]) then
            exit
        end if
    end for

end procedure
------------------------------------------------------------------------------
procedure useCursorKeysToMove(integer key, integer shift)

sequence the, OSControls, OSControls2, sizeS, holdName, multiThe, name
sequence extent
integer controlnamelength

    if not isChecked(MenuFormLock) then
        --backup controls
        windows[selectedWindow] = controls
        backupControls = windows
        toolBarInfoBack = toolBarInfo
        controlResourceBack = controlResource
        backupSelectedWindow = selectedWindow
        backupLayerTabItemSeq = layerTabItemSeq
        backupLayerCaptionSeq = layerCaptionSeq
        setEnable(MenuControlUndo, w32True)
        setEnable(PopUpDesign_Undo, w32True)
        setVisible(ToolUndo, w32True)
        setVisible(ToolUndoD, w32False)

        the = controls[selectedControl]

        if and_bits(shift, ShiftMask) then
            -- shift is held down to change CX or CY
            if not equal(controls[selectedControl][SeqParentClass],"FlatToolBar") then
                if key=VK_UP then
                    controls[selectedControl][CY] -= SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][CY] -= SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for
                elsif key=VK_DOWN then
                    controls[selectedControl][CY] += SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][CY] += SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for
                elsif key=VK_LEFT then
                    controls[selectedControl][CX] -= SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][CX] -= SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for
                else
                    controls[selectedControl][CX] += SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][CX] += SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for
                end if
                if selectedControl=TheWindow then
                    setRect(Design, 0,0, controls[TheWindow][CX], controls[TheWindow][CY], w32True)
                    setRect(LayersTC, 0,0, controls[TheWindow][CX], 20, w32True)
                else
                    call_proc(check_ResizeDrag_id,{the[CX],the[CY]})
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    multiThe = controls[j]
                                    call_proc(check_ResizeDrag_id,{multiThe[CX],multiThe[CY]})
                                    exit
                                end if
                            end for
                        end if
                    end for
                end if
            end if
        elsif and_bits(shift, ControlMask) then
            --adjust both CX and CY when use Ctrl+arrow key
            if key=VK_LEFT  then
                controls[selectedControl][CX] -= SnapSize
                controls[selectedControl][CY] -= SnapSize
                for i=1 to length(MultiPropertySelect) do
                    if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                        for j=1 to length(controls) do
                            if equal(MultiPropertySelect[i], controls[j][Name]) then
                                controls[j][CX] -= SnapSize
                                controls[j][CY] -= SnapSize
                                exit
                            end if
                        end for
                    end if
                end for
                if selectedControl=TheWindow then
                    setRect(Design, 0, 0, controls[TheWindow][CX], controls[TheWindow][CY], w32True)
                else
                    call_proc(check_ResizeDrag_id,{the[CX],the[CY]})
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    multiThe = controls[j]
                                    call_proc(check_ResizeDrag_id,{multiThe[CX],multiThe[CY]})
                                    exit
                                end if
                            end for
                        end if
                    end for
                end if
            elsif key=VK_RIGHT then
                controls[selectedControl][CX] += SnapSize
                controls[selectedControl][CY] += SnapSize
                for i=1 to length(MultiPropertySelect) do
                    if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                        for j=1 to length(controls) do
                            if equal(MultiPropertySelect[i], controls[j][Name]) then
                                controls[j][CX] += SnapSize
                                controls[j][CY] += SnapSize
                                exit
                            end if
                        end for
                    end if
                end for
                if selectedControl=TheWindow then
                    setRect(Design, 0,0,controls[TheWindow][CX], controls[TheWindow][CY], w32True)
                else
                    call_proc(check_ResizeDrag_id,{the[CX],the[CY]})
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    multiThe = controls[j]
                                    call_proc(check_ResizeDrag_id,{multiThe[CX],multiThe[CY]})
                                    exit
                                end if
                            end for
                        end if
                    end for
                end if
            end if
        else
            if not find(controls[selectedControl][SeqParentClass],{"ToolBar","FlatToolBar"})
            and not equal(controls[selectedControl][Class],"Window") then
                --arrow key moves the control
                if key=VK_UP then
                    controls[selectedControl][Y] -= SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][Y] -= SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for

                elsif key=VK_DOWN then
                    controls[selectedControl][Y] += SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][Y] += SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for
                elsif key=VK_LEFT then
                    controls[selectedControl][X] -= SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][X] -= SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for
                else
                    controls[selectedControl][X] += SnapSize
                    for i=1 to length(MultiPropertySelect) do
                        if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                            for j=1 to length(controls) do
                                if equal(MultiPropertySelect[i], controls[j][Name]) then
                                    controls[j][X] += SnapSize
                                    exit
                                end if
                            end for
                        end if
                    end for
                end if
                call_proc(check_MoveDrag_id,{the[X],the[Y], the[X], the[Y],
                                             the[CX], the[CY], w32False, w32False})
                for i=1 to length(MultiPropertySelect) do
                    if not equal(controls[selectedControl][Name], MultiPropertySelect[i]) then
                        for j=1 to length(controls) do
                            if equal(MultiPropertySelect[i], controls[j][Name]) then
                                multiThe = controls[j]
                                call_proc(check_MoveDrag_id,{multiThe[X], multiThe[Y],
                                                             multiThe[X], multiThe[Y],
                                                             multiThe[CX],multiThe[CY], w32False, w32False})
                                exit
                            end if
                        end for
                    end if
                end for
            end if
        end if

        sizeS = getRect(Screen)

        --check if control went off screen
        if controls[selectedControl][X]<0 then
            haveOffscreen = w32True
            OSControls = controls[selectedControl]

            if OSControls[X]<0 then
                OSControls[X] = dCX+controls[selectedControl][X]
            end if
            if OSControls[Y]<0 then
                OSControls[Y] *= -1  --can't draw negative Y yet
            end if
            copyBlt(OffScreenBlit, 0, 0, GridBlit)

            drawControl(OffScreenBlit, OSControls, Normal,selectedControl,0)

            --did it have children?
            for i=1 to length(controls) do
                if equal(controls[i][ControlParent],
                         controls[selectedControl][Name]) then
                    OSControls2 = controls[i]
                    if OSControls2[X]<0 then
                        OSControls2[X] = dCX+controls[i][X]
                    end if
                    if OSControls2[Y]<0 then
                        OSControls[Y] *= -1 --can't draw negative Y yet
                    end if
                    drawControl(OffScreenBlit, OSControls2, Normal,i,0)
                end if
            end for
        end if
    else
        return
    end if

    holdName = controls[selectedControl][Name]

    --insure control in Code Editor stays in sync with controls sequence after sort
    name = getItem(CodeControls,getIndex(CodeControls))
    controls = sort(controls)
    --reload CodeControls
    eraseItems(CodeControls)
    controlnamelength = 0
    for i=1 to length(controls) do
        addItem(CodeControls, controls[i][Name])
        if length(controls[i][Name])>controlnamelength then
            controlnamelength = length(controls[i][Name])
        end if
    end for
    extent = getTextExtent(CodeControls, "M")
    controlnamelength *= extent[1]
    VOID = sendMessage(CodeControls, LB_SETHORIZONTALEXTENT, controlnamelength, 0)

    for i=1 to getCount(CodeControls) do
        if equal(name, getItem(CodeControls,i)) then
            setIndex(CodeControls,i)
            editorSelectedControl = i
            exit
        end if
    end for

    selectedControl = TheWindow
    call_proc(drawIt_id,{})

    --Need to refind the selectedcontrol
    for i=1 to length(controls) do
        if equal(holdName, controls[i][Name]) then
            selectedControl = i
            exit
        end if
    end for

    if selectedControl!=TheWindow
    and not controls[selectedControl][DontDraw] then
        -- draw selected control
        drawControl(ControlBlit, controls[selectedControl], Normal,selectedControl,0)

        if length(controls[selectedControl][SeqChildName]) then
            moveCursorKeysChildren(selectedControl)
        end if

        drawControl(ControlBlit, controls[selectedControl], Selected,selectedControl,0)
        if thelayerNumber           --drawing layer 1..n
        and (find(0,showBackLayer)  --with base layer as background
             or backgroundlayer=0) then
            --does layer 1..n have controls hiding layer 0 control?
            call_proc(drawHiddenControls_id,{selectedControl})
        end if
    end if

    bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    if showActive then
        bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if offsetActive then
        bitBlt(OffScreen, 0, 0, OffScreenBlit,0,0,gridX,gridY,SRCCOPY)
    end if

    if equal(getItem(PropertyTitleBar,getIndex(PropertyTitleBar)),
             controls[selectedControl][Name]) then
        if and_bits(shift, ShiftMask) then
            -- shift is held down
            if key=VK_UP
            or key=VK_DOWN then
                call_proc(updateProperty_id,{"Height"})
            elsif key=VK_LEFT
               or     key=VK_RIGHT then
                call_proc(updateProperty_id,{"Width"})
            end if
        elsif and_bits(shift, ControlMask) then
            call_proc(updateProperty_id,{"Height"})
        else
            if key=VK_UP
            or key=VK_DOWN then
                call_proc(updateProperty_id,{"Row"})
            elsif key=VK_LEFT
               or key=VK_RIGHT then
                call_proc(updateProperty_id,{"Column"})
            end if
        end if
    else
        call_proc(updateProperties_id,{})
    end if

end procedure
------------------------------------------------------------------------------
global procedure keyDown_Design(integer Self, integer Event, sequence Params)
integer key, shift
--handle special keys
integer skipDelete, flag
sequence parentCell1

    key = Params[1]
    shift = Params[2]

    if find(controls[selectedControl][Class], {"Menu","MenuItem","Submenu","SubmenuItem",
                                               "Sub2menu","Sub2menuItem","Sub3menu","Sub3menuItem",
                                               "Popup","PopupItem","Subpopup","SubpopupItem","Sub2popup","Sub2popupItem",
                                               "Sub3popup","Sub3popupItem","Timer","TabControl","ReBar"}) then
        return
    end if

    if key=VK_UP or key=VK_DOWN or key=VK_LEFT or key=VK_RIGHT then
        --may now be used by Window control v0.19.0
        useCursorKeysToMove(key, shift)
        return
    end if

    if equal(controls[selectedControl][Class], "Window") then
        return
    end if

    if and_bits(shift, ControlMask) then
        if key=26
        or key=90 then
            --Ctrl+Z
            ok = invokeHandler(MenuControlUndo,w32HClick,{})
            return
        end if
    end if

    -- is a control selected?
    if selectedControl!=TheWindow then
        if equal(controls[selectedControl][Class], "TabItem") then
            if (and_bits(shift, ControlMask)
                or and_bits(shift, ShiftMask)
                or and_bits(shift, AltMask) )
            and key=VK_DELETE then
                --delete the TabControl and all TabItems and controls
                --use TabItem parent as selected control
                flag = findSeqParentName(selectedControl)
                if flag then
                    selectedControl = flag
                else
                    --bail out; something is wrong if tabitem has no parent
                    selectedControl = TheWindow
                    return
                end if
            elsif key=VK_DELETE then
                deleteTheControl()
            end if
            return
        end if

        --delete key?
        if key=VK_DELETE then
            if controls[selectedControl][TableCell]>1 then
                ok = displayErrorMessage(112,{})
            elsif controls[selectedControl][TableCell] then
                skipDelete = w32False
                parentCell1 = controls[selectedControl][SeqParentName]

                --can only delete cell 1 if no other cells created
                for i=1 to length(controls) do
                    if equal(controls[i][SeqParentName], parentCell1)
                    and i!=selectedControl
                    and controls[i][TableCell]>1 then
                        ok = displayErrorMessage(113,{})
                        skipDelete = w32True
                        exit
                    end if
                end for
                --but if only cell 1 then delete it
                if not skipDelete then
                    deleteTheControl()
                end if
            else
                deleteTheControl()
            end if
            selectedControl = TheWindow

        elsif key=VK_ESCAPE then

            -- unselect
            selectedControl = TheWindow
            call_proc(updateProperties_id,{})

            -- repaint the window
            call_proc(drawIt_id,{})
            bitBlt(Design, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
            if showActive then
                bitBlt(Show, 0, 0, ControlBlit,0,0,gridX,gridY,SRCCOPY)
            end if

            if offsetActive then
                bitBlt(OffScreen, 0, 0, OffScreenBlit,0,0,gridX,gridY,SRCCOPY)
            end if
        end if
    end if

end procedure
setHandler({Design,TV,Controls}, w32HKeyDown, routine_id("keyDown_Design"))
------------------------------------------------------------------------------
sequence testClass
testClass = ""

global procedure keyPress_Design(integer Self, integer Event, sequence Params)
integer key, shift

    key = Params[1]
    shift = Params[2]

    if and_bits(shift, ShiftMask) then
        if key=65 then
            --Shift+A
            MultiPropertySelect = {}
        elsif key=82 then
            --Shift+R
            userWantsResize = w32True
        elsif key=83 then
            --SHIFT+S
            if length(MultiPropertySelect) then
                if not equal(controls[selectedControl][Class], testClass) then
                    ok = displayErrorMessage(44,{testClass})
                    return
                end if
            end if
            MultiPropertySelect &= {controls[selectedControl][Name]}
            if length(MultiPropertySelect)=1 then
                testClass = controls[selectedControl][Class]
            end if
        end if
    end if
end procedure
setHandler(Design, w32HKeyPress, routine_id("keyPress_Design"))

