-- ide_proj.ew
-- project reading/writing for win32lib ide
-- modifications by Judith
-- modifications by Roland Stowasser

integer ok,lineCount
        lineCount = 0   --count lines for compare to ex.err
sequence
    priorMenuName,
--  priorSubmenuName,       --RS
--  priorSub2menuName,      --RS
--  priorSub3menuName,      --RS
--  priorPopupName,
--  priorPopupItemName,     --RS
--  priorSubpopupName,      --RS
--  priorSub2popupName,     --RS
--  priorSub3popupName,     --RS
    priorWindowName,
    priorTableName,
    pathName,
    priorFontName,
    priorFontAttrib,
    priorFontPts,
    layerSeq,
    ncontrols,
    IDE_hintFont,
        IDE_hinttext,
        IDE_fontName,
        IDE_hintFontPts,
        IDE_fontPts,
        IDE_fontColor,
        IDE_windowFontName,
        IDE_windowFontPts,
        IDE_windowHintFontName,
        IDE_windowHintFontPts

    pathName = {}
    priorTableName = {}
    priorFontName = {}
    priorFontAttrib = {}
    priorFontPts = {}
    ncontrols = {}
    IDE_hintFont = {}
        IDE_hinttext = {}
        IDE_fontName = {}
        IDE_hintFontPts = {}
        IDE_fontPts = {}
        IDE_fontColor = {}
        IDE_windowFontName = {}
        IDE_windowFontPts = {}
        IDE_windowHintFontName = {}
        IDE_windowHintFontPts = {}

integer priorColRow,
        priorCols,
        priorRows,
        priorLocal,
        priorInteger,
        IDE_windowAttrib,
                IDE_windowBold,
                IDE_windowUnder,
                IDE_windowStrike

    priorColRow = 0
    priorCols = 0
    priorRows = 0
    priorLocal = w32False
    priorInteger = w32False
    IDE_windowAttrib = 0
        IDE_windowBold = 0
        IDE_windowUnder = 0
        IDE_windowStrike = 0

global sequence tabNewTitle
    tabNewTitle = {}

sequence VarColorNames
VarColorNames = {}

sequence allIndexedArray --holds all copy-indexed controls for a window
sequence indexedArray   --holds copy-indexed controls and primary
allIndexedArray = {}
indexedArray = {}

-------------------------------------------------------------------------------
--callback code and selectDirectory params code from Win32lib demo by
--Thomas Parslow
-------------------------------------------------------------------------------
integer vcb vcb = 0
integer vattempts vattempts = 0
atom bif bif = 0

function callback(atom hWnd, atom msg, atom lParam, atom lData)
atom res
sequence foldername
integer VOID

    res = 0
    if msg=BFFM_INITIALIZED then
        if hWnd=0 then
            -- Starting initialiation
            bif = lParam
            vcb = 0
            vattempts += 1
            w32store(bif, bfTitle, "Get Include Folder for IDE_ScrollingTable.ew")
        else
            -- Completed initialiation.
            vcb = 1
        end if

    elsif msg=BFFM_VALIDATEFAILED then
        foldername = w32peek_string(lParam)
        VOID = displayErrorMessage(36,{foldername})
        if VOID=IDOK then
            res = -1
        else
            res = 0
        end if
    end if

    return res
end function
-------------------------------------------------------------------------------
global procedure flushControls()
    -- save controls to window
    if length(windows) then
        if selectedWindow then
            windows[selectedWindow] = controls
        end if
    else
        windows &= {controls}   --needed for crashfile       
    end if
end procedure
--------------------------------------------------------------------------------
sequence ctrls, size
    ctrls = {}
    size = {}

sequence CWindowBars
CWindowBars = {}
integer haveToolBarControl, haveToolBarControlInCWindow
haveToolBarControl = 0
haveToolBarControlInCWindow = 0
integer haveReBarControl, haveReBarControlInCWindow
haveReBarControl = 0
haveReBarControlInCWindow = 0

--list of settings Buffer slots
constant cfgGridColor = 1,
cfgGridColorname = 2,
cfgGridPixel = 3,
cfgGridStyle = 4,
cfgIdeDocs = 5,
cfgRulerDocs = 6,
cfgWin32libDocs = 7,
cfgWin32libName = 8,
cfgGlobal = 9,
cfgNoBackupsave = 10,
cfgTempRules1 = 11,
cfgTempRules2 = 12,
cfgHintStatusBar = 13,
cfgHintDisabled = 14,
cfgMultipleInstance = 15,
cfgWaitKey = 16,
cfgProjectFileType = 17,
cfgNotSetHandler = 18,--this is not used any longer; slot may be reused
cfgIDE_R1 = 19,
cfgIDE_R2 = 20,
cfgIDE_R3 = 21,
cfgDesign_R1 = 22,
cfgDesign_R2 = 23,
cfgDesign_R3 = 24,
cfgDesign_CB1 = 25,
cfgCode_R1 = 26,
cfgCode_R2 = 27,
cfgCode_R3 = 28,
cfgCode_CB1 = 29,
cfgPV_R1 = 30,
cfgPV_CB1 = 31,
cfgPV_CB2 = 32,
         cfgProp_R1 = 33,
         cfgProp_CB1 = 34,
         cfgProp_CB2 = 35,
         cfgCB_Start = 36,
         cfgCB_WantDefault = 37,
         cfgEditPrjDef = 38,
         cfgSaveToProject = 39,
         cfgAskSaveToProject = 40,
         cfgNoEditorBackup = 41,
         cfgFiles = 42,
         cfgControls = 43,
         cfgCopyIndex = 44,
                --used in IDE but not by proj.ew: cfgLangPref=45,
         cfgRegisterStyle = 46,
         cfgNoEditorAutoComplete = 47,
         cfgDefaultMIS = 48,
         cfgNoIndexing = 49,
         cfgControlEventBehavior = 50,
         cfgHideGutter = 51,
         cfgNoMinMenuRun = 52,
         cfgColorEuWinlib = 53,
         cfgColorLocal = 54,
         cfgChangeName = 55,
         cfgAutoSave = 56,
         cfgColorControlName = 57,
cfgNoBackupAftersave = 58,
cfgReuseBak1File = 59,
cfgReuseBak2File = 60,
cfgDefaultEditor = 61,
--               cfgEditorOpen=62,
cfgAutosaveOnOff = 63,
cfgAutosaveMinutes = 64,
cfgBackupFolderName = 65,
cfgCbDocs = 66,

         maxSlots = 66
-----------------------------------------------------------------------------
function reOrderControls(sequence ctrls)

integer found, infrontCounter, newposition
sequence newControls

    newControls = {}
    infrontCounter = 0

    while w32True do

        found = w32False

        for i=1 to length(ctrls) do
            if ctrls[i][AWindow]<20 then

                infrontCounter += 1

                found = w32True
                newControls &= {ctrls[i]}
                ctrls = ctrls[1..i-1] & ctrls[i+1..length(ctrls)]
                exit
            end if
        end for

        if found=w32False then
            newControls &= ctrls[1..length(ctrls)]
            exit
        end if

    end while

    --put into tab order after above controls moved to top
    for i=1 to length(ctrls) do
        if ctrls[i][TabOrder] then
            newposition = infrontCounter+ctrls[i][TabOrder]

            if newposition>length(newControls) then
                ok = displayErrorMessage(222,{})
                return newControls
            else
                newControls[newposition] = ctrls[i]
            end if
        end if
    end for

    return newControls

end function
-----------------------------------------------------------------------------
constant alt_249 = 001
constant alt_250 = 002
constant alt_251 = 003
constant alt_252 = 004
constant alt_253 = 005

function cleanTitle(sequence holddata, sequence class)
--parse the Title for quote and backslash

integer at, foundIt

    if match("var:", holddata) then
        return holddata
    end if

    foundIt = w32False

    --look for { or } and remove
    at = match("{", holddata)
    if at then
        holddata = holddata[1..at-1] & holddata[at+1..length(holddata)]
    end if

    at = match("}", holddata)
    if at then
        holddata = holddata[1..at-1] & holddata[at+1..length(holddata)]
    end if

    --look for required beginning quote marks
    --if missing add to front and back
    at = match("\"", holddata)
    if not at
    and equal(class, "ListView") then
        holddata = "\"" & holddata & "\""
    end if

    --now find any "," in listview
    while w32True do
        foundIt = w32False

        at = match("\",\"", holddata)
        if at then
            holddata = holddata[1..at-1] & alt_253  & "  "
                       & holddata[at+3..length(holddata)]
            foundIt = w32True
        end if

        if not foundIt then
            exit
        end if

    end while


    while w32True do
        foundIt = w32False

        at = match("\"", holddata)   --find "
        if at then
            if equal(class, "ListView") then
                if at!=1 and at!=length(holddata) then
                    holddata = holddata[1..at-1] & alt_250
                               & holddata[at+1..length(holddata)]
                    foundIt = w32True
                else
                    holddata = holddata[1..at-1] & alt_249
                               & holddata[at+1..length(holddata)]
                    foundIt = w32True
                end if
            end if

            if not equal(class, "ListView") then
                holddata = holddata[1..at-1] & alt_250
                           & holddata[at+1..length(holddata)]
                foundIt = w32True
            end if
        end if

        at = match("\\n", holddata)  --find \n
        if at then
            holddata = holddata[1..at-1]    & alt_251
                       & holddata[at+2..length(holddata)]
            foundIt = w32True
        end if

        if not foundIt then
            exit
        end if

    end while

    while w32True do
        foundIt = w32False

        at = match("\\", holddata)   --find \
        if at then
            if not find(class, {"Menu","MenuItem","Submenu",
                                "SubmenuItem","Sub2menu","Sub2menuItem",
                                "Sub3menu","Sub3menuItem"}) then
                holddata = holddata[1..at-1] & alt_252
                           & holddata[at+1..length(holddata)]
                foundIt = w32True
            end if
        end if

        if not foundIt then
            exit
        end if

    end while

    --now put in the \", \\ and \n  and " if in ListView
    foundIt = w32False

    while w32True do

        foundIt = w32False

        for j=1 to length(holddata) do

            at = find(alt_253, holddata)
            if at then
                holddata = holddata[1..at-1] & "\",\"" & holddata[at+3..length(holddata)]
                foundIt = w32True
                exit
            end if

            at = find(alt_249, holddata)
            if at then
                holddata = holddata[1..at-1] & "\"" & holddata[at+1..length(holddata)]
                foundIt = w32True
                exit
            end if

            at = find(alt_250, holddata)
            if at then
                if equal(class, "ListView") then
                    holddata = holddata[1..at-1] & " \\\"" & holddata[at+1..length(holddata)]
                else
                    holddata = holddata[1..at-1] & "\\\"" & holddata[at+1..length(holddata)]
                end if
                foundIt = w32True
                exit
            end if

            at = find(alt_251, holddata)
            if at then
                holddata = holddata[1..at-1] & "\\n" & holddata[at+1..length(holddata)]
                foundIt = w32True
                exit
            end if

            at = find(alt_252, holddata)
            if at then
                holddata = holddata[1..at-1] & "\\\\" & holddata[at+1..length(holddata)]
                foundIt = w32True
                exit
            end if

        end for

        if not foundIt then
            exit
        end if

    end while

    return holddata

end function
------------------------------------------------------------------------------
sequence tables
tables = {}

sequence table
--------------------------------------------------------------------------------
procedure addCellToArray(sequence ctrl, sequence title, sequence parent, sequence x, sequence y,
                        sequence cx, sequence cy, sequence style, sequence exstyle)

    table = {"","","","","","","","",""}
    table[1] = ctrl
    table[2] = title
    table[3] = parent
    table[4] = x
    table[5] = y
    table[6] = cx
    table[7] = cy
    table[8] = style
    table[9] = exstyle

    tables &= {table}
end procedure
--------------------------------------------------------------------------------
integer oneIndex, controlCounter, listViewCounter
oneIndex = w32False
controlCounter = 1
listViewCounter = 0

sequence attributes
attributes = {}

sequence buddyDataArray, buddyListArray
    buddyListArray = {}
    buddyDataArray = {"",""}

integer firstLV, firstLvItems
firstLV = w32True
firstLvItems = w32True
--------------------------------------------------------------------------------
function cleanListView(sequence titles)
sequence testData, newData, newData2, fixedData
integer at

    if match("var:",titles) then
        return titles
    end if

    newData = {}
    newData2 = {}

    testData = titles
    at = match("\"",testData)
    if at then
        newData = testData[1..at-1] & "\\" & testData[at]
        testData = testData[at+1..length(testData)]
        --keep looking
        while at do
            at = match("\"",testData)
            if at then
                newData &= testData[1..at-1] & "\\" & testData[at]
                testData = testData[at+1..length(testData)]
            else
                newData &= testData[1..length(testData)]
            end if
        end while
    else
        newData &= testData[1..length(testData)]
    end if

    --divide at caret
    at = w32True
    while at do
        at = match("^", newData)
        if at then
            newData2 &= {newData[1..at-1]}
            newData = newData[at+1..length(newData)]
        else
            newData2 &= {newData[1..length(newData)]}
        end if
    end while

    fixedData = {}
    for i=1 to length(newData2) do
        fixedData &= ",\"" & newData2[i] & "\""
    end for
    --remove comma
    fixedData = fixedData[2..length(fixedData)]
    return fixedData
end function
-------------------------------------------------------------------------------
procedure doAttributesNow(sequence ctrl, integer row, integer col, integer index)
--this is shared between Table Control and copy-index controls and index primary
sequence textA, testStyle, saveName, examDocs, cleanSeq, len, Len, Column, column,
                testIco, newIco,attTableName, hinttext
integer at, at1, at2
    at = 0

    textA = {}
    attTableName = priorTableName&"Array"

    if ctrl[Indexed] then
        attTableName = ctrl[Name]
    end if
    if length(ctrl[IndexParent]) then
        attTableName = ctrl[IndexParent]
    end if

     --now write the special file stuff like setVisible, setEnable, etc
    if not ctrl[Visible] then
        textA = "setVisible( " & attTableName & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= ",w32False )\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "], w32False )\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index)
                     & "], w32False )\n"
        end if
        attributes &= {textA}
    end if

    if ctrl[PB_Caption_Pos] then
        textA = "removeStyle( " & attTableName & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= ", BS_CENTER )\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "], BS_CENTER )\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index)
                     & "], BX_CENTER )\n"
        end if
        attributes &= {textA}

        textA = "addStyle( " & attTableName & "[" & sprint(row) & "]"
        if ctrl[PB_Caption_Pos]=1 then
            if oneIndex then
                textA &= ", BS_LEFT )\n"
            elsif controlCounter=1 then
                textA &= "[" & sprint(col) & "], BS_LEFT )\n"
            else
                textA &= "[" & sprint(col) & "][" & sprint(index)
                         & "], BX_LEFT )\n"
            end if
        else
            if oneIndex then
                textA &= ", BS_RIGHT )\n"
            elsif controlCounter=1 then
                textA &= "[" & sprint(col) & "], BS_RIGHT )\n"
            else
                textA &= "[" & sprint(col) & "][" & sprint(index)
                         & "], BX_RIGHT )\n"
            end if
        end if
        attributes &= {textA}
    end if

    if not ctrl[EnableC] then
        textA = "setEnable( " & attTableName & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= ",w32False )\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "], w32False )\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index)
                     & "], w32False )\n"
        end if
        attributes &= {textA}
    end if

    if ctrl[Limit]
    and not equal(ctrl[Class], "EuGrid") then
        textA = "limitText( " & attTableName & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= "," & sprint(ctrl[Limit]) & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]," & sprint(ctrl[Limit])
                     & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "],"
                     & sprint(ctrl[Limit]) & ")\n"
        end if
        attributes &= {textA}
    end if

    if ctrl[TxtColor] then
        textA = "setTextColor( "
                & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= "," & sprint(ctrl[TxtColor]) & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]," & sprint(ctrl[TxtColor])
                     & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "],"
                     & sprint(ctrl[TxtColor]) & ")\n"
        end if
        attributes &= {textA}
        if not ctrl[BkColor] then
            --to force text to show the color change
            if find(ctrl[Class], {"EditText","List"}) then
                textA = "setWindowBackColor( "
                        & attTableName
                        & "[" & sprint(row) & "]"
                if oneIndex then
                    textA &= ", " & sprint(WindowColor) & ")\n"
                elsif controlCounter=1 then
                    textA &= "[" & sprint(col) & "], " & sprint(WindowColor) & ")\n"
                else
                    textA &= "[" & sprint(col) & "][" & sprint(index) & "], " & sprint(WindowColor) & ")\n"
                end if
            else
                textA = "repaintFG( "
                        & attTableName
                        & "[" & sprint(row) & "]"
                if oneIndex then
                    textA &= " )\n"
                elsif controlCounter=1 then
                    textA &= "[" & sprint(col) & "] )\n"
                else
                    textA &= "[" & sprint(col) & "][" & sprint(index) & "] )\n"
                end if
            end if
            attributes &= {textA}
        end if
    end if

    if ctrl[BkColor]
    and not find(ctrl[Class],{"EuGrid","ProgressBar"})
    and not equal(ctrl[SeqParentClass],"EuGrid")
    and ctrl[BkColor]!=getSysColor(COLOR_BTNFACE) then
        textA = "setWindowBackColor( "
                & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= "," & sprint(ctrl[BkColor]) & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]," & sprint(ctrl[BkColor])
                     & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "],"
                     & sprint(ctrl[BkColor]) & ")\n"
        end if
        attributes &= {textA}

    elsif equal(ctrl[Class],"ProgressBar") then
        textA = "VOID = sendMessage(" & attTableName & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= ",#2001,0," & sprint(ctrl[BkColor]) & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]," & "#2001,0," & sprint(ctrl[BkColor]) & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "]," & "#2001,0," & sprint(ctrl[BkColor]) & ")\n"
        end if
        attributes &= {textA}
        textA = "VOID = sendMessage(" & attTableName & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= ",#0409,0," & sprint(ctrl[BkBarColor]) & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]," & "#0409,0," & sprint(ctrl[BkBarColor]) & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "]," & "#0409,0," & sprint(ctrl[BkBarColor]) & ")\n"
        end if
        attributes &= {textA}
    end if

    if length(ctrl[InitialVal])
    and not equal(ctrl[Class], "ListView") then
        for i=1 to length(ctrl[InitialVal]) do
            textA = "addItem( " & attTableName
                    & "[" & sprint(row) & "]"
            if oneIndex then
                textA &= ", \"" & ctrl[InitialVal][i] & "\")\n"
            elsif controlCounter=1 then
                textA &= "[" & sprint(col) & "], \"" & ctrl[InitialVal][i]
                         & "\")\n"
            else
                textA &= "[" & sprint(col) & "][" & sprint(index) & "], \""
                         & ctrl[InitialVal][i] & "\")\n"
            end if
            attributes &= {textA}
        end for
    end if

    if ctrl[MinValue]
    or ctrl[MaxValue] then
        textA = "setScrollRange( "
                & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= "," & sprint(ctrl[MinValue]) & ", " & sprint(ctrl[MaxValue])
                     & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]," & sprint(ctrl[MinValue])
                     & ", " & sprint(ctrl[MaxValue])
                     & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "],"
                     & sprint(ctrl[MinValue])
                     & ", " & sprint(ctrl[MaxValue])
                     & ")\n"
        end if
        attributes &= {textA}
    end if

    if ctrl[LineChg]
    or ctrl[PageChg] then
        textA = "setScrollChange( "
                & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= "," & sprint(ctrl[LineChg]) & ", " & sprint(ctrl[PageChg])
                     & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]," & sprint(ctrl[LineChg])
                     & ", " & sprint(ctrl[PageChg])
                     & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "],"
                     & sprint(ctrl[LineChg])
                     & ", " & sprint(ctrl[PageChg])
                     & ")\n"
        end if
        attributes &= {textA}
    end if

    if equal(ctrl[Class], "UpDown") then
        if not length(ctrl[Buddy]) then
            --user did not supply a buddy name, so user placed the buddy
            --control where he wanted it or added setBuddy() in General event
        else
            --save the buddy name for later
            buddyDataArray[1] = ctrl[Name]
            buddyDataArray[2] = ctrl[Buddy]
            buddyListArray &= {buddyDataArray}
        end if
    end if

    --if Table was assigned a font, it applies to all the cells in it
    if length(priorFontName)
    and not length(ctrl[FontName])
    and not length(ctrl[FontVarName]) then
        textA = "setFont( " & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= "," & priorFontName & ","
                     & priorFontPts & "," & priorFontAttrib
                     & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col)
                     & "]" & "," & priorFontName & ","
                     & priorFontPts & "," & priorFontAttrib
                     & ")\n"
        else
            textA &= "[" & sprint(col)
                     & "][" & sprint(index) & "]" & "," & priorFontName & ","
                     & priorFontPts & "," & priorFontAttrib
                     & ")\n"
        end if
        attributes &= {textA}
    end if
    --but can be overridden by the font on the particular cell    
    if length(ctrl[FontName])
    or length(ctrl[FontVarName]) then
        if length(ctrl[FontName]) then
            IDE_fontName = "\"" & ctrl[FontName] & "\""
        end if
        if length(ctrl[FontVarName]) then
            IDE_fontName = ctrl[FontVarName]
        end if
        if ctrl[FontPts] then
            IDE_fontPts = sprint(ctrl[FontPts])
        end if
        if length(ctrl[FontVarPts]) then
            IDE_fontPts = ctrl[FontVarPts]
        end if
        testStyle = "Normal"
        if ctrl[FontAttrib]
        or length(ctrl[FontVarItalic])then
            testStyle = "Italic"
        end if
        if ctrl[FontBold]
        or length(ctrl[FontVarBold]) then
            testStyle &= "+Bold"
        end if
        if ctrl[FontUnderline]
        or length(ctrl[FontVarUnderline]) then
            testStyle &= "+Underline"
        end if
        if ctrl[FontStrikeout]
        or length(ctrl[FontVarStrikeout]) then
            testStyle &= "+Strikeout"
        end if

        textA = "setFont( " & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= "," & IDE_fontName & ","
                     & IDE_fontPts & "," & testStyle
                     & ")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]"
                     & "," & IDE_fontName & ","
                     & IDE_fontPts & "," & testStyle
                     & ")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "]"
                     & "," & IDE_fontName & ","
                     & IDE_fontPts & "," & testStyle
                     & ")\n"
        end if
        attributes &= {textA}
    end if

    if length(ctrl[HintText])
    or length(ctrl[HintVarText]) then

        textA = "setHint( " & attTableName
                & "[" & sprint(row) & "]"
        if match("var:",ctrl[HintText]) then
            hinttext = ctrl[HintText]
            hinttext = hinttext[5..length(hinttext)]
            hinttext = trimL(hinttext)
            if oneIndex then
                textA &= "," & hinttext & ")\n"
            elsif controlCounter=1 then
                textA &= "[" & sprint(col)
                         & "]" & "," & hinttext & ")\n"
            else
                textA &= "[" & sprint(col)
                         & "][" & sprint(index) & "]"
                         & "," & hinttext & ")\n"
            end if
        else
            if length(ctrl[HintText]) then
                IDE_hinttext = "\"" & ctrl[HintText] & "\""
            elsif length(ctrl[HintVarText]) then
                IDE_hinttext = ctrl[HintVarText]
            end if
            if oneIndex then
                textA &= "," & IDE_hinttext & ")\n"
            elsif controlCounter=1 then
                textA &= "[" & sprint(col)
                         & "]" & "," & IDE_hinttext & ")\n"
            else
                textA &= "[" & sprint(col)
                         & "][" & sprint(index) & "]"
                         & "," & IDE_hinttext & ")\n"
            end if
        end if
        attributes &= {textA}
    end if

    if length(ctrl[IcoFile])
    and not equal(ctrl[Class], "ListView") then
        saveName = {}
        examDocs = ctrl[IcoFile]
        at = match(lower(projectDir), lower(examDocs))
        if at then
            examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
        end if
        at = 1
        while at do
            at = 0
            for k=1 to length(examDocs) do
                if examDocs[k]='\\' then
                    saveName &= examDocs[1..k-1] & "\\\\"
                    examDocs = examDocs[k+1..length(examDocs)]
                    at = 1
                    exit
                end if
            end for
        end while
        saveName &= examDocs
        textA = "setIcon( " & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA = ",\"" & saveName & "\")\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "],\""
                     & saveName & "\")\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "],\""
                     & saveName & "\")\n"
        end if
        attributes &= {textA}
    end if

    if length(ctrl[BitmapFile]) then
        saveName = {}
        examDocs = ctrl[BitmapFile]
        at = match(lower(projectDir), lower(examDocs))
        if at then
            examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
        end if
        at = 1
        while at do
            at = 0
            for k=1 to length(examDocs) do
                if examDocs[k]='\\' then
                    saveName &= examDocs[1..k-1] & "\\\\"
                    examDocs = examDocs[k+1..length(examDocs)]
                    at = 1
                    exit
                end if
            end for
        end while
        saveName &= examDocs
        if equal(ctrl[Class], "Pixmap") then
            textA = "setPixmap( " & attTableName
                    & "[" & sprint(row) & "]"
            if oneIndex then
                textA &= "\"" & saveName & "\")\n"
            elsif controlCounter=1 then
                textA &= "[" & sprint(col) & "],\""
                         & saveName & "\")\n"
            else
                textA &= "[" & sprint(col) & "][" & sprint(index)
                         & "],\""
                         & saveName & "\")\n"
            end if
        else
            textA = "setBitmap( " & attTableName
                    & "[" & sprint(row) & "]"
            if oneIndex then
                textA &= ",\"" & saveName & "\")\n"
            elsif controlCounter=1 then
                textA &= "[" & sprint(col) & "],\""
                         & saveName & "\")\n"
            else
                textA &= "[" & sprint(col) & "][" & sprint(index)
                         & "],\""
                         & saveName & "\")\n"
            end if
        end if
        attributes &= {textA}
    end if
    if equal(ctrl[Class], "ListView") then
        if length(ctrl[IcoFile]) then
            --in ListView the IcoFile is a sequence of icons
            for i=1 to length(ctrl[IcoFile]) do
                listViewCounter += 1
                testIco = ctrl[IcoFile][i]
                at = match(lower(projectDir),lower(testIco))
                if at then
--                  testIco=testIco[at+1+projectDir..length(testIco)]
                    testIco = testIco[at+1+length(projectDir)..length(testIco)]
                end if
                at = match("\\", testIco)
                if at then
                    newIco = testIco[1..at] & "\\"
                    testIco = testIco[at+1..length(testIco)]
                    while at do
                        at = match("\\", testIco)
                        if at then
                            newIco &= testIco[1..at] & "\\"
                            testIco = testIco[at+1..length(testIco)]
                        else
                            newIco &= testIco[1..length(testIco)]
                        end if
                    end while
                else
                    newIco &= testIco[1..length(testIco)]
                end if

                textA = "constant LVIcon" & sprint(listViewCounter) & " = addIcon(extractIcon(\""
                        & newIco & "\") ) \n"
                attributes &= {textA}
            end for
        end if
    end if

    if length(ctrl[ExtExStyle]) then
        --ListView sendMessages
        for i=1 to length(ctrl[ExtExStyle]) do
            if find(ctrl[ExtExStyle][i],{"LVS_EX_UNDERLINECOLD","LVS_EX_UNDERLINEHOT",
                                         "LVS_EX_TRACKSELECT","LVS_EX_TWOCLICKACTIVATE",
                                         "LVS_EX_ONECLICKACTIVATE","LVS_EX_FLATSB",
                                         "LVS_EX_FULLROWSELECT","LVS_EX_HEADERDRAGDROP",
                                         "LVS_EX_CHECKBOXES","LVS_EX_GRIDLINES"}) then
                if firstLV then
                    textA = "atom lvMask \n"
                    attributes &= {textA}
                    textA = "integer lvOk \n"
                    attributes &= {textA}
                    firstLV = w32False
                end if
                textA = "lvMask = w32or_all({" & ctrl[ExtExStyle][i] & "})\n"
                attributes &= {textA}
                textA = "lvOk=sendMessage(" & attTableName
                        & "[" & sprint(row) & "]"
                if oneIndex then
                    textA &= ",LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)\n"
                elsif controlCounter=1 then
                    textA &= "[" & sprint(col) & "]" & ",LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)\n"
                else
                    textA &= "[" & sprint(col) & "][" & sprint(index) & "]"
                             & ",LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)\n"
                end if
                attributes &= {textA}
            end if
            at = match("LVM_SETCOLUMNWIDTH", ctrl[ExtExStyle][i])
            if at then
                len = {}
                --find the width; we have three cases -1, -2 and actual length
                at1 = match(" Column ", ctrl[ExtExStyle][i])
                if at1 then
                    len = ctrl[ExtExStyle][i][at+19..at1-1]
                    column = ctrl[ExtExStyle][i][at1+8..length(ctrl[ExtExStyle][i])]
                    at2 = match("OVR", column)
                    if at2 then column = column[1..at2-1] end if
                    Len = value(len)
                    if Len[1]=GET_SUCCESS then
                        Column = value(column)
                        if Column[1]=GET_SUCCESS then
                            if firstLV then
                                textA = "integer lvOk \n"
                                firstLV = w32False
                                attributes &= {textA}
                            end if
                            --ok to write the sendMessage
                            textA = "lvOk=sendMessage(" & attTableName
                                    & "[" & sprint(row) & "]"
                            if oneIndex then
                                textA &= ",LVM_SETCOLUMNWIDTH," & sprint(Column[2]-1)
                                         &"," & sprint(Len[2]) & ")\n"
                            elsif controlCounter=1 then
                                textA &= "[" & sprint(col) & "]" & ",LVM_SETCOLUMNWIDTH,"
                                         & sprint(Column[2]-1)
                                         &"," & sprint(Len[2]) & ")\n"
                            else
                                textA &= "[" & sprint(col) & "][" & sprint(index) & "]"
                                         & ",LVM_SETCOLUMNWIDTH," & sprint(Column[2]-1)
                                         &"," & sprint(Len[2]) & ")\n"
                            end if
                            attributes &= {textA}
                        end if
                    end if
                end if
            end if
            at = match("LVM_SETBKCOLOR", ctrl[ExtExStyle][i])
            if at then
                len = ctrl[ExtExStyle][i][at+15..length(ctrl[ExtExStyle][i])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        textA = "integer lvOk \n"
                        attributes &= {textA}
                        firstLV = w32False
                    end if
                    textA = "lvOk=sendMessage(" & attTableName
                            & "[" & sprint(row) & "]"
                    if oneIndex then
                        textA &= ",LVM_SETBKCOLOR,0," & sprint(Len[2]) & ")\n"
                    elsif controlCounter=1 then
                        textA &= "[" & sprint(col) & "]" & ",LVM_SETBKCOLOR,0," & sprint(Len[2]) & ")\n"
                    else
                        textA &= "[" & sprint(col) & "][" & sprint(index) & "]"
                                 & ",LVM_SETBKCOLOR,0," & sprint(Len[2]) & ")\n"
                    end if
                    attributes &= {textA}
                end if
            end if
            at = match("LVM_SETTEXTBKCOLOR", ctrl[ExtExStyle][i])
            if at then
                len = ctrl[ExtExStyle][i][at+19..length(ctrl[ExtExStyle][i])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        textA = "integer lvOk \n"
                        attributes &= {textA}
                        firstLV = w32False
                    end if
                    textA = "lvOk=sendMessage(" & attTableName
                            & "[" & sprint(row) & "]"
                    if oneIndex then
                        textA &= ",LVM_SETTEXTBKCOLOR,0," & sprint(Len[2]) & ")\n"
                    elsif controlCounter=1 then
                        textA &= "[" & sprint(col) & "]" & ",LVM_SETTEXTBKCOLOR,0," & sprint(Len[2]) & ")\n"
                    else
                        textA &= "[" & sprint(col) & "][" & sprint(index) & "]"
                                 & ",LVM_SETTEXTBKCOLOR,0," & sprint(Len[2]) & ")\n"
                    end if
                    attributes &= {textA}
                end if
            end if
            at = match("LVM_SETTEXTCOLOR", ctrl[ExtExStyle][i])
            if at then
                len = ctrl[ExtExStyle][i][at+17..length(ctrl[ExtExStyle][i])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        textA = "integer lvOk \n"
                        attributes &= {textA}
                        firstLV = w32False
                    end if
                    textA = "lvOk=sendMessage(" & attTableName
                            & "[" & sprint(row) & "]"
                    if oneIndex then
                        textA &= ",LVM_SETTEXTCOLOR,0," & sprint(Len[2]) & ")\n"
                    elsif controlCounter=1 then
                        textA &= "[" & sprint(col) & "]" & ",LVM_SETTEXTCOLOR,0," & sprint(Len[2]) & ")\n"
                    else
                        textA &= "[" & sprint(col) & "][" & sprint(index) & "]"
                                 & ",LVM_SETTEXTCOLOR,0," & sprint(Len[2]) & ")\n"
                    end if
                    attributes &= {textA}
                end if
            end if
        end for
    end if

    if length(ctrl[InitialVal])
    and equal(ctrl[Class], "ListView") then
        --create the lvItems list
        if firstLvItems then
            textA = "sequence IDElvItems\n"
            attributes &= {textA}
            textA = "sequence IDElvData\n"
            attributes &= {textA}
            textA = "integer IDElvItemNo\n"
            attributes &= {textA}
            firstLvItems = w32False
        end if
        textA = "IDElvItems = {}\n"
        attributes &= {textA}
        textA = "IDElvData  = {}\n"
        attributes &= {textA}
        --find the first LVIcon number which was used to generate the image lists
        --above
        if length(ctrl[IcoFile]) then
            listViewCounter -= length(ctrl[IcoFile])
        end if
        --now take icon data and row data and combine
        for i=1 to length(ctrl[InitialVal]) do
            listViewCounter += 1
            cleanSeq = cleanListView(ctrl[InitialVal][i])
            if length(ctrl[IcoFile]) then
                textA = "IDElvData={LVIcon" & sprint(listViewCounter) & "," &
                        cleanSeq & "}\n"
            else
                textA = "IDElvData={0," & cleanSeq & "}\n"
            end if
            attributes &= {textA}
            textA = "IDElvItems &= {IDElvData}\n"
            attributes &= {textA}
        end for
        textA = "for i=1 to length(IDElvItems) do \n"
        attributes &= {textA}
        textA = "    IDElvItemNo = addLVItem( " & attTableName
                & "[" & sprint(row) & "]"
        if oneIndex then
            textA &= ", IDElvItems[i][1], IDElvItems[i][2..length(IDElvItems[i])] )\n"
        elsif controlCounter=1 then
            textA &= "[" & sprint(col) & "]" & ", IDElvItems[i][1], IDElvItems[i][2..length(IDElvItems[i])] )\n"
        else
            textA &= "[" & sprint(col) & "][" & sprint(index) & "]"
                     & ", IDElvItems[i][1], IDElvItems[i][2..length(IDElvItems[i])] )\n"
        end if
        attributes &= {textA}
        textA = "end for\n"
        attributes &= {textA}
    end if
end procedure
-------------------------------------------------------------------------------
--procedure tabulateArrayCharCnt(integer outFile, sequence theLine, integer charCnt)       
--      integer at
--
--      while length(theLine) do
--              if length(theLine) < charCnt then
--                      puts(outFile, theLine & "\n")
--                      lineCount+=1
--                      exit
--              else
--                      --put out characters when find preceeding space or comma
--                      at=charCnt-1
--                      for i=charCnt-1 to 1 by -1 do
--                              if theLine[i] = ' '
--                              or theLine[i] = ',' then
--                                      at=i
--                                      exit
--                              end if                                                  
--                      end for
--                      puts(outFile, theLine[1..at] & "\n")
--                      lineCount+=1
--                      theLine=theLine[at+1..length(theLine)]  
--              end if
--      end while
--end procedure
---------------------------------------------------------------------------------
sequence changeNameToIndex
changeNameToIndex = {}

function textInQuotes(sequence text, integer at, integer matchLength)
integer cnt,back,backpos,s

    if matchLength then end if
    cnt = 0
    back = 0
    backpos = 0
    for i=1 to at do
        if text[i]='\\' then
            back += 1
            backpos = i
        end if
        if text[i]='\"' then
            if back then
                if backpos=i-1 then
                else
                    cnt += 1
                end if
                back = 0
                backpos = 0
            else
                cnt += 1
            end if
        end if
    end for
    if cnt then
        s = remainder(cnt,2)
        if s then
            return w32True
        else
            return w32False
        end if
    else
        return w32False
    end if
end function
--------------------------------------------------------------------------------
function convertToArrayName(sequence text)
integer at, foundAt, hit
sequence newName,tempText

    if not length(changeNameToIndex) then
        return text
    end if

    for i=1 to length(changeNameToIndex) do
        at = match(changeNameToIndex[i][1], text)
        if at then
            --we have a match but there are cases where we still do not want to
            --change the name such as when it is a procedure name or the procedure
            --name in a call_proc statement, in a setHandler statement or in quotes.

            --first compress out spaces in a temporary area
            tempText = text
            hit = 1

            while hit do
                hit = 0

                foundAt = match(" ",tempText)
                if foundAt then
                    --found a space
                    hit = 1
                    tempText = tempText[1..foundAt-1]
                               & tempText[foundAt+1..length(tempText)]
                end if

            end while

            --case look for procedure names
            foundAt = match("call_proc(" & changeNameToIndex[i][1], tempText)
            if foundAt then
                --do nothing
                return text
            else
                foundAt = match("procedure" & changeNameToIndex[i][1], tempText)
                if foundAt then
                    --do nothing
                    return text
                else
                    --case look for procedure name
                    foundAt = match(changeNameToIndex[i][1] & "()", tempText)
                    if foundAt then
                        --do nothing
                        return text
                    else
                        --case look for routine_id name
                        foundAt = match(changeNameToIndex[i][1] & "routine_id=(", tempText)
                        if foundAt then
                            --do nothing
                            return text
                        end if
                        foundAt = match(changeNameToIndex[i][1] & "_", tempText)
                        if foundAt
                        and not match("setHandler",tempText) then
                            --do nothing
                            return text
                        end if
                        --find if text in quotes
                        if length(tempText) then
                            foundAt = match(changeNameToIndex[i][1], tempText)
                            if foundAt>1 then
                                if textInQuotes(tempText,foundAt,length(changeNameToIndex[i][1])) then
                                    --do nothing
                                    return text
                                end if
                            end if
                        end if
                    end if
                end if
            end if

            --continue with changing the name
            newName = changeNameToIndex[i][2] & "[" & sprint(changeNameToIndex[i][3])
                      & "]"

            if changeNameToIndex[i][4] then
                newName &= "[" & sprint(changeNameToIndex[i][4]) & "]"
            end if

            if changeNameToIndex[i][5] then
                newName &= "[" & sprint(changeNameToIndex[i][5]) & "]"
            end if

            text = text[1..at-1] & newName & text[at+length(changeNameToIndex[i][1])..length(text)]

            exit
        end if
    end for

    return text

end function
--------------------------------------------------------------------------------
sequence theConstant
theConstant = "constant"
----------------------------------------------------------------------------------
procedure writeIndexedArray(integer outFile, integer windowNumber)
sequence theLine, ctrls, theControl, indexChange, attCtrls
integer row

    theControl = {}
    indexChange = {"","",0,0,0}
    attributes = {}
    row = 0

    for i=1 to length(indexedArray) do
        if length(indexedArray)=1 then
                --make the start of createEx statement
            ctrls = indexedArray[1][1]
            theControl = ctrls[Name]
            if ctrls[Local] then
                puts(outFile, "global ")
            end if
            if ctrls[Integers] then
                theConstant = ""
                puts(outFile, "integer " & ctrls[Name] & "\n")
                lineCount += 1
            else
                theConstant = "constant "
            end if
            puts(outFile, theConstant & ctrls[Name] & " = \n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrls[Name], "create", lineCount)
            theLine = ""

        elsif i=1 then
            --make the start of createEx statement
            ctrls = indexedArray[i][1]
            theControl = ctrls[Name]
            if ctrls[Local] then
                puts(outFile, "global ")
            end if
            if ctrls[Integers] then
                theConstant = ""
                puts(outFile, "integer " & ctrls[Name] & "\n")
                lineCount += 1
            else
                theConstant = "constant "
            end if
            puts(outFile, theConstant & ctrls[Name] & " = {\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrls[Name], "create", lineCount)
            theLine = ""
        else
            theLine = ","
        end if
        --save the correlation of Name and indexing for
        --changing in coding statements
        attCtrls = indexedArray[i][1]
        row += 1
        oneIndex = w32True
        priorFontName = {}
        indexChange[1] = attCtrls[Name]
        indexChange[2] = theControl
        indexChange[3] = row
        indexChange[4] = 0
        indexChange[5] = 0
        changeNameToIndex &= {indexChange}

        --pass parent past name change test
        indexedArray[i][3] = convertToArrayName(indexedArray[i][3])

        if match("var:",indexedArray[i][2]) then
            indexedArray[i][2] = indexedArray[i][2][5..length(indexedArray[i][2])]
            indexedArray[i][2] = trimL(indexedArray[i][2])
            theLine &= sprintf(
                "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                {ctrls[Class],indexedArray[i][2],indexedArray[i][3],indexedArray[i][4],
                 indexedArray[i][5],indexedArray[i][6],indexedArray[i][7],
                 indexedArray[i][8],indexedArray[i][9]})
        else
            theLine &= sprintf(
                "createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                {ctrls[Class],indexedArray[i][2],indexedArray[i][3],indexedArray[i][4],
                 indexedArray[i][5],indexedArray[i][6],indexedArray[i][7],
                 indexedArray[i][8],indexedArray[i][9]})
        end if
        puts(outFile,theLine & "\n")
        lineCount += 1

        makeNameEventLine(windowNumber, theControl , "create", lineCount)

        doAttributesNow(attCtrls,row,0,0)

    end for
    if length(indexedArray)=1 then
        puts(outFile, "\n")
    else
        puts(outFile, "}\n")
    end if
    lineCount += 1

    --now write out the attributes array
    for i=1 to length(attributes) do
        puts(outFile, attributes[i])
        lineCount += 1
        makeNameEventLine(windowNumber, theControl, "create", lineCount)
    end for

    -- sort the change name array so deal with long names first
    -- so will not get a match when the shorter name is a portion of the longer
    changeNameToIndex = sort(changeNameToIndex)
    changeNameToIndex = reverse(changeNameToIndex)
    for j=1 to length(buddyListArray) do
        --now add the buddy associations
        lineCount += 1
        theLine = "setBuddy( " & buddyListArray[j][1] & ", "
                  & buddyListArray[j][2] & " )\n"
        theLine = convertToArrayName(theLine)
        --do conversion again since two names in line affected
        theLine = convertToArrayName(theLine)
        puts(outFile, theLine)
        lineCount += 1
    end for
    buddyListArray = {}

end procedure
----------------------------------------------------------------------------------
procedure makeTableArray(integer outFile, integer windowNumber, integer priorLocal,
                        integer priorInteger)

sequence ctrl, theLine
integer cnt, row, col, index, rowCounter
sequence indexChange

    indexChange = {"","",0,0,0}

    attributes = {}

    --first make the create statement

    if not priorLocal then
        puts(outFile, "global ")
    end if

    if priorInteger then
        theConstant = ""
        puts(outFile, "integer " & priorTableName & "Array \n")
        lineCount += 1
    else
        theConstant = "constant "
    end if

    puts(outFile, theConstant & priorTableName & "Array" & " = {\n")
    lineCount += 1

    makeNameEventLine(windowNumber, priorTableName, "create", lineCount)

    --make multi-dimensional array regardless
    oneIndex = w32False

    if length(tables)/priorCols=1
    or length(tables)/priorRows=1 then
        row = 0
        --flag that one dimension for setting attributes below
        oneIndex = w32True

        --only 1 control per cell and one dimension
        for i=1 to length(tables)-1 do
            ctrl = tables[i][1]
            theLine = ""
            if i>1
            and oneIndex then
                theLine = ","
            end if
            --see if line is too long
            if length(tables[i][9]) then
                if equal(ctrl[Class], "ListView") then
                    if match("var:",tables[i][2]) then
                        tables[i][2] = tables[i][2][5..length(tables[i][2])]
                        tables[i][2] = trimL(tables[i][2])
                        theLine &= sprintf(
                        "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         tables[i][9]})
                    else
                        theLine &= sprintf(
                        "createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s )",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         tables[i][9]})
                    end if
                else
                    if match("var:",tables[i][2]) then
                        tables[i][2] = tables[i][2][5..length(tables[i][2])]
                        tables[i][2] = trimL(tables[i][2])
                        theLine &= sprintf(
                        "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         tables[i][9]})
                    else
                        theLine &= sprintf(
                        "createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         tables[i][9]})
                    end if
                end if
            else
                if equal(ctrl[Class], "ListView") then
                    if match("var:",tables[i][2]) then
                        tables[i][2] = tables[i][2][5..length(tables[i][2])]
                        tables[i][2] = trimL(tables[i][2])
                        theLine &= sprintf(
                        "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s)",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         "0"})
                    else
                        theLine &= sprintf(
                        "createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s)",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         "0"})
                    end if
                else
                    if match("var:",tables[i][2]) then
                        tables[i][2] = tables[i][2][5..length(tables[i][2])]
                        tables[i][2] = trimL(tables[i][2])
                        theLine &= sprintf(
                        "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s)",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         "0"})
                    else
                        theLine &= sprintf(
                        "createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                        {ctrl[Class],tables[i][2],tables[i][3],tables[i][4],
                         tables[i][5],tables[i][6],tables[i][7],tables[i][8],
                         "0"})
                    end if
                end if
            end if

            puts(outFile,theLine & "\n")
            lineCount += 1

            makeNameEventLine(windowNumber, priorTableName, "create", lineCount)

            row += 1
            doAttributesNow(tables[i][1],row,1,1)

            --save the correlation of Name and indexing for
            --changing in coding statements
            indexChange[1] = tables[i][1][Name]
            indexChange[2] = priorTableName&"Array"
            indexChange[3] = row
            indexChange[4] = 0
            indexChange[5] = 0
            changeNameToIndex &= {indexChange}

        end for
        ctrl = tables[length(tables)][1]
        --see if line is too long
        if oneIndex then
            theLine = ","
        end if
        if length(tables[length(tables)][9]) then
            if equal(ctrl[Class], "ListView") then
                if match("var",tables[length(tables)][2]) then
                    tables[length(tables)][2] = tables[length(tables)][2][5..length(tables[length(tables)][2])]
                    tables[length(tables)][2] = trimL(tables[length(tables)][2])
                    theLine &= sprintf(
                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],
                     tables[length(tables)][9]})
                else
                    theLine &= sprintf(
                    "createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],
                     tables[length(tables)][9]})
                end if
            else
                if match("var",tables[length(tables)][2]) then
                    tables[length(tables)][2] = tables[length(tables)][2][5..length(tables[length(tables)][2])]
                    tables[length(tables)][2] = trimL(tables[length(tables)][2])
                    theLine &= sprintf(
                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],
                     tables[length(tables)][9]})
                else
                    theLine &= sprintf(
                    "createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],
                     tables[length(tables)][9]})
                end if
            end if
        else
            if equal(ctrl[Class], "ListView") then
                if match("var",tables[length(tables)][2]) then
                    tables[length(tables)][2] = tables[length(tables)][2][5..length(tables[length(tables)][2])]
                    tables[length(tables)][2] = trimL(tables[length(tables)][2])
                    theLine &= sprintf(
                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],"0"})
                else
                    theLine &= sprintf(
                    "createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],"0"})
                end if
            else
                if match("var",tables[length(tables)][2]) then
                    tables[length(tables)][2] = tables[length(tables)][2][5..length(tables[length(tables)][2])]
                    tables[length(tables)][2] = trimL(tables[length(tables)][2])
                    theLine &= sprintf(
                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],"0"})
                else
                    theLine &= sprintf(
                    "create( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                    {ctrl[Class],tables[length(tables)][2],tables[length(tables)][3],
                     tables[length(tables)][4],
                     tables[length(tables)][5],tables[length(tables)][6],
                     tables[length(tables)][7],tables[length(tables)][8],"0"})
                end if
            end if
        end if

        puts(outFile,theLine & "\n")
        lineCount += 1
        row += 1

        makeNameEventLine(windowNumber, priorTableName, "create", lineCount)
        puts(outFile, "}\n")
        lineCount += 1

        doAttributesNow(tables[length(tables)][1],row,1,1)

        --save the correlation of Name and indexing for
        --changing in coding statements
        indexChange[1] = tables[length(tables)][1][Name]
        indexChange[2] = priorTableName&"Array"
        indexChange[3] = row
        indexChange[4] = 0
        indexChange[5] = 0
        changeNameToIndex &= {indexChange}

    else
        rowCounter = 0
        controlCounter = floor(length(tables)/priorColRow)
        if remainder(floor(length(tables)),priorColRow) then
            controlCounter += 1
        end if
        cnt = 0 --the control we are adding for the cell
        col = 0
        index = 0
        row = 1

        --put out starting bracket for row
        puts(outFile, "{")

        --put out starting bracket for cell
        if controlCounter>1 then
            puts(outFile,"{")
        end if

        for i=1 to priorColRow do
            for j=1 to length(tables) do
                ctrl = tables[j][1]

                if ctrl[TableCell]=i then
                    --have a control for the cell
                    cnt += 1

                    if ctrl[TableCell]>priorCols then
                        col = ctrl[TableCell]-(priorCols*rowCounter)
                    else
                        col = ctrl[TableCell]
                    end if

                    index = cnt

                    --if multiple controls for cell then need to bracket them
                    if cnt<controlCounter then
                        if cnt!=1 then
                            --put out control seperator
                            puts(outFile, ",")
                        end if
                        --see if line is too long
                        if length(tables[j][9]) then
                            if equal(ctrl[Class], "ListView") then
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[j][2])
                                    theLine = sprintf(
                                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                else
                                    theLine = sprintf(
                                    "createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                end if
                            else
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[j][2])
                                    theLine = sprintf(
                                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                else
                                    theLine = sprintf(
                                    "createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                end if
                            end if
                        else
                            if equal(ctrl[Class], "ListView") then
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[j][2])
                                    theLine = sprintf(
                                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                else
                                    theLine = sprintf(
                                    "createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                end if
                            else
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[j][2])
                                    theLine = sprintf(
                                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                else
                                    theLine = sprintf(
                                    "createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                end if
                            end if
                        end if
                        puts(outFile,theLine & "\n")
                        lineCount += 1

                        makeNameEventLine(windowNumber, priorTableName,
                                          "create", lineCount)

                    elsif cnt=controlCounter then
                        --end of cell and all controls in it
                        if (i=1 or ctrl[TableCell]=(priorCols*rowCounter)+1)
                        and controlCounter=1 then
                        else
                            puts(outFile, ",")
                        end if
                        --see if line is too long
                        if length(tables[j][9]) then
                            if equal(ctrl[Class], "ListView") then
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[i][2])
                                    theLine = sprintf(
                                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                else
                                    theLine = sprintf(
                                    "createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                end if
                            else
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[i][2])
                                    theLine = sprintf(
                                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                else
                                    theLine = sprintf(
                                    "createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],
                                     tables[j][9]})
                                end if
                            end if
                        else
                            if equal(ctrl[Class], "ListView") then
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[i][2])
                                    theLine = sprintf(
                                    "createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                else
                                    theLine = sprintf(
                                    "create( %s, {%s}, %s, %s, %s, %s, %s, %s, %s)",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                end if
                            else
                                if match("var:",tables[j][2]) then
                                    tables[j][2] = tables[j][2][5..length(tables[j][2])]
                                    tables[j][2] = trimL(tables[j][2])
                                    theLine = sprintf(
                                    "create( %s, %s, %s, %s, %s, %s, %s, %s, %s)",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                else
                                    theLine = sprintf(
                                    "create( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s)",
                                    {ctrl[Class],tables[j][2],tables[j][3],tables[j][4],
                                     tables[j][5],tables[j][6],tables[j][7],tables[j][8],"0"})
                                end if
                            end if
                        end if

                        puts(outFile,theLine & "\n")
                        lineCount += 1

                        if controlCounter>1 then
                            puts(outFile, "}")
                        end if

                        --is this the last cell in row?
                        if not remainder(ctrl[TableCell],priorCols)
                        or ctrl[TableCell]=priorColRow then

                            --is this the last row
                            rowCounter += 1
                            if rowCounter!=priorRows then
                                --put out row bracket and comma for next row
                                puts(outFile, "},\n")
                                lineCount += 1

                                makeNameEventLine(windowNumber,
                                                  priorTableName, "create", lineCount)


                                if controlCounter>1 then
                                    puts(outFile, "{{")
                                else
                                    puts(outFile, "{")
                                end if

                            else
                                puts(outFile,"}")
                            end if

                        else
                            if controlCounter>1 then
                                puts(outFile, ",{")
                            end if
                        end if

                        puts(outFile, "\n")
                        lineCount += 1

                        --reset cnt for next cell
                        cnt = 0

                    end if

                end if

                if ctrl[TableCell]=i then
                    row = rowCounter+1
                    if col=priorCols
                    and index=controlCounter then
                        row -= 1
                    end if

                    doAttributesNow(tables[j][1], row, col, index)

                    --save the correlation of Name and indexing for
                    --changing in coding statements
                    indexChange[1] = tables[j][1][Name]
                    indexChange[2] = priorTableName&"Array"
                    indexChange[3] = row
                    indexChange[4] = col
                    indexChange[5] = index
                    if controlCounter=1 then
                        indexChange[5] = 0
                    end if
                    changeNameToIndex &= {indexChange}
                end if
            end for
        end for

        puts(outFile,"\n}\n")
        lineCount += 2
    end if

    --now write out the attributes array
    for i=1 to length(attributes) do
        puts(outFile, attributes[i])
        lineCount += 1
        makeNameEventLine(windowNumber, priorTableName, "create", lineCount)
    end for

    -- sort the change name array so deal with long names first
    -- so will not get a match when the shorter name is a portion of the longer
    changeNameToIndex = sort(changeNameToIndex)
    changeNameToIndex = reverse(changeNameToIndex)
    for j=1 to length(buddyListArray) do
        --now add the buddy associations
        theLine = "setBuddy( " & buddyListArray[j][1] & ", "
                  & buddyListArray[j][2] & " )\n"
        theLine = convertToArrayName(theLine)
        --do conversion again since two names in line affected
        theLine = convertToArrayName(theLine)
        puts(outFile, theLine)
        lineCount += 1
    end for
    buddyListArray = {}

end procedure
------------------------------------------------------------------------------
integer hintFound, hintFontFound
    hintFound = w32False
    hintFontFound = w32False

integer usedOk, usedTree
usedOk = w32False
usedTree = w32False


integer charCnt
charCnt = 0
-------------------------------------------------------------------------------
procedure DoTheAttrib(integer i,integer controlCount, sequence attTableName,
                                        integer col, integer row, integer outFile)
sequence testStyle, saveName, examDocs, cleanSeq, len, Len, Column, column,
         testIco, newIco, hinttext, testname, testpts, replaceClass
integer at, at1, at2

    --write the special file stuff like setVisible, setEnable, etc
    if not ncontrols[i][Visible] then
        puts(outFile, "setVisible( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "], w32False )  \n")
        lineCount += 1
    end if

    if not ncontrols[i][EnableC] then
        puts(outFile,"setEnable( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "], w32False ) \n")
        lineCount += 1
    end if

    if ncontrols[i][Limit] then
        puts(outFile, "LimitText( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
             & sprint(ncontrols[i][Limit]) & ")\n")
        lineCount += 1
    end if

    if ncontrols[i][TxtColor] then
        puts(outFile, "setTextColor( "& attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
             & sprint(ncontrols[i][TxtColor]) & ")\n")
        lineCount += 1
        if not ncontrols[i][BkColor] then
            if find(ncontrols[i][Class], {"EditText","List"}) then
                puts(outFile, "setWindowBackColor( "& attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "], " & sprint(WindowColor) & " )\n")
            else
                puts(outFile, "repaintFG( "& attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "] )\n")
            end if
            lineCount += 1
        end if
    end if

    if ncontrols[i][BkColor]
    and not find(ncontrols[i][Class],{"EuGrid","ProgressBar"})
    and not equal(ncontrols[i][SeqParentClass],"EuGrid")
    and ncontrols[i][BkColor]!=getSysColor(COLOR_BTNFACE) then
        puts(outFile,"setWindowBackColor( "& attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
             & sprint(ncontrols[i][BkColor]) & ")\n")
        lineCount += 1
    elsif ncontrols[i][BkColor]
      and equal(ncontrols[i][Class],"ProgressBar")
      and ncontrols[i][BkColor]!=getSysColor(COLOR_BTNFACE) then
        puts(outFile,"VOID = sendMessage( "& attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
             & "#2001,0,"
             & sprint(ncontrols[i][BkColor]) & ")\n")
        lineCount += 1
        if ncontrols[i][BkBarColor] then
            puts(outFile,"VOID = sendMessage( "& attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
                 & "#0409,0,"
                 & sprint(ncontrols[i][BkBarColor]) & ")\n")
            lineCount += 1
        end if
    end if

    if ncontrols[i][PB_Caption_Pos] then
        puts(outFile, "removeStyle( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
             & " BS_CENTER )\n")
        if ncontrols[i][PB_Caption_Pos]=1 then
            puts(outFile, "addStyle( " & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
                 & " BS_LEFT )\n")
        else
            puts(outFile, "addStyle( " & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
                 & " BS_RIGHT )\n")
        end if
        lineCount += 2
    end if

    if length(ncontrols[i][InitialVal])
    and not equal(ncontrols[i][Class], "ListView") then
        for j=1 to length(ncontrols[i][InitialVal]) do
            puts(outFile, "addItem( " & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "], \""
                 & ncontrols[i][InitialVal][j] & "\")\n")
            lineCount += 1
        end for
    end if

    if ncontrols[i][MinValue]
    or ncontrols[i][MaxValue] then
        puts(outFile, "setScrollRange( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "], "
             & sprint(ncontrols[i][MinValue]) & ", " & sprint(ncontrols[i][MaxValue])
             & ")\n")
        lineCount += 1
    end if

    if ncontrols[i][LineChg]
    or ncontrols[i][PageChg] then
        puts(outFile,"setScrollChange( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "], "
             & sprint(ncontrols[i][LineChg]) & ", " & sprint(ncontrols[i][PageChg])
             & ")\n")
        lineCount += 1
    end if

    if equal(ncontrols[i][Class], "UpDown") then
        if not length(ncontrols[i][Buddy]) then
            --user did not supply a buddy name, so user placed the buddy
            --control where he wanted it or added setBuddy() in General event
        else
            --save the buddy name for later
            buddyDataArray[1] = ncontrols[i][Name]
            buddyDataArray[2] = ncontrols[i][Buddy]
            buddyListArray &= {buddyDataArray}
        end if
    end if

    --if Table was assigned a font, it applies to all the cells in it
    if length(priorFontName)
    and not length(ncontrols[i][FontName])
    and not length(ncontrols[i][FontVarName]) then
        puts(outFile,"setFont( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "],"
             & priorFontName & ","
             & priorFontPts & "," & priorFontAttrib & ")\n")
        lineCount += 1
    end if
    --but can be overridden by the font on the particular cell
    if length(ncontrols[i][FontName])
    or length(ncontrols[i][FontVarName]) then
        testStyle = "Normal"
        if ncontrols[i][FontAttrib]
        or length(ncontrols[i][FontVarItalic]) then
            testStyle = "Italic"
        end if
        if ncontrols[i][FontBold]
        or length(ncontrols[i][FontVarBold]) then
            testStyle &= "+Bold"
        end if
        if ncontrols[i][FontUnderline]
        or length(ncontrols[i][FontVarUnderline]) then
            testStyle &= "+Underline"
        end if
        if ncontrols[i][FontStrikeout]
        or length(ncontrols[i][FontVarStrikeout]) then
            testStyle &= "+Strikeout"
        end if

        if length(ncontrols[i][FontName]) then
            testname = "\"" & ncontrols[i][FontName] & "\""
        elsif length(ncontrols[i][FontVarName]) then
            testname = ncontrols[i][FontVarName]
        end if

        if ncontrols[i][FontPts] then
            testpts = sprint(ncontrols[i][FontPts])
        elsif length(ncontrols[i][FontVarPts]) then
            testpts = ncontrols[i][FontVarPts]
        end if

        puts(outFile,"setFont( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "]"
             & "," & testname & ","
             & testpts & "," & testStyle & ")\n")
        lineCount += 1
    end if

    if length(ncontrols[i][HintText])
    or length(ncontrols[i][HintVarText]) then
        puts(outFile, "setHint( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "]")
        if match("var:",ncontrols[i][HintText]) then
            hinttext = ncontrols[i][HintText]
            hinttext = hinttext[5..length(hinttext)]
            hinttext = trimL(hinttext)
            puts(outFile, "," & hinttext & ")\n")
        else
            if length(ncontrols[i][HintVarText]) then
                puts(outFile, "," & ncontrols[i][HintVarText] & ")\n")
            else
                puts(outFile, ",\"" & ncontrols[i][HintText] & "\")\n")
            end if
        end if
        lineCount += 1
    end if

    if ncontrols[i][TreatAsColorButton] then
        puts(outFile,"translateToColoredButton(" & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "]")
        puts(outFile, "," & "{}" & "," & "{}" & ")\n")
        puts(outFile,"initiateColoredButtons()\n")
        lineCount += 2


        if ncontrols[i][cbMultiline] then
            puts(outFile, "multilineCBCaption(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", w32True)\n")
            lineCount += 1
        end if

        if ncontrols[i][cbFlat] then
            replaceClass = "FlatButton"
            puts(outFile, "changeCBClass(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", " & "\"" & replaceClass & "\")\n")
            lineCount += 1
        end if

        if ncontrols[i][cbCentVert] then
            puts(outFile, "centerVerticallyCBText(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & " , w32True)\n")
            lineCount += 1
        else
            puts(outFile, "centerVerticallyCBText(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & " , w32False)\n")
            lineCount += 1
        end if

        if not ncontrols[i][cbColor] then
            puts(outFile, "changeCBColor(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 1, " & sprint(getSysColor(COLOR_BTNFACE)) & ")\n")
        else
            puts(outFile, "changeCBColor(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 1, " & sprint(ncontrols[i][cbColor]) & ")\n")
        end if
        lineCount += 1

        if ncontrols[i][cbPressColor] then
            puts(outFile, "changeCBColor(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 2, " & sprint(ncontrols[i][cbPressColor]) & ")\n")
            lineCount += 1
        end if

        if ncontrols[i][cbCaptionColor] then
            puts(outFile, "changeCBTextColor(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 1, " & sprint(ncontrols[i][cbCaptionColor]) & ")\n")
            lineCount += 1
        end if

        if ncontrols[i][cbPressCaptionColor] then
            puts(outFile, "changeCBTextColor(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 2, " & sprint(ncontrols[i][cbPressCaptionColor]) & ")\n")
            lineCount += 1
        end if

        if ncontrols[i][cbThickness] then
            puts(outFile, "changeBorderThickness(" & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", " & sprint(ncontrols[i][cbThickness]) & ")\n")
            lineCount += 1
        end if

        if ncontrols[i][cbGraphicPos] then
            if ncontrols[i][cbGraphicPos]=1 then
                puts(outFile, "moveCBGraphic(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 1)\n")
            elsif ncontrols[i][cbGraphicPos]=2 then
                puts(outFile, "moveCBGraphic(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 0)\n")
            elsif ncontrols[i][cbGraphicPos]=3 then
                puts(outFile, "moveCBGraphic(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 2)\n")
            end if
            lineCount += 1
        end if

        if ncontrols[i][cbCaptionPos] then
            if ncontrols[i][cbCaptionPos]=1 then
                puts(outFile, "moveCBCaption(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 1)\n")
            elsif ncontrols[i][cbCaptionPos]=2 then
                puts(outFile, "moveCBCaption(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 0)\n")
            elsif ncontrols[i][cbCaptionPos]=3 then
                puts(outFile, "moveCBCaption(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 2)\n")
            elsif ncontrols[i][cbCaptionPos]=4 then
                puts(outFile, "moveCBCaption(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCount) & "]" & ", 3)\n")
            end if
            lineCount += 1
        end if
    end if

    if length(ncontrols[i][IcoFile])
    and not equal(ncontrols[i][Class], "ListView") then
        saveName = {}
        examDocs = ncontrols[i][IcoFile]
        at = match(lower(projectDir), lower(examDocs))
        if at then
            examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
        end if
        at = 1
        while at do
            at = 0
            for k=1 to length(examDocs) do
                if examDocs[k]='\\' then
                    saveName &= examDocs[1..k-1] & "\\\\"
                    examDocs = examDocs[k+1..length(examDocs)]
                    at = 1
                    exit
                end if
            end for
        end while
        saveName &= examDocs
        puts(outFile, "setIcon( " & attTableName & "[" & sprint(col) & "]"
             & "[" & sprint(row) & "][" & sprint(controlCount) & "]"
             & ",\"" & saveName & "\")\n")
        lineCount += 1
    end if

    if length(ncontrols[i][BitmapFile]) then
        saveName = {}
        examDocs = ncontrols[i][BitmapFile]
        at = match(lower(projectDir), lower(examDocs))
        if at then
            examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
        end if
        at = 1
        while at do
            at = 0
            for k=1 to length(examDocs) do
                if examDocs[k]='\\' then
                    saveName &= examDocs[1..k-1] & "\\\\"
                    examDocs = examDocs[k+1..length(examDocs)]
                    at = 1
                    exit
                end if
            end for
        end while
        saveName &= examDocs
        if equal(ncontrols[i][Class], "Pixmap") then
            puts(outFile, "setPixmap( " & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]"
                 & "[" & sprint(row) & "]"
                 & "\"" & saveName & "\")\n")
        else
            puts(outFile, "setBitmap( " & attTableName & "[" & sprint(col) & "]"
                 & "[" & sprint(row) & "][" & sprint(controlCount) & "]"
                 & "[" & sprint(row) & "]"
                 & "\"" & saveName & "\")\n")
        end if
        lineCount += 1
    end if
    if equal(ncontrols[i][Class], "ListView") then
        if length(ncontrols[i][IcoFile]) then
            --in ListView the IcoFile is a sequence of icons
            for j=1 to length(ncontrols[i][IcoFile]) do
                listViewCounter += 1
                testIco = ncontrols[i][IcoFile][j]
                at = match(lower(projectDir),lower(testIco))
                if at then
--                  testIco=testIco[at+1+projectDir..length(testIco)]
                    testIco = testIco[at+1+length(projectDir)..length(testIco)]
                end if
                at = match("\\", testIco)
                if at then
                    newIco = testIco[1..at] & "\\"
                    testIco = testIco[at+1..length(testIco)]
                    while at do
                        at = match("\\", testIco)
                        if at then
                            newIco &= testIco[1..at] & "\\"
                            testIco = testIco[at+1..length(testIco)]
                        else
                            newIco &= testIco[1..length(testIco)]
                        end if
                    end while
                else
                    newIco &= testIco[1..length(testIco)]
                end if

                puts(outFile, "constant LVIcon" & sprint(listViewCounter) & " = addIcon(extractIcon(\""
                     & newIco & "\") ) \n")
                lineCount += 1
            end for
        end if
    end if

    if length(ncontrols[i][ExtExStyle]) then
        --ListView sendMessages
        for j=1 to length(ncontrols[i][ExtExStyle]) do
            if find(ncontrols[i][ExtExStyle][j],{"LVS_EX_UNDERLINECOLD","LVS_EX_UNDERLINEHOT",
                                                 "LVS_EX_TRACKSELECT","LVS_EX_TWOCLICKACTIVATE",
                                                 "LVS_EX_ONECLICKACTIVATE","LVS_EX_FLATSB",
                                                 "LVS_EX_FULLROWSELECT","LVS_EX_HEADERDRAGDROP",
                                                 "LVS_EX_CHECKBOXES","LVS_EX_GRIDLINES"}) then
                if firstLV then
                    puts(outFile,"atom lvMask \n")
                    puts(outFile,"integer lvOk \n")
                    lineCount += 2
                    firstLV = w32False
                end if
                puts(outFile,"lvMask = w32or_all({" & ncontrols[i][ExtExStyle][j] & "})\n")
                puts(outFile,"lvOk=sendMessage(" & attTableName & "[" & sprint(col) & "]"
                     & "[" & sprint(row) & "][" & sprint(controlCounter) & "]"
                     & ",LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)\n")
                lineCount += 2
            end if
            at = match("LVM_SETCOLUMNWIDTH", ncontrols[i][ExtExStyle][j])
            if at then
                len = {}
                --find the width; we have three cases -1, -2 and actual length
                at1 = match(" Column ", ncontrols[i][ExtExStyle][j])
                if at1 then
                    len = ncontrols[i][ExtExStyle][j][at+19..at1-1]
                    column = ncontrols[i][ExtExStyle][j][at1+8..length(ncontrols[i][ExtExStyle][j])]
                    at2 = match("OVR", column)
                    if at2 then column = column[1..at2-1] end if
                    Len = value(len)
                    if Len[1]=GET_SUCCESS then
                        Column = value(column)
                        if Column[1]=GET_SUCCESS then
                            if firstLV then
                                puts(outFile,"integer lvOk \n")
                                firstLV = w32False
                                lineCount += 1
                            end if
                            --ok to write the sendMessage
                            puts(outFile, "lvOk=sendMessage(" & attTableName
                                 & "[" & sprint(col) & "][" & sprint(row) & "]"
                                 & "[" & sprint(controlCounter) & "]"
                                 & ",LVM_SETCOLUMNWIDTH," & sprint(Column[2]-1)
                                 &"," & sprint(Len[2]) & ")\n")
                            lineCount += 1
                        end if
                    end if
                end if
            end if
            at = match("LVM_SETBKCOLOR",ncontrols[i][ExtExStyle][j])
            if at then
                len = ncontrols[i][ExtExStyle][j][at+15..length(ncontrols[i][ExtExStyle][j])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        puts(outFile,"integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile,"lvOk=sendMessage(" & attTableName & "[" & sprint(col) & "]"
                         & "[" & sprint(row) & "][" & sprint(controlCount) & "]"
                         & ",LVM_SETBKCOLOR,0," & sprint(Len[2]) & ")\n")
                    lineCount += 1
                end if
            end if
            at = match("LVM_SETTEXTBKCOLOR", ncontrols[i][ExtExStyle][j])
            if at then
                len = ncontrols[i][ExtExStyle][j][at+19..length(ncontrols[i][ExtExStyle][j])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        puts(outFile,"integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile,"lvOk=sendMessage(" & attTableName & "[" & sprint(col) & "]"
                         & "[" & sprint(row) & "][" & sprint(controlCount) & "]"
                         & ",LVM_SETTEXTBKCOLOR,0," & sprint(Len[2]) & ")\n")
                    lineCount += 1
                end if
            end if
            at = match("LVM_SETTEXTCOLOR", ncontrols[i][ExtExStyle][j])
            if at then
                len = ncontrols[i][ExtExStyle][j][at+17..length(ncontrols[i][ExtExStyle][j])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        puts(outFile,"integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile,"lvOk=sendMessage(" & attTableName & "[" & sprint(col) & "]"
                         & "[" & sprint(row) & "][" & sprint(controlCount) & "]"
                         & ",LVM_SETTEXTCOLOR,0," & sprint(Len[2]) & ")\n")
                    lineCount += 1
                end if
            end if
        end for
    end if

    if length(ncontrols[i][InitialVal])
    and equal(ncontrols[i][Class], "ListView") then
        --create the lvItems list
        if firstLvItems then
            puts(outFile, "sequence IDElvItems\n")
            puts(outFile, "sequence IDElvData\n")
            puts(outFile, "integer IDElvItemNo\n")
            lineCount += 3
            firstLvItems = w32False
        end if
        puts(outFile,"IDElvItems = {}\n")
        puts(outFile,"IDElvData  = {}\n")
        lineCount += 2
        --find the first LVIcon number which was used to generate the image lists
        --above
        if length(ncontrols[i][IcoFile]) then
            listViewCounter -= length(ncontrols[i][IcoFile])
        end if
        --now take icon data and row data and combine
        for j=1 to length(ncontrols[i][InitialVal]) do
            listViewCounter += 1
            cleanSeq = cleanListView(ncontrols[i][InitialVal][j])
            if length(ncontrols[i][IcoFile]) then
                puts(outFile,"IDElvData={LVIcon" & sprint(listViewCounter) & "," &
                     cleanSeq & "}\n")
            else
                puts(outFile,"IDElvData={0," & cleanSeq & "}\n")
            end if
            lineCount += 1
            puts(outFile,"IDElvItems &= {IDElvData}\n")
            lineCount += 1
        end for
        puts(outFile,"for i=1 to length(IDElvItems) do \n")
        lineCount += 1
        puts(outFile,"    IDElvItemNo = addLVItem( " & attTableName
             & "[" & sprint(col) & "][" & sprint(row) & "][" & sprint(controlCount) & "]"
             & ", IDElvItems[i][1], IDElvItems[i][2..length(IDElvItems[i])] )\n")

        puts(outFile,"end for\n")
        lineCount += 2
    end if
end procedure
--------------------------------------------------------------------------------
procedure genInExwAttributes(integer index, integer NControls, integer tableRows, integer tableCols,
                        integer outFile, sequence attTableName)
integer controlCount,row,col,cell
sequence indexChange

    if tableRows then end if

    controlCount = NControls
    row = 1
    col = 1
    cell = 1
    indexChange = {"","",0,0,0}

    for i=index to length(ncontrols) do
        if ncontrols[i][TableCell] then
            --figure which row and col we are on
            if ncontrols[i][TableCell]=1 then
                if ncontrols[i][TableCell]=cell then
                    row = 1
                    col = 1
                    cell = 2    --the next cell to look for
                    --save the correlation of Name and indexing for
                        --changing in coding statements
                    indexChange[1] = ncontrols[i][Name]
                    indexChange[2] = attTableName
                    indexChange[3] = col
                    indexChange[4] = row
                    indexChange[5] = controlCount
                    changeNameToIndex &= {indexChange}
                    DoTheAttrib(i,controlCount,attTableName,col, row, outFile)
                end if
            else
                if ncontrols[i][TableCell]=cell then
                    cell += 1
                    col += 1
                    if tableCols<col then
                        row += 1
                        col = 1
                    end if

                    --save the correlation of Name and indexing for
                        --changing in coding statements
                    indexChange[1] = ncontrols[i][Name]
                    indexChange[2] = attTableName
                    indexChange[3] = col
                    indexChange[4] = row
                    indexChange[5] = controlCount
                    changeNameToIndex &= {indexChange}
                    DoTheAttrib(i,controlCount,attTableName,col, row, outFile)
                end if
            end if
        end if
    end for

    for j=1 to length(buddyListArray) do
        --now add the buddy associations        
        puts(outFile,"setBuddy( " & buddyListArray[j][1] & ", "
             & buddyListArray[j][2] & " )\n")
        lineCount += 1
    end for
    buddyListArray = {}
end procedure
--------------------------------------------------------------------------------
function replaceComma(sequence combineStyle)
integer at
    while w32True do
        at = match(",",combineStyle)
        if at then
            combineStyle = combineStyle[1..at-1] & "+" & combineStyle[at+1..length(combineStyle)]
        else
            exit
        end if
    end while

    return combineStyle
end function
--------------------------------------------------------------------------------
sequence buddyData, buddyList
    buddyList = {}
    buddyData = {"",""}

integer IconUsed
IconUsed = w32False

integer TimerCounter
TimerCounter = 1999

integer hadTable            hadTable = w32False
integer scrollTableCnt      scrollTableCnt = 0
sequence scrollTableName    scrollTableName = {}
sequence associatedTable    associatedTable = {}
sequence tableParent        tableParent = {}
atom tableId                tableId = 0
integer WinPosDef           WinPosDef = w32False
integer WinPosTaskBarDef        WinPosTaskBarDef = w32False
integer usedIDEFlags        usedIDEFlags = w32False
integer usedGenInExw            usedGenInExw = w32False
integer offset,tableGenInExw,tableGenBorder,addOffset
sequence hintarray                      hintarray = {}
sequence disableArray           disableArray = {}
offset = 0
tableGenInExw = 0
tableGenBorder = 0
addOffset = 0
-----------------------------------------------------------------------------
procedure writeControlToExw(integer outFile, sequence ctrl,
                                    integer windowNumber, integer id)

-- generate the definition of a control
sequence title, x, y, cx, cy, style, parent, combineStyle, parentClass,
            saveName, examDocs, hintFontStyle, fontStyle, theLine, rebarParent,
            exStyle, len, Len, column, Column, testIco, newIco, cleanSeq, thecolor,
            comment, tableStyle, olddir, theLineD
integer at, at1, at2, childWindow, haveTitleBar, marginX, marginY, width, height,
            foundIt, skipThis,childCnt,usedCCWinStyle,tx1,tx2,ty1,ty2,Ky,Kx,Bx,By,parentX,
            parentY,Ny,Nx,NControls,offsetX,offsetY,tcx1,tcy1,flag, row, col, cell, controlNo,
            adjustYby, adjustXby
object testStyle, testHintStyle, exists
sequence folders, newDir, typeControl, graphicName
sequence what,rowIndex,colIndex,controlIndex,holdcontrols
sequence indextable, gridtitle, testncontrols, newncontrols, replaceClass

    folders = {}
    newDir = {}
    combineStyle = {}
    hintFontStyle = {}
    fontStyle = {}
    usedCCWinStyle = w32False
    haveTitleBar = 0



    --Replace normal attributes with vars. We can do this here because we are setting 
    --true/false. 
    if length(ctrl[HintFontVarItalic]) then
        ctrl[HintFontAttrib] = w32True
    end if
    if length(ctrl[HintFontVarBold]) then
        ctrl[HintFontBold] = w32True
    end if
    if length(ctrl[HintFontVarUnderline]) then
        ctrl[HintFontUnderline] = w32True
    end if
    if length(ctrl[HintFontVarStrikeout]) then
        ctrl[HintFontStrikeout] = w32True
    end if
    if length(ctrl[FontVarItalic]) then
        ctrl[FontAttrib] = w32True
    end if
    if length(ctrl[FontVarBold]) then
        ctrl[FontBold] = w32True
    end if
    if length(ctrl[FontVarUnderline]) then
        ctrl[FontUnderline] = w32True
    end if
    if length(ctrl[FontVarStrikeout]) then
        ctrl[FontStrikeout] = w32True
    end if
    testStyle = "Normal"
    if ctrl[FontAttrib]
    or length(ctrl[FontVarItalic]) then
        testStyle = "Italic"
    end if
    if ctrl[FontBold]
    or length(ctrl[FontVarBold]) then
        testStyle &= "+Bold"
    end if
    if ctrl[FontUnderline]
    or length(ctrl[FontVarUnderline]) then
        testStyle &= "+Underline"
    end if
    if ctrl[FontStrikeout]
    or length(ctrl[FontVarStrikeout]) then
        testStyle &= "+Strikeout"
    end if

    --don't generate setFont statement if font, size and attributes are the default
    if equal(ctrl[FontName],theDefaultFont[1])
    and ctrl[FontPts]=theDefaultFont[2]
    and equal(testStyle,"Normal") then
        ctrl[FontName] = ""
        ctrl[FontPts] = 0
    end if

    --check if any data need to use default font data
    if not length(ctrl[FontName])
    and not length(ctrl[FontVarName]) then
        if ctrl[FontPts]
        or length(ctrl[FontVarPts])
        or not equal(testStyle, "Normal") then
            --use default fontname
            ctrl[FontName] = theDefaultFont[1]
        end if
    end if
    if not ctrl[FontPts]
    and not length(ctrl[FontVarPts]) then
        ctrl[FontPts] = theDefaultFont[2]
    end if

    testHintStyle = "Normal"
    if ctrl[HintFontAttrib]
    or length(ctrl[HintFontVarItalic]) then
        testHintStyle = "Italic"
    end if
    if ctrl[HintFontBold]
    or length(ctrl[HintFontVarBold]) then
        testHintStyle &= "+Bold"
    end if
    if ctrl[HintFontUnderline]
    or length(ctrl[HintFontVarUnderline]) then
        testHintStyle &= "+Underline"
    end if
    if ctrl[HintFontStrikeout]
    or length(ctrl[HintFontVarStrikeout]) then
        testHintStyle &= "+Strikeout"
    end if

    --don't generate setFont statement if font, size and attributes are the default
    if equal(ctrl[HintFontName],theDefaultFont[1])
    and ctrl[HintFontPts]=theDefaultFont[2]
    and equal(testHintStyle,"Normal") then
        ctrl[HintFontName] = ""
        ctrl[HintFontPts] = 0
    end if

    if not length(ctrl[HintFontName])
    and not length(ctrl[HintFontVarName]) then
        if ctrl[HintFontPts]
        or length(ctrl[HintFontVarPts])
        or not equal(testHintStyle, "Normal") then
            ctrl[HintFontName] = theDefaultFont[1]
        end if
    end if
    if not ctrl[HintFontPts]
    and not length(ctrl[HintFontVarPts]) then
        ctrl[HintFontPts] = theDefaultFont[2]
    end if

    --we can overlay Name and Hint Text, Points here but also need to set quotes around the data
    --when it isn't a var
    IDE_hintFont = {}
    if length(ctrl[HintFontName]) then
        IDE_hintFont = "\"" & ctrl[HintFontName] & "\""
    end if
    if length(ctrl[HintFontVarName]) then
        IDE_hintFont = ctrl[HintFontVarName]
    end if

    IDE_hinttext = {}
    if length(ctrl[HintText]) then
        IDE_hinttext = "\"" & ctrl[HintText] & "\""
    end if

    if length(ctrl[HintVarText]) then
        IDE_hinttext = ctrl[HintVarText]
    end if

    IDE_fontName = {}
    if length(ctrl[FontName]) then
        IDE_fontName = "\"" & ctrl[FontName] & "\""
    end if
    if length(ctrl[FontVarName]) then
        IDE_fontName = ctrl[FontVarName]
    end if

    if length(ctrl[HintFontName])
    or length(ctrl[HintFontVarName]) then
        if not ctrl[HintFontPts] then
            ctrl[HintFontPts] = theDefaultFont[2]
        end if
    end if

    if ctrl[HintFontPts] then
        IDE_hintFontPts = sprint(ctrl[HintFontPts])
    end if
    if length(ctrl[HintFontVarPts]) then
        IDE_hintFontPts = ctrl[HintFontVarPts]
    end if

    if length(ctrl[FontName])
    or length(ctrl[FontVarName]) then
        if not ctrl[FontPts] then
            ctrl[FontPts] = theDefaultFont[2]
        end if
    end if

    if ctrl[FontPts] then
        IDE_fontPts = sprint(ctrl[FontPts])
    end if
    if length(ctrl[FontVarPts]) then
        IDE_fontPts = ctrl[FontVarPts]
    end if

    IDE_fontColor = {}
    IDE_fontColor = sprint(ctrl[FontColor])
    if length(ctrl[FontVarColor]) then
        IDE_fontColor = ctrl[FontVarColor]
    end if

    if equal(ctrl[Class], "Window")  then
        IDE_windowFontName = IDE_fontName
        IDE_windowFontPts  = IDE_fontPts
        IDE_windowHintFontName = IDE_hintFont
        IDE_windowHintFontPts  = IDE_hintFontPts
        IDE_windowAttrib = ctrl[HintFontAttrib]
        IDE_windowBold = ctrl[HintFontBold]
        IDE_windowUnder = ctrl[HintFontUnderline]
        IDE_windowStrike = ctrl[HintFontStrikeout]
    end if

    if equal(ctrl[Class], "None") then
        return
    end if

    if find(ctrl[Class], controlsWithOutColor) then
        ctrl[BkColor] = 0
    end if

    if equal(ctrl[Class], "LabelEdit") then
        ctrl[Class] = "EditText"
        ctrl[Title] = ctrl[ValueEdit]
    end if

    if ctrl[TableCell]
    and ctrl[SuppressCell]
    and not length(priorTableName) then --not an arrayed table
        return
    end if

    if ctrl[TableCell]
    and tableGenInExw then  --per Table Class control
        return
    end if

    if ctrl[TableCell]
    and (tableGenBorder or addOffset) then --per Table Class control        
        ctrl[Y] += offset --because Group control drops the top line we need to drop each
                                                        --control within the Group; we have already adjusted the Group CY               
    end if

    if equal(ctrl[Class], "Timer") then
        --increment a counter
        TimerCounter += 1
        puts(outFile, "constant "   & ctrl[Name] & " = " & sprint(TimerCounter)
             & "\n")
        lineCount += 1
        return
    end if

    --combine the various font attributes to make only one style
    if length(ctrl[HintFontName])
    or length(ctrl[HintFontVarName]) then
        hintFontStyle = "Normal"
        if ctrl[HintFontAttrib]
        or length(ctrl[HintFontVarItalic]) then
            hintFontStyle = "Italic"
        end if
        if ctrl[HintFontBold]
        or length(ctrl[HintFontVarBold]) then
            hintFontStyle &= "+Bold"
        end if
        if ctrl[HintFontUnderline]
        or length(ctrl[HintFontVarUnderline]) then
            hintFontStyle &= "+Underline"
        end if
        if ctrl[HintFontStrikeout]
        or length(ctrl[HintFontVarStrikeout]) then
            hintFontStyle &= "+Strikeout"
        end if
    end if

    if length(ctrl[FontName])
    or length(ctrl[FontVarName]) then
        fontStyle = "Normal"
        if ctrl[FontAttrib]
        or length(ctrl[FontVarItalic]) then
            fontStyle = "Italic"
        end if
        if ctrl[FontBold]
        or length(ctrl[FontVarBold]) then
            fontStyle &= "+Bold"
        end if
        if ctrl[FontUnderline]
        or length(ctrl[FontVarUnderline]) then
            fontStyle &= "+Underline"
        end if
        if ctrl[FontStrikeout]
        or length(ctrl[FontVarStrikeout]) then
            fontStyle &= "+Strikeout"
        end if
    end if

    -- if control is window then reset flag to make a TabControl if have any
    -- TabItems
    if equal(ctrl[Class], "Window") then
        tabCounter += 1
        tables = {}
        offset = 0
        tableGenInExw = 0
        tableGenBorder = 0
        addOffset = 0
    end if

    if equal(ctrl[Class], "EuGrid")
    or equal(ctrl[SeqParentClass], "EuGrid") then
        if ctrl[GridHeaderColor]=getSysColor(COLOR_BTNFACE) then
            ctrl[GridHeaderColor] = 0
        end if
        if ctrl[BkColor]=getSysColor(COLOR_BTNFACE) then
            ctrl[BkColor] = 0
        end if
    end if

    if equal(ctrl[Class], "ProgressBar") then
        if ctrl[BkColor]=getSysColor(COLOR_BTNFACE) then
            ctrl[BkColor] = 0
        end if
    end if

    parent = {}
    parentClass = {}
    style = sprintf("%d", 0)
    exStyle = sprintf("%d", 0)

    -- determine parent from prior control
    if equal(ctrl[Class], "Window")
    and equal(priorWindowName, "") then
        -- first window is main window
        parent = "0"

        if treatAsInclude
        and length(ctrl[ControlParent]) then
            parent = ctrl[ControlParent]
        end if

    elsif equal(ctrl[Class], "Window")
      and not equal(priorWindowName,"") then
        --if has parent use it otherwise use 0
        if length(ctrl[ControlParent]) then
            parent = ctrl[ControlParent]
        else
            parent = "0"
        end if
    else
        -- parent to main window
        parent = priorWindowName
        if equal(ctrl[Class], "Table") then
            --match child controls by [Parent]
            tableParent = ctrl[Name]
            tableId = id    --sequence number in controls
            tableGenInExw = ctrl[TableGenInExw]
            tableGenBorder = ctrl[TableGenBorder]
        end if

        if treatAsInclude
        and length(ctrl[ControlParent]) then
            parent = ctrl[ControlParent]
        end if

    end if

        -- if control has a parent already assigned use it
    if length(ctrl[ControlParent]) then
        parent = ctrl[ControlParent]
        parentClass = ctrl[ParentClass]
        if length(ctrl[SeqParentName]) then
            parent = ctrl[SeqParentName]
            parentClass = ctrl[SeqParentClass]
        end if
    elsif length(ctrl[SeqParentName]) then
        parent = ctrl[SeqParentName]
        parentClass = ctrl[SeqParentClass]
    end if

    -- items following Window and Menu are children
    if equal(ctrl[Class], "Window") then
        -- save name
        priorWindowName = ctrl[Name]
    elsif equal(ctrl[Class], "Table") then
        --was there an arrayed table right before this one?
        --if so need to write it out now.
        if length(tables) then
            makeTableArray(outFile, windowNumber, priorLocal,
                           priorInteger)
            tables = {}
        end if
        priorFontName = IDE_fontName    --ctrl[FontName]
        priorFontPts = IDE_fontPts      --ctrl[FontPts]
        priorFontAttrib = fontStyle
        priorLocal = ctrl[Local]
        if ctrl[Integers] then
            priorInteger = w32True
        else
            priorInteger = w32False
        end if

        if ctrl[TableCols]=1
        and ctrl[TableRows]=1 then
            ctrl[TableArray] = w32False
            ctrl[TableGenInExw] = w32False
        end if

        if ctrl[TableArray] then
            --save name
            priorTableName = ctrl[Name]
            priorColRow = ctrl[TableCols]*ctrl[TableRows]
            priorCols = ctrl[TableCols]
            priorRows = ctrl[TableRows]
            if ctrl[TableGenInExw] then
                tableGenInExw = w32True
            else
                tableGenInExw = w32False
            end if
        else
            priorTableName = {}
            priorColRow = 0
            priorCols = 0
            tableGenInExw = w32False
        end if
    end if


    -- save the title
    title = ctrl[Title]

    --clean it up
    if length(title) then
        title = cleanTitle(title, ctrl[Class])
    end if

    if ctrl[Showcap] then
        title = ""
    end if

    -- position
    x = sprintf("%d", ctrl[X])

    --if control doesn't have a parent and is not CWindow then adjust by one of the following:
    --  Window ReBar or (ToolBar/FlatToolBar not on ReBar) if there is one.
    --
    haveReBarControlInCWindow = 0
    haveToolBarControlInCWindow = 0
    adjustYby = 0
    adjustXby = 0
    if not find(ctrl[Class],{"CWindow","Window"}) then
        if not length(ctrl[ControlParent]) then
            --Window is parent
            if haveReBarControl then
                adjustYby = haveReBarControl
            else
                --this has already been ignored if on ReBar or not a ToolBar/FlatToolBar
                adjustYby = haveToolBarControl
            end if
        end if

        if equal(ctrl[SeqParentClass],"CWindow") then
            for k=1 to length(CWindowBars) do
                if equal(ctrl[SeqParentName], CWindowBars[k][1]) then
                    haveReBarControlInCWindow = CWindowBars[k][2]
                    haveToolBarControlInCWindow = CWindowBars[k][3]
                    adjustYby = 0
                    exit
                end if
            end for

            --additionally adjust by CWindow ReBar or CWindow Toolbar/FlatToolBar
            --and the CWindow titleBar CY         
            if haveReBarControlInCWindow then
                if not equal(ctrl[Class], "ReBar") then
                    adjustYby += haveReBarControlInCWindow
                end if
            else
                --this has already been zeroed if on ReBar or not a ToolBar/FlatToolBar
                --but do not adjust itself!
                if not find(ctrl[Class], {"FlatToolBar","ToolBar"}) then
                    adjustYby += haveToolBarControlInCWindow
                end if
            end if

            --also need to adjust by CWindow X and Y position and titleBar                                                                  
            if id>length(controls) then
                holdcontrols = controls
                controls = ctrls
            end if
            flag = findSeqParentName(id)
            if flag then
                adjustYby += controls[flag][Y]
                adjustXby += controls[flag][X]
                if equal("WS_POPUP",controls[flag][Style]) then
                    if not equal(controls[flag][StyleType],"{...}") then
                                                --needs caption bar
                        adjustYby += titleBar
                    end if
                elsif match("WS_POPUP",controls[flag][Style]) then
                    if match("WS_CAPTION",controls[flag][Style]) then
                    --needs caption bar
                        adjustYby += (titleBar+borderY)
                    elsif match("WS_CHILD",controls[flag][Style])
                      and equal(controls[flag][StyleType],"w32or_all({...})") then
                                                --needs caption bar
                        adjustYby += titleBar
                    else
                        if not equal(controls[flag][StyleType],"{...}") then
                            adjustYby -= borderY
                        end if
                    end if
                elsif equal("WS_CHILD",controls[flag][Style]) then
                    if not equal(controls[flag][StyleType],"{...}") then
                        --needs caption bar
                        adjustYby += titleBar
                    end if
                elsif match("WS_CHILD",controls[flag][Style]) then
                    if not equal(controls[flag][StyleType],"{...}")
                    or match("WS_CAPTION",controls[flag][Style]) then
                        --needs caption bar
                        adjustYby += (titleBar+borderY)
                    end if
                end if
            end if

            if id>length(controls) then
                controls = holdcontrols
            end if

        elsif length(ctrl[SeqParentName]) then
            --a game when looking for parent of labelEdit label portion. 
            --Because the label is not a control in controls. 
            --Need to search based upon ctrls where labeledit was split into two
            --controls and the label portion added.         
            if id>length(controls) then
                holdcontrols = controls
                controls = ctrls
            end if
            flag = findSeqParentName(id)
            if flag then
                --so need to adjust its x,y
                adjustXby = controls[flag][X]
                adjustYby = controls[flag][Y]
            end if
            if id>length(controls) then
                controls = holdcontrols
            end if
        end if
    end if

    y = sprintf("%d", (ctrl[Y]-adjustYby ))
    x = sprintf("%d", (ctrl[X]-adjustXby ))

    if equal(ctrl[SeqParentClass],"CWindow") then
        flag = findSeqParentName(id)
        if flag then
            if equal(controls[flag][StyleType],"{...}") then
                y = sprintf("%d", (ctrl[Y]-adjustYby ))
                x = sprintf("%d", (ctrl[X]-adjustXby ))
            else
                y = sprintf("%d", (ctrl[Y]-(adjustYby+borderY) ))
                x = sprintf("%d", (ctrl[X]-(adjustXby+borderX) ))
            end if
        end if
    end if

    if equal(ctrl[Class], "Window")
    and equal(x, sprint(0))
    and equal(y, sprint(0)) then
        if not ctrl[DefaultXY] then
            x = "Default"
            y = "Default"
        end if
    end if

    testStyle = ctrl[Style]
    if atom(testStyle) then
        --skip this test
    else
        if match("WS_POPUP", ctrl[Style]) then
            if match("WS_CAPTION",ctrl[Style]) then
                                --needs caption bar                             
            else
                if equal(ctrl[Class], "Window")
                and equal(ctrl[StyleType], "{...}") then
                    --titlebar gets removed from window....
                    ctrl[CY] -= titleBar
                end if
            end if
        end if
    end if

    if ctrl[WinPos] and
    not equal(ctrl[Class], "Window") then
        ctrl[WinPos] = 0
    end if

    if ctrl[WinPos] then
        --figure the new X and Y for the main window at run time.
        --generate IDE canned routine for this now....

        if ctrl[WinPos]=1 then
            ctrl[X] = 0
            ctrl[Y] = 0
            x = sprintf("%d", ctrl[X])
            y = sprintf("%d", ctrl[Y])
        else
            x = {}
            y = {}

            if ctrl[WinPos]!=5
            or (ctrl[WinPos]=5
                and ctrl[WinPosTaskBar]) then
                if not WinPosDef then
                    puts(outFile, " -------- IDE generated routine ------------ \n")
                    puts(outFile, "integer IDEcenterWinX, IDEcenterWinY, IDEcenterScreenX, IDEcenterScreenY \n")
                    puts(outFile, "sequence IDEScreenSize \n")
                    puts(outFile, "integer IDEctrlX, IDEctrlY, IDEctrlCX, IDEctrlCY \n")
                    lineCount += 4
                    WinPosDef = w32True
                end if

                if ctrl[WinPosTaskBar] then
                    if not WinPosTaskBarDef then
                        --reduce ScreenSize CY by taskbar
                        puts(outFile, "--begin brian broker code \n")
                        puts(outFile, "constant xSystemParameters = registerw32Function(user32,\"SystemParametersInfoA\",\n")
                        puts(outFile, "{C_UINT,C_UINT,C_POINTER,C_UINT},C_LONG),\n")
                        puts(outFile, "SPI_GETWORKAREA = 48 \n")
                        puts(outFile, "function getWorkArea()\n")
                        puts(outFile, "atom mset, workarea\n")
                        puts(outFile, "sequence wa_out\n")
                        puts(outFile, "mset = new_memset()\n")
                        puts(outFile, "workarea = acquire_mem(mset,SIZEOF_RECT)\n")
                        puts(outFile, "if not w32Func(xSystemParameters,{SPI_GETWORKAREA,0,workarea,0}) then\n")
                        puts(outFile, "warnErr(\"getWorkspace:SystemParametersInfo failed\")\n")
                        puts(outFile, "end if\n")
                        puts(outFile, "wa_out = {w32fetch(workarea,rectLeft),w32fetch(workarea,rectTop),\n")
                        puts(outFile, "w32fetch(workarea,rectRight),w32fetch(workarea,rectBottom)}\n")
                        puts(outFile, "w32release_mem(mset)\n")    --"free(mset)\n")
                        puts(outFile, "return wa_out\n")
                        puts(outFile, "end function\n")
                        puts(outFile, "--end brian broker\n")
                        lineCount += 18
                        WinPosTaskBarDef = w32True
                    end if
                end if

                puts(outFile, "IDEctrlCX = ")
                printf(outFile, "%d", ctrl[CX])
                puts(outFile, " \n")
                puts(outFile, "IDEctrlCY = ")
                printf(outFile, "%d", ctrl[CY])
                puts(outFile, " \n")
                if ctrl[WinPosTaskBar] then
                    puts(outFile, "IDEScreenSize = getWorkArea()\n")
                else
                    puts(outFile, "IDEScreenSize = getRect(Screen) \n")
                end if
                lineCount += 3
            end if

            if ctrl[WinPos]=2 then
                if ctrl[WinPosTaskBar] then
                    puts(outFile, "IDEcenterWinX=floor( IDEctrlCX/2 ) \n")
                    puts(outFile, "IDEcenterScreenX = floor( IDEScreenSize[3]/2 ) \n")
                    puts(outFile, "IDEctrlX=IDEcenterScreenX-IDEcenterWinX \n")
                    lineCount += 3
                    x = "1"
                end if
                puts(outFile, "IDEctrlY=0 \n")
                y = "1"
                lineCount += 1

            elsif ctrl[WinPos]=3 then
                puts(outFile, "IDEctrlX=IDEScreenSize[3]-IDEctrlCX \n")
                puts(outFile, "IDEctrlY=0 \n")
                x = "1"
                y = "1"
                lineCount += 2

            elsif ctrl[WinPos]=4 then
                puts(outFile, "IDEctrlX=0 \n")
                x = "1"
                lineCount += 1
                if ctrl[WinPosTaskBar] then
                    puts(outFile, "IDEcenterWinY=floor( IDEctrlCY/2 ) \n")
                    puts(outFile, "IDEcenterScreenY=floor( IDEScreenSize[4]/2 ) \n")
                    puts(outFile, "IDEctrlY=IDEcenterScreenY - IDEcenterWinY \n")
                    lineCount += 3
                    y = "1"
                end if

            elsif ctrl[WinPos]=5 then
                if ctrl[WinPosTaskBar] then
                    puts(outFile, "IDEcenterWinX=floor( IDEctrlCX/2 ) \n")
                    puts(outFile, "IDEcenterScreenX = floor( IDEScreenSize[3]/2 ) \n")
                    puts(outFile, "IDEctrlX=IDEcenterScreenX-IDEcenterWinX \n")
                    puts(outFile, "IDEcenterWinY=floor( IDEctrlCY/2 ) \n")
                    puts(outFile, "IDEcenterScreenY=floor( IDEScreenSize[4]/2 ) \n")
                    puts(outFile, "IDEctrlY=IDEcenterScreenY - IDEcenterWinY \n")
                    lineCount += 6
                    x = "1"
                    y = "1"
                end if

            elsif ctrl[WinPos]=6 then
                puts(outFile, "IDEctrlX=IDEScreenSize[3]-IDEctrlCX \n")
                x = "1"
                lineCount += 1
                if ctrl[WinPosTaskBar] then
                    puts(outFile, "IDEcenterWinY=floor( IDEctrlCY/2 ) \n")
                    puts(outFile, "IDEcenterScreenY=floor( IDEScreenSize[4]/2 ) \n")
                    puts(outFile, "IDEctrlY=IDEcenterScreenY - IDEcenterWinY \n")
                    lineCount += 3
                    y = "1"
                end if

            elsif ctrl[WinPos]=7 then
                puts(outFile, "IDEctrlX=0 \n")
                puts(outFile, "IDEctrlY=IDEScreenSize[4]-IDEctrlCY \n")
                x = "1"
                y = "1"
                lineCount += 2

            elsif ctrl[WinPos]=8 then
                if ctrl[WinPosTaskBar] then
                    puts(outFile, "IDEcenterWinX=floor( IDEctrlCX/2 ) \n")
                    puts(outFile, "IDEcenterScreenX = floor( IDEScreenSize[3]/2 ) \n")
                    puts(outFile, "IDEctrlX=IDEcenterScreenX-IDEcenterWinX \n")
                    lineCount += 3
                    x = "1"
                end if
                puts(outFile, "IDEctrlY=IDEScreenSize[4]-IDEctrlCY \n")
                y = "1"
                lineCount += 1

            else
                puts(outFile, "IDEctrlX=IDEScreenSize[3]-IDEctrlCX \n")
                puts(outFile, "IDEctrlY=IDEScreenSize[4]-IDEctrlCY \n")
                x = "1"
                y = "1"
                lineCount += 2
            end if

            puts(outFile, "\n")
            lineCount += 1

            if not length(x) then
                x = "Center"
            else
                x = "IDEctrlX"
            end if

            if not length(y) then
                y = "Center"
            else
                y = "IDEctrlY"
            end if
        end if
    end if

    rebarParent = {}

    if length(ctrl[SeqParentName]) then
        if length(ctrl[SeqParentName])
        and equal(ctrl[SeqParentClass], "ReBarBand") then
            --assign Rebar parent for addToBand statement
            rebarParent = ctrl[SeqParentName]
            --reBar control must be parent for children of RebarBand
            for xx=1 to length(controls) do
                if equal(controls[xx][Name],rebarParent) then
                    parent = controls[xx][SeqParentName]
                end if
            end for
        end if
    end if

    if length(ctrl[ControlParent])
    and equal(ctrl[ParentClass], "StatusBar") then
        --a control within a StatusBar
        --so need to adjust its x,y
        y = sprintf("%d", ( 3 ))
    end if

    if find(ctrl[Class], {"TabItem","StatusBar","ReBar","ReBarBand"})
    or equal(ctrl[SeqParentClass], "ReBarBand")  then
        x = sprintf("%d", 0)
        y = sprintf("%d", 0)
    end if

    -- size
    cx = sprintf("%d", ctrl[CX])
    cy = sprintf("%d", ctrl[CY])

    if find(ctrl[Class], {"Combo","DropDownList"}) then
        -- allow room for six items
        cy &= "*6"

    elsif equal(ctrl[Class], "TabItem")
       or equal(ctrl[Class], "StatusBar")
       or equal(ctrl[Class], "UpDown") then
        cx = sprintf("%d", 0)
        cy = sprintf("%d", 0)
    end  if

    if equal(ctrl[SeqParentClass],"FlatToolBar") then
        x = sprintf("%d", 0)
        y = sprintf("%d", 0)
        cx = sprintf("%d", 0)
        cy = sprintf("%d", 0)
    end if

    if equal(ctrl[Class], "UpDown") then
        if not length(ctrl[Buddy]) then
            --user did not supply a buddy name, so user placed the buddy
            --control where he wanted it or added setBuddy() in General event
        else
            if length(priorTableName)   --is array
            and ctrl[TableCell] then
                --get table buddys later
            else
                --save the buddy name for later
                buddyData[1] = ctrl[Name]
                buddyData[2] = ctrl[Buddy]
                buddyList &= {buddyData}
            end if
        end if
    end if

    if equal(ctrl[Class], "PopupItem") then
        ctrl[Class] = "MenuItem"
    end if

    if find(ctrl[Class], {"Menu","MenuItem","PopupItem"})then
        x = "0"
        y = "0"
        cx = "0"
        cy = "0"
    end if

    if equal(ctrl[Class], "PopupItem")         --RS
    or equal(ctrl[Class], "SubpopupItem")           --RS
    or equal(ctrl[Class], "Sub2popupItem")      --RS
    or equal(ctrl[Class], "Sub3popupItem")      --RS
    or equal(ctrl[Class], "SubmenuItem")          --RS
    or equal(ctrl[Class], "Sub2menuItem")         --RS
    or equal(ctrl[Class], "Sub3menuItem") then   --RS
        ctrl[Class] = "MenuItem"                   --RS
        x = "0"
        y = "0"
        cx = "0"
        cy = "0"
    end if

    if equal(ctrl[Class], "Submenu")               --RS
    or equal(ctrl[Class], "Sub2menu")              --RS
    or equal(ctrl[Class], "Sub3menu") then         --RS
        ctrl[Class] = "Menu"
        x = "0"
        y = "0"
        cx = "0"
        cy = "0"
    end if

    if equal(ctrl[Class], "Subpopup")              --RS
    or equal(ctrl[Class], "Sub2popup")         --RS
    or equal(ctrl[Class], "Sub3popup") then    --RS
        ctrl[Class] = "Popup"
        x = "0"
        y = "0"
        cx = "0"
        cy = "0"
    end if

    --prepare for the icons
    if equal(ctrl[Class], "FlatToolBar") then
        if not IconUsed then
            puts(outFile, "sequence icons\n")
            lineCount += 1
            IconUsed = w32True
        end if
        puts(outFile, "icons={}\n")
        lineCount += 1
    end if

    if equal(ctrl[ParentClass], "FlatToolBar")
    or equal(parentClass, "FlatToolBar") then
        --get the icons
        if not length(ctrl[IcoFile])
        and not length(ctrl[TwoIcoFile])
        and not length(ctrl[TriIcoFile]) then
            --skip this
        elsif not length(ctrl[IcoFile]) then
            --skip this
        else
            if not length(ctrl[TriIcoFile]) then
                ctrl[TriIcoFile] = ctrl[IcoFile]
            end if
            if not length(ctrl[TwoIcoFile]) then
                ctrl[TwoIcoFile] = ctrl[IcoFile]
            end if
            --should have all icons slots now;build the icon array
            puts(outFile, "integer " & ctrl[Name] & "Icon" & sprint(1) & "\n")
            puts(outFile, "integer " & ctrl[Name] & "Icon" & sprint(2) & "\n")
            puts(outFile, "integer " & ctrl[Name] & "Icon" & sprint(3) & "\n")
            lineCount += 3
            saveName = {}
            examDocs = ctrl[IcoFile]
            saveName = {}
            at = match(lower(projectDir), lower(examDocs))
            if at then
                examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
            end if
            at = 1
            while at do
                at = 0
                for j=1 to length(examDocs) do
                    if examDocs[j]='\\' then
                        saveName &= examDocs[1..j-1] & "\\\\"
                        examDocs = examDocs[j+1..length(examDocs)]
                        at = 1
                        exit
                    end if
                end for
            end while
            saveName &= examDocs
            puts(outFile, ctrl[Name] & "Icon" & sprint(1) & " = extractIcon( \""
                 & saveName & "\" )\n")
            lineCount += 1
            saveName = {}
            examDocs = ctrl[TwoIcoFile]
            saveName = {}
            at = match(lower(projectDir), lower(examDocs))
            if at then
                examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
            end if
            at = 1
            while at do
                at = 0
                for j=1 to length(examDocs) do
                    if examDocs[j]='\\' then
                        saveName &= examDocs[1..j-1] & "\\\\"
                        examDocs = examDocs[j+1..length(examDocs)]
                        at = 1
                        exit
                    end if
                end for
            end while
            saveName &= examDocs
            puts(outFile, ctrl[Name] & "Icon" & sprint(2) & " = extractIcon( \""
                 & saveName & "\" )\n")
            lineCount += 1
            saveName = {}
            examDocs = ctrl[TriIcoFile]
            saveName = {}
            at = match(lower(projectDir), lower(examDocs))
            if at then
                examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
            end if
            at = 1
            while at do
                at = 0
                for j=1 to length(examDocs) do
                    if examDocs[j]='\\' then
                        saveName &= examDocs[1..j-1] & "\\\\"
                        examDocs = examDocs[j+1..length(examDocs)]
                        at = 1
                        exit
                    end if
                end for
            end while
            saveName &= examDocs
            puts(outFile, ctrl[Name] & "Icon" & sprint(3) & " = extractIcon( \""
                 & saveName & "\" )\n")
            lineCount += 1
            puts(outFile, "icons &= addIcon( {" & ctrl[Name] & "Icon" & sprint(1)
                 & ", " & ctrl[Name] & "Icon" & sprint(2) & ", "
                 & ctrl[Name] & "Icon" & sprint(3) & "} )\n")
            lineCount += 1
            x = "icons[length(icons)]"
        end if
    end if

    if atom(ctrl[Style]) then
        --must be 0
    else
        if equal("0", ctrl[Style])
        or not length(ctrl[Style]) then
            --ok
        elsif equal(ctrl[StyleType], "w32or_all({...})") then
            style = "w32or_all({" & ctrl[Style] & "})"
        elsif equal(ctrl[StyleType], "{...}") then
            style = "{" & ctrl[Style] & "}"
        elsif equal(ctrl[StyleType], "...") then
            style = ctrl[Style]
        elsif not length(ctrl[StyleType]) then
            style = "w32or_all({" & ctrl[Style] & "})"
        end if
    end if


    if compare("0",ctrl[ExStyle])=0
    or not length(ctrl[ExStyle]) then
        --ok took care of in sprintf previously
    else
        if equal(ctrl[StyleType], "w32or_all({...})") then
            exStyle = "w32or_all({" & ctrl[ExStyle] & "})"
        elsif equal(ctrl[StyleType], "{...}") then
            exStyle = "{" & ctrl[ExStyle] & "}"
        elsif equal(ctrl[StyleType], "...") then
            exStyle = ctrl[ExStyle]
        elsif not length(ctrl[StyleType]) then
            exStyle = "w32or_all({" & ctrl[ExStyle] & "})"
        end if
    end if


    --for controls combine with style
    if not equal(ctrl[Class], "Window")
    and not equal(ctrl[Class], "CWindow") then
        --test for other styles and add to Style, w32or_all'd
        if equal("0", style) then
            combineStyle = {}
        else
            combineStyle &= ctrl[Style]
        end if

        if ctrl[Upper] then
            if length(combineStyle) then
                combineStyle &= ",ES_UPPERCASE"
            else
                combineStyle = "ES_UPPERCASE"
            end if
        end if

        if ctrl[Lower] then
            if  length(combineStyle) then
                combineStyle &= ",ES_LOWERCASE"
            else
                combineStyle &= "ES_LOWERCASE"
            end if
        end if

        if ctrl[ReadOnly] then
            if length(combineStyle) then
                combineStyle &= ",ES_READONLY"
            else
                combineStyle &= "ES_READONLY"
            end if
        end if

        if ctrl[Pswd] then
            if length(combineStyle) then
                combineStyle &= ",ES_PASSWORD"
            else
                combineStyle &= "ES_PASSWORD"
            end if
        end if

        if ctrl[Numeric] then
            if length(combineStyle) then
                combineStyle &= ",#2000"
            else
                combineStyle &= "#2000"
            end if
        end if

        if ctrl[Multiline] then
            if equal(ctrl[Class], "TabControl") then
                if length(combineStyle) then
                    combineStyle &= ",#0200"
                else
                    combineStyle &= "#0200"
                end if
            else
                if not ctrl[cbColor]
                and not ctrl[TableButtonAllColor]
                and not ctrl[TreatAsColorButton] then
                    if length(combineStyle) then
                        combineStyle &= ",BS_MULTILINE"
                    else
                        combineStyle &= "BS_MULTILINE"
                    end if
                end if
            end if
        end if

        if ctrl[TabsBottom]
        and equal(ctrl[Class], "TabControl") then
            if length(combineStyle) then
                combineStyle &= ",#0002"
            else
                combineStyle &= "#0002"
            end if
        end if

        if ctrl[Hscrolls] then
            if length(combineStyle) then
                combineStyle &= ",ES_AUTOHSCROLL,WS_HSCROLL"
            else
                combineStyle &= "ES_AUTOHSCROLL,WS_HSCROLL"
            end if
        end if

        if ctrl[Vscrolls] then
            if length(combineStyle) then
                combineStyle &= ",ES_AUTOVSCROLL,WS_VSCROLL"
            else
                combineStyle &= "ES_AUTOVSCROLL,WS_VSCROLL"
            end if
        end if

        if ctrl[MultiSel] then
            if length(combineStyle) then
                combineStyle &= ",LBS_MULTIPLESEL"
            else
                combineStyle &= "LBS_MULTIPLESEL"
            end if
        end if

        if ctrl[ExtendSel] then
            if length(combineStyle) then
                combineStyle &= ",LBS_EXTENDEDSEL"
            else
                combineStyle &= "LBS_EXTENDEDSEL"
            end if
        end if

        if ctrl[RBBSBREAK] then
            if length(combineStyle) then
                combineStyle &= ",RBBS_BREAK"
            else
                combineStyle &= "RBBS_BREAK"
            end if
        end if

        if ctrl[Clickable] then
            if length(combineStyle) then
                combineStyle &= ",SS_NOTIFY"
            else
                combineStyle &= "SS_NOTIFY"
            end if
        end if

        if equal(ctrl[Class], "MonthCalendar")
        and ctrl[MCS_multiselect] then
            if length(combineStyle) then
                combineStyle &= ",MCS_MULTISELECT"
            else
                combineStyle &= "MCS_MULTISELECT"
            end if
        end if

        if ctrl[PBS_smooth] then
            if length(combineStyle) then
                combineStyle &= ",PBS_SMOOTH"
            else
                combineStyle &= "PBS_SMOOTH"
            end if
        end if

        if ctrl[BS_flat] then
            if not ctrl[cbColor]
            and not ctrl[TableButtonAllColor]
            and not ctrl[TreatAsColorButton] then
                if length(combineStyle) then
                    combineStyle &= ",#8000"
                else
                    combineStyle &= "#8000"
                end if
            end if
        end if

        if ctrl[NoIntegralHeight] then
            if length(combineStyle) then
                combineStyle &= ",LBS_NOINTEGRALHEIGHT"
            else
                combineStyle &= "LBS_NOINTEGRALHEIGHT"
            end if
        end if

        if ctrl[AdjCenter] then
            if length(combineStyle) then
                combineStyle &= ",ES_CENTER"
            else
                combineStyle &= "ES_CENTER"
            end if
        end if

        if ctrl[AdjRight] then
            if length(combineStyle) then
                combineStyle &= ",ES_RIGHT"
            else
                combineStyle &= "ES_RIGHT"
            end if
        end if

        if length(combineStyle) then
            if equal(ctrl[StyleType],"{...}") then
                style = "{" & combineStyle & "}"
            elsif equal(ctrl[StyleType],"...") then
                --need to inspect combineStyle and change , to +
                combineStyle = replaceComma(combineStyle)
                style = combineStyle
            else
                style = "w32or_all({" & combineStyle & "})"
            end if
        end if

        if equal("0",ctrl[ExStyle]) then
            --is zero
        else
            exStyle = "w32or_all({" & ctrl[ExStyle] & "})"
        end if
    end if

    if equal(ctrl[Class], "Table")
    and ctrl[FitToTable] then
        --normal table forced to something else
        ctrl[Class] = "LText"
        if ctrl[TableGenBorder]
        and not ctrl[BkColor] then
            ctrl[Class] = "Group"
            --need to make allowance for group top line lowered to center text on the line
            offset = floor(getTextHeight(Controls, "|")/2)
            cy = sprintf("%d", ctrl[CY]+offset)
            --need to adjust child controls later           
        end if
    elsif equal(ctrl[Class], "Table") then
        addOffset = 0
        --figure the dimensions of Table based on all cells showing
        marginX = 0 marginY = 0
        width = 0 height = 0
        for i=id to length(controls) do
            if controls[i][TableCell]
            and equal(controls[i][SeqParentName], ctrl[Name]) then
                --find largest control in a cell
                if not marginX then
                    marginX = controls[i][X]-ctrl[X]
                end if
                if not marginY then
                    marginY = controls[i][Y]-ctrl[Y]
                end if
                --find widest and tallest control in case more than 1 per cell
                if controls[i][X]+controls[i][CX]>width then
                    width = controls[i][X]+controls[i][CX]
                end if
                if controls[i][Y]+controls[i][CY]>height then
                    height = controls[i][Y]+controls[i][CY]
                end if
            end if
        end for
        width = width+marginX+marginX
        height = height+marginY+marginY
    end if

    if equal(ctrl[ParentClass], "FlatToolBar")
    or equal(parentClass, "FlatToolBar") then
        --we had to make it PictureButton in order to assign icons
        --but win32lib wants PushButton.....
        if not equal(ctrl[Class], "SepButton") then
            ctrl[Class] = "PushButton"
        end if
    end if

    if find(ctrl[Class], {"Window","CWindow"})
    and length(ctrl[CCWinStyle]) then
        if not usedIDEFlags then
            puts(outFile, "sequence IDEFlags\n")
            lineCount += 1
        end if
        puts(outFile, "IDEFlags = classDefaults( Window, {{CCwinstyle,{" & ctrl[CCWinStyle] & "}}})\n")
        usedIDEFlags = w32True
        usedCCWinStyle = w32True
        lineCount += 1
        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
    end if

    --alternate x,y,cx,cy?
    if length(ctrl[OutX]) then
        x = ctrl[OutX]
    end if
    if length(ctrl[OutY]) then
        y = ctrl[OutY]
    end if
    if length(ctrl[OutCX]) then
        cx = ctrl[OutCX]
    end if
    if length(ctrl[OutCY]) then
        cy = ctrl[OutCY]
    end if

    --controlcomment?
    if length(ctrl[ControlComment]) then
        --first test for a long line
        comment = ctrl[ControlComment]
        puts(outFile, comment & "\n")
        lineCount += 1
    end if

    if length(ctrl[ClassDefaults]) then
        if not usedIDEFlags then
            puts(outFile, "sequence IDEFlags\n")
            lineCount += 1
            usedIDEFlags = w32True
        end if
        if equal("CWindow",ctrl[Class]) then
            puts(outFile, "IDEFlags = classDefaults( Window, { {1, {" & ctrl[ClassDefaults] & "}},{2, {" & ctrl[ExStyle] & "}} } )\n")
        else
            puts(outFile, "IDEFlags = classDefaults(" & ctrl[Class] & ", { {1, {" & ctrl[ClassDefaults] & "}},{2, {" & ctrl[ExStyle] & "}} } )\n")
        end if
        lineCount += 1
    end if

    childWindow = w32False
    if equal(ctrl[Class], "CWindow") then
        ctrl[Class] = "Window"
        childWindow = w32True
    end if

    if ctrl[Indexed]
    and length(indexedArray) then
        writeIndexedArray(outFile,windowNumber)
        indexedArray = {}
    end if

    if ctrl[Indexed]
    or length(ctrl[IndexParent]) then
        --add to indexed array
        indextable = {"","","","","","","","",""}
        indextable[1] = ctrl
        indextable[2] = title
        indextable[3] = parent
        indextable[4] = x
        indextable[5] = y
        indextable[6] = cx
        indextable[7] = cy
        indextable[8] = style
        indextable[9] = exStyle

        indexedArray &= {indextable}
        --will get attribute stuff later
        return
    else
        if length(indexedArray) then
            writeIndexedArray(outFile,windowNumber)
            indexedArray = {}
        end if
    end if

    --must have something in parent
    parent = trimR(parent)
    if not length(parent) then
        parent = "0"
    end if

    -- create the control
    if equal(ctrl[Class], "EuGrid") then
        --build EuGrid now
        theConstant = "integer"
        if not ctrl[Local] then
            theConstant = "global integer"
        end if

        theLine = sprintf(
            "%s %s %s = EGW_CreateGrid( %s, %s, %s, %s, %s, %s )",
            {theConstant,ctrl[Name],ctrl[Name],parent,x,y,cx,cy,sprint(ctrl[Visible])})

        puts(outFile, theLine & "\n")
        lineCount += 1

        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)

        --add set grid properties which depend upon changes in Properties
        if not ctrl[GridActiveHeaders] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_ACTIVE_HEADERS, w32False )",
            {ctrl[Name]})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if not ctrl[GridAllowColResize] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_ALLOW_COL_RESIZE, w32False )",
            {ctrl[Name]})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if not ctrl[GridAllowColSort] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_ALLOW_COL_SORT, w32False )",
            {ctrl[Name]})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if not ctrl[GridCellBorder] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_CELL_BORDER, w32False )",
            {ctrl[Name]})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridHighlightText] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_HIGHLIGHT_TEXT, w32True )",
            {ctrl[Name]})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridHeaderType] then
            what = "EGW_ROWNUM"
            if ctrl[GridHeaderType]=1 then
                what = sprint(ctrl[GridHeaderInCol])
            elsif ctrl[GridHeaderType]=2 then
                what = "0"
            end if
            theLine = sprintf(
                "gridvoid = EGW_SetGridProperty( %s, EGW_ROW_HEADER_DATACOL,%s )",
                {ctrl[Name],what})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridRowSelect] then
            what = "" --single is defaulted
            if ctrl[GridRowSelect]=2 then
                what = "EGW_NONE"
            end if
            if length(what) then
                theLine = sprintf(
                    "gridvoid = EGW_SetGridProperty( %s, EGW_ROW_SELECT,%s )",
                    {ctrl[Name],what})
                puts(outFile, theLine & "\n")
                lineCount += 1
            end if
        end if

        if ctrl[BkColor] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_NULL_GRID_COLOR,%s )",
            {ctrl[Name],sprint(ctrl[BkColor])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_ROW_HEADER_WIDTH,%s )",
            {ctrl[Name],sprint(ctrl[GridRowHeaderCX])})
        puts(outFile, theLine & "\n")
        lineCount += 1

        theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_COL_HEADER_HEIGHT,%s )",
            {ctrl[Name],sprint(ctrl[GridColHeaderCY])})
        puts(outFile, theLine & "\n")
        lineCount += 1

        if ctrl[GridBkColorRows] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_BACKGROUND_COLOR,%s )",
            {ctrl[Name],sprint(ctrl[GridBkColorRows])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridLineColor] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_LINE_COLOR,%s )",
            {ctrl[Name],sprint(ctrl[GridLineColor])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridTextColor] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_TEXT_COLOR,%s )",
            {ctrl[Name],sprint(ctrl[GridTextColor])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridBkColorRows] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_BACKGROUND_COLOR,%s )",
            {ctrl[Name],sprint(ctrl[GridBkColorRows])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridHeaderColor] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_HEADER_BACKGROUND_COLOR,%s )",
            {ctrl[Name],sprint(ctrl[GridHeaderColor])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if length(ctrl[GridFormat]) then
            ctrl[GridFormat] = trimL(ctrl[GridFormat])
            if ctrl[GridFormat][1]='\"' then
                theLine = sprintf(
                "gridvoid = EGW_SetGridProperty( %s, EGW_NUMBER_FORMAT,%s )",
                {ctrl[Name],ctrl[GridFormat]})
            else
                theLine = sprintf(
                "gridvoid = EGW_SetGridProperty( %s, EGW_NUMBER_FORMAT,\"%s\" )",
                {ctrl[Name],ctrl[GridFormat]})
            end if
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridRowCY] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_ROW_HEIGHT,%s )",
            {ctrl[Name],sprint(ctrl[GridRowCY])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridTextAlign] then
            what = {}
            if ctrl[GridTextAlign]=2 then
                what = "EGW_CENTER"
            elsif ctrl[GridTextAlign]=3 then
                what = "EGW_RIGHT"
            end if
            if length(what) then
                theLine = sprintf(
                "gridvoid = EGW_SetGridProperty( %s, EGW_TEXT_ALIGN,%s )",
                {ctrl[Name],what})
                puts(outFile, theLine & "\n")
                lineCount += 1
            end if
        end if

        if ctrl[GridBkSelectColor] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_BACKGROUND_COLOR_SELECT,%s )",
            {ctrl[Name],sprint(ctrl[GridBkSelectColor])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridCellBorderColor] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_CELL_BORDER_COLOR,%s )",
            {ctrl[Name],sprint(ctrl[GridCellBorderColor])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        if ctrl[GridTextColorSelect] then
            theLine = sprintf(
            "gridvoid = EGW_SetGridProperty( %s, EGW_TEXT_COLOR_SELECT,%s )",
            {ctrl[Name],sprint(ctrl[GridTextColorSelect])})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

        --now create the columns
        if length(ctrl[SeqChildName]) then
            childCnt = 0
            for i=1 to length(controls) do
                if find(controls[i][Name], ctrl[SeqChildName]) then
                    childCnt += 1
                    if find(controls[i][Class], {"LText","CText","RText"}) then
                        typeControl = "EGW_STATIC"
                    elsif equal(controls[i][Class],"Combo") then
                        typeControl = "EGW_COMBO"
                    elsif equal(controls[i][Class],"EditText") then
                        typeControl = "EGW_EDIT"
                    elsif equal(controls[i][Class],"CheckBox") then
                        typeControl = "EGW_CHECKBOX"
                    elsif equal(controls[i][Class],"DropDownList") then
                        typeControl = "EGW_DROPDOWN"
                    elsif equal(controls[i][Class],"Bitmap") then
                        typeControl = "EGW_PICTURE"
                    else
                        typeControl = "EGW_RADIOBUTTON"
                    end if
                    if find(controls[i][Class], controlsWithOutColor) then
                        controls[i][BkColor] = 0
                    end if
                    theConstant = "integer"
                    if not controls[i][Local] then
                        theConstant = "global integer"
                    end if
                    if match("var:",controls[i][Title]) then
                        gridtitle = controls[i][Title][5..length(controls[i][Title])]
                        gridtitle = trimL(gridtitle)
                        theLine = sprintf(
                        "%s %s %s = EGW_AddColumn( %s, %s, %s, %s, %s, %s )",
                        {theConstant,controls[i][Name],controls[i][Name],ctrl[Name],
                         gridtitle,sprint(100),
                         "EGW_LAST",typeControl,sprint(childCnt)})
                    else
                        theLine = sprintf(
                        "%s %s %s = EGW_AddColumn( %s, \"%s\", %s, %s, %s, %s )",
                        {theConstant,controls[i][Name],controls[i][Name],ctrl[Name],
                         controls[i][Title],sprint(100),
                         "EGW_LAST",typeControl,sprint(childCnt)})
                    end if

                    puts(outFile, theLine & "\n")
                    lineCount += 1

                    makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
                    theLine = sprintf(
                        "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_WIDTH, %s )",
                        {ctrl[Name],controls[i][Name],sprint(controls[i][CX])})
                    puts(outFile, theLine & "\n")
                    lineCount += 1
                    if controls[i][BkColor] then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_BACKGROUND_COLOR, %s)",
                            {ctrl[Name],controls[i][Name],
                             sprint(controls[i][BkColor])})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                    end if

                    if controls[i][GridTextAlign] then
                        what = {}
                        if controls[i][GridTextAlign]=2 then
                            what = "EGW_CENTER"
                        else
                            what = "EGW_RIGHT"
                        end if
                        if length(what) then
                            theLine = sprintf(
                                "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_ALIGN, %s)",
                                {ctrl[Name],controls[i][Name], what})
                            puts(outFile, theLine & "\n")
                            lineCount += 1
                        end if
                    end if

                    if controls[i][Limit] then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_MAXCHARS, %s)",
                            {ctrl[Name],controls[i][Name],sprint(controls[i][Limit])})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                    end if
                    if controls[i][ReadOnly] then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_EDITABLE, w32False)",
                            {ctrl[Name],controls[i][Name]})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                    end if
                    if controls[i][Multiline] then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_MULTILINE, %s)",
                            {ctrl[Name],controls[i][Name],sprint(controls[i][Multiline])})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                    end if
                    if controls[i][Numeric] then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_DATATYPE, EGW_NUMBER)",
                            {ctrl[Name],controls[i][Name]})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                        if length(controls[i][GridFormat]) then
                            controls[i][GridFormat] = trimL(controls[i][GridFormat])
                            if controls[i][GridFormat][1]='\"' then
                                theLine = sprintf(
                                    "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_NUMFORMAT, %s)",
                                    {ctrl[Name],controls[i][Name],controls[i][GridFormat]})
                            else
                                theLine = sprintf(
                                    "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_NUMFORMAT, \"%s\")",
                                    {ctrl[Name],controls[i][Name],controls[i][GridFormat]})
                            end if
                            puts(outFile, theLine & "\n")
                            lineCount += 1
                        end if
                    end if
                    if controls[i][GridColTextColor] then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_TEXT_COLOR,%s )",
                            {ctrl[Name],controls[i][Name], sprint(controls[i][GridColTextColor])})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                    end if
                    if controls[i][GridColListDataCol] then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_LIST_DATACOL,%s )",
                            {ctrl[Name],controls[i][Name], sprint(controls[i][GridColListDataCol])})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                    end if
                    if length(controls[i][GridColListValues]) then
                        theLine = sprintf(
                            "gridvoid = EGW_SetColumnProperty( %s, %s, EGW_COL_LISTVALUES,%s )",
                            {ctrl[Name],controls[i][Name], controls[i][GridColListValues]})
                        puts(outFile, theLine & "\n")
                        lineCount += 1
                    end if

                end if
                if childCnt>=length(ctrl[SeqChildName]) then
                    exit
                end if
            end for
        end if

        if length(ctrl[GridDataArrayName]) then
            theLine = sprintf(
                "gridvoid = EGW_LoadData( %s, %s, EGW_REPLACE)",
                {ctrl[Name],ctrl[GridDataArrayName]})
            puts(outFile, theLine & "\n")
            lineCount += 1
        end if

    elsif equal(ctrl[SeqParentClass], "EuGrid") then
        --ignore we got it above

    elsif equal(ctrl[Class], "ListView") then
        if length(priorTableName)
        and ctrl[TableCell] then
            addCellToArray(ctrl,title,parent,x,y,cx,cy,style,exStyle)
        else
            charCnt = 0
            theLine = ""
            if not ctrl[Local] then
                puts(outFile, "global ")
                charCnt = 7
            end if

            if ctrl[Integers] then
                theConstant = ""
                puts(outFile, "integer " & ctrl[Name] & "\n")
                lineCount += 1
                charCnt = 0
            else
                theConstant = "constant"
            end if

            --see if line is too long
            if match("var:",title) then
                title = title[5..length(title)]
                title = trimL(title)
                theLine = sprintf(
                    "%s %s = createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                    {theConstant,ctrl[Name],ctrl[Class],title,parent,x,y,cx,cy,style,exStyle})
            else
                theLine = sprintf(
                    "%s %s = createEx( %s, {%s}, %s, %s, %s, %s, %s, %s, %s )",
                    {theConstant,ctrl[Name],ctrl[Class],title,parent,x,y,cx,cy,style,exStyle})
            end if

            puts(outFile, theLine & "\n")
            lineCount += 1

            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        end if

    else
        if length(priorTableName)       --is an arrayed Table
        and ctrl[TableCell] then        --this control is a cell in that array
            --be sure when scrollable table it gets the new window for parent
            if length(associatedTable) then
                for i=1 to length(associatedTable) do
                    if equal(parent, associatedTable[i][2]) then
                        exit
                    end if
                end for
            end if
            addCellToArray(ctrl,title,parent,x,y,cx,cy,style,exStyle)
        else
            if equal(ctrl[Class], "Table")
            and not ctrl[FitToTable] then
                --this is a scrollable table
                if not hadTable then
                    skipThis = w32False
                    if equal(projectDir, the_current_dir) then
                        --can we find it in IDE's dir
                        exists = dir(the_current_dir & "\\includes\\IDE_ScrollingTable.ew")
                        if atom(exists) then
                        else
                            puts(outFile, "include includes\\IDE_ScrollingTable.ew \n")
                            skipThis = w32True
                            lineCount += 1
                        end if
                    else
                        puts(outFile, "include IDE_ScrollingTable.ew \n")
                        lineCount += 1
                    end if
                    --place copy of include file into an include folder
                    --of project if not already there
                    if not skipThis then
--                    and not equal(lower(the_current_dir), lower(projectDir)) then
                        olddir = projectDir
                        exists = dir(projectDir & "\\IDE_ScrollingTable.ew")
                        if atom(exists) then
                            --find it in an include file
                            --either EU include or a EuInc file
                            --if not found ask where to save it.
                            foundIt = w32False
                            for i=1 to length(euIncFiles) do
                                exists = dir(euIncFiles[i] & "\\IDE_ScrollingTable.ew")
                                if atom(exists) then
                                    foundIt = w32False
                                else
                                    foundIt = w32True
                                    exit
                                end if
                            end for

                            if not length(euIncFiles)
                            or not foundIt then
                                --look in Eu/Include folder
                                euDir = whereEu
                                exists = dir(euDir & "\\Include\\IDE_ScrollingTable.ew")
                                if atom(exists) then
                                    foundIt = w32False
                                else
                                    foundIt = w32True
                                end if
                            end if

                            if not foundIt then
                                folders = selectDirectory("Please indicate where to put IDE_ScrollingTable.ew", {BIF_USENEWUI,BIF_VALIDATE},
                                                          routine_id("callback"), 0)

                                if length(folders) then
                                    newDir = folders
                                else
                                    newDir = projectDir
                                end if

                                exists = dir(newDir & "\\IDE_ScrolllingTable.ew")
                                if atom(exists) then
                                    ok = copyFile(the_current_dir & "\\includes\\IDE_ScrollingTable.ew",
                                                  newDir & "\\IDE_ScrollingTable.ew", w32False)
                                    if not ok then
                                        ok = displayErrorMessage(9,{the_current_dir & "\\includes\\IDE_ScrollingTable.ew",
                                                                    newDir & "\\IDE_ScrollingTable.ew"})
                                    end if
                                end if

                            end if
                        end if
                    end if

                    hadTable = w32True
                    if ctrl[TableHScroll] then
                        puts(outFile, "IDE_ScrollWindow_bars=1 \n")
                    elsif ctrl[TableVScroll] then
                        puts(outFile, "IDE_ScrollWindow_bars=2 \n")
                    else
                        puts(outFile, "IDE_ScrollWindow_bars=0 \n")
                    end if
                    lineCount += 1
                end if
                --create the child window to hold it
                tableStyle = "{WS_CHILD"
                if ctrl[TableHScroll] then
                    tableStyle &= ",WS_HSCROLL"
                end if
                if ctrl[TableVScroll] then
                    tableStyle &= ",WS_VSCROLL"
                end if
                if ctrl[TableResizable] then
                    tableStyle &= ",WS_THICKFRAME"
                end if
                tableStyle &= "}"

                scrollTableCnt += 1
                scrollTableName = "ScrollTableWindow"&sprint(scrollTableCnt)
                puts(outFile, "global integer " & scrollTableName & "\n")
                printf(outFile,
                       "%s = createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )\n",
                       {scrollTableName,"Window","",parent,x,y,cx,cy,tableStyle,"0"})
                lineCount += 2
                --LText to be createEx with adjusted values
                ctrl[Class] = "LText"
                parent = scrollTableName
                x = "0"
                y = "0"
                cx = sprintf("%d", {width})
                cy = sprintf("%d", {height})

                if not ctrl[BkColor]
                and ctrl[TableGenBorder] then
                    ctrl[Class] = "Group"
                    addOffset = w32True
                    offset = floor(getTextHeight(Controls, "|")/2)
                    cy = sprintf("%d", ctrl[CY]+offset)
                end if
            end if

            if ctrl[TableCell] then
                if length(associatedTable) then
                    for i=1 to length(associatedTable) do
                        if equal(parent,associatedTable[i][2]) then
                            exit
                        end if
                    end for
                end if
            end if

            charCnt = 0
            theLine = ""
            theLineD = ""
            if not ctrl[Local] then
                puts(outFile, "global ")
                charCnt = 7
            end if

            if ctrl[Integers] then
                theConstant = ""
                puts(outFile, "integer " & ctrl[Name] & "\n")
                lineCount += 1
                charCnt = 0
            else
                theConstant = "constant"
            end if

            --see if line is too long
            if equal(ctrl[SeqParentClass], "FlatToolBar")
            or equal(parentClass, "FlatToolBar") then
                title = ""
            end if

            if match("var:",title) then
                title = title[5..length(title)]
                title = trimL(title)
                theLine = sprintf(
                    "%s %s = createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                    {theConstant,ctrl[Name],ctrl[Class],title,parent,x,y,cx,cy,style,exStyle})
                if length(ctrl[XpmDisableObject]) then
                    theLineD = sprintf(
                        "%s %s = createEx( %s, %s, %s, %s, %s, %s, %s, %s, %s )",
                        {theConstant,ctrl[Name] & "D",ctrl[Class],title,parent,x,y,cx,cy,style,exStyle})
                end if
            else
                theLine = sprintf(
                    "%s %s = createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                    {theConstant,ctrl[Name],ctrl[Class],title,parent,x,y,cx,cy,style,exStyle})
                if length(ctrl[XpmDisableObject]) then
                    theLineD = sprintf(
                        "%s %s = createEx( %s, \"%s\", %s, %s, %s, %s, %s, %s, %s )",
                        {theConstant,ctrl[Name] & "D",ctrl[Class],title,parent,x,y,cx,cy,style,exStyle})
                end if
            end if

            puts(outFile, theLine & "\n")
            lineCount += 1
            if length(theLineD) then
                puts(outFile, theLineD & "\n")
                puts(outFile, "setVisible(" & ctrl[Name] & "D" & ", w32False)\n")
                lineCount += 2
            end if

            if equal(ctrl[Class],"MleText")
            and not ctrl[Vscrolls] then
                puts(outFile,"removeStyle(" & ctrl[Name] & ",WS_VSCROLL)" & "\n")
                lineCount += 1
            end if

            if find(ctrl[Class], {"LText","Group"})
            and equal(parent, scrollTableName) then
                printf(outFile, "IDEAssociatedTable &={{%s,%s,0,0}} \n",
                       {scrollTableName,ctrl[Name]})
                associatedTable &= {{scrollTableName,ctrl[Name]}}
                printf(outFile, "setHandler( %s, w32HEvent, routine_id(\"event_IDEChildWin\")) \n",
                       {scrollTableName})
                printf(outFile, "setHandler( %s, w32HResize, routine_id(\"resize_IDEChildWin\")) \n",
                       {scrollTableName})
                printf(outFile,"resize_IDEChildWin(%s,0,{})\n",
                       {scrollTableName})
                printf(outFile,"openWindow(%s,Normal)\n",
                       {scrollTableName})
                lineCount += 5
            end if

            if equal(ctrl[Class],"MonthCalendar") then
                if ctrl[MC_background] then
                    puts(outFile, "setMonthColor( " & ctrl[Name] & "," & sprint(ctrl[MC_background]) & ",MCSC_BACKGROUND" & " )\n")
                    lineCount += 1
                end if
                if ctrl[MC_text] then
                    puts(outFile, "setMonthColor( " & ctrl[Name] & "," & sprint(ctrl[MC_text]) & ",MCSC_TEXT" & " )\n")
                    lineCount += 1
                end if
                if ctrl[MC_titleBK] then
                    puts(outFile, "setMonthColor( " & ctrl[Name] & "," & sprint(ctrl[MC_titleBK]) & ",MCSC_TITLEBK" & " )\n")
                    lineCount += 1
                end if
                if ctrl[MC_titleText] then
                    puts(outFile, "setMonthColor( " & ctrl[Name] & "," & sprint(ctrl[MC_titleText]) & ",MCSC_TITLETEXT" & " )\n")
                    lineCount += 1
                end if
                if ctrl[MC_monthBK] then
                    puts(outFile, "setMonthColor( " & ctrl[Name] & "," & sprint(ctrl[MC_monthBK]) & ",MCSC_MONTHBK" & " )\n")
                    lineCount += 1
                end if
                if ctrl[MC_trailingText] then
                    puts(outFile, "setMonthColor( " & ctrl[Name] & "," & sprint(ctrl[MC_trailingText]) & ",MCSC_TRAILINGTEXT" & " )\n")
                    lineCount += 1
                end if
            end if

            if childWindow then
                puts(outFile, "openWindow(" & ctrl[Name] & ", Normal)\n")
                lineCount += 1
            end if
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)

            if ctrl[TableGenInExw] then
                --regroup the ncontrols
                testncontrols = ncontrols
                newncontrols = {}
                row = 1
                col = 1
                cell = 1
                NControls = 0
                for i=1 to length(testncontrols) do
                    if testncontrols[i][TableCell]=1 then
                        NControls += 1
                    end if
                end for
                newncontrols &= {testncontrols[1]}

                while True do
                    for i=2 to length(testncontrols) do
                        if testncontrols[i][TableCell] then
                            --figure which row and col we are on
                            if testncontrols[i][TableCell]=1 then
                                if testncontrols[i][TableCell]=cell then
                                    row = 1
                                    col = 1
                                    cell = 2    --the next cell to look for
                                    --remove cell from testncontrols and add to newncontrols                                                                
                                    newncontrols &= {testncontrols[i]}
                                    testncontrols[i][TableCell] = 0
                                end if
                            else
                                if testncontrols[i][TableCell]=cell then
                                    --remove cell from testncontrols and add to newncontrols                                                                        
                                    newncontrols &= {testncontrols[i]}
                                    testncontrols[i][TableCell] = 0
                                    cell += 1
                                    col += 1
                                    if testncontrols[1][TableCols]<col then
                                        row += 1
                                        col = 1
                                    end if
                                    if testncontrols[1][TableCols]*testncontrols[1][TableRows]
                                                                                          =cell-1 then
                                        cell = 1
                                    end if
                                end if
                            end if
                        end if
                    end for
                    if testncontrols[1][TableCols]*testncontrols[1][TableRows]*NControls
                                                          =length(newncontrols)-1 then
                        exit
                    end if
                end while

                ncontrols = newncontrols

                --figure my base tableCaptionArray                              
                row = ncontrols[1][TableRows]
                col = ncontrols[1][TableCols]
                controlNo = NControls
                rowIndex = {""}
                colIndex = {{""}}
                controlIndex = {}

                if row>1 then
                    for i=2 to row do
                        rowIndex &= {""}
                    end for
                end if

                colIndex = {rowIndex}
                if col>1 then
                    for i=2 to col do
                        colIndex &= {rowIndex}
                    end for
                end if

                controlIndex = {colIndex}
                if controlNo>1 then
                    for i=2 to controlNo do
                        controlIndex &= {colIndex}
                    end for
                end if

                for i=1 to length(controlIndex) do
                    for j=1 to length(colIndex) do
                        for k=1 to length(rowIndex) do
                            controlIndex[i][j][k] = "c"&sprint(i)&"-"&sprint(j)&"-"&sprint(k)
                        end for
                    end for
                end for

                --go back and change base captions based on empty caption or changed caption in actual control
                --in Properties
                row = 0
                NControls = 0

                for i=2 to length(ncontrols) do
                    if ncontrols[i][TableCell] then
                        if ncontrols[i][TableCell]=1 then
                            --start new control
                            NControls += 1
                            row = 1
                            col = 1
                        else
                            col += 1
                            if col>ncontrols[1][TableCols] then
                                col = 1
                                row += 1
                            end if
                        end if
                        if equal(ncontrols[i][Class],"LabelEdit") then
                            controlIndex[NControls][col][row] = ncontrols[i][ValueEdit]
                        else
                            if not length(ncontrols[i][Title]) then
                                controlIndex[NControls][col][row] = ""
                            else
                                --title changed use it
                                if not equal(ncontrols[i][Title], ncontrols[i][OrigTitle]) then
                                    controlIndex[NControls][col][row] = ncontrols[i][Title]
                                end if
                            end if
                        end if
                    end if
                end for
                NControls = 0

                --build canned code for building the array in the exw
                --the formula for producing the array was contributed by Andy Drummond

                --find cell1 controls for this Table (they should be behind Table control)              
                tx1 = 0 tx2 = 0 ty1 = 0 ty2 = 0 Kx = 0 Ky = 0 Bx = 0 By = 0 parentX = 0 parentY = 0 Ny = 0 Nx = 0 NControls = 0
                offsetX = 0 offsetY = 0 tcx1 = 0 tcy1 = 0

                for i=1 to length(controls) do
                    if equal(ctrl[Name], controls[i][Name]) then
                        parentX = controls[i][X]
                        parentY = controls[i][Y]
                        Nx = ctrl[TableCols]
                        Ny = ctrl[TableRows]
                        if not ctrl[TableGenBorder] then
                            --offset = calculation to adjust cells Y if Table is bounded by Group
                            offset = 0
                        end if

                        for j=2 to length(ncontrols) do
                            if ncontrols[j][TableCell]=1 then
                                NControls += 1
                                --find the cell with the leftmost X
                                if not tx1 then
                                    tx1 = ncontrols[j][X]
                                elsif ncontrols[j][X]<tx1 then
                                    tx1 = ncontrols[j][X]
                                end if
                                --trap control whose width is most to right
                                if not tcx1 then
                                    tcx1 = ncontrols[j][X]+ncontrols[j][CX]
                                    tx2 = ncontrols[j][X]
                                elsif ncontrols[j][X]+ncontrols[j][CX]>tcx1 then
                                    tcx1 = ncontrols[j][X]+ncontrols[j][CX]
                                    tx2 = ncontrols[j][X]
                                end if
                                --find the cell with the lowest Y
                                if not ty1 then
                                    ty1 = ncontrols[j][Y]
                                elsif ncontrols[j][Y]<ty1 then
                                    ty1 = ncontrols[j][Y]
                                end if
                                --trap control whose height is most down
                                if not tcy1 then
                                    tcy1 = ncontrols[j][Y]+ncontrols[j][CY]
                                    ty2 = ncontrols[j][Y]
                                elsif ncontrols[j][Y]+ncontrols[j][CY]>tcy1 then
                                    tcy1 = ncontrols[j][Y]+ncontrols[j][CY]
                                    ty2 = ncontrols[j][Y]
                                end if
                            end if
                        end for
                        --width of cell is CX of widest control in cell less its X
                        --plus difference between X of widest control and leftmost X                                                                                                            
                        if tx2=tx1 then
                            Kx = tcx1-tx2
                        else
                            Kx = (tcx1-tx2)+(tx2-tx1)
                        end if
                        Kx += ctrl[TableColsSpace]
                        if ty2=ty1 then
                            Ky = tcy1-ty2
                        else
                            Ky = (tcy1-ty2)+(ty2-ty1)
                        end if
                        Ky += ctrl[TableRowsSpace]
                        --find the difference of Table and leftmost control
                        Bx = tx1-parentX
                        By = ty1-parentY
                        if not usedGenInExw then
                            puts(outFile, "integer Kx        --Horizontal size of Cell 1 \n")
                            puts(outFile, "integer Ky        --Vertical size of Cell 1 \n")
                            puts(outFile, "integer Nx        --Number of horizontal repeats \n")
                            puts(outFile, "integer Ny        --Number of vertical repeats \n")
                            puts(outFile, "integer Bx        --Offset from LText or Group to leftmost control \n")
                            puts(outFile, "integer By        --Offset from LText or Group to top control \n")
                            puts(outFile, "integer offset    --adjustment for Group top line \n")
                            puts(outFile, "integer NControls --Number of controls in cell 1 to be repeated \n")

                            lineCount += 8
                            usedGenInExw = w32True
                        end if
                        --now go back and generate the statements from cell 1 controls                                  
                        puts(outFile, "sequence " & ctrl[Name] & "CaptionArray \n")
                        puts(outFile, ctrl[Name] & "CaptionArray = \n")
                        puts(outFile, "{")
                        lineCount += 2

                        for p=1 to length(controlIndex) do
                            if p=1 then
                                puts(outFile,"{")
                            else
                                puts(outFile,",{")
                            end if

                            --do controls
                            for c=1 to length(controlIndex[p]) do
                                --do columns
                                if c=1 then
                                    puts(outFile,"{")
                                else
                                    puts(outFile,",{")
                                end if

                                for r=1 to length(controlIndex[p][c]) do
                                    --do rows
                                    if r=1 then
                                        puts(outFile, "\"" & controlIndex[p][c][r] & "\"")
                                    else
                                        puts(outFile, ",\"" & controlIndex[p][c][r] & "\"")
                                    end if

                                    if r=length(controlIndex[p][c]) then
                                        puts(outFile,"}")       --\n") if string gets too long may need to split line										
                                    end if
                                end for

                                if c=length(controlIndex[p]) then
                                    puts(outFile,"}\n")
                                    lineCount += 1
                                end if
                            end for
                        end for
                        puts(outFile, "}\n")
                        lineCount += 1
                        puts(outFile, "Kx = " & sprint(Kx) & "\n")
                        puts(outFile, "Ky = " & sprint(Ky) & "\n")
                        puts(outFile, "Bx = " & sprint(Bx) & "\n")
                        puts(outFile, "By = " & sprint(By) & "\n")
                        puts(outFile, "Nx = " & sprint(Nx) & "\n")
                        puts(outFile, "Ny = " & sprint(Ny) & "\n")
                        puts(outFile, "NControls = " & sprint(NControls) & "\n")
                        puts(outFile, "offset = " & sprint(offset) & "\n")
                        puts(outFile, "--build table by [column][row][cell 1 controls] \n")
                        lineCount += 9
                        if not ctrl[Local] then
                            puts(outFile, "global ")
                        end if
                        puts(outFile, "sequence " & ctrl[Name] & "Array \n")
                        puts(outFile, ctrl[Name] & "Array = repeat(repeat(repeat(0, NControls), Ny), Nx) \n")
                        puts(outFile, "for y = 1 to Ny do \n")
                        puts(outFile, "    for x = 1 to Nx do \n")
                        lineCount += 4
                        NControls = 0

                        for j=2 to length(ncontrols) do
                            if ncontrols[j][TableCell]=1 then
                                NControls += 1
                                                --get the amount this control is different x and y than
                                                --leftmost and lowest x and y                                           
                                if tx1<ncontrols[j][X] then
                                    offsetX = ncontrols[j][X]-tx1
                                else offsetX = 0
                                end if
                                if ty1<ncontrols[j][Y] then
                                    offsetY = ncontrols[j][Y]-ty1
                                else offsetY = 0
                                end if

                                if equal(ncontrols[j][Class], "LabelEdit") then
                                    puts(outFile, ctrl[Name] & "Array[x][y][" & sprint(NControls) & "] = createEx( EditText"
                                         & "," & ctrl[Name] & "CaptionArray[" & sprint(NControls) & "][x][y]," & ctrl[Name] & ", Bx+" & sprint(offsetX) &
                                         "+Kx*(x-1), offset+By+" & sprint(offsetY) & "+Ky*(y-1)," & sprint(ncontrols[j][CX]) & "," &
                                         sprint(ncontrols[j][CY]) & "," & style & "," & exStyle & ") \n")
                                else
                                    puts(outFile, ctrl[Name] & "Array[x][y][" & sprint(NControls) & "] = createEx( "
                                         & ncontrols[j][Class] & "," & ctrl[Name] & "CaptionArray[" & sprint(NControls) & "][x][y],"
                                         & ctrl[Name] & ", Bx+" & sprint(offsetX) &
                                         "+Kx*(x-1), offset+By+" & sprint(offsetY) & "+Ky*(y-1)," & sprint(ncontrols[j][CX]) & "," &
                                         sprint(ncontrols[j][CY]) & "," & style & "," & exStyle & ") \n")
                                end if
                                lineCount += 1
                                makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
                            end if
                        end for
                        puts(outFile, "    end for \n")
                        puts(outFile, "end for \n")
                        lineCount += 2

                        --now go back and asign attributes
                        NControls = 0
                        for j=2 to length(ncontrols) do
                            if ncontrols[j][TableCell]=1 then
                                NControls += 1
                                genInExwAttributes(j,NControls,ncontrols[1][TableRows], ncontrols[1][TableCols],
                                                   outFile, ncontrols[1][Name] & "Array")
                            end if
                        end for
                        exit
                    end if
                end for
            end if
        end if
    end if

    if length(priorTableName)
    and ctrl[TableCell] then
        --we will get these later
        return
    end if

    -- code goes here to set default values for menus,
    -- color, etc.
    if (equal(ctrl[Class], "Window") or childWindow)
    and canUseTransparency
    and ctrl[WinTransparency] then
        printf(outFile,
               "alphablend_SetWinAlpha(getHandle(%s),%d) \n",
               {ctrl[Name],ctrl[WinTransparency]})
        lineCount += 1
    end if

    if (equal(ctrl[Class], "Window") and not childWindow)
    and ctrl[setCreatefont]
    and length(ctrl[FontName]) then
        testStyle = "Normal"
        if ctrl[FontAttrib]
        or length(ctrl[FontVarItalic]) then
            testStyle = "Italic"
        end if
        if ctrl[FontBold]
        or length(ctrl[FontVarBold]) then
            testStyle &= "+Bold"
        end if
        if ctrl[FontUnderline]
        or length(ctrl[FontVarUnderline]) then
            testStyle &= "+Underline"
        end if
        if ctrl[FontStrikeout]
        or length(ctrl[FontVarStrikeout]) then
            testStyle &= "+Strikeout"
        end if
        printf(outFile, "w32VOID=setCreateFont(\"%s\",%d,%s,0) \n",
               {ctrl[FontName],ctrl[FontPts],testStyle})
        lineCount += 1
    end if

    if equal(ctrl[Class], "ListView") then
        if ctrl[SETLVInsert] then
            if not usedOk then
                puts(outFile, "integer IDEok\n")
                lineCount += 1
                usedOk = w32True
            end if
            puts(outFile, "IDEok=setLVInsert(1) \n")
            lineCount += 1
        end if
        if length(ctrl[IcoFile]) then
            --in ListView the IcoFile is a sequence of icons
            for i=1 to length(ctrl[IcoFile]) do
                listViewCounter += 1
                testIco = ctrl[IcoFile][i]
                at = match(lower(projectDir), lower(testIco))
                if at then
                    testIco = testIco[at+1+length(projectDir)..length(testIco)]
                end if
                newIco = {}
                at = match("\\", testIco)
                if at then
                    newIco = testIco[1..at] & "\\"
                    testIco = testIco[at+1..length(testIco)]
                    while at do
                        at = match("\\", testIco)
                        if at then
                            newIco &= testIco[1..at] & "\\"
                            testIco = testIco[at+1..length(testIco)]
                        else
                            newIco &= testIco[1..length(testIco)]
                        end if
                    end while
                else
                    newIco &= testIco[1..length(testIco)]
                end if

                puts(outFile, "constant LVIcon" & sprint(listViewCounter) & " = addIcon(extractIcon(\""
                     & newIco & "\") ) \n")
                lineCount += 1
                makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
            end for
        end if
    end if

    if equal(ctrl[Class], "TreeView")
    and not usedTree then
        if length(ctrl[TwoIcoFile]) then
            testIco = ctrl[TwoIcoFile]
            at = match(lower(projectDir), lower(testIco))
            if at then
                testIco = testIco[at+1+length(projectDir)..length(testIco)]
            end if
            newIco = {}
            at = match("\\", testIco)
            if at then
                newIco = testIco[1..at] & "\\"
                testIco = testIco[at+1..length(testIco)]
                while at do
                    at = match("\\", testIco)
                    if at then
                        newIco &= testIco[1..at] & "\\"
                        testIco = testIco[at+1..length(testIco)]
                    else
                        newIco &= testIco[1..length(testIco)]
                    end if
                end while
            else
                newIco &= testIco[1..length(testIco)]
            end if
            --add " front and back
            newIco = "\"" & newIco & "\""
            puts(outFile, "constant closefolder = addIcon( extractIcon(" & newIco & ") )\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
            usedTree = w32True
        end if
        if length(ctrl[TriIcoFile]) then
            testIco = ctrl[TriIcoFile]
            newIco = {}
            at = match(lower(projectDir), lower(testIco))
            if at then
                testIco = testIco[at+1+length(projectDir)..length(testIco)]
            end if
            at = match("\\", testIco)
            if at then
                newIco = testIco[1..at] & "\\"
                testIco = testIco[at+1..length(testIco)]
                while at do
                    at = match("\\", testIco)
                    if at then
                        newIco &= testIco[1..at] & "\\"
                        testIco = testIco[at+1..length(testIco)]
                    else
                        newIco &= testIco[1..length(testIco)]
                    end if
                end while
            else
                newIco &= testIco[1..length(testIco)]
            end if
            newIco = "\"" & newIco & "\""
            puts(outFile, "constant openfolder  = addIcon( extractIcon(" & newIco & ") )\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
            usedTree = w32True
        end if
    end if

    if find(ctrl[Class], {"Menu","MenuItem","Popup","PopupItem"}) then
        if not ctrl[Enabled] then
            puts(outFile, "setEnable( " & ctrl[Name] & ", w32False )\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        end if
    end if

    if equal(ctrl[Class], "Window")
    and sequence(ctrl[Style])
    and match("WS_CHILD,",ctrl[Style]) then
        puts(outFile, "moveZOrder( " & ctrl[Name] & ", HWND_TOP)\n")
        lineCount += 1
        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
    end if

    if ctrl[Checked] then
        puts(outFile, "setCheck( " & ctrl[Name] & ", w32True )\n")
        lineCount += 1
        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
    end if


    if not ctrl[Visible] then
        puts(outFile, "setVisible( " & ctrl[Name] & ", w32False )\n")
        lineCount += 1
        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
    end if

    if not find(ctrl[Class], {"Menu","MenuItem","Popup","PopupItem"}) then
        if not ctrl[EnableC] then
            disableArray &= {ctrl[Name]}
        end if
    end if

    if ctrl[Limit]
    and not equal(ctrl[Class],"EuGrid") then
        --if RichEdit put out sendMesage instead of limitText
        if not equal(ctrl[Class], "RichEdit") then
            puts(outFile, "limitText( " & ctrl[Name] & "," & sprint(ctrl[Limit])
                 & ")\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        else
            --dont do this statement if already have in this run
            if not usedOk then
                puts(outFile, "integer IDEok\n")
                lineCount += 1
                usedOk = w32True
            end if
            puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",197," & sprint(ctrl[Limit])
                 & ",0)\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        end if
    end if

    if ctrl[TxtColor] then
        puts(outFile, "setTextColor( " & ctrl[Name] & ","  & sprint(ctrl[TxtColor]) & ")\n")
        lineCount += 1

        if equal(ctrl[SeqParentClass], "TabItem") then
            --these controls when on TabItem and setting text color must also set the background color        
            if not ctrl[BkColor] then
                if find(ctrl[Class],{"EditText","List"}) then
                    puts(outFile, "setWindowBackColor( " & ctrl[Name] & ", " & sprint(WindowColor) & ")\n")
                    lineCount += 1
                elsif find(ctrl[Class],{"LText","CText","RText"}) then
                    puts(outFile, "setWindowBackColor( " & ctrl[Name] & ", " & sprint(getSysColor(COLOR_BTNFACE)) & ")\n")
                    lineCount += 1
                end if
            end if
        else
            --these controls when setting text color must also repaint for the new color to show  
            if not ctrl[BkColor]
            and find(ctrl[Class],{"LText","CText","RText"}) then
                puts(outFile, "repaintFG( " & ctrl[Name] & " )\n")
                lineCount += 1
            end if
            if not ctrl[BkColor]
            and find(ctrl[Class],{"EditText","List"}) then
                puts(outFile, "setWindowBackColor( " & ctrl[Name] & ", " & sprint(WindowColor) & ")\n")
                lineCount += 1
            end if
        end if
    end if

    if ctrl[BkColor] then
        --insert Black if bkcolor < 0
        if equal(ctrl[Class], "RichEdit") then
            --dont do this statement if already have in this run
            if not usedOk then
                puts(outFile, "integer IDEok\n")
                lineCount += 1
                usedOk = w32True
            end if
            if ctrl[BkColor]<0 then
                puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",1091,0, Black"
                     & " )\n")
                lineCount += 1
            else
                puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",1091,0," & sprint(ctrl[BkColor])
                     & " )\n")
                lineCount += 1
            end if
        elsif equal(ctrl[Class], "StatusBar") then
            --dont do this statement if already have in this run
            if not usedOk then
                puts(outFile, "integer IDEok\n")
                lineCount += 1
                usedOk = w32True
            end if
            if ctrl[BkColor]<0 then
                puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",#2001,0,Black" --SB_SETBKCOLOR
                     & " )\n")
                lineCount += 1
            else
                puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",#2001,0," & sprint(ctrl[BkColor])
                     & " )\n")
                lineCount += 1
            end if
        elsif equal(ctrl[Class], "ProgressBar") then
            --dont do this statement if already have in this run
            if not usedOk then
                puts(outFile, "integer IDEok\n")
                lineCount += 1
                usedOk = w32True
            end if
            if ctrl[BkColor]<0 then
                puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",#2001,0,Black" --SB_SETBKCOLOR
                     & " )\n")
                lineCount += 1
            else
                puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",#2001,0," & sprint(ctrl[BkColor])
                     & " )\n")
                lineCount += 1
            end if                                                      --SB_SETBKCOLOR
            if ctrl[BkBarColor]<0 then
                puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",#0409,0,Black"
                     & " )\n")                                                                  --SB_SETBARCOLOR
                lineCount += 1
            else
                if ctrl[BkBarColor] then
                    puts(outFile, "IDEok=sendMessage( " & ctrl[Name] & ",#0409,0," & sprint(ctrl[BkBarColor])
                         & " )\n")                                                                  --SB_SETBARCOLOR
                    lineCount += 1
                end if
            end if
        else
            if length(ctrl[SystemBkColor]) then
                --find the text name in validColors and use its occurance to get number call
                at = find(ctrl[SystemBkColor], validColors)
                if at=1 then
                    if not equal(ctrl[Class],"EuGrid")
                    and not equal(ctrl[SeqParentClass],"EuGrid")
                    and ctrl[BkColor]!=getSysColor(COLOR_BTNFACE) then
                        puts(outFile, "setWindowBackColor( " & ctrl[Name] & ","
                             & sprint(ctrl[BkColor]) & ")\n")
                        lineCount += 1
                    end if
                elsif at>2 then
                    thecolor = prepend(validColors[at],'_')
                    thecolor = prepend(thecolor, 'R')
                    thecolor = prepend(thecolor, 'O')
                    thecolor = prepend(thecolor, 'L')
                    thecolor = prepend(thecolor, 'O')
                    thecolor = prepend(thecolor, 'C')
                    puts(outFile, "setWindowBackColor( " & ctrl[Name] & ", getSysColor("
                         & thecolor & "))\n")
                    lineCount += 1
                end if
            else
                if not equal(ctrl[Class],"EuGrid")
                and not equal(ctrl[SeqParentClass],"EuGrid") then
                    if ctrl[BkColor]!=getSysColor(COLOR_BTNFACE) then
                        puts(outFile, "setWindowBackColor( " & ctrl[Name] & ","
                             & sprint(ctrl[BkColor]) & " )\n")
                        lineCount += 1
                    end if
                end if
            end if
        end if
        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
    else
        --if the selected system color value is 0 then put out Black            
        if length(ctrl[SystemBkColor]) then
            at = find(ctrl[SystemBkColor], validColors)
            if at=1 then
                if not equal(ctrl[Class],"EuGrid")
                and not equal(ctrl[SeqParentClass],"EuGrid")then
                    puts(outFile, "setWindowBackColor( " & ctrl[Name] & ", Black"
                         & ")\n")
                    lineCount += 1
                end if
            elsif at>1 then
                puts(outFile, "setWindowBackColor( " & ctrl[Name] & ", Black"
                     & ")\n")
                lineCount += 1
            end if
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        end if
    end if

    if ctrl[PB_Caption_Pos] then
        puts(outFile, "removeStyle( " & ctrl[Name] & ", BS_CENTER )\n")
        if ctrl[PB_Caption_Pos]=1 then
            puts(outFile, "addStyle( " & ctrl[Name] & ", BS_LEFT )\n")
        else
            puts(outFile, "addStyle( " & ctrl[Name] & ", BS_RIGHT )\n")
        end if
        lineCount += 2
    end if

    if length(ctrl[HintText])
    or length(ctrl[HintVarText]) then
        hintarray &= {{ctrl[Name],IDE_hinttext}}        --ctrl[HintText]} }
        hintFound = w32True
    end if

    if length(ctrl[HintFontName])
    or length(ctrl[HintFontVarName]) then
        --REMEMBER to set Hint before setHintFont!! or get Win32Lib error
        hintFontFound = w32True
    end if

    --if Table was assigned a font, it applies to all the cells in it
    if ctrl[TableCell] then
        if length(priorFontName)
        and not length(ctrl[FontName])
        and not length(ctrl[FontVarName]) then
            puts(outFile, "setFont( " & ctrl[Name] &  "," & priorFontName & ","
                 & priorFontPts & "," & priorFontAttrib & ")\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        end if
    end if
    --but can be overridden by the font on the particular cell
    if length(ctrl[FontName])
    or length(ctrl[FontVarName]) then
        if length(ctrl[FontName]) then
            IDE_fontName = "\"" & ctrl[FontName] & "\""
        end if
        if length(ctrl[FontVarName]) then
            IDE_fontName = ctrl[FontVarName]
        end if
        --if control is not a RichEdit control
        if not equal(ctrl[Class], "RichEdit") then
            puts(outFile, "setFont( " & ctrl[Name] & "," & IDE_fontName & ","
                 & IDE_fontPts & "," & fontStyle & ")\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        else
            --when rich edit add color before the fontName and also write a
            --setIndex for the length of the text, otherwise the setFont will
            --not work.
            puts(outFile, "setIndex( " & ctrl[Name] & ",{1, length(getText(" &
                 ctrl[Name] & "))+1} )\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)

            puts(outFile, "setFont( " & ctrl[Name] & ",{" & IDE_fontColor & "," & IDE_fontName & "},"
                 & IDE_fontPts & "," & fontStyle & ")\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)

            puts(outFile, "setIndex( " & ctrl[Name] & ",length(getText("
                 & ctrl[Name] & "))+1 )\n")
            lineCount += 1
            makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
        end if
    end if

    if length(ctrl[IcoFile])
    and not equal(ctrl[ParentClass], "FlatToolBar")
    and not equal(ctrl[Class],"ListView") then
        saveName = {}
        examDocs = ctrl[IcoFile]
        at = match(lower(projectDir), lower(examDocs))
        if at then
            examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
        end if
        at = 1
        while at do
            at = 0
            for j=1 to length(examDocs) do
                if examDocs[j]='\\' then
                    saveName &= examDocs[1..j-1] & "\\\\"
                    examDocs = examDocs[j+1..length(examDocs)]
                    at = 1
                    exit
                end if
            end for
        end while
        saveName &= examDocs
        puts(outFile, "setIcon( " & ctrl[Name] & ",\""
             & saveName & "\")\n")
        lineCount += 1
        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
    end if

    if length(ctrl[BitmapFile]) then
        saveName = {}
        examDocs = ctrl[BitmapFile]
        at = match(lower(projectDir),lower(examDocs))
        if at then
            examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
        end if
        at = 1
        while at do
            at = 0
            for j=1 to length(examDocs) do
                if examDocs[j]='\\' then
                    saveName &= examDocs[1..j-1] & "\\\\"
                    examDocs = examDocs[j+1..length(examDocs)]
                    at = 1
                    exit
                end if
            end for
        end while
        saveName &= examDocs
        if equal(ctrl[Class], "Pixmap") then
            puts(outFile, "setPixmap( " & ctrl[Name] & ",\""
                 & saveName & "\")\n")
            lineCount += 1
        else
            --Put out setBitmap only if not coloredButton
            if ctrl[cbColor]
            or ctrl[TableButtonAllColor]
            or ctrl[TreatAsColorButton] then
                                --will be a colored button
            else
                puts(outFile, "setBitmap( " & ctrl[Name] & ",\""
                     & saveName & "\")\n")
                lineCount += 1
            end if
        end if
        makeNameEventLine(windowNumber, ctrl[Name], "create", lineCount)
    end if

    if length(ctrl[InitialVal])
    and not equal(ctrl[Class], "ListView") then
        for i=1 to length(ctrl[InitialVal]) do
            puts(outFile, "addItem(" & ctrl[Name] & ", \""
                 & ctrl[InitialVal][i] & "\")\n")
            lineCount += 1
        end for
    end if

    graphicName = {}
    if length(ctrl[BitmapFile]) then
        --this entry might be an actual file name or a handle from win32eru which will be
        --further converted below.
        graphicName = ctrl[BitmapFile]
        at = match(lower(projectDir), lower(graphicName))
        if at then
            graphicName = graphicName[at+1+length(projectDir)..length(graphicName)]
        end if
    end if

    if length(ctrl[XPM]) then
        graphicName = ctrl[XPM]
        at = match(lower(projectDir), lower(graphicName))
        if at then
            graphicName = graphicName[at+1+length(projectDir)..length(graphicName)]
        end if
    end if

    if length(graphicName) then
        examDocs = graphicName
        saveName = {}
        at = 1
        while at do
            at = 0
            for k=1 to length(examDocs) do
                if examDocs[k]='\\' then
                    saveName &= examDocs[1..k-1] & "\\\\"
                    examDocs = examDocs[k+1..length(examDocs)]
                    at = 1
                    exit
                end if
            end for
        end while
        saveName &= examDocs
        graphicName = saveName
    end if

    if find(ctrl[Class],{"PushButton","PictureButton","ToggleButton","TogglePicture","DefPushButton",
                         "CancelButton"}) then
        if ctrl[TableButtonAllColor]
        or ctrl[TreatAsColorButton] then
            puts(outFile, "translateToColoredButton(" & ctrl[Name] & ", {}, {})\n")
            puts(outFile, "initiateColoredButtons()\n")
            lineCount += 2

            if ctrl[cbMultiline] then
                puts(outFile, "multilineCBCaption(" & ctrl[Name] & ", w32True)\n")
                lineCount += 1
            end if

            if ctrl[cbFlat] then
                replaceClass = "FlatButton"
                puts(outFile, "changeCBClass(" & ctrl[Name] & ", " & "\"" & replaceClass & "\")\n")
                lineCount += 1
            end if

            if ctrl[cbCentVert] then
                puts(outFile, "centerVerticallyCBText(" & ctrl[Name] & " , w32True)\n")
                lineCount += 1
            else
                puts(outFile, "centerVerticallyCBText(" & ctrl[Name] & " , w32False)\n")
                lineCount += 1
            end if

            if not ctrl[cbColor] then
                puts(outFile, "changeCBColor(" & ctrl[Name] & ", 1, " & sprint(getSysColor(COLOR_BTNFACE)) & ")\n")
            else
                puts(outFile, "changeCBColor(" & ctrl[Name] & ", 1, " & sprint(ctrl[cbColor]) & ")\n")
            end if

            lineCount += 1
            if not length(ctrl[XpmObject])
            and not length(ctrl[XPMmember]) then
                lineCount += 1
                --look to see if there is a crossreference in convertNameToHandle[1] for graphicName
                --if so put out convertNameToHandle[2] instead of graphicName
                puts(outFile, "addCBGraphic(" & ctrl[Name] & ", 1, \"" & graphicName & "\")\n")
            end if
            --XpmObject has been moved to behind preparedTheXpmObjectStatements so I have the handle                        


            if ctrl[cbPressColor] then
                puts(outFile, "changeCBColor(" & ctrl[Name] & ", 2, " & sprint(ctrl[cbPressColor]) & ")\n")
                lineCount += 1
            end if

            if ctrl[cbCaptionColor] then
                puts(outFile, "changeCBTextColor(" & ctrl[Name] & ", 1, " & sprint(ctrl[cbCaptionColor]) & ")\n")
                lineCount += 1
            end if

            if ctrl[cbPressCaptionColor] then
                puts(outFile, "changeCBTextColor(" & ctrl[Name] & ", 2, " & sprint(ctrl[cbPressCaptionColor]) & ")\n")
                lineCount += 1
            end if

            if ctrl[cbThickness] then
                puts(outFile, "changeBorderThickness(" & ctrl[Name] & ", " & sprint(ctrl[cbThickness]) & ")\n")
                lineCount += 1
            end if

            if ctrl[cbGraphicPos] then
                if ctrl[cbGraphicPos]=1 then
                    puts(outFile, "moveCBGraphic(" & ctrl[Name] & ", 1)\n")
                elsif ctrl[cbGraphicPos]=2 then
                    puts(outFile, "moveCBGraphic(" & ctrl[Name] & ", 0)\n")
                elsif ctrl[cbGraphicPos]=3 then
                    puts(outFile, "moveCBGraphic(" & ctrl[Name] & ", 2)\n")
                end if
                lineCount += 1
            end if

            if ctrl[cbCaptionPos] then
                if ctrl[cbCaptionPos]=1 then
                    puts(outFile, "moveCBCaption(" & ctrl[Name] & ", 1)\n")
                elsif ctrl[cbCaptionPos]=2 then
                    puts(outFile, "moveCBCaption(" & ctrl[Name] & ", 0)\n")
                elsif ctrl[cbCaptionPos]=3 then
                    puts(outFile, "moveCBCaption(" & ctrl[Name] & ", 2)\n")
                elsif ctrl[cbCaptionPos]=4 then
                    puts(outFile, "moveCBCaption(" & ctrl[Name] & ", 3)\n")
                end if
                lineCount += 1
            end if
        end if
    end if

    if length(ctrl[DEFIndex]) then
        --only for List, SortedList
        --I got this routine from Aku
        --who got it from someone else:
        -- set on-off of multi-select list box
        -- setMany(list, {index,...}, on_or_off)
        -- setMany(list, {0,-1}, 1) to select all
        puts(outFile, "constant IDE_LB_SETSEL = 389 \n")
        puts(outFile, "sequence IDEselectlist \n")
        if equal(upper(ctrl[DEFIndex]), "ALL") then
            puts(outFile, "IDEselectlist={0,-1}\n")
        else
            puts(outFile, "IDEselectlist={" & ctrl[DEFIndex] & "}\n")
        end if
        puts(outFile, "--routine contributed by Aku \n")
        puts(outFile, "procedure setMany(integer id, sequence idx, integer onoff)\n")
        puts(outFile, "atom VOID\n")
        puts(outFile, "idx -= 1\n")
        puts(outFile, "if equal(idx, {0,-1}) then\n")
        puts(outFile, "    for i = 1 to getCount(id) do\n")
        puts(outFile, "        VOID = sendMessage( id, IDE_LB_SETSEL, onoff, i-1 )\n")
        puts(outFile, "    end for\n")
        puts(outFile, "else\n")
        puts(outFile, "    for i = 1 to length(idx) do\n")
        puts(outFile, "        VOID = sendMessage( id, IDE_LB_SETSEL, onoff, idx[i] )\n")
        puts(outFile, "    end for\n")
        puts(outFile, "end if\n")
        puts(outFile, "end procedure\n")
        puts(outFile, "setMany(" & ctrl[Name] & ",IDEselectlist, w32True)\n")
        lineCount += 18
    end if

    if ctrl[MinValue]
    or ctrl[MaxValue] then
        lineCount += 1
        puts(outFile, "setScrollRange( " & ctrl[Name] & ", "
             & sprint(ctrl[MinValue]) & ", " & sprint(ctrl[MaxValue])
             & ")\n")
    end if

    if ctrl[LineChg]
    or ctrl[PageChg] then
        puts(outFile, "setScrollChange( " & ctrl[Name] & ", "
             & sprint(ctrl[LineChg]) & ", " & sprint(ctrl[PageChg])
             & ")\n")
        lineCount += 1
    end if

--    if equal( parent, ctrl[SeqParentName] )
    if length(rebarParent) then
        puts(outFile, "addToBand( " & ctrl[Name] & ", " & rebarParent & ")\n")
        lineCount += 1
    end if

    if length(ctrl[ExtExStyle]) then
        --ListView sendMessages
        for i=1 to length(ctrl[ExtExStyle]) do
            if find(ctrl[ExtExStyle][i],{"LVS_EX_UNDERLINECOLD","LVS_EX_UNDERLINEHOT",
                                         "LVS_EX_TRACKSELECT","LVS_EX_TWOCLICKACTIVATE",
                                         "LVS_EX_ONECLICKACTIVATE","LVS_EX_FLATSB",
                                         "LVS_EX_FULLROWSELECT","LVS_EX_HEADERDRAGDROP",
                                         "LVS_EX_CHECKBOXES","LVS_EX_GRIDLINES"}) then
                if firstLV then
                    puts(outFile, "atom lvMask \n")
                    puts(outFile, "integer lvOk \n")
                    lineCount += 2
                    firstLV = w32False
                end if
                puts(outFile, "lvMask = w32or_all({" & ctrl[ExtExStyle][i] & "})\n")
                puts(outFile, "lvOk = sendMessage(" & ctrl[Name] & ",LVM_SETEXTENDEDLISTVIEWSTYLE,lvMask,lvMask)\n")
                lineCount += 2
            end if

            at = match("LVM_SETBKCOLOR", ctrl[ExtExStyle][i])
            if at then
                len = ctrl[ExtExStyle][i][at+15..length(ctrl[ExtExStyle][i])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        puts(outFile, "integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile, "lvOk = sendMessage(" & ctrl[Name]
                         & ",LVM_SETBKCOLOR,0," & sprint(Len[2]) & ")\n")
                    lineCount += 1
                end if
            end if
            at = match("LVM_SETTEXTBKCOLOR", ctrl[ExtExStyle][i])
            if at then
                len = ctrl[ExtExStyle][i][at+19..length(ctrl[ExtExStyle][i])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        puts(outFile, "integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile, "lvOk = sendMessage(" & ctrl[Name]
                         & ",LVM_SETTEXTBKCOLOR,0," & sprint(Len[2]) & ")\n")
                    lineCount += 1
                end if
            end if
            at = match("LVM_SETTEXTCOLOR", ctrl[ExtExStyle][i])
            if at then
                len = ctrl[ExtExStyle][i][at+17..length(ctrl[ExtExStyle][i])]
                Len = value(len)
                if Len[1]=GET_SUCCESS then
                    if firstLV then
                        puts(outFile, "integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile, "lvOk = sendMessage(" & ctrl[Name]
                         & ",LVM_SETTEXTCOLOR,0," & sprint(Len[2]) & ")\n")
                    lineCount += 1
                end if
            end if
        end for
    end if

    if length(ctrl[InitialVal])
    and equal(ctrl[Class], "ListView") then
        --create the lvItems list
        if firstLvItems then
            puts(outFile, "sequence IDElvItems\n")
            puts(outFile, "sequence IDElvData\n")
            puts(outFile, "integer IDElvItemNo\n")
            lineCount += 3
            firstLvItems = w32False
        end if
        puts(outFile, "IDElvItems = {}\n")
        puts(outFile, "IDElvData = {}\n")
        lineCount += 2
        --find the first LVIcon number which was used to generate the image lists
        --above
        if length(ctrl[IcoFile]) then
            listViewCounter -= length(ctrl[IcoFile])
        end if
        --now take icon data and row data and combine
        for i=1 to length(ctrl[InitialVal]) do
            listViewCounter += 1
            cleanSeq = cleanListView(ctrl[InitialVal][i])
            if length(ctrl[IcoFile]) then
                puts(outFile, "IDElvData={LVIcon" & sprint(listViewCounter) & "," &
                     cleanSeq & "}\n")
            else
                puts(outFile, "IDElvData={0," & cleanSeq & "}\n")
            end if
            puts(outFile, "IDElvItems &= {IDElvData}\n")
            lineCount += 2
        end for
        puts(outFile, "for i=1 to length(IDElvItems) do \n")
        puts(outFile, "    IDElvItemNo = addLVItem( " &ctrl[Name] & ", IDElvItems[i][1], IDElvItems[i][2..length(IDElvItems[i])] )\n")
        puts(outFile, "end for\n")
        lineCount += 3
    end if
--VOID=message_box("put send messages here","",0)
    if length(ctrl[ExtExStyle]) then
        for i=1 to length(ctrl[ExtExStyle]) do
            at = match("LVM_SETCOLUMNWIDTH", ctrl[ExtExStyle][i])
            if at then
                len = {}
                --find the width; we have three cases -1, -2 and actual length
--6-11-08                
                if match("-2 Column",ctrl[ExtExStyle][i]) then  --Fit title                
                    if firstLV then
                        puts(outFile, "integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile, "lvOk = sendMessage(" & ctrl[Name]
                         & ",LVM_SETCOLUMNWIDTH," & sprint(i-1) & ",-2" & ")\n")
                    lineCount += 1
                elsif match("-1 Column",ctrl[ExtExStyle][i]) then       --Fit data                              
                    if firstLV then
                        puts(outFile, "integer lvOk \n")
                        lineCount += 1
                        firstLV = w32False
                    end if
                    puts(outFile, "lvOk = sendMessage(" & ctrl[Name]
                         & ",LVM_SETCOLUMNWIDTH," & sprint(i-1) & ",-1" & ")\n")
                    lineCount += 1
--ended 06-11-08        
                elsif match(" Column ", ctrl[ExtExStyle][i]) then
                    at1 = match(" Column ", ctrl[ExtExStyle][i])
                    if at1 then
                        --have actual length for a row
                        len = ctrl[ExtExStyle][i][at+19..at1-1]
                        column = ctrl[ExtExStyle][i][at1+8..length(ctrl[ExtExStyle][i])]
                        at2 = match("OVR",column)
                        if at2 then column = column[1..at2-1] end if
                        Len = value(len)
                        if Len[1]=GET_SUCCESS then
                            Column = value(column)
                            if Column[1]=GET_SUCCESS then
                                if firstLV then
                                    puts(outFile, "integer lvOk \n")
                                    lineCount += 1
                                    firstLV = w32False
                                end if
                                --ok to write the sendMessage
                                puts(outFile, "lvOk = sendMessage(" & ctrl[Name]
                                     & ",LVM_SETCOLUMNWIDTH," & sprint(Column[2]-1)
                                     & "," & sprint(Len[2]) & ")\n")
                                lineCount += 1
                            end if
                        end if
                    end if
                end if
            end if
        end for
    end if
    if usedCCWinStyle then
        puts(outFile, "IDEFlags = classDefaults( Window, {{CCwinstyle,{0}}})\n")
        lineCount += 1
    end if

end procedure
-----------------------------------------------------------------------------
procedure containsCrashFile(sequence text)
integer at, at2

    if not length(text) then
        return
    end if
    --is crash_file here?
    at = match("crash_file", text)
    at2 = match("--",text)
    if at
    and at2
    and at2<at then
        --ignore crash_file if commented
        return
    end if
    if at then
        text = text[at+10..length(text)]
        at = match("\"", text)
        if at then
            text = text[at+1..length(text)]
            at2 = match("\"",text)
            if at2 then
                crashfile = text[1..at2-1]
            end if
        end if
    end if

    if not length(crashfile) then
        return
    end if

    --need to remove a slash from file
    while w32True do
        at = match("\\\\", crashfile)
        if at then
            crashfile = crashfile[1..at]&crashfile[at+2..length(crashfile)]
        else
            exit
        end if
    end while
end procedure
--------------------------------------------------------------------------------
function findId(integer lookAt,sequence text)
sequence name
    name = {}
    for i=1 to length(text) do
        if text[lookAt]='(' then
            for j=lookAt+1 to length(text) do
                if text[j]!=32
                and text[j]!=','
                and text[j]!=')' then
                    name = append(name,text[j])
                end if
                if text[j]=','
                or text[j]=')'then
                    exit
                end if
            end for
            for k=1 to length(windows) do
                for m=1 to length(windows[k]) do
                    if equal(name,windows[k][m][Name]) then
                        if windows[k][m][TreatAsColorButton] then
                            return {1,name}
                        end if
                    end if
                end for
            end for
            return {0,name}
        end if
        return {0,name}
    end for
end function
--------------------------------------------------------------------------------
function parseForRoutineNameChange(sequence text)
--parse for Win32lib routine name that needs to be ColoredButton.ew name
integer lookAt
object result
    lookAt = match("setText", text)
    if lookAt then
        --find the id                        
        result = findId(lookAt+7,text)
        if result[1]=w32True then
            text = text[1..lookAt-1] & "changeCBCaption" & text[lookAt+7..length(text)]
        end if
    end if
    lookAt = match("setEnable", text)
    if lookAt then
        result = findId(lookAt+9,text)
        if result[1]=w32True then
            text = text[1..lookAt-1] & "setEnable" & text[lookAt+9..length(text)]
            text &= " forceCBPaint(" & result[2] & ")"
        end if
    end if
    lookAt = match("setVisible", text)
    if lookAt then
        result = findId(lookAt+10,text)
        if result[1]=w32True then
            text = text[1..lookAt-1] & "setVisible" & text[lookAt+10..length(text)]
            text &= " forceCBPaint(" & result[2] & ")"
        end if
    end if
    lookAt = match("setFocus", text)
    if lookAt then
        result = findId(lookAt+8,text)
        if result[1]=w32True then
            text = text[1..lookAt-1] & "setCBFocus" & text[lookAt+8..length(text)]
        end if
    end if
    lookAt = match("setHint", text)
    if lookAt then
        result = findId(lookAt+7,text)
        if result[1]=w32True then
            text = text[1..lookAt-1] & "setCBHint" & text[lookAt+7..length(text)]
            text &= " forceCBPaint(" & result[2] & ")"
        end if
    end if
    lookAt = match("setFont", text)
    if lookAt then
        result = findId(lookAt+7,text)
        if result[1]=w32True then
            text = text[1..lookAt-1] & "setCBFont" & text[lookAt+7..length(text)]
        end if
    end if
    lookAt = match("setDefaultFont", text)
    if lookAt then
        result = findId(lookAt+14,text)
        if result[1]=w32True then
            text = text[1..lookAt-1] & "setCBDefaultFont" & text[lookAt+14..length(text)]
        end if
    end if
    return text
end function
---------------------------------------------------------------------------------
sequence priorEvent, w32HName
priorEvent = {}
w32HName = {}

procedure writeControlCodeToExw(integer outFile, sequence ctrl, integer windowNumber)

-- generate code associated with a control
sequence text, theName
integer header, hasData

    -- sort the change name array so deal with long names first
    -- so will not get a match when the shorter name is a portion of the longer
    if equal(ctrl[Class],"Timer") then  --Timer can not have code
        return
    end if

    if equal(ctrl[Class],"Menu")
    and not match("!",ctrl[Title]) then --!Menu only can have code
        return
    end if

    changeNameToIndex = sort(changeNameToIndex)
    changeNameToIndex = reverse(changeNameToIndex)

    -- examine each to see if code is associated
    -- skip Intro and Begin   -- they are already done before this routine
    -- skip Final -- it will be done after this routine 
    for events=1 to length(ctrl[Code]) do
        -- code?
        text = ctrl[Code][events]
        if length(text) then
            if events!=General
            and events!=Intro
            and events!=Final
            and events!=Begin then
                hasData = w32False

                for i=1 to length(text) do
                    if match("end procedure", text[i]) then
                        exit
                    end if
                    if match("procedure", text[i]) then
                            --ignore
                    elsif length(text[i]) then
                        hasData = w32True
                        containsCrashFile(text[i])

                        text[i] = parseForRoutineNameChange(text[i])

                        exit
                    end if
                end for

                if hasData then

                    header = findIfHasHeader(text)

                    -- line break
                    puts(outFile, repeat('-', 80) & cr)
                    lineCount += 1

                    if not header then
                        --attach a header
                        puts(outFile, "procedure "
                             & ctrl[Name]
                             & "_"
                             & Events[events][1]             -- event name
                             & " (integer self, integer event, sequence params)"
                             & cr)

                        lineCount += 1
                        makeNameEventLine(windowNumber, ctrl[Name], Events[events][1], lineCount)
                    end if

                    -- output the code
                    for i=1 to length(text) do
                        --look at text for one of the array names and
                        --change to the index
                        if ctrl[TableCell] then
                            text[i] = convertToArrayName(text[i])
                        end if
                        containsCrashFile(text[i])
                        if equal(text[i], "end procedure") then
                            --event is one in which setTimer or killTimer needs to be
                            --added, do it now
                            for j=1 to length(windows[windowNumber]) do
                                if equal(windows[windowNumber][j][Class], "Timer") then
                                    if length(windows[windowNumber][j][SetEvent])
                                    and equal(windows[windowNumber][j][SetControl], ctrl[Name]) then
                                        if equal(windows[windowNumber][j][SetEvent], Events[events][1]) then
                                            puts(outFile, "-- Generated by IDE for Timer in " & Events[events][1] & "\n")
                                            puts(outFile, "setTimer ( "
                                                 & windows[windowNumber][1][Name]
                                                 & ", " & windows[windowNumber][j][Name] & ", "
                                                 & sprint(windows[windowNumber][j][TimerInt]) & " )\n")
                                            lineCount += 2
                                        end if
                                    end if
                                    if length(windows[windowNumber][j][KillEvent])
                                    and equal(windows[windowNumber][j][KillControl], ctrl[Name]) then
                                        if equal(windows[windowNumber][j][KillEvent], Events[events][1]) then
                                            puts(outFile, "-- Generated by IDE for Timer in " & Events[events][1] & "\n")
                                            puts(outFile, "killTimer ( "
                                                 & windows[windowNumber][1][Name]
                                                 & ", " & windows[windowNumber][j][Name] & " )\n")
                                            lineCount += 2
                                        end if
                                    end if
                                end if
                            end for
                        end if

                        puts(outFile, text[i] & '\n')
                        lineCount += 1

                        if header
                        and i=1 then
                            makeNameEventLine(windowNumber, ctrl[Name], Events[events][1], lineCount)
                        end if
                    end for

                    -- attach the callback
                    theName = ctrl[Name]

                    --look at text for one of the array names and
                    --change to the index
                    if ctrl[TableCell] then
                        ctrl[Name] = convertToArrayName(ctrl[Name])
                    end if

                    if not header then
                        w32HName = "w32H"
                        for i=3 to length(Events[events][1]) do
                            w32HName = append(w32HName, Events[events][1][i])
                        end for
                        printf(outFile, "setHandler(%s, %s, routine_id(\"%s_%s\"))" & cr & cr,
                               {ctrl[Name],w32HName,theName,Events[events][1]})
                        lineCount += 2
                    end if
                end if

            else

                --it should be General
                if events!=Intro and events!=Begin and events!=Final then
                    -- line break
                    puts(outFile, repeat('-', 80) & cr)
                    lineCount += 1
                    if events=General then
                        makeNameEventLine(windowNumber, ctrl[Name], "(General)", lineCount+1)
                    end if
                end if
                -- output the code
                for i=1 to length(text) do
                    if events!=Begin and events!=Intro and events!=Final then
                        --look at text for one of the array names and
                        --change to the index
                        if ctrl[TableCell] then
                            text[i] = convertToArrayName(text[i])
                        end if
                        containsCrashFile(text[i])
                        text[i] = parseForRoutineNameChange(text[i])
                        puts(outFile, text[i] & '\n')
                        lineCount += 1
                    end if
                end for

                --if event is one in which setTimer or killTimer needs to be
                --added, do it now

                for i=1 to length(windows[windowNumber]) do
                    if events!=Begin and events!=Intro and events!=Final then
                        if equal(windows[windowNumber][i][Class], "Timer") then
                            if length(windows[windowNumber][i][SetEvent])
                            and equal(windows[windowNumber][i][SetControl], ctrl[Name]) then
                                if equal(windows[windowNumber][i][SetEvent], Events[events][1]) then
                                    puts(outFile, "-- Generated by IDE for Timer in " & Events[events][1] & "\n")
                                    puts(outFile, "setTimer ( "
                                         & windows[windowNumber][1][Name]
                                         & ", " & windows[windowNumber][i][Name] & ", "
                                         & sprint(windows[windowNumber][i][TimerInt]) & " )\n")
                                    lineCount += 2
                                end if
                            end if
                            if length(windows[windowNumber][i][KillEvent])
                            and equal(windows[windowNumber][i][KillControl], ctrl[Name]) then
                                if equal(windows[windowNumber][i][KillEvent], Events[events][1]) then
                                    puts(outFile, "-- Generated by IDE for Timer in" & Events[events][1] & "\n")
                                    puts(outFile, "killTimer ( "
                                         & windows[windowNumber][1][Name]
                                         & ", " & windows[windowNumber][i][Name] & " )\n")
                                    lineCount += 2
                                end if
                            end if
                        end if
                    end if
                end for

            end if
        else    --there was no existing data
            --might need to generate an onEvent procedure due to set or kill timer
            for i=1 to length(windows[windowNumber]) do
                if equal(windows[windowNumber][i][Class], "Timer") then
                    if (equal(windows[windowNumber][i][SetEvent], Events[events][1])
                        and equal(windows[windowNumber][i][SetControl], ctrl[Name]) )
                    or (equal(windows[windowNumber][i][KillEvent], Events[events][1])
                        and equal(windows[windowNumber][i][KillControl], ctrl[Name]) ) then
--                    and not find( Events[events][1], priorEvent ) then
--                        priorEvent&={Events[events][1]}                        

                        if events!=General
                        and events!=Final
                        and events!=Begin
                        and events!=Intro then
                            -- line break
                            puts(outFile, repeat('-', 80) & cr)
                            puts(outFile, "-- Generated by IDE because of Timer and no coding by user \n")
                            lineCount += 2
                            makeNameEventLine(windowNumber, ctrl[Name],
                                              Events[events][1], lineCount)

                        else

                            if events=General then
                                -- line break
                                puts(outFile, repeat('-', 80) & cr)
                                puts(outFile, "-- Generated in General by IDE because of Timer and no coding by user \n")
                                lineCount += 2

                                makeNameEventLine(windowNumber, ctrl[Name],
                                                  "(General)", lineCount)
                            end if
                        end if

                        -- output the code
                        for j=1 to length(windows[windowNumber]) do
                            if length(windows[windowNumber][j][SetEvent])
                            and equal(windows[windowNumber][j][SetEvent], Events[events][1])
                            and not equal(Events[events][1],"(Final)") then
                                if events!=General
                                and events!=Begin
                                and events!=Final
                                and events!=Intro then
                                    puts(outFile, "procedure " & windows[windowNumber][j][Name] & "_"
                                         & Events[events][1] & "(integer self, integer event, sequence params)\n")
                                    lineCount += 1  --Josef
                                end if
                                puts(outFile, "setTimer ( "
                                     & windows[windowNumber][1][Name]
                                     & ", " & windows[windowNumber][j][Name] & ", "
                                     & sprint(windows[windowNumber][j][TimerInt]) & " )\n")
                                lineCount += 1  --Josef
                            end if
                            if length(windows[windowNumber][j][KillEvent])
                            and equal(windows[windowNumber][j][KillEvent], Events[events][1])
                            and not equal(Events[events][1],"(Final)") then
                                if events!=General
                                and events!=Begin
                                and events!=Final
                                and events!=Intro then
                                    puts(outFile, "procedure " & windows[windowNumber][j][Name] & "_"
                                         & Events[events][1] & "(integer self, integer event, sequence params)\n")
                                    lineCount += 1  --Josef
                                end if
                                puts(outFile, "killTimer ( "
                                     & windows[windowNumber][1][Name]
                                     & ", " & windows[windowNumber][j][Name] & " )\n")
                                lineCount += 1  --Josef
                            end if
                        end for

                        if events!=General
                        and events!=Begin
                        and events!=Final
                        and events!=Intro then
                            puts(outFile, "end procedure \n")
                            lineCount += 1  --Josef
                            -- attach the callback
                            if length(windows[windowNumber][i][SetControl])
                            and equal(windows[windowNumber][i][SetEvent], Events[events][1]) then
                                theName = windows[windowNumber][i][SetControl]
                            end if
                            if length(windows[windowNumber][i][KillControl])
                            and equal(windows[windowNumber][i][KillEvent], Events[events][1]) then
                                theName = windows[windowNumber][i][KillControl]
                            end if
                            --look at text for one of the array names and
                            --change to the index
                            if ctrl[TableCell] then
                                ctrl[Name] = convertToArrayName(ctrl[Name])
                            end if
                            w32HName = "w32H"
                            for j=3 to length(Events[events][1]) do
                                w32HName = append(w32HName, Events[events][1][j])
                            end for
                            printf(outFile, "setHandler(%s, %s, routine_id(\"%s_%s\"))" & cr & cr,
                                   {ctrl[Name],w32HName,theName,Events[events][1]})

                            lineCount += 2
                        end if
                    end if
                end if
            end for
        end if
    end for

end procedure
--------------------------------------------------------------------------------
--In the routines that follow, I used to set a switch to notify me whether or not
--I had put out setTransparentColor but with the addition of colored buttons which
--would want to set various colors for transparency and the possibility that the
--colored buttons and non colored buttons intermingle I can not figure out how to
--know if I had already used the statement. Unless I track the color last used and
--compare to the new transparent color and only when different write the statement.
--This is something to consider.
--------------------------------------------------------------------------------
integer preparedTheStatements
preparedTheStatements = w32False

integer settransparentcolor
settransparentcolor = w32False

procedure prepareTheStatements(integer outFile, sequence IDEctrlname, integer useColor)

    if sequence(IDEctrlname) then end if

    if not preparedTheStatements then
        puts(outFile, "---------------------------GENERATED BY IDE--------------------\n")
        puts(outFile, "atom dib\n")
        puts(outFile, "procedure IDEaddXPM(integer IDEctrl, sequence IDEXPM, integer useColor)\n")
        puts(outFile, "--add emulated xpms to button\n")
        puts(outFile, "-- convert the xpm to a dib\n")
        puts(outFile, "integer result\n")
        if useColor then
            puts(outFile, "    setTransparentColor(useColor)\n")
            lineCount += 1
        else
            puts(outFile, "    setTransparentColor( getSysColor( COLOR_BTNFACE ) )\n")
            lineCount += 1
            --settransparentcolor=w32True           
        end if
        puts(outFile, "    -- create to dib\n")
        puts(outFile, "    dib = createDIB( xpmToEuBmp(IDEXPM) )\n")
        puts(outFile, "    result = sendMessage(IDEctrl, BM_SETIMAGE, IMAGE_BITMAP, dib)\n")
        puts(outFile, "end procedure\n")
        lineCount += 10
        preparedTheStatements = w32True
    end if
end procedure
--------------------------------------------------------------------------------
procedure prepareTheXPM(integer outFile, sequence ctrls, integer color, integer useDib)
    if ctrls[TableCell] then
        ctrls[Name] = convertToArrayName(ctrls[Name])
    end if
    puts(outFile, "IDEaddXPM("
         & ctrls[Name] & ","
         & ctrls[XPMmember] & ","
         & sprint(color) & ")\n")
    lineCount += 1
    if useDib then
        puts(outFile, "addCBXpmmerGraphic(" & ctrls[Name] & ", 1, dib)\n")
        lineCount += 1
    end if
end procedure
--------------------------------------------------------------------------------
integer preparedTheRealStatements
preparedTheRealStatements = w32False

procedure prepareTheRealXpm(integer outFile)

    if not preparedTheRealStatements then
        puts(outFile, "---------------------------GENERATED BY IDE--------------------\n")
        puts(outFile, "procedure IDERealXpmToButton(integer IDEctrl, sequence filename) \n")
        puts(outFile, "    -- assign a real xpm to the button \n")
        puts(outFile, "object theBmp \n")
        puts(outFile, "atom dib \n")
        puts(outFile, "integer result \n")
        if not settransparentcolor then
            puts(outFile, "    -- transparent colors are converted to the button color \n")
            puts(outFile, "    setTransparentColor( getSysColor( COLOR_BTNFACE ) )\n")
            lineCount += 2
            settransparentcolor = w32True
        end if
        puts(outFile, "    theBmp=readXpm(filename)\n")
        puts(outFile, "    if atom(theBmp) then \n")
        puts(outFile, "        result=message_box(\"error reading xpm file: \" \n")
        puts(outFile, "            & sprint(theBmp),\"\",0) \n")
        puts(outFile, "    else \n")
        puts(outFile, "        -- create to dib \n")
        puts(outFile, "        dib = createDIB( theBmp ) \n")
        puts(outFile, "        result = sendMessage(IDEctrl, BM_SETIMAGE, IMAGE_BITMAP, dib) \n")
        puts(outFile, "    end if \n")
        puts(outFile, "end procedure \n")
        lineCount += 16
        preparedTheRealStatements = w32True
    end if
end procedure
--------------------------------------------------------------------------------
procedure makeTheRealXpm(integer outFile, sequence ctrls)
sequence saveName, examDocs
integer at

--examine file for \ and make \\ for Euphoria reading in EXW
    saveName = {}
    examDocs = ctrls[XPM]
    at = match(lower(projectDir), lower(examDocs))
    if at then
        examDocs = examDocs[at+1+length(projectDir)..length(examDocs)]
    end if
    at = 1
    while at do
        at = 0
        for k=1 to length(examDocs) do
            if examDocs[k]='\\' then
                saveName &= examDocs[1..k-1] & "\\\\"
                examDocs = examDocs[k+1..length(examDocs)]
                at = 1
                exit
            end if
        end for
    end while
    saveName &= examDocs
    if not length(saveName) then
        saveName = ctrls[XPM]
        at = match(lower(projectDir),lower(saveName))
        if at then
            saveName = saveName[at+1+length(projectDir)..length(saveName)]
        end if
    end if

    if ctrls[TableCell] then
        ctrls[Name] = convertToArrayName(ctrls[Name])
    end if
    puts(outFile, "IDERealXpmToButton("
         & ctrls[Name] & ","
         & "\"" & saveName & "\")\n")

    lineCount += 1
end procedure
--------------------------------------------------------------------------------
integer preparedTheXpmObjectStatements
preparedTheXpmObjectStatements = w32False
--this routine creates the routine in the exw
procedure prepareTheXPMObjectStatements(integer outFile, sequence IDEctrl, sequence IDEclass, sequence XPMobject, integer useDib, integer color, integer disabled)
    --this is the routine that gets run in the exw and is a general purpose routine for all buttons
    if not preparedTheXpmObjectStatements then
        puts(outFile, "---------------------------GENERATED BY IDE--------------------\n")
        puts(outFile, "--add emulated xpmmers to button\n")
        puts(outFile, "sequence IDEBmp\n")
        puts(outFile, "atom IDEdib\n")
        puts(outFile, "integer IDEresult\n")
        lineCount += 5
        preparedTheXpmObjectStatements = w32True
    end if
    --if not settransparentcolor then
    if color then
        puts(outFile, "    setTransparentColor(" & sprint(color) & ")\n")
    else
        puts(outFile, "    setTransparentColor( getSysColor( COLOR_BTNFACE ) )\n")
    end if
    lineCount += 1
        --      settransparentcolor=w32True
        --end if                        
    puts(outFile, "    IDEBmp = xpmToEuBmp( \n")
    puts(outFile, "{ \n")
    lineCount += 2
    for i=1 to length(XPMobject) do
        if i=length(XPMobject) then
            puts(outFile, "\"" & XPMobject[i] & "\" \n")
        else
            puts(outFile, "\"" & XPMobject[i] & "\", \n")
        end if
        lineCount += 1
    end for
    puts(outFile, "} \n")
    puts(outFile, ") \n")
    puts(outFile, "    IDEdib=createDIB({IDEBmp[1],IDEBmp[2]})\n")
    if equal(IDEclass, "Bitmap") then
        puts(outFile, "    setBitmap(" & IDEctrl & ", IDEdib)\n")
    else
        puts(outFile, "    IDEresult = sendMessage(" & IDEctrl & ", BM_SETIMAGE, IMAGE_BITMAP, IDEdib)\n")
    end if
    lineCount += 4
    if useDib then
        if disabled then
            --remove the 'D' at end of IDEctrl (Name) because coloredbuttons.ew can 
            --use the disable graphic on the emulated active button
            IDEctrl = IDEctrl[1..length(IDEctrl)-1]
            puts(outFile, "addCBXpmmerGraphic(" & IDEctrl & ", 2, IDEdib)\n")
        else
            puts(outFile, "addCBXpmmerGraphic(" & IDEctrl & ", 1, IDEdib)\n")
        end if
        lineCount += 1
    end if
    puts(outFile, "------------------------------------------------------------------------------- \n")
    lineCount += 1
end procedure
------------------------------------------------------------------------------
function adjustTableSetHandlers(sequence controls, integer selectedControl)
        --if CommonSetHandler was set on any of the controls in cell1 need to go through all the
        --controls in cell one and trap the routine_id.
        --Then apply the routine_id to those cells that need it.
integer foundIt, at, at1, addedToArray, cnt, newEvent
sequence commonEntry, commonEntryCode, rID, testEvent

    commonTableArray = {}
    commonEntryCode = {0,{},{}}
    commonEntry = {"",0,0,{},{}}--control name, row, col, {{event, routine_id},{event, routine_id}....},genFromName
    for i=1 to length(controls) do
        if equal(controls[i][SeqParentName], controls[selectedControl][Name]) then
            commonEntryCode = {0,{},{}}
            commonEntry = {"",0,0,{},{}}
            addedToArray = w32False
            if controls[i][CommonSetHandler] then
                commonEntry[1] = controls[i][Name]
                commonEntry[2] = controls[i][CommonRow]
                commonEntry[3] = controls[i][CommonCol]
                commonEntry[5] = controls[i][GenFromName]

                --look at each event                            
                for j=1 to length(controls[i][Code]) do
                    for k=length(controls[i][Code][j]) to 1 by -1 do
                        foundIt = 0
                        if match("setHandler", controls[i][Code][j][k]) then
                            foundIt = w32True
                            --parse for event                                               
                            at = match("w32H",controls[i][Code][j][k])
                            if at then
                                --find the following comma
                                testEvent = controls[i][Code][j][k][at..length(controls[i][Code][j][k])]
                                at1 = match(",",testEvent)--controls[i][Code][j][k])
                                if at1 then
                                    commonEntryCode[3] = testEvent[1..at1-1]
                                end if
                            end if
                            --parse for routine_id
                            at = match("routine_id",controls[i][Code][j][k])
                            if at then
                                rID = controls[i][Code][j][k][at..length(controls[i][Code][j][k])]
                                commonEntryCode[1] = j
                                commonEntryCode[2] = rID
                                commonEntry[4] &= {commonEntryCode}
                            end if
                        end if
                        if foundIt then
                            addedToArray = w32True
                        end if
                    end for
                end for
            end if
            if addedToArray then
                commonTableArray &= {commonEntry}
            end if
        end if
    end for

    if not length(commonTableArray) then
        return controls
    end if

    if controls[selectedControl][CommonSetHandler]=1 then-- by row; selectedControl is the Table                                    
        cnt = 0
        for j=selectedControl+1 to length(controls) do
            if equal(controls[j][SeqParentName],controls[selectedControl][Name]) then
                cnt += 1
                foundIt = w32False
                for i=1 to length(commonTableArray) do
                    if not equal(controls[j][Name], commonTableArray[i][1])--don't change itself
                    and controls[j][CommonRow]=commonTableArray[i][2]
                    and equal(controls[j][GenFromName],commonTableArray[i][5]) then --don't affect a different control																						
                        for m=1 to length(commonTableArray[i][4]) do
                            if controls[j][CommonCol]!=1 then
                                newEvent = commonTableArray[i][4][m][1]
                                w32HName = commonTableArray[i][4][m][3]
                                foundIt = w32True
                                if not length(controls[j][Code][newEvent]) then
                                    controls[j][Code][newEvent] = {"procedure "
                                                                   & controls[j][Name]
                                                                   & "_"
                                                                   & Events[newEvent][1]       -- event name
                                                                   & " "
                                                                   & "( integer self, integer event, sequence params )"}
                                                                  & controls[j][Code][newEvent][1..length(controls[j][Code][newEvent])]
                                    controls[j][Code][newEvent] &= {"--"}
                                    controls[j][Code][newEvent] &= {"end procedure"}
                                    controls[j][Code][newEvent] &= {"setHandler(" & controls[j][Name] & ","
                                                                    & w32HName & "," & commonTableArray[i][4][m][2]}
                                else
                                    --need to find setHandler and replace routine_id
                                    for t=length(controls[j][Code][newEvent]) to 1 by -1 do
                                        at = match("routine_id", controls[j][Code][newEvent][t])
                                        if at then
                                            controls[j][Code][newEvent][t] = controls[j][Code][newEvent][t][1..at-1]
                                                                             & commonTableArray[i][4][m][2]
                                            exit
                                        end if
                                    end for
                                end if
                            end if
                        end for
                    end if
                    if foundIt then
                        exit
                    end if
                end for
            end if
            if cnt=length(controls[selectedControl][SeqChildName]) then
                exit
            end if
        end for

    elsif controls[selectedControl][CommonSetHandler]=2 then-- by column; selectedControl is the Table                                      
        cnt = 0
        for j=selectedControl+1 to length(controls) do
            if equal(controls[j][SeqParentName],controls[selectedControl][Name]) then
                cnt += 1
                foundIt = w32False
                for i=1 to length(commonTableArray) do
                    if not equal(controls[j][Name], commonTableArray[i][1])--don't change itself
                    and controls[j][CommonCol]=commonTableArray[i][3]
                    and equal(controls[j][GenFromName],commonTableArray[i][5]) then --don't affect a different control																													
                        for m=1 to length(commonTableArray[i][4]) do
                            if controls[j][CommonRow]!=1 then
                                newEvent = commonTableArray[i][4][m][1]
                                w32HName = commonTableArray[i][4][m][3]
                                foundIt = w32True
                                if not length(controls[j][Code][newEvent]) then
                                    controls[j][Code][newEvent] = {"procedure "
                                                                   & controls[j][Name]
                                                                   & "_"
                                                                   & Events[newEvent][1]       -- event name
                                                                   & " "
                                                                   & "( integer self, integer event, sequence params )"}
                                                                  & controls[j][Code][newEvent][1..length(controls[j][Code][newEvent])]
                                    controls[j][Code][newEvent] &= {"--"}
                                    controls[j][Code][newEvent] &= {"end procedure"}
                                    controls[j][Code][newEvent] &= {"setHandler(" & controls[j][Name] & ","
                                                                    & w32HName & "," & commonTableArray[i][4][m][2]}
                                else
                                    --need to find setHandler and replace routine_id
                                    for t=length(controls[j][Code][newEvent]) to 1 by -1 do
                                        at = match("routine_id", controls[j][Code][newEvent][t])
                                        if at then
                                            controls[j][Code][newEvent][t] = controls[j][Code][newEvent][t][1..at-1]
                                                                             & commonTableArray[i][4][m][2]
                                            exit
                                        end if
                                    end for
                                end if
                            end if
                        end for
                    end if
                    if foundIt then
                        exit
                    end if
                end for
            end if
            if cnt=length(controls[selectedControl][SeqChildName]) then
                exit
            end if
        end for

    elsif controls[selectedControl][CommonSetHandler]=3 then--all use col 1                         
        cnt = 0
        for j=selectedControl+1 to length(controls) do
            if equal(controls[j][SeqParentName],controls[selectedControl][Name]) then
                cnt += 1
                foundIt = w32False
                for i=1 to length(commonTableArray) do
                    if not equal(controls[j][Name], commonTableArray[i][1])--don't change itself				 	
                    and equal(controls[j][GenFromName],commonTableArray[i][5]) then --don't affect a different control																							
                        for m=1 to length(commonTableArray[i][4]) do
                            newEvent = commonTableArray[i][4][m][1]
                            w32HName = commonTableArray[i][4][m][3]
                            foundIt = w32True
                            if not length(controls[j][Code][newEvent]) then
                                controls[j][Code][newEvent] = {"procedure "
                                                               & controls[j][Name]
                                                               & "_"
                                                               & Events[newEvent][1]       -- event name
                                                               & " "
                                                               & "( integer self, integer event, sequence params )"}
                                                              & controls[j][Code][newEvent][1..length(controls[j][Code][newEvent])]
                                controls[j][Code][newEvent] &= {"--"}
                                controls[j][Code][newEvent] &= {"end procedure"}
                                controls[j][Code][newEvent] &= {"setHandler(" & controls[j][Name] & ","
                                                                & w32HName & "," & commonTableArray[i][4][m][2]}
                            else
                                --need to find setHandler and replace routine_id
                                for t=length(controls[j][Code][newEvent]) to 1 by -1 do
                                    at = match("routine_id", controls[j][Code][newEvent][t])
                                    if at then
                                        controls[j][Code][newEvent][t] = controls[j][Code][newEvent][t][1..at-1]
                                                                         & commonTableArray[i][4][m][2]
                                        exit
                                    end if
                                end for
                            end if
                        end for
                    end if
                    if foundIt then
                        exit
                    end if
                end for
            end if
            if cnt=length(controls[selectedControl][SeqChildName]) then
                exit
            end if
        end for
    end if
    return controls
end function
--------------------------------------------------------------------------------
sequence CrLf      CrLf    = {'\r', '\n'}

global procedure writeCode(sequence fileName)

integer outFile, at, ok, haveEuGridInclude, which, cntr, haveTransparency,
                needEuGridInclude, needTransparency, haveGridvoid, haveColoredButton, needColoredButton
sequence shortName, projectFileTypeTest,
            holdControls, testIco, newIco,
            hintStyle, tableChildren
integer addIt, skipWinMain, events, insertAt, windowUsingWinMain, priorCell,
            doRow, doCol, useCellRows, useCellCols, oneIndex, controlcounter,
            controlCnt, xx, useDib,useColor,foundIt
sequence thefilename, text, module, includeModulesData, openAs, theModuleName,
            checkText, whichsystray, tempwindows, theModulePath, useCellParent,
            newCtrl,hinttext, xpm, arrayElements, crashproject
object theBmp, res

    StopRun = w32False

    includeModulesData = {"","","",0}
    theModulePath = {}

    holdControls = {}
    ncontrols = {}

    -- save controls to window structure    
    flushControls()

    --Irv found but can not reproduce a situation in which the IDE changed
    --WINDOW class to RText. This is just a bandaid routine for any future reoccurance.
    for i=1 to length(windows) do
        if not equal(windows[i][1][Class], "Window") then
            windows[i][1][Class] = "Window"
        end if
    end for

    for i=1 to length(windows) do
        for j=1 to length(windows[i]) do
            --check for Window or CWindow with WS_CHILD style but no parent         
            if sequence(windows[i][j][Style]) then
                if match("WS_CHILD",windows[i][j][Style]) then
                    if equal(windows[i][j][Class],"Window") then
                        if not length(windows[i][j][ControlParent]) then
                            ok = displayErrorMessage(117,{windows[i][j][Name]})
                            StopRun = w32True
                            return
                        end if
                    end if
                end if
            end if
        end for
    end for

    -- replace the .PRJ with .EXW

    -- truncate path from name
    shortName = fileName
    for i=length(fileName) to 1 by -1 do
        if fileName[i]='\\' then
            shortName = fileName[i+1..length(fileName)]
            pathName = fileName[1..i]
            exit
        end if
    end for

    projectFileTypeTest = reverse(projectFileType)

    shortName = reverse(shortName)
    at = find('.', shortName)
    if at then
        if equal(projectFileTypeTest, lower(shortName[1..at-1]))
        or equal("wxe", lower(shortName[1..at-1]))
        or equal("we", lower(shortName[1..at-1])) then
            shortName = shortName[at+1..length(shortName)]
        end if

        shortName = reverse(shortName)
        fileName = pathName & shortName

    end if

    if treatAsInclude then
        fileName &= ".ew"
    else
        fileName &= ".exw"
    end if

    for i=1 to length(controls) do
        if equal(controls[i][Class],"Table")
        and controls[i][CommonSetHandler] then
            controls = adjustTableSetHandlers(controls,i)
        end if
    end for

    holdControls = controls
    layerSeq = {}
    useCellRows = 0
    useCellCols = 0
    doRow = 0
    doCol = 0
    oneIndex = w32False
    controlcounter = 0

    for i=1 to length(windows) do
        controls = windows[i]
        allIndexedArray = {}
        --build indexed and indexParents
        for k=1 to length(controls) do
            arrayElements = {{},0,{},0}--parentIndex,sort flag,controlName,control index
            if controls[k][Indexed] then
                --this is the primary
                arrayElements[1] = controls[k][Name]
                arrayElements[2] = 0
                arrayElements[3] = controls[k][Name]
                arrayElements[4] = k
                allIndexedArray &= {arrayElements}
            elsif length(controls[k][IndexParent]) then
                --this is the indexed controls
                arrayElements[1] = controls[k][IndexParent]
                arrayElements[2] = 1
                arrayElements[3] = controls[k][Name]
                arrayElements[4] = k
                allIndexedArray &= {arrayElements}
            end if
        end for
        allIndexedArray = sort(allIndexedArray)

        for k=1 to length(controls) do
            which = 0
            for m=1 to length(layerCaptionSeq[i]) do
                if layerCaptionSeq[i][m][3]=controls[k][ControlLayer] then
                    which = m
                    exit
                end if
            end for

            if equal(controls[k][Class],"Table") then
                if controls[k][SetLayerOK]
                and which then
                    layerSeq &= {{controls[TheWindow][Name],layerCaptionSeq[i][which][1],controls[k][Name],controls[k][ControlLayer]}}--added last index
                end if

                if controls[k][TableArray]
                and not controls[k][SetLayerOK] then
                    useCellParent = controls[k][Name]
                    useCellRows = controls[k][TableRows]
                    useCellCols = controls[k][TableCols]
                    doRow = 1
                    doCol = 0

                    --child cells of Table may use different values in SetLayerOK than parent
                    if length(controls[k][SeqChildName]) then
                        if length(controls[k][SeqChildName])/useCellRows=1
                        or length(controls[k][SeqChildName])/useCellCols=1 then
                            oneIndex = w32True
                        else
                            controlcounter = floor(length(controls[k][SeqChildName])/(useCellRows*useCellCols))
                            if  remainder(floor(length(controls[k][SeqChildName])),(useCellRows*useCellCols)) then
                                controlcounter += 1
                            end if
                        end if
                    end if
                    --for children build small table of TableCell, Y, X, SetLayerOK, ControlLayer
                    cntr = 0
                    tableChildren = {}
                    for x=k to length(controls) do
                        if find(controls[x][Name],controls[k][SeqChildName]) then
                            cntr += 1
                            tableChildren &= {{controls[x][TableCell],controls[x][Y],controls[x][X],
                                               controls[x][SetLayerOK],controls[x][ControlLayer]}}
                        end if
                        if cntr=length(controls[k][SeqChildName]) then
                            exit
                        end if
                    end for
                    tableChildren = sort(tableChildren)
                    priorCell = 0
                    controlCnt = 0
                    for s=1 to length(tableChildren) do
                        which = 0
                        for m=1 to length(layerCaptionSeq[i]) do
                            if layerCaptionSeq[i][m][3]=tableChildren[s][5] then  --ControlLayer
                                which = m
                                exit
                            end if
                        end for
                        if tableChildren[s][1]!=priorCell then  --TableCell
                            doCol += 1
                            priorCell = tableChildren[s][1]
                            controlCnt = 1
                        else
                            controlCnt += 1
                        end if
                        if doCol>useCellCols then
                            doCol = 1
                            doRow += 1
                        end if
                        if doCol<=useCellCols
                        and doRow<=useCellRows then
                            if which
                            and tableChildren[s][4] then --SetLayerOK
                                if oneIndex then
                                    layerSeq &= {{controls[TheWindow][Name],layerCaptionSeq[i][which][1],useCellParent & "Array["
                                                  & sprint(doRow) & "]",controls[i][which][1][ControlLayer]}}--added last index
                                elsif controlcounter=1 then
                                    layerSeq &= {{controls[TheWindow][Name],layerCaptionSeq[i][which][1],useCellParent & "Array["
                                                  & sprint(doRow) & "][" & sprint(doCol) & "]",controls[i][which][1][ControlLayer]}}--added last index
                                else
                                    for x=1 to controlcounter do
                                        layerSeq &= {{controls[TheWindow][Name],layerCaptionSeq[i][which][1],useCellParent & "Array["
                                                      & sprint(doRow) & "][" & sprint(doCol) & "][" & sprint(controlCnt) & "]"},controls[i][which][1][ControlLayer]}--added last index
                                    end for
                                end if
                            end if
                        end if
                    end for
                elsif not controls[k][SetLayerOK] then
                    cntr = 0
                    for x=k to length(controls) do
                        if find(controls[x][Name],controls[k][SeqChildName]) then
                            cntr += 1
                            which = 0
                            for m=1 to length(layerCaptionSeq[i]) do
                                if layerCaptionSeq[i][m][3]=controls[x][ControlLayer] then
                                    which = m
                                    exit
                                end if
                            end for
                            if controls[x][SetLayerOK]
                            and which then
                                layerSeq &= {{controls[TheWindow][Name],layerCaptionSeq[i][which][1],controls[x][Name],controls[x][ControlLayer]}}--added last index
                            end if
                        end if
                        if cntr=length(controls[k][SeqChildName]) then
                            exit
                        end if
                    end for
                end if
            end if

            if equal(controls[k][Class],"Table") then
            elsif equal(controls[k][SeqParentClass], "Table") then
            else
                if controls[k][SetLayerOK]
                and which then
                    layerSeq &= {{controls[TheWindow][Name],layerCaptionSeq[i][which][1],controls[k][Name],
                                  controls[k][ControlLayer]}}
                end if
            end if


            --prepare the filename by getting only the last part
            if length(controls[k][XPM])
            and not match(".xpm", lower(controls[k][XPM]))
            and length(controls[k][XPMmember]) then
                thefilename = reverse(controls[k][XPM])
                if length(thefilename) then
                    --find only name of module
                    at = match("\\",thefilename)
                    if at then
                        theModulePath = thefilename[at+1..length(thefilename)]
                        thefilename = thefilename[1..at-1]
                    end if
                    thefilename = reverse(thefilename)
                    theModulePath = reverse(theModulePath)
                end if

                --add file name to module list if not already there
                addIt = w32True

                for j=1 to length(includeModules) do

                    if equal(lower(includeModules[j][1]), lower(controls[k][XPM])) then
                        --already in do nothing
                        addIt = w32False
                        exit
                    elsif equal(lower(includeModules[j][1]), lower(thefilename)) then
                        addIt = w32False
                        exit
                    elsif match(lower(includeModules[j][1]), lower(controls[k][XPM]))
                       or     match(lower(controls[k][XPM]), lower(includeModules[j][1])) then
                        addIt = w32False
                        exit
                    else
                        --maybe user did not enter path with xpm name; try
                        --stripping path from include module and see if matches
                        theModuleName = reverse(includeModules[j][1])
                        theModulePath = {}
                        at = match("\\", theModuleName)
                        if at then
                            theModulePath = theModuleName[at+1..length(theModuleName)]
                            theModuleName = theModuleName[1..at-1]
                        end if
                        theModuleName = reverse(theModuleName)
                        if equal(lower(controls[k][XPM]), lower(theModuleName)) then
                            --already in do nothing
                            addIt = w32False
                            exit
                        end if
                    end if
                end for
                if addIt then
                    includeModulesData[1] = controls[k][XPM]
                    includeModulesData[2] = ""
                    includeModulesData[3] = theModulePath
                    includeModulesData[4] = w32False
                    includeModules &= {includeModulesData}
                    addTreeViewNode("Modules", thefilename)
                    theTreeModules &= {thefilename}
                end if
            end if
        end for
    end for

    controls = holdControls

    layerSeq = sort(layerSeq)

    -- initialize
    priorWindowName = ""
    priorMenuName = ""

    changeNameToIndex = {}
    indexedArray = {}
    disableArray = {}

    -- write the window and attributes out to a file
    outFile = open(fileName, "w")

    --give user another chance to save the file
    if outFile= -1 then
        -- give message and exit
        ok = displayErrorMessage(143,{fileName})
        --give user a chance to save under another name
        if ok=IDNO then
            StopRun = w32True
            return
        else
            ok = invokeHandler(MenuSaveAs,w32HClick,{})
            StopRun = w32True
            return
        end if

    end if

    nameEventLine = {}
    crashfile = {}

    printf(outFile, "--  code generated by %s v%s Build %s\n", {Application, Version, Build_date})
    puts(outFile, cr)

    if treatAsInclude then
        puts(outFile, "constant TheProgramType=\"ew\" \n")
    else
        puts(outFile, "constant TheProgramType=\"exw\" \n")
    end if
    lineCount = 3

    --put out program information if it was input
    if length(config_Title) then
        printf(outFile, "constant TheTitle = \"%s\" \n", {config_Title})
        lineCount += 1
    end if
    if length(config_Author) then
        printf(outFile, "constant TheAuthor = \"%s\" \n", {config_Author})
        lineCount += 1
    end if
    if length(config_Version) then
        printf(outFile, "constant TheVersion = \"%s\" \n", {config_Version})
        lineCount += 1
    end if
    if length(config_Date) then
        printf(outFile, "constant TheDate = \"%s\" \n", {config_Date})
        lineCount += 1
    end if
    if length(config_WinLibVer) then
        printf(outFile, "constant TheWinlibVersion = \"%s\" \n", {config_WinLibVer})
        lineCount += 1
    end if
    if length(config_Desc) then
        puts(outFile, "--Description:\n")
        lineCount += 1
        text = config_Desc
        containsCrashFile(text)

        while w32True do
            -- look for an end of line
            at = match(CrLf, text)
            if at=0 then
                -- any text remaining?
                checkText = text

                while length(checkText) do
                    printf(outFile, "%s %s \n", {"--",checkText})
                    lineCount += 1
                    exit
                end while
                exit
            end if

            checkText = text[1..at-1]
            while length(checkText) do
                printf(outFile, "%s %s \n", {"--",checkText})
                lineCount += 1
                exit
            end while

            -- remove from text
            text = text[at+2..length(text)]
        end while
    end if

    if length(config_Comment) then
        puts(outFile, "--Comment:\n")
        lineCount += 1
        text = config_Comment
        containsCrashFile(text)

        while w32True do
            -- look for an end of line
            at = match(CrLf, text)
            if at=0 then
                -- any text remaining?
                checkText = text

                while length(checkText) do
                    printf(outFile, "%s %s \n", {"--",checkText})
                    lineCount += 1
                    exit
                end while
                exit
            end if

            checkText = text[1..at-1]
            while length(checkText) do
                printf(outFile, "%s %s \n", {"--",checkText})
                lineCount += 1
                exit
            end while

            -- remove from text
            text = text[at+2..length(text)]
        end while
    end if

    puts(outFile, " \n")
    lineCount += 1

    --put in Begin event if present
    for i=1 to length(windows) do
        if length(windows[i][1][Code][Begin]) then
            text = windows[i][1][Code][Begin]
            for j=1 to length(text) do
                containsCrashFile(text[j])
                puts(outFile, text[j] & "\n")
                lineCount += 1
                makeNameEventLine(i, windows[i][1][Name], "(Begin)", lineCount)
            end for
        end if
    end for

    haveEuGridInclude = w32False
    haveGridvoid = w32False
    haveTransparency = w32False
    haveColoredButton = w32False
    needEuGridInclude = w32False
    needTransparency = w32False
    needColoredButton = w32False
    for i=1 to length(windows) do
        for j=1 to length(windows[i]) do
            if equal(windows[i][j][Class], "EuGrid") then
                needEuGridInclude = w32True
            end if
            if windows[i][j][WinTransparency] then
                needTransparency = w32True
            end if
            if (windows[i][j][cbColor] and find(windows[i][j][Class],{"PushButton","ToggleButton","PictureButton",
                                                                      "TogglePicture","DefPushButton","CancelButton"}))
            or windows[i][j][TableButtonAllColor]
            or windows[i][j][TreatAsColorButton] then
                needColoredButton = w32True
            end if
        end for
    end for

    if config_has_Winlib then
        --use config file name if present
        if length(config_Winlib_Name) then
            puts(outFile, "include " & config_Winlib_Name  & cr)
        else
            puts(outFile, "include Win32Lib.ew" & cr)
        end if
        puts(outFile, "without warning" & cr)
        lineCount += 2

        --projectDir needs \ changed to \\ for use in print statement   
        crashproject = projectDir
        while w32True do
            foundIt = w32False

            at = match("\\", crashproject)   --find \
            if at then
                crashproject = crashproject[1..at-1] & alt_252
                               & crashproject[at+1..length(crashproject)]
                foundIt = w32True
            end if

            if not foundIt then
                exit
            end if

        end while
        while w32True do

            foundIt = w32False

            for j=1 to length(crashproject) do
                at = find(alt_252, crashproject)
                if at then
                    crashproject = crashproject[1..at-1] & "\\\\" & crashproject[at+1..length(crashproject)]
                    foundIt = w32True
                    exit
                end if

            end for

            if not foundIt then
                exit
            end if

        end while

        if addCrashFile then
            printf(outFile, "crash_file(" & "%s" & ")\n", {"\"" & crashproject & "\\\\" & "ex.err" & "\""})
            lineCount += 1
        end if

        for i=1 to length(includeModules) do
            --IGNORE PATH if same as projectDir
            module = includeModules[i][1]
            at = match(lower(projectDir), lower(module))
            if at then
                --remove
                module = module[at+length(projectDir)+1..length(module)]
            else
                for x=1 to length(euIncFiles) do
                    at = match(lower(euIncFiles[x]), lower(module))
                    if at then
                        --remove
                        module = module[at+length(euIncFiles[x])+1..length(module)]
                        exit
                    end if
                end for
            end if

            if match("eugrid.ew",lower(module)) then
                haveEuGridInclude = w32True
                if not haveGridvoid then
                    puts(outFile, "atom gridvoid" & cr)
                    haveGridvoid = w32True
                    lineCount += 1
                end if
            end if

            if match("coloredbuttons.ew",lower(module)) then
                haveColoredButton = w32True
            end if

            if match("alphablend.ew",lower(module)) then
                haveTransparency = w32True
            end if

            if length(includeModules[i][2]) then
                module &= " "
                module &= includeModules[i][2]
            end if

            if length(module) and module[1]='\\' then
                module = module[2..length(module)]
            end if

            puts(outFile, "include " & module & cr)
            lineCount += 1
        end for

        if needEuGridInclude
        and not haveEuGridInclude  then
            puts(outFile, "include EuGrid.ew" & cr)
            lineCount += 1
            if not haveGridvoid then
                puts(outFile, "atom gridvoid" & cr)
                haveGridvoid = w32True
                lineCount += 1
            end if
        end if

        if needColoredButton
        and not haveColoredButton then
            puts(outFile, "include coloredbuttons.ew" & cr)
            lineCount += 1
        end if

        if needTransparency
        and not haveTransparency  then
            --use from IDE includes folder
            puts(outFile, "include alphablend.ew" & cr)
            lineCount += 1
        end if

        puts(outFile, cr)
        lineCount += 1
    else
        if length(includeModules) then
            puts(outFile, "without warning" & cr)
            lineCount += 1
            for i=1 to length(includeModules) do
                --IGNORE PATH
                module = includeModules[i][1]
                includeModules[i][1] = reverse(includeModules[i][1])
                at = match("\\", includeModules[i][1])
                if at then
                    module = includeModules[i][1][1..at-1]
                    module = reverse(module)
                end if
                includeModules[i][1] = reverse(includeModules[i][1])

                if match("eugrid.ew",lower(module)) then
                    haveEuGridInclude = w32True
                    if not haveGridvoid then
                        puts(outFile, "atom gridvoid" & cr)
                        lineCount += 1
                        haveGridvoid = w32True
                    end if
                end if

                if match("alphablend.ew",lower(module)) then
                    haveTransparency = w32True
                end if

                if length(includeModules[i][2]) then
                    module &= " "
                    module &= includeModules[i][2]
                end if

                if length(module) and module[1]='\\' then
                    module = module[2..length(module)]
                end if

                puts(outFile, "include " & module & cr)
                lineCount += 1
            end for

            if needEuGridInclude
            and not haveEuGridInclude  then
                puts(outFile, "include EuGrid.ew" & cr)
                lineCount += 1
                if not haveGridvoid then
                    puts(outFile, "atom gridvoid" & cr)
                    haveGridvoid = w32True
                    lineCount += 1
                end if
            end if

            if needColoredButton then
                puts(outFile, "include coloredButtons.ew" & cr)
                lineCount += 1
            end if

            if needTransparency
            and not haveTransparency  then
                puts(outFile, "include alphablend.ew" & cr)
                lineCount += 1
            end if

            puts(outFile, cr)
            lineCount += 1
        end if
    end if

    IconUsed = w32False
    hadTable = w32False
    usedOk = w32False
    usedTree = w32False
    firstLV = w32True
    firstLvItems = w32True
    listViewCounter = 0
    preparedTheStatements = w32False
    preparedTheRealStatements = w32False
    preparedTheXpmObjectStatements = w32False
    settransparentcolor = w32False
    TimerCounter = 1999
    WinPosDef = w32False
    WinPosTaskBarDef = w32False
    usedIDEFlags = w32False
    usedGenInExw = w32False

    VarColorNames = {}
    associatedTable = {}

    tempwindows = windows
    -- for each window...
    for i=1 to length(windows) do
        --generate SysTray coding if needed
        --generate code in tempwindows because do not want to save the code in prj file
        --plus if user decides not to use systray and unchecks it in property all the
        --code would have to be stripped away
        if i=1
        and length(windows[1][TheWindow][SysTrayIcon]) then
            for j=1 to length(Events) do
                if equal(Events[j][1],"(General)") then
                    events = j
                    exit
                end if
            end for
            testIco = windows[1][TheWindow][SysTrayIcon]
            newIco = {}
            if match("\\\\", testIco) then
                --already converted
                newIco = testIco
            else
                at = match("\\", testIco)
                if at then
                    newIco = testIco[1..at] & "\\"
                    testIco = testIco[at+1..length(testIco)]
                    while at do
                        at = match("\\", testIco)
                        if at then
                            newIco &= testIco[1..at] & "\\"
                            testIco = testIco[at+1..length(testIco)]
                        else
                            newIco &= testIco[1..length(testIco)]
                        end if
                    end while
                else
                    newIco &= testIco[1..length(testIco)]
                end if
            end if

            whichsystray = "include systray.ew"

            if length(windows[1][TheWindow][Code][events]) then
                --in General code
                tempwindows[1][TheWindow][Code][events] =
                        append(tempwindows[1][TheWindow][Code][events], whichsystray)
                tempwindows[1][TheWindow][Code][events] =
                        append(tempwindows[1][TheWindow][Code][events], "constant SysTray = systray_Create("
                               & tempwindows[1][TheWindow][Name] & ")")
                tempwindows[1][TheWindow][Code][events] =
                        append(tempwindows[1][TheWindow][Code][events], "systray_SetIcon(SysTray,\""
                               & newIco & "\")")
                tempwindows[1][TheWindow][Code][events] =
                        append(tempwindows[1][TheWindow][Code][events], "systray_SetTip(SysTray,\""
                               & tempwindows[1][TheWindow][SysTrayHint] & "\")")

            else
                tempwindows[1][TheWindow][Code][events] = {whichsystray}
                                                          & {"constant SysTray = systray_Create("
                                                             & tempwindows[1][TheWindow][Name] & ")"}
                                                          & {"systray_SetIcon(SysTray,\""
                                                             & newIco & "\")"}
                                                          & {"systray_SetTip(SysTray,\""
                                                             & tempwindows[1][TheWindow][SysTrayHint] & "\")"}
            end if

            for j=1 to length(Events) do
                if equal(Events[j][1],"onOpen") then
                    events = j
                    exit
                end if
            end for

            if length(tempwindows[1][TheWindow][Code][events]) then
                --find procedure statement
                for j=1 to length(windows[1][TheWindow][Code][events]) do
                    if match("procedure", tempwindows[1][TheWindow][Code][events][j]) then
                        --find first line that is not a declaration or comment
                        insertAt = j
                        for k=j+1 to length(tempwindows[1][TheWindow][Code][events]) do
                            text = tempwindows[1][TheWindow][Code][events][k]
                            text = trimL(text)

                            if length(text)>=2 and equal(text[1..2], "--") then  --VB
                                                --comment line, keep looking
                            elsif not length(text) then  --VB
                                                --blank line, keep looking
                            elsif match("int",text)=1
                               or match("seq",text)=1
                               or match("object", text)=1
                               or match("atom", text)=1 then
                                                --declaration line, keep looking
                            elsif match("end procedure", text) then
                                insertAt = k-1
                                exit
                            else
                                insertAt = k-1  --VB
                                exit
                            end if
                        end for
                        tempwindows[1][TheWindow][Code][events] = tempwindows[1][TheWindow][Code][events][1..insertAt]
                                                                  & {"systray_Show(SysTray)"}
                                                                  & tempwindows[1][TheWindow][Code][events][insertAt+1..length(tempwindows[1][TheWindow][Code][events])]

                        exit
                    end if
                end for
            else
                tempwindows[1][TheWindow][Code][events] = {"systray_Show(SysTray)"}
                                                          & {"end procedure"}
            end if

            for j=1 to length(Events) do
                if equal(Events[j][1],"onClose") then
                    events = j
                    exit
                end if
            end for

            if not tempwindows[1][TheWindow][SysTrayHide] then
                --user does not want to code his own sysTrayHide statement
                if length(tempwindows[1][TheWindow][Code][events]) then
                    for j=1 to length(tempwindows[1][TheWindow][Code][events]) do
                        if match("end procedure", tempwindows[1][TheWindow][Code][events][j]) then
                            tempwindows[1][TheWindow][Code][events] = tempwindows[1][TheWindow][Code][events][1..j-1]
                                                                      & {"systray_Hide(SysTray)"}
                                                                      & tempwindows[1][TheWindow][Code][events][j..length(tempwindows[1][TheWindow][Code][events])]
                            exit
                        end if
                    end for
                else
                    tempwindows[1][TheWindow][Code][events] = {"systray_Hide(SysTray)"}
                                                              & {"end procedure"}
                end if
            end if

            if length(tempwindows[1][TheWindow][Code][Final]) then
                tempwindows[1][TheWindow][Code][Final] =
                        tempwindows[1][TheWindow][Code][Final] & tempwindows[1][TheWindow][SysTrayText]
            else
                tempwindows[1][TheWindow][Code][Final] = tempwindows[1][TheWindow][SysTrayText]
            end if
        end if

        -- get controls for window
        ctrls = windows[i]
        --reset hintfont info
        hintFound = w32False
        hintFontFound = w32False
        hintarray = {}

        --put in Intro event if present
        if length(windows[i][1][Code][Intro]) then
            text = windows[i][1][Code][Intro]
            for j=1 to length(text) do
                containsCrashFile(text[j])
                puts(outFile, text[j] & "\n")
                lineCount += 1
                makeNameEventLine(i, windows[i][1][Name], "(Intro)", lineCount)
            end for
        end if

        -- generate header
        puts(outFile, repeat('-', 80) & '\n')
        printf(outFile, "--  Window %s\n", {windows[i][1][Name]})
        lineCount += 2

        if userReorderControls then
            ctrls = reOrderControls(ctrls)
        end if

        --routine called is using 'controls' for hunting parent but
        --we are using ctrls
        --temporarily save controls and replace with ctrls
        holdControls = controls
        controls = ctrls
        tableParent = {}
        tableId = 0
        haveToolBarControl = 0
        haveReBarControl = 0
        CWindowBars = {}
        -- generate each control
        xx = length(ctrls)

        for j=1 to length(ctrls) do
            if equal(ctrls[j][Class], "CWindow") then
                CWindowBars &= {{ctrls[j][Name],0,0}}
            end if
            if find(ctrls[j][Class], {"ToolBar","FlatToolBar"}) then
            --count only those in Window1 or CWindow; those in ReBarBand are covered
            -- by ReBar CY
                if not length(ctrls[j][SeqParentName]) then
                    --the bar is in Window1                 
                    if ctrls[j][CY]>haveToolBarControl then
                        haveToolBarControl = ctrls[j][CY]
                    end if
                else
                    if equal(ctrls[j][SeqParentClass],"CWindow") then
                        for k=1 to length(CWindowBars) do
                            if equal(ctrls[j][SeqParentName], CWindowBars[k][1]) then
                                if ctrls[j][CY]>CWindowBars[k][3] then
                                    CWindowBars[k][3] = ctrls[j][CY]
                                end if
                                exit
                            end if
                        end for
                    end if
                end if
            end if

            if equal(ctrls[j][Class], "ReBar") then
                if not length(ctrls[j][SeqParentName]) then
                    --reBar is in Window1
                    if ctrls[j][CY]>haveReBarControl then
                        haveReBarControl = ctrls[j][CY]
                    end if
                else
                    --it must be in CWindow
                    for k=1 to length(CWindowBars) do
                        if equal(ctrls[j][SeqParentName], CWindowBars[k][1]) then
                            if ctrls[j][CY]>CWindowBars[k][2] then
                                CWindowBars[k][2] = ctrls[j][CY]
                            end if
                            exit
                        end if
                    end for
                end if
            end if

            if equal(ctrls[j][Class], "Table")
            and ctrls[j][TableGenInExw] then
                --need to build a sequence of Table and its cells for use when
                --generating cells in the exw
                ncontrols = {}
                ncontrols &= {ctrls[j]}
                cntr = 0
                for k=j to length(ctrls) do
                    if ctrls[k][TableCell]
                    and find(ctrls[k][Name], ctrls[j][SeqChildName]) then
                        cntr += 1
                        ncontrols &= {ctrls[k]}
                        if equal(ctrls[k][Class], "LabelEdit") then
                        --create a new control for LText and add at end of ctrls
                            newCtrl = ctrls[k]
                            newCtrl[Class] = "LText"
                            newCtrl[Name] = "LText" & ctrls[k][Name]
                            newCtrl[Showcap] = w32False
                            newCtrl[X] = ctrls[k][X]-ctrls[k][LabelExtent]
                            if ctrls[k][LabelSide] then
                                newCtrl[X] = ctrls[k][X]+ctrls[k][CX]
                            end if
                            newCtrl[CX] = ctrls[k][LabelExtent]+8 --give some padding
                            newCtrl[Y] += 4
                            ncontrols &= {newCtrl}
                        end if
                        if cntr=length(ctrls[j][SeqChildName]) then
                            exit
                        end if
                    end if
                end for
                ncontrols = sort(ncontrols)
            end if

            if equal(ctrls[j][Class], "LabelEdit") then
                        --create a new control for LText and add at end of ctrls
                newCtrl = ctrls[j]
                newCtrl[Class] = "LText"
                newCtrl[Name] = "LText" & ctrls[j][Name]
                newCtrl[Showcap] = w32False
                newCtrl[X] = ctrls[j][X]-ctrls[j][LabelExtent]
                if ctrls[j][LabelSide] then
                    newCtrl[X] = ctrls[j][X]+ctrls[j][CX]
                end if
                newCtrl[CX] = ctrls[j][LabelExtent]+8 --give some padding
                newCtrl[Y] += 4
                ctrls &= {newCtrl}
            end if
            if not length(ctrls[j][IndexParent])
            and not ctrls[j][Indexed] then
                writeControlToExw(outFile, ctrls[j], i, j)
            end if
            if ctrls[j][Indexed] then
                for x=1 to length(allIndexedArray) do
                    if equal(ctrls[j][Name], allIndexedArray[x][1])
                    and allIndexedArray[x][2]=0 then
                        writeControlToExw(outFile, ctrls[j], i, j)
                    elsif equal(ctrls[j][Name], allIndexedArray[x][1])
                      and allIndexedArray[x][2]=1 then
                        writeControlToExw(outFile, controls[allIndexedArray[x][4]], i, allIndexedArray[x][4])
                    end if
                end for
            end if
        end for

        for j=xx+1 to length(ctrls) do
            writeControlToExw(outFile, ctrls[j], i, j)
        end for

        if length(disableArray) then
            for j=1 to length(disableArray) do
                puts(outFile, "setEnable( " & disableArray[j] & ", w32False )\n")
                lineCount += 1
                makeNameEventLine(i, disableArray[j], "create", lineCount)
            end for
            disableArray = {}
        end if

        if length(indexedArray) then
            writeIndexedArray(outFile,i)
            indexedArray = {}
        end if

        --generate the table entry if there is one
        if length(tables) then
            makeTableArray(outFile, i, priorLocal, priorInteger)
            tables = {}
        end if

        for j=1 to length(hintarray) do
                        --hintarray[j]={ctrl,hint}
            if match("var:", hintarray[j][2]) then
                hinttext = hintarray[j][2][5..length(hintarray[j][2])]
                hinttext = trimL(hinttext)
                puts(outFile, "setHint( " & hintarray[j][1] & "," & hinttext & ")\n")
            else
                puts(outFile, "setHint( " & hintarray[j][1] & "," & hintarray[j][2] & ")\n")
            end if
            lineCount += 1
            makeNameEventLine(i, hintarray[j][1], "create", lineCount)
        end for

        --ok can replace now
        controls = holdControls

        if hintFound then
            if hintFontFound then
                hintStyle = "Normal"
                if IDE_windowAttrib then        --ctrls[1][HintFontAttrib] then
                    hintStyle = "Italic"
                end if
                if IDE_windowBold then  --ctrls[1][HintFontBold] then
                    hintStyle &= "+Bold"
                end if
                if IDE_windowUnder then --ctrls[1][HintFontUnderline] then
                    hintStyle &= "+Underline"
                end if
                if IDE_windowStrike then        --ctrls[1][HintFontStrikeout] then
                    hintStyle &= "+Strikeout"
                end if

                puts(outFile, "setHintFont( " & IDE_windowHintFontName & ","
                     & IDE_windowHintFontPts & "," & hintStyle & ")\n")
                lineCount += 1
                makeNameEventLine(i, priorTableName, "create", lineCount)
            end if
        end if

        for j=1 to length(ctrls) do
            useDib = w32False
            useColor = 0--getSysColor(COLOR_BTNFACE)
            if ctrls[j][cbColor]
            or ctrls[j][TableButtonAllColor]
            or ctrls[j][TreatAsColorButton] then
                useDib = w32True
            end if
            if ctrls[j][cbColor] then
                useColor = ctrls[j][cbColor]
            end if
            if length(ctrls[j][XpmObject]) then
                prepareTheXPMObjectStatements(outFile, ctrls[j][Name], ctrls[j][Class], ctrls[j][XpmObject], useDib, useColor, w32False)
                if length(ctrls[j][XpmDisableObject]) then
                    if ctrls[j][cbColor]
                    or ctrls[j][TableButtonAllColor]
                    or ctrls[j][TreatAsColorButton] then
                        prepareTheXPMObjectStatements(outFile, ctrls[j][Name] & "D", ctrls[j][Class], ctrls[j][XpmDisableObject],useDib, useColor, w32True)
                    else
                        prepareTheXPMObjectStatements(outFile, ctrls[j][Name] & "D", ctrls[j][Class], ctrls[j][XpmDisableObject],useDib, useColor, w32False)
                    end if
                end if
            elsif length(ctrls[j][XPM]) then
                --xpm may be either an .xpm file or an include type of xpm
                if match(".xpm", lower(ctrls[j][XPM])) then
                    --we need to determine which C-preamble is used for the xpm                     
                    theBmp = readXpm(ctrls[j][XPM])
                    if sequence(theBmp) then
                                --David Cuny style
                        prepareTheRealXpm(outFile)
                        makeTheRealXpm(outFile, ctrls[j])
                    else
                        --Andy Drummnd style
                        res = call_func(ProcessXPMFile_id,{ctrls[j][XPM]})
                        if length(res) then
                            xpm = call_func(MakeXPM_id,{})
                        end if
                        prepareTheXPMObjectStatements(outFile, ctrls[j][Name], ctrls[j][Class], xpm, w32False, getSysColor(COLOR_BTNFACE), w32False)
                    end if
                elsif length(ctrls[j][XPMmember]) then
                    prepareTheStatements(outFile, ctrls[j][Name], useColor)
                    prepareTheXPM(outFile, ctrls[j], useColor, useDib)
                end if
            end if
        end for
        puts(outFile, "---------------------------------------------------------\n")
        lineCount += 1
    end for

    if length(layerSeq) then
        --put out table of controls by layer by window for canned routines to use
        puts(outFile, "sequence IDE_labeltable\n")
        puts(outFile, "IDE_labeltable = {\n")
        lineCount += 2
        for i=1 to length(layerSeq) do
            if i!=1 then
                puts(outFile, ",\n")
                lineCount += 1
            end if
            puts(outFile,"{" & layerSeq[i][1] & ",\"" & layerSeq[i][2] & "\"," & layerSeq[i][3] & "," & sprint(layerSeq[i][4]) & "}")
        end for
        puts(outFile,"\n}\n")
        lineCount += 2

        --generate routines for manipulating layer controls
        puts(outFile, "function setLayerVisible(integer windowName,object layerName,integer state)\n")
        puts(outFile, "    integer foundIt\n")
        puts(outFile, "    foundIt=0\n")
        puts(outFile, "    for i=1 to length(IDE_labeltable) do\n")
        puts(outFile, "        if sequence(layerName) then\n")
        puts(outFile, "            if equal(windowName,IDE_labeltable[i][1])\n")
        puts(outFile, "            and equal(layerName,IDE_labeltable[i][2]) then\n")
        puts(outFile, "                setVisible(IDE_labeltable[i][3],state)\n")
        puts(outFile, "                foundIt=w32True\n")
        puts(outFile, "            elsif foundIt then\n")
        puts(outFile, "                exit\n")
        puts(outFile, "            end if\n")
        puts(outFile, "        else\n")
        puts(outFile, "            if equal(windowName,IDE_labeltable[i][1])\n")
        puts(outFile, "            and layerName=IDE_labeltable[i][4] then\n")
        --puts(outFile, "                for j=1 to length(IDE_labeltable) do\n")
        puts(outFile, "                    setVisible(IDE_labeltable[i][3],state)\n")
        --puts(outFile, "                end for\n")
        puts(outFile, "                foundIt=w32True\n")
        puts(outFile, "            elsif foundIt then\n")
        puts(outFile, "                exit\n")
        puts(outFile, "            end if\n")
        puts(outFile, "        end if\n")
        puts(outFile, "    end for\n")
        puts(outFile, "    if foundIt then\n")
        puts(outFile, "        return 0\n")
        puts(outFile, "    else\n")
        puts(outFile, "        return 1\n")
        puts(outFile, "    end if\n")
        puts(outFile, "end function\n")
        puts(outFile, "function setLayerEnable(integer windowName,object layerName,integer state)\n")
        puts(outFile, "    integer foundIt\n")
        puts(outFile, "    foundIt=0\n")
        puts(outFile, "    for i=1 to length(IDE_labeltable) do\n")
        puts(outFile, "        if sequence(layerName) then\n")
        puts(outFile, "            if equal(windowName,IDE_labeltable[i][1])\n")
        puts(outFile, "            and equal(layerName,IDE_labeltable[i][2]) then\n")
        puts(outFile, "                setEnable(IDE_labeltable[i][3],state)\n")
        puts(outFile, "                foundIt=w32True\n")
        puts(outFile, "            elsif foundIt then\n")
        puts(outFile, "                exit\n")
        puts(outFile, "            end if\n")
        puts(outFile, "        else\n")
        puts(outFile, "            if equal(windowName,IDE_labeltable[i][1])\n")
        puts(outFile, "            and layerName=IDE_labeltable[i][4] then\n")
        --puts(outFile, "                for j=1 to length(IDE_labeltable) do\n")
        puts(outFile, "                    setEnable(IDE_labeltable[i][3],state)\n")
        --puts(outFile, "                end for\n")
        puts(outFile, "                foundIt=w32True\n")
        puts(outFile, "            elsif foundIt then\n")
        puts(outFile, "                exit\n")
        puts(outFile, "            end if\n")
        puts(outFile, "        end if\n")
        puts(outFile, "    end for\n")
        puts(outFile, "    if foundIt then\n")
        puts(outFile, "        return 0\n")
        puts(outFile, "    else\n")
        puts(outFile, "        return 1\n")
        puts(outFile, "    end if\n")
        puts(outFile, "end function\n")
        lineCount += 56
    end if

    -- generate code
    windowUsingWinMain = 1
    for i=1 to length(tempwindows) do
        -- get controls for window
        ctrls = tempwindows[i]
        if ctrls[1][UseInWinMain] then
            windowUsingWinMain = i
        end if
        priorEvent = {}

        -- generate code for each control
        for j=1 to length(ctrls) do
            writeControlCodeToExw(outFile, ctrls[j], i)
        end for

        for j=1 to length(buddyList) do
            --now add the buddy associations
            lineCount += 1
            puts(outFile, "setBuddy( " & buddyList[j][1] & ", "
                 & buddyList[j][2] & " )\n")
        end for
        buddyList = {}
    end for
    puts(outFile, "---------------------------------------------------------\n")
    lineCount += 1


    skipWinMain = w32False
    for i=1 to length(tempwindows) do
        -- write the Final event if exists
        if length(tempwindows[i][1][Code][Final]) then
            text = tempwindows[i][1][Code][Final]
            for j=1 to length(text) do
                containsCrashFile(text[j])
                --parse for "WinMain"
                if match("WinMain", text[j]) then
                    skipWinMain = w32True
                end if
                puts(outFile, text[j] & "\n")
                lineCount += 1
            end for

            --add timer code
            for k=1 to length(tempwindows[i]) do
                if length(windows[i][k][SetEvent]) then
                    if equal(windows[i][k][SetEvent], "(Final)") then
                        puts(outFile, "-- Generated by IDE for Timer in Final \n")
                        puts(outFile, "setTimer ( "
                             & windows[i][1][Name]
                             & ", " & windows[i][k][Name] & ", "
                             & sprint(windows[i][k][TimerInt]) & " )\n")
                        lineCount += 2
                    end if
                end if

                if length(windows[i][k][KillEvent]) then
                    if equal(windows[i][k][KillEvent], "(Final)") then
                        puts(outFile, "-- Generated by IDE for Timer in Final \n")
                        puts(outFile, "killTimer ( "
                             & windows[i][1][Name]
                             & ", " & windows[i][k][Name] & " )\n")
                        lineCount += 2
                    end if
                end if
            end for
        else
                --add timer code
            for k=1 to length(tempwindows[i]) do
                if length(windows[i][k][SetEvent]) then
                    if equal(windows[i][k][SetEvent], "(Final)") then
                        puts(outFile, "-- Generated by IDE for Timer in Final without code \n")
                        puts(outFile, "setTimer ( "
                             & windows[i][1][Name]
                             & ", " & windows[i][k][Name] & ", "
                             & sprint(windows[i][k][TimerInt]) & " )\n")
                        lineCount += 2
                    end if
                end if

                if length(windows[i][k][KillEvent]) then
                    if equal(windows[i][k][KillEvent], "(Final)") then
                        puts(outFile, "-- Generated by IDE for Timer in Final without code \n")
                        puts(outFile, "killTimer ( "
                             & windows[i][1][Name]
                             & ", " & windows[i][k][Name] & " )\n")
                        lineCount += 2
                    end if
                end if
            end for
        end if
        makeNameEventLine(i, windows[i][1][Name], "(Final)", lineCount)
    end for

    --determine WinMain open  option
    if not windows[windowUsingWinMain][TheWindow][WinMainOpen] then
        openAs = "Normal"
    elsif windows[windowUsingWinMain][TheWindow][WinMainOpen]=1 then
        openAs = "Maximize"
    else
        openAs = "Minimize"
    end if

    if not treatAsInclude
    and not skipWinMain then
        puts(outFile, cr & cr)

        if not length(windows[windowUsingWinMain][TheWindow][WinOpenAtCtrl]) then
            printf(outFile, "WinMain( %s,%s )\n", {windows[windowUsingWinMain][TheWindow][Name],openAs})
        else
            printf(outFile, "WinMain( {%s,%s},%s )\n", {windows[windowUsingWinMain][TheWindow][Name],
                                                        windows[windowUsingWinMain][TheWindow][WinOpenAtCtrl],
                                                        openAs})
        end if
        lineCount += 3
    else
        lineCount += 1  --just to increment beyond last procedure
    end if

    makeNameEventLine(1, " ", " ", lineCount)

    close(outFile)

end procedure
writeCode_id = routine_id("writeCode")
------------------------------------------------------------------------------
procedure writeControlToPrj(integer outFile, sequence ctrl)

sequence text, saveName
integer hasData, at

-- control information            
    printf(outFile, "#Control: %s\n", {ctrl[Name]})
    if ctrl[AWindow] then
        printf(outFile, "AWindow : %d\n", {ctrl[AWindow]})
    end if
    printf(outFile, "X       : %d\n", {ctrl[X]})
    printf(outFile, "Y       : %d\n", {ctrl[Y]})
    printf(outFile, "CX      : %d\n", {ctrl[CX]})
    printf(outFile, "CY      : %d\n", {ctrl[CY]})
    printf(outFile, "ControlLayer: %d\n", {ctrl[ControlLayer]})

    if ctrl[ToolRowCY] then
        printf(outFile, "ToolRowCY: %d\n", {ctrl[ToolRowCY]})
    end if
    printf(outFile, "Title   : %s\n", {ctrl[Title]})
    if length(ctrl[WidthTitle]) then
        printf(outFile, "WidthTitle : %s\n", {ctrl[WidthTitle]})
    end if
    if length(ctrl[ValueEdit]) then
        printf(outFile, "Valueedit : %s\n", {ctrl[ValueEdit]})
    end if
    if ctrl[LabelExtent] then
        printf(outFile, "Labelextent : %d\n", {ctrl[LabelExtent]})
    end if
    if ctrl[TableGenInExw] then
        printf(outFile, "TableGenInExw : %d\n", {ctrl[TableGenInExw]})
    end if
    if ctrl[TableGenBorder] then
        printf(outFile, "TableGenBorder : %d\n", {ctrl[TableGenBorder]})
    end if
    if length(ctrl[SubClass]) then
        printf(outFile, "SubClass: %s\n", {ctrl[SubClass]})
    end if
    printf(outFile, "Class   : %s\n", {ctrl[Class]})
    printf(outFile, "Enabled : %d\n", {ctrl[Enabled]})
    printf(outFile, "Checked : %d\n", {ctrl[Checked]})
    if not equal(ctrl[ControlParent], "0") then
        printf(outFile, "Parent  : %s\n", {ctrl[ControlParent]})
        printf(outFile, "PClass  : %s\n", {ctrl[ParentClass]})
    else
        printf(outFile, "Parent  : %s\n", {" "})
        printf(outFile, "PClass  : %s\n", {" "})
    end if
    printf(outFile, "SeqParentName  : %s\n", {ctrl[SeqParentName]})
    printf(outFile, "SeqParentClass  : %s\n", {ctrl[SeqParentClass]})
    if length(ctrl[SeqChildName]) then
        for i=1 to length(ctrl[SeqChildName]) do
            printf(outFile, "SeqChildName  : %s\n", {ctrl[SeqChildName][i]})
        end for
    else
        printf(outFile, "SeqChildName  : %s\n", {""})
    end if
    if length(ctrl[Parent]) then
        printf(outFile, "DirParent : %s\n", {ctrl[Parent]})
    end if
    if ctrl[Active] then
        printf(outFile, "Active  : %d\n", {ctrl[Active]})
    end if
    if ctrl[Visible] then
        printf(outFile, "Visible : %d\n", {ctrl[Visible]})
    end if
    if ctrl[Upper] then
        printf(outFile, "Upper   : %d\n", {ctrl[Upper]})
    end if
    if ctrl[Lower] then
        printf(outFile, "Lower   : %d\n", {ctrl[Lower]})
    end if
    if ctrl[ReadOnly] then
        printf(outFile, "ReadOnly: %d\n", {ctrl[ReadOnly]})
    end if
    if ctrl[Pswd] then
        printf(outFile, "Pswd    : %d\n", {ctrl[Pswd]})
    end if
    if ctrl[Limit] then
        printf(outFile, "Limit   : %d\n", {ctrl[Limit]})
    end if
    if ctrl[TxtColor] then
        printf(outFile, "TxtColor : %d\n", {ctrl[TxtColor]})
    end if
    if find(ctrl[Class], controlsWithOutColor) then
        ctrl[BkColor] = 0
    end if
    if ctrl[BkColor] then
        if ctrl[BkColor]=getSysColor(COLOR_BTNFACE) then
            printf(outFile, "BkColor : %d\n", {0})
        else
            printf(outFile, "BkColor : %d\n", {ctrl[BkColor]})
        end if
    end if
    if ctrl[BkBarColor] then
        if ctrl[BkBarColor]=getSysColor(COLOR_BTNFACE) then
            ctrl[BkBarColor] = 0
        end if
        printf(outFile, "BkBarColor : %d\n", {ctrl[BkBarColor]})
    end if

    if length(ctrl[SystemBkColor])
    and equal(ctrl[Class], "Window") then
        printf(outFile, "SystemBkColor : %s\n", {ctrl[SystemBkColor]})
    end if
    if ctrl[EnableC] then
        printf(outFile, "EnableC : %d\n", {ctrl[EnableC]})
    end if
    if ctrl[Numeric] then
        printf(outFile, "Numeric : %d\n", {ctrl[Numeric]})
    end if
    if ctrl[Multiline] then
        printf(outFile, "Multline: %d\n", {ctrl[Multiline]})
    end if
    if ctrl[cbMultiline] then
        printf(outFile, "cbMultline: %d\n", {ctrl[cbMultiline]})
    end if
    if ctrl[Hscrolls] then
        printf(outFile, "Hscrolls: %d\n", {ctrl[Hscrolls]})
    end if
    if ctrl[Vscrolls] then
        printf(outFile, "Vscrolls: %d\n", {ctrl[Vscrolls]})
    end if
    if length(ctrl[Buddy]) then
        printf(outFile, "Buddy   : %s\n", {ctrl[Buddy]})
    end if
    if length(ctrl[IcoFile]) then
        if equal(ctrl[Class], "ListView") then
            printf(outFile, "#IcoFile: %s\n", {ctrl[Name]})
            for k=1 to length(ctrl[IcoFile]) do
                saveName = ctrl[IcoFile][k]
                at = match(projectDir,saveName)
                if at then
                    saveName = saveName[at+length(projectDir)+1..length(saveName)]
                    puts(outFile, saveName & '\n')
                else
                    puts(outFile, ctrl[IcoFile][k] & '\n')
                end if
            end for
            puts(outFile, "#EndIcoFile\n\n")
        else
            saveName = ctrl[IcoFile]
            at = match(projectDir,saveName)
            if at then
                saveName = saveName[at+length(projectDir)+1..length(saveName)]
                printf(outFile, "IcoFile : %s\n", {saveName})
            else
                printf(outFile, "IcoFile : %s\n", {ctrl[IcoFile]})
            end if
        end if
    end if
    if length(ctrl[TwoIcoFile]) then
        saveName = ctrl[TwoIcoFile]
        at = match(projectDir,saveName)
        if at then
            saveName = saveName[at+length(projectDir)+1..length(saveName)]
            printf(outFile, "TwoIcoFile : %s\n", {saveName})
        else
            printf(outFile, "TwoIcoFile : %s\n", {ctrl[TwoIcoFile]})
        end if
    end if
    if length(ctrl[TriIcoFile]) then
        saveName = ctrl[TriIcoFile]
        at = match(projectDir,saveName)
        if at then
            saveName = saveName[at+length(projectDir)+1..length(saveName)]
            printf(outFile, "TriIcoFile : %s\n", {saveName})
        else
            printf(outFile, "TriIcoFile : %s\n", {ctrl[TriIcoFile]})
        end if
    end if
    if length(ctrl[BitmapFile]) then
        saveName = ctrl[BitmapFile]
        at = match(projectDir,saveName)
        if at then
            saveName = saveName[at+length(projectDir)+1..length(saveName)]
            printf(outFile, "BitmapFile : %s\n", {saveName})
        else
            printf(outFile, "BitmapFile : %s\n", {ctrl[BitmapFile]})
        end if
    end if
    if ctrl[TableCols] then
        printf(outFile, "TableCols : %d\n", {ctrl[TableCols]})
    end if
    if ctrl[TableRows] then
        printf(outFile, "TableRows : %d\n", {ctrl[TableRows]})
    end if
    if ctrl[TableColsSpace] then
        printf(outFile, "TableSpaceCols : %d\n", {ctrl[TableColsSpace]})
    end if
    if ctrl[TableRowsSpace] then
        printf(outFile, "TableSpaceRows : %d\n", {ctrl[TableRowsSpace]})
    end if
    if ctrl[TableCell] then
        printf(outFile, "TableCell : %d\n", {ctrl[TableCell]})
    end if
    if ctrl[TableArray] then
        printf(outFile, "TableArray : %d\n", {ctrl[TableArray]})
    end if
    if length(ctrl[HintFontName]) then
        printf(outFile, "FontHintName : %s\n", {ctrl[HintFontName]})
    end if
    if ctrl[HintFontPts] then
        printf(outFile, "FontHintPts : %d\n", {ctrl[HintFontPts]})
    end if
    if ctrl[HintFontAttrib] then
        printf(outFile, "FontHintAttrib : %d\n", {ctrl[HintFontAttrib]})
    end if
    if ctrl[HintFontBold] then
        printf(outFile, "FontHintBold : %d\n", {ctrl[HintFontBold]})
    end if
    if ctrl[HintFontUnderline] then
        printf(outFile, "FontHintUnderline : %d\n", {ctrl[HintFontUnderline]})
    end if
    if ctrl[HintFontStrikeout] then
        printf(outFile, "FontHintStrikeout : %d\n", {ctrl[HintFontStrikeout]})
    end if
    if length(ctrl[HintText]) then
        printf(outFile, "HintText : %s\n", {ctrl[HintText]})
    end if
    if ctrl[ShowHintFontVar] then
        printf(outFile, "ShowHintFontVar : %d\n", {ctrl[ShowHintFontVar]})
    end if
    if ctrl[ShowFontVar] then
        printf(outFile, "ShowFontVar : %d\n", {ctrl[ShowFontVar]})
    end if
    if length(ctrl[HintFontVarName]) then
        printf(outFile, "HintFontVarName : %s\n", {ctrl[HintFontVarName]})
    end if
    if length(ctrl[HintFontVarPts]) then
        printf(outFile, "HintFontVarPts : %s\n", {ctrl[HintFontVarPts]})
    end if
    if length(ctrl[HintFontVarItalic]) then
        printf(outFile, "HintFontVarItalic : %s\n", {ctrl[HintFontVarItalic]})
    end if
    if length(ctrl[HintFontVarBold]) then
        printf(outFile, "HintFontVarBold : %s\n", {ctrl[HintFontVarBold]})
    end if
    if length(ctrl[HintFontVarUnderline]) then
        printf(outFile, "HintFontVarUnderline : %s\n", {ctrl[HintFontVarUnderline]})
    end if
    if length(ctrl[HintFontVarStrikeout]) then
        printf(outFile, "HintFontVarStrikeout : %s\n", {ctrl[HintFontVarStrikeout]})
    end if
    if length(ctrl[HintVarText]) then
        printf(outFile, "HintVarText : %s\n", {ctrl[HintVarText]})
    end if
    if length(ctrl[FontName]) then
        printf(outFile, "FontName : %s\n", {ctrl[FontName]})
    end if
    if ctrl[setCreatefont] then
        printf(outFile, "setCreatefont : %d\n", {ctrl[setCreatefont]})
    end if
    if ctrl[FontPts] then
        printf(outFile, "FontPts : %d\n", {ctrl[FontPts]})
    end if
    if ctrl[FontAttrib] then
        printf(outFile, "FontAttrib : %d\n", {ctrl[FontAttrib]})
    end if
    if ctrl[FontBold] then
        printf(outFile, "FontBold : %d\n", {ctrl[FontBold]})
    end if
    if ctrl[FontUnderline] then
        printf(outFile, "FontUnderline : %d\n", {ctrl[FontUnderline]})
    end if
    if ctrl[FontStrikeout] then
        printf(outFile, "FontStrikeout : %d\n", {ctrl[FontStrikeout]})
    end if
    if ctrl[FontColor] then
        printf(outFile, "FontColor : %d\n", {ctrl[FontColor]})
    end if
    if length(ctrl[FontVarName]) then
        printf(outFile, "FontVarName : %s\n", {ctrl[FontVarName]})
    end if
    if length(ctrl[FontVarPts]) then
        printf(outFile, "FontVarPts : %s\n", {ctrl[FontVarPts]})
    end if
    if length(ctrl[FontVarItalic]) then
        printf(outFile, "FontVarItalic : %s\n", {ctrl[FontVarItalic]})
    end if
    if length(ctrl[FontVarBold]) then
        printf(outFile, "FontVarBold : %s\n", {ctrl[FontVarBold]})
    end if
    if length(ctrl[FontVarUnderline]) then
        printf(outFile, "FontVarUnderline : %s\n", {ctrl[FontVarUnderline]})
    end if
    if length(ctrl[FontVarStrikeout]) then
        printf(outFile, "FontVarStrikeout : %s\n", {ctrl[FontVarStrikeout]})
    end if
    if length(ctrl[FontVarColor]) then
        printf(outFile, "FontVarColor : %s\n", {ctrl[FontVarColor]})
    end if
    if length(ctrl[ClassDefaults]) then
        printf(outFile, "DefaultsClass : %s\n", {ctrl[ClassDefaults]})
    end if
    if atom(ctrl[Style]) then
        printf(outFile, "Style   : %d\n", {ctrl[Style]})
    else
        printf(outFile, "Style   : %s\n", {ctrl[Style]})
    end if
    printf(outFile, "TypStyle: %s\n", {ctrl[StyleType]})
    if not length(ctrl[ExStyle]) then
        ctrl[ExStyle] = "0"
    end if
    printf(outFile, "ExStyle : %s\n", {ctrl[ExStyle]})
    if length(ctrl[ExtExStyle]) then
        printf(outFile, "#ExtExStyle: %s\n", {ctrl[Name]})
        for k=1 to length(ctrl[ExtExStyle]) do
            puts(outFile, ctrl[ExtExStyle][k] & '\n')
        end for
        puts(outFile, "#EndExtExStyle\n\n")
    end if
    if length(ctrl[SelectWidth]) then
        printf(outFile, "#SelectWidth: %s\n", {ctrl[Name]})
        for k=1 to length(ctrl[SelectWidth]) do
            puts(outFile, ctrl[SelectWidth][k] & '\n')
        end for
        puts(outFile, "#EndSelectWidth\n\n")
    end if
    if ctrl[TabOrder] then
        printf(outFile, "TabOrder : %d\n", {ctrl[TabOrder]})
    end if
    if ctrl[DefaultXY] then
        printf(outFile, "DefaultXY : %d\n", {ctrl[DefaultXY]})
    end if
    if length(ctrl[XPM]) then
        printf(outFile, "NameXPM   : %s\n", {ctrl[XPM]})
    end if
    if ctrl[Showcap] then
        printf(outFile, "Showcap : %d\n", {ctrl[Showcap]})
    end if
    if length(ctrl[XPMmember]) then
        printf(outFile, "MemberXPM   : %s\n", {ctrl[XPMmember]})
    end if
    if length(ctrl[XpmObject]) then
        puts(outFile, "#XpmObject \n")
        for k=1 to length(ctrl[XpmObject]) do
            puts(outFile, ctrl[XpmObject][k] & '\n')
        end for
        puts(outFile, "#EndXpmObject\n\n")
    end if
    if length(ctrl[XpmDisableObject]) then
        puts(outFile, "#XpmDisableObject \n")
        for k=1 to length(ctrl[XpmDisableObject]) do
            puts(outFile, ctrl[XpmDisableObject][k] & '\n')
        end for
        puts(outFile, "#EndXpmDisableObject\n\n")
    end if
    if ctrl[Local] then
        printf(outFile, "Local : %d\n", {ctrl[Local]})
    end if
    if ctrl[MinValue] then
        printf(outFile, "MinValue : %d\n", {ctrl[MinValue]})
    end if
    if ctrl[MaxValue] then
        printf(outFile, "MaxValue : %d\n", {ctrl[MaxValue]})
    end if
    if ctrl[MinValue] then
        printf(outFile, "MinValue : %d\n", {ctrl[MinValue]})
    end if
    if ctrl[LineChg] then
        printf(outFile, "LineChg : %d\n", {ctrl[LineChg]})
    end if
    if ctrl[PageChg] then
        printf(outFile, "PageChg : %d\n", {ctrl[PageChg]})
    end if
    if ctrl[ExtendSel] then
        printf(outFile, "ExtendSel : %d\n", {ctrl[ExtendSel]})
    end if
    if ctrl[MultiSel] then
        printf(outFile, "MultiSel : %d\n", {ctrl[MultiSel]})
    end if
    if ctrl[RBBSBREAK] then
        printf(outFile, "RBBSBREAK : %d\n", {ctrl[RBBSBREAK]})
    end if
    if ctrl[TimerInt] then
        printf(outFile, "TimerInt : %d\n", {ctrl[TimerInt]})
    end if
    if length(ctrl[SetEvent]) then
        printf(outFile, "SetEvent   : %s\n", {ctrl[SetEvent]})
    end if
    if length(ctrl[SetControl]) then
        printf(outFile, "SetControl   : %s\n", {ctrl[SetControl]})
    end if
    if length(ctrl[KillEvent]) then
        printf(outFile, "KillEvent   : %s\n", {ctrl[KillEvent]})
    end if
    if length(ctrl[KillControl]) then
        printf(outFile, "KillControl   : %s\n", {ctrl[KillControl]})
    end if
    if ctrl[Clickable] then
        printf(outFile, "Clickable : %d\n", {ctrl[Clickable]})
    end if
    if ctrl[WinMainOpen] then
        printf(outFile, "WinMainOpen : %d\n", {ctrl[WinMainOpen]})
    end if
    if length(ctrl[WinOpenAtCtrl]) then
        printf(outFile, "WinOpenAtCtrl : %s\n", {ctrl[WinOpenAtCtrl]})
    end if
    if ctrl[WinPos] then
        printf(outFile, "WinPos : %d\n", {ctrl[WinPos]})
    end if
    if ctrl[Integers] then
        printf(outFile, "Integers : %d\n", {ctrl[Integers]})
    end if
    if length(ctrl[CCWinStyle]) then
        printf(outFile, "CCWinStyle : %s\n", {ctrl[CCWinStyle]})
    end if
    if ctrl[WinPosTaskBar] then
        printf(outFile, "WinPosTaskBar : %d\n", {ctrl[WinPosTaskBar]})
    end if
    if equal(ctrl[Class], "MonthCalendar") then
        if ctrl[MCS_multiselect] then
            printf(outFile, "MCS_multiselect : %d\n", {ctrl[MCS_multiselect]})
        end if
    end if
    if ctrl[PBS_smooth] then
        printf(outFile, "PBS_smooth : %d\n", {ctrl[PBS_smooth]})
    end if
    if ctrl[BS_flat] then
        printf(outFile, "BS_flat : %d\n", {ctrl[BS_flat]})
    end if
    if ctrl[cbFlat] then
        printf(outFile, "cbFlat : %d\n", {ctrl[cbFlat]})
    end if
    if ctrl[NoIntegralHeight] then
        printf(outFile, "NoIntegralHeight : %d\n", {ctrl[NoIntegralHeight]})
    end if
    if ctrl[AdjCenter] then
        printf(outFile, "AdjCenter : %d\n", {ctrl[AdjCenter]})
    end if
    if ctrl[AdjRight] then
        printf(outFile, "AdjRight : %d\n", {ctrl[AdjRight]})
    end if
    if ctrl[UpDownLeft] then
        printf(outFile, "UpDownLeft : %d\n", {ctrl[UpDownLeft]})
    end if
    if ctrl[UpDownHorz] then
        printf(outFile, "UpDownHorz : %d\n", {ctrl[UpDownHorz]})
    end if
    if ctrl[TabsBottom] then
        printf(outFile, "TabsBottom : %d\n", {ctrl[TabsBottom]})
    end if
    if length(ctrl[OutX]) then
        printf(outFile, "OutX : %s\n", {ctrl[OutX]})
    end if
    if length(ctrl[OutY]) then
        printf(outFile, "OutY : %s\n", {ctrl[OutY]})
    end if
    if length(ctrl[OutCX]) then
        printf(outFile, "OutCX : %s\n", {ctrl[OutCX]})
    end if
    if length(ctrl[OutCY]) then
        printf(outFile, "OutCY : %s\n", {ctrl[OutCY]})
    end if
    if length(ctrl[ControlComment]) then
        printf(outFile, "ControlComment : %s\n", {ctrl[ControlComment]})
    end if
    if length(ctrl[DEFIndex]) then
        printf(outFile, "DEFIndex : %s\n", {ctrl[DEFIndex]})
    end if
    if length(ctrl[SysTrayIcon]) then
        printf(outFile, "SysTrayIcon : %s\n", {ctrl[SysTrayIcon]})
    end if
    if length(ctrl[SysTrayHint]) then
        printf(outFile, "SysTrayHint : %s\n", {ctrl[SysTrayHint]})
    end if
    if ctrl[SysTrayHide] then
        printf(outFile, "SysTrayHide : %d\n", {ctrl[SysTrayHide]})
    end if
    if ctrl[SuppressCell] then
        printf(outFile, "SuppressCell : %d\n", {ctrl[SuppressCell]})
    end if
    if integer(ctrl[PreserveName]) then     --bug I can not find
    else
        ctrl[PreserveName] = 0
    end if
    if ctrl[PreserveName] then
        printf(outFile, "PreserveName : %d\n", {ctrl[PreserveName]})
    end if
    if ctrl[FitToTable] then
        printf(outFile, "FitToTable : %d\n", {ctrl[FitToTable]})
    end if
    if ctrl[DontDraw] then
        printf(outFile, "DontDraw : %d\n", {ctrl[DontDraw]})
    end if
    if ctrl[TableHScroll] then
        printf(outFile, "TableHScroll : %d\n", {ctrl[TableHScroll]})
    end if
    if ctrl[TableVScroll] then
        printf(outFile, "TableVScroll : %d\n", {ctrl[TableVScroll]})
    end if
    if ctrl[TableResizable] then
        printf(outFile, "TableResizable : %d\n", {ctrl[TableResizable]})
    end if
    if ctrl[SETLVInsert] then
        printf(outFile, "SETLvInsert : %d\n", {ctrl[SETLVInsert]})
    end if
    if ctrl[Indexed] then
        printf(outFile, "Indexed : %d\n", {ctrl[Indexed]})
    end if
    if length(ctrl[IndexParent]) then
        printf(outFile, "IndexParent : %s\n", {ctrl[IndexParent]})
    end if
    if ctrl[GridColHeaderCY] then
        printf(outFile, "GridColHeaderCY : %d\n", {ctrl[GridColHeaderCY]})
    end if
    if ctrl[GridRowHeaderCX] then
        printf(outFile, "GridRowHeaderCX : %d\n", {ctrl[GridRowHeaderCX]})
    end if
    if ctrl[GridActiveHeaders] then
        printf(outFile, "GridActiveHeaders : %d\n", {ctrl[GridActiveHeaders]})
    end if
    if ctrl[GridAllowColResize] then
        printf(outFile, "GridAllowColResize : %d\n", {ctrl[GridAllowColResize]})
    end if
    if ctrl[GridAllowColSort] then
        printf(outFile, "GridAllowColSort : %d\n", {ctrl[GridAllowColSort]})
    end if
    if ctrl[GridBkColorRows] then
        printf(outFile, "GridBkColorRows : %d\n", {ctrl[GridBkColorRows]})
    end if
    if ctrl[GridCellBorder] then
        printf(outFile, "GridCellBorder : %d\n", {ctrl[GridCellBorder]})
    end if
    if ctrl[GridHighlightText] then
        printf(outFile, "GridHighlightText : %d\n", {ctrl[GridHighlightText]})
    end if
    if ctrl[GridHeaderColor] then
        printf(outFile, "GridHeaderColor : %d\n", {ctrl[GridHeaderColor]})
    end if
    if ctrl[GridHeaderType] then
        printf(outFile, "GridHeaderType : %d\n", {ctrl[GridHeaderType]})
    end if
    if ctrl[GridHeaderInCol] then
        printf(outFile, "GridHeaderInCol : %d\n", {ctrl[GridHeaderInCol]})
    end if
    if ctrl[GridLineColor] then
        printf(outFile, "GridLineColor : %d\n", {ctrl[GridLineColor]})
    end if
    if ctrl[GridTextColor] then
        printf(outFile, "GridTextColor : %d\n", {ctrl[GridTextColor]})
    end if
    if ctrl[GridColTextColor] then
        printf(outFile, "GridColTextColor : %d\n", {ctrl[GridColTextColor]})
    end if
    if ctrl[GridBkSelectColor] then
        printf(outFile, "GridBkSelectColor : %d\n", {ctrl[GridBkSelectColor]})
    end if
    if ctrl[GridCellBorderColor] then
        printf(outFile, "GridCellColorBorder : %d\n", {ctrl[GridCellBorderColor]})
    end if
    if ctrl[GridTextColorSelect] then
        printf(outFile, "GridTextColorSelect : %d\n", {ctrl[GridTextColorSelect]})
    end if
    if ctrl[GridRowCY] then
        printf(outFile, "GridRowCY : %d\n", {ctrl[GridRowCY]})
    end if
    if ctrl[GridTextAlign] then
        printf(outFile, "GridTextAlign : %d\n", {ctrl[GridTextAlign]})
    end if
    if ctrl[GridRowSelect] then
        printf(outFile, "GridRowSelect : %d\n", {ctrl[GridRowSelect]})
    end if
    if ctrl[GridColListDataCol] then
        printf(outFile, "GridColListDataCol : %d\n", {ctrl[GridColListDataCol]})
    end if
    if length(ctrl[GridFormat]) then
        printf(outFile, "GridFormat : %s\n", {ctrl[GridFormat]})
    end if
    if length(ctrl[GridDataArrayName]) then
        printf(outFile, "GridDataArrayName : %s\n", {ctrl[GridDataArrayName]})
    end if
    if length(ctrl[GridColListValues]) then
        printf(outFile, "GridColListValues : %s\n", {ctrl[GridColListValues]})
    end if
    if ctrl[WinTransparency] then
        printf(outFile, "Transparency : %d\n", {ctrl[WinTransparency]})
    end if
    if ctrl[LastEditorEvent] then
        printf(outFile, "LastEditorEvent : %d\n", {ctrl[LastEditorEvent]})
        at = ctrl[LastEditorEvent]
        printf(outFile, "LastEditorNameEvent : %s\n", {Events[at][3]})
    end if
    if ctrl[SetLayerOK] then
        printf(outFile, "SetLayerOK : %d\n", {ctrl[SetLayerOK]})
    end if
    if ctrl[SetLayerAll] then
        printf(outFile, "SetLayerAll : %d\n", {ctrl[SetLayerAll]})
    end if
    if ctrl[UseInWinMain] then
        printf(outFile, "UseInWinMain : %d\n", {ctrl[UseInWinMain]})
    end if
    if ctrl[LastListHeight] then
        printf(outFile, "LastListHeight : %d\n", {ctrl[LastListHeight]})
    end if
    if length(ctrl[OrigTitle]) then
        printf(outFile, "OrigTitle : %s\n", {ctrl[OrigTitle]})
    end if
    if length(ctrl[GenFromName]) then
        printf(outFile, "GenFromName : %s\n", {ctrl[GenFromName]})
    end if
    if ctrl[CommonSetHandler] then
        printf(outFile, "CommonSetHandler : %d\n", {ctrl[CommonSetHandler]})
    end if
    if ctrl[CommonRow] then
        printf(outFile, "CommonRow : %d\n", {ctrl[CommonRow]})
    end if
    if ctrl[CommonCol] then
        printf(outFile, "CommonCol : %d\n", {ctrl[CommonCol]})
    end if
    if length(ctrl[ControlPartners]) then
        puts(outFile, "#Partners \n")
        for k=1 to length(ctrl[ControlPartners]) do
            puts(outFile, ctrl[ControlPartners][k] & '\n')
        end for
        puts(outFile, "#EndPartners\n\n")
    end if
    if ctrl[ParentIsFrozen] then
        printf(outFile, "FrozenParent : %d\n", {ctrl[ParentIsFrozen]})
    end if
    if ctrl[PB_Caption_Pos] then
        printf(outFile, "PBCAPPOS : %d\n", {ctrl[PB_Caption_Pos]})
    end if
    if ctrl[cbColor] then
        printf(outFile, "cbColor : %d\n", {ctrl[cbColor]})
    end if
    if ctrl[cbPressColor] then
        printf(outFile, "cbPressColor : %d\n", {ctrl[cbPressColor]})
    end if
    if ctrl[cbCaptionColor] then
        printf(outFile, "cbCaptionColor : %d\n", {ctrl[cbCaptionColor]})
    end if
    if ctrl[cbPressCaptionColor] then
        printf(outFile, "cbPressCaptionColor : %d\n", {ctrl[cbPressCaptionColor]})
    end if
    if ctrl[cbThickness] then
        printf(outFile, "cbThickness : %d\n", {ctrl[cbThickness]})
    end if
    if ctrl[cbGraphicPos] then
        printf(outFile, "cbGraphicPos : %d\n", {ctrl[cbGraphicPos]})
    end if
    if ctrl[cbCaptionPos] then
        printf(outFile, "cbCaptionPos : %d\n", {ctrl[cbCaptionPos]})
    end if
    if ctrl[cbCentVert] then
        printf(outFile, "cbCentVert : %d\n", {ctrl[cbCentVert]})
    end if
    if ctrl[TableButtonAllColor] then
        printf(outFile, "TableButtonAllColor : %d\n", {ctrl[TableButtonAllColor]})
    end if
    if ctrl[TreatAsColorButton] then
        printf(outFile, "TreatAsColorButton : %d\n", {ctrl[TreatAsColorButton]})
    end if
    if ctrl[MC_background] then
        printf(outFile, "MC_background : %d\n", {ctrl[MC_background]})
    end if
    if ctrl[MC_text] then
        printf(outFile, "MC_text : %d\n", {ctrl[MC_text]})
    end if
    if ctrl[MC_titleBK] then
        printf(outFile, "MC_titleBK : %d\n", {ctrl[MC_titleBK]})
    end if
    if ctrl[MC_titleText] then
        printf(outFile, "MC_titleText : %d\n", {ctrl[MC_titleText]})
    end if
    if ctrl[MC_monthBK] then
        printf(outFile, "MC_monthBK : %d\n", {ctrl[MC_monthBK]})
    end if
    if ctrl[MC_trailingText] then
        printf(outFile, "MC_trailingText : %d\n", {ctrl[MC_trailingText]})
    end if

    puts(outFile, "\n")

    if length(ctrl[SysTrayText]) then
        -- proc name
        printf(outFile, "#SysTrayText: %s\n", {ctrl[Name]})

        -- the values
        for k=1 to length(ctrl[SysTrayText]) do
            puts(outFile, ctrl[SysTrayText][k] & '\n')
        end for

        -- end proc marker
        puts(outFile, "#EndSysTrayText\n\n")
    end if

    --List values for this control
    if length(ctrl[InitialVal]) then

        -- proc name
        printf(outFile, "#ListValues: %s\n", {ctrl[Name]})

        -- the values
        for k=1 to length(ctrl[InitialVal]) do
            puts(outFile, ctrl[InitialVal][k] & '\n')
        end for

        -- end proc marker
        puts(outFile, "#EndListValues\n\n")

    end if

    -- procedure header

    if equal(ctrl[Class], "Timer") then
        return
    end if

    if equal(ctrl[Class], "Menu")
    and not match("!",ctrl[Title]) then
        return
    end if

    for j=1 to length(ctrl[Code]) do

        if length(ctrl[Code][j]) then

            hasData = w32False
            text = ctrl[Code][j]
            for i=1 to length(text) do
                if match("end procedure", text[i]) then
                    exit
                end if
                if match("procedure", text[i]) then
                    --ignore
                elsif length(text[i]) then
                    hasData = w32True
                    exit
                end if
            end for

            if hasData then
                -- proc name
                printf(outFile, "#Proc: %s\n", {Events[j][1]})

                -- the code
                for k=1 to length(ctrl[Code][j]) do
                    puts(outFile, ctrl[Code][j][k] & '\n')
                end for

                -- end proc marker
                puts(outFile, "#EndProc\n\n")

            end if

        end if

    end for

end procedure
------------------------------------------------------------------------------
global procedure writeProject(sequence fName)

integer outFile, ignore, ok, at, good
sequence ctrl, text, module, controlstest, testModule

    StopRun = w32False

    -- save controls to window structure
    flushControls()

    --Irv found but can not reproduce a situation in which the IDE changed
    --WINDOW class to RText. This is just a bandaid routine for any future reoccurance.
    for i=1 to length(windows) do
        if not equal(windows[i][1][Class], "Window") then
            windows[i][1][Class] = "Window"
        end if
    end for

    --12/01/07 make sure Indexed and IndexParent are in sync. Deleting one or the other might
    --cause a failure.
    for i=1 to length(windows) do
        controlstest = windows[i]
        for j=1 to length(controlstest) do
            if length(controlstest[j][IndexParent]) then
                --look for other control with name of IndexParent
                good = 0
                for k=1 to length(controlstest) do
                    if equal(controlstest[k][Name], controlstest[j][IndexParent]) then
                        good = 1
                        exit
                    end if
                end for
                if not good then
                    controlstest[j][IndexParent] = {}
                end if
            end if
        end for
        for j=1 to length(controlstest) do
            if controlstest[j][Indexed] then
                --look for controls with this control as IndexParent
                good = 0
                for k=1 to length(controlstest) do
                    if equal(controlstest[j][Name],controlstest[k][IndexParent]) then
                        good = 1
                        exit
                    end if
                end for
                if not good then
                    controlstest[j][Indexed] = w32False
                end if
            end if
        end for
        windows[i] = controlstest
    end for

    -- open the output file
    outFile = open(fName, "w")
    if outFile= -1 then
        -- give message and exit
        ignore = displayErrorMessage(144,{fName})
        --give user a chance to save under another name
        if ignore=IDNO then
            StopRun = w32True
            return
        else
            ok = invokeHandler(MenuSaveAs, w32HClick,{})
            StopRun = w32True
            return
        end if
    end if
    startSave = 1

    -- header    
    printf(outFile, "#Version %s\n", {Version})
    printf(outFile, "#Counter: %d\n", {counter})
    printf(outFile, "#WinCounter: %d\n", {winCounter})
    if checkDebug then
        puts(outFile, "#BindDebug\n")
    end if
    if checkList then
        puts(outFile, "#BindList\n")
    end if
    if checkQuiet then
        puts(outFile, "#BindQuiet\n")
    end if
    if checkCon then
        puts(outFile, "#BindCon\n")
    end if
    if length(bindingOutName) then
        printf(outFile, "#BindOutName: %s\n", {bindingOutName})
    end if
    if length(bindingIconName) then
        printf(outFile, "#BindIcoName: %s\n", {bindingIconName})
    end if
    if treatAsInclude then
        printf(outFile, "#Win32libInclude: %s\n", {"ew"})
    end if
    if not config_has_Winlib then
        printf(outFile, "#NoWin32libInclude: %d\n", {w32True})
    end if
    if length(prjWin32lib)
    and not equal(upper(prjWin32lib), upper(cfgWin32lib)) then
        printf(outFile, "#Win32libName: %s\n", {prjWin32lib})
    end if

    if addCrashFile then
        printf(outFile, "#AddCrashFile: %s\n",{w32True})
    end if

    if length(commandLineRun) then
        printf(outFile, "#CommandLine: %s\n", {commandLineRun})
    end if

    if length(config_Title) then
        printf(outFile, "#PgmTitle : %s\n", {config_Title})
    end if
    if length(config_Author) then
        printf(outFile, "#PgmAuthor : %s\n", {config_Author})
    end if
    if length(config_Date) then
        printf(outFile, "#PgmDate : %s\n", {config_Date})
    end if
    if length(config_Version) then
        printf(outFile, "#PgmVersion : %s\n", {config_Version})
    end if
    if length(config_WinLibVer) then
        printf(outFile, "#ReqWinlib : %s\n", {config_WinLibVer})
    end if
    if length(config_Desc) then
        puts(outFile, "#PgmDesc\n")
        text = config_Desc
        while w32True do

            -- look for an end of line
            at = match(CrLf, text)
            if at=0 then

                -- any text remaining?
                if length(text) then
                    puts(outFile, text & "\n")
                end if

                -- leave loop
                exit

            end if

            puts(outFile, text[1..at-1] & "\n")

            -- remove from text
            text = text[at+2..length(text)]

        end while

        puts(outFile, "#EndPgmDesc\n")
    end if

    if length(config_Comment) then
        puts(outFile, "#PgmComment\n")
        text = config_Comment
        while w32True do

            -- look for an end of line
            at = match(CrLf, text)
            if at=0 then

                -- any text remaining?
                if length(text) then
                    puts(outFile, text & "\n")
                end if

                -- leave loop
                exit

            end if

            puts(outFile, text[1..at-1] & "\n")

            -- remove from text
            text = text[at+2..length(text)]

        end while

        puts(outFile, "#EndPgmComment\n")
    end if

    if length(openModuleAt) then
        puts(outFile, "#OpenModuleAt\n")
        for i=1 to length(openModuleAt) do
            printf(outFile, "moduleAtControlEvent : %s\n", {openModuleAt[i][1]})
            printf(outFile, "moduleAtCol : %d\n", {openModuleAt[i][2]})
            printf(outFile, "moduleAtRow : %d\n", {openModuleAt[i][3]})
            printf(outFile, "moduleAtTop : %d\n", {openModuleAt[i][4]})
        end for
        puts(outFile, "#EndOpenModuleAt\n")
    end if

    -- write the windows
    for i=1 to length(windows) do
        -- window header
        printf(outFile, "#Window %d\n", {i})
        --put out layer tab captions, rename indicator for this window
        if length(layerCaptionSeq[i]) then
            puts(outFile, "#TabInfo\n")
        end if
        for j=1 to length(layerCaptionSeq[i]) do
            printf(outFile, "TabText: %s\n", {layerCaptionSeq[i][j][1]})
            printf(outFile, "TabRenamed: %d\n", {layerCaptionSeq[i][j][2]})
            printf(outFile, "TabNumber: %d\n", {layerCaptionSeq[i][j][3]})
            printf(outFile, "TabsetLayer: %d\n", {layerCaptionSeq[i][j][4]})
        end for

        -- get the controls
        ctrl = windows[i]

        -- write the controls
        for j=1 to length(ctrl) do
            writeControlToPrj(outFile, ctrl[j])
        end for

    end for

    --add the modules for this PRJ file
    for i=1 to length(includeModules) do
        module = includeModules[i][1]
        at = match(lower(projectDir), lower(module))
        if at then
           --remove
            module = module[at+length(projectDir)+1..length(module)]
        end if
        if length(module) and module[1]='\\' then
            module = module[2..length(module)]
        end if
        if match(projectDir,includeModules[1][3]) or length(includeModules[1][3])=0 then
            -- when path is project path do not write       
            puts(outFile, "#PathModule\n")
        else
            testModule = includeModules[i][3]
            if length(testModule) and testModule[length(testModule)]='\\' then
                testModule = testModule[1..length(testModule)-1]
                printf(outFile, "#PathModule %s\n", {testModule})
            else
                printf(outFile, "#PathModule %s\n", {includeModules[i][3]})
            end if
        end if
        printf(outFile, "#Module %s\n", {module})
        if length(includeModules[i][2]) then
            printf(outFile, "#ModuleAppend %s\n", {includeModules[i][2]})
        end if
    end for

    -- close the project file    
    close(outFile)
    endSave = 1
end procedure
------------------------------------------------------------------------------
function extractText(sequence text)
-- return text following colon.
-- ex: "foo  : 123" --> "123"
integer at
    at = find(':', text)
    if at+2>length(text) then
        return ""
    else
        return text[at+2..length(text)]
    end if
end function
------------------------------------------------------------------------------
function extractNumber(sequence text)
-- extract number following colon
-- ex: "foo  : 123" --> 123
sequence result
    text = extractText(text)
    if length(text) then
        result = value(text)
        return result[2]
    else
        return 0
    end if
end function
-----------------------------------------------------------------------------
global procedure setOpenFileName(integer id, sequence fName)

-- save the name of the open file
-- update the title bar of the window

sequence shortName

    if id then end if

    -- save name
    openFileName = fName

    -- truncate path from name
    shortName = fName
    for i=length(fName) to 1 by -1 do
        if fName[i]='\\' then
            shortName = fName[i+1..length(fName)]
            exit
        end if
    end for

    --check if project is for a Module
    if config_Ew then
        --update title bar
        setText(Controls, Application & " Module - " & shortName)
    else
        -- update title bar
        setText(Controls, Application & " - " & shortName)
    end if

end procedure
------------------------------------------------------------------------------
global procedure rebuildWindowList()

-- update the window list
sequence ctrls

    if winCounter=0 then
        --must be old version of IDE loaded
        winCounter = length(windows)
    end if

    -- clear the window list
    eraseItems(WinList)

    --clear the TabItemList
    eraseItems(TheTabItemCombo)

    -- add names of windows to list
    for i=1 to length(windows) do

        -- get the controls
        ctrls = windows[i]

        -- get the text of the first control (the window)
        addItem(WinList, ctrls[1][Name])
    end for

    -- restore the index
    if selectedWindow then
        setIndex(WinList, selectedWindow)
        setText(Design, getItem(WinList, selectedWindow))

        --restore the TabItem titles to TabItem combo
        ctrls = windows[selectedWindow]
        for i=1 to length(ctrls) do
            if equal(ctrls[i][Class], "TabItem") then
                addItem(TheTabItemCombo,ctrls[i][Name])
            end if
        end for

        --set the titlebar of combobox
        --for some reason you can not delete a control before going
        --to the properties page so use that to know the last tabItem
        for i=1 to getCount(TheTabItemCombo) do
            if equal(getItem(TheTabItemCombo, i), tabNewTitle) then
                setIndex(TheTabItemCombo, i)
                exit
            end if
        end for

    end if

end procedure
------------------------------------------------------------------------------
global procedure pickWindow(integer index)
sequence ctrls,controlsOff
integer saveActive
sequence sizeS, size

    delayDraw = w32True

    sizeS = getRect(Screen)

    saveActive = 0
    tabItemCoordinates = {}

    -- pick a window on the window list
    -- does NOT save current controls to window

    -- no control is selected
    selectedControl = TheWindow

    -- set index
    selectedWindow = index

    -- get controls
    controls = windows[selectedWindow]

    -- pick in list
    setIndex(WinList, selectedWindow)
    setText(Design, controls[TheWindow][Title])

    --restore the TabItem titles to TabItem combo
    eraseItems(TheTabItemCombo)
    selectedTabItem = {}
    ctrls = windows[selectedWindow]

    counterInWindow = 0
    haveReBar = w32False
    haveToolBar = w32False
    haveStatusBar = w32False
    haveEuGrid = 0
    repaintWinResize = w32False

    --delete any layer tabitems
    for i=1 to length(layerTabItemSeq) do
        destroy(layerTabItemSeq[i])
    end for

    layerNum = 0
    layerNumber = 0

    for i=1 to length(ctrls) do

        if equal(ctrls[i][Class], "TabItem") then
            addItem(TheTabItemCombo,ctrls[i][Name])
        end if

        --if there were tabitems then highlight the first active one
        if ctrls[i][Active]
        and not saveActive then
            saveActive = getCount(TheTabItemCombo)
        end if

        if find(ctrls[i][Class], {"ToolBar","FlatToolBar"}) then
            haveToolBar += 1
            forceRedraw = w32True
            repaintWinResize = w32True
        end if

        if equal(ctrls[i][Class], "ReBar") then
            haveReBar += 1
        end if

        if equal(ctrls[i][Class], "StatusBar") then
            haveStatusBar += 1
        end if

        if equal(ctrls[i][Class], "EuGrid") then
            haveEuGrid += 1
        end if
    end for

    layerTabItemSeq = {}

    for i=1 to length(layerCaptionSeq[selectedWindow]) do
        --build new tabitem for layer number
        layerNumber = layerCaptionSeq[selectedWindow][i][3]
        setCheck(MenuTabAllUseLayer, layerCaptionSeq[selectedWindow][i][4])

        LayersTI = createEx(TabItem,layerCaptionSeq[selectedWindow][i][1],LayersTC,0,0,0,0,0,0)
        setHandler(LayersTI,w32HClick,routine_id("change_LayerTI"))
        setHandler(LayersTC,w32HMouse,routine_id("mouse_LayerTC"))
        defineUserProperty(LayersTI,"layer",{layerNumber})
        setUserProperty(LayersTI,"layer",{layerNumber})
        layerTabItemSeq &= LayersTI
        if layerNumber>layerNum then
            layerNum = layerNumber
        end if
    end for
    setFocus(layerTabItemSeq[1])
    change_LayerTI(0,0,{})
    setText(Form, "Form Design")
    showBackLayer = {}
    setText(PopUpDesign_Layers, IDEText[986][1])

    if saveActive then
        setIndex(TheTabItemCombo, saveActive)

        for i=1 to length(ctrls) do
            if equal(ctrls[i][Title],
                     getItem(TheTabItemCombo, saveActive)) then
                selectedTabItem = ctrls[i][Name]
                exit
            end if
        end for
    end if

    --set popup for this window
    setEnable(PopUpDesign_PopUp, w32False)
    hasPopup = w32False

    for i=1 to length(ctrls) do
        if equal(ctrls[i][Class], "PopupItem") then
            setEnable(PopUpDesign_PopUp, w32True)
            exit
        end if
    end for

    --load the Properties DropDownList
    eraseItems(PropertyTitleBar)
    for i=1 to length(ctrls) do
        if match("Menu", ctrls[i][Class]) then
            --do nothing
        elsif match("Popup", ctrls[i][Class]) then
            --do nothing
        elsif match("Timer", ctrls[i][Class]) then
            --do nothing
        else
            addItem(PropertyTitleBar, ctrls[i][Name])
        end if
    end for
    if getCount(PropertyTitleBar) then
        setIndex(PropertyTitleBar, 1)
    end if

    dCX = ctrls[TheWindow][CX]
    dCY = ctrls[TheWindow][CY]

    dX = 0
    dY = 0

    setRect(Design, dX, dY, dCX, dCY, 1)

    size = getClientRect(Form)

    if dCX<=size[3] then
        setWindowScrollRange(Form, SB_HORZ, 0, 0, 1)
    else
        setWindowScrollRange(Form, SB_HORZ, 1, ctrls[TheWindow][CX], size[3])
    end if

    if dCY<=size[4] then
        setWindowScrollRange(Form, SB_VERT, 0, 0, 1)
    else
        setWindowScrollRange(Form, SB_VERT, 1, ctrls[TheWindow][CY]+20, size[4]) --20 is layer toolbar
    end if

    setHScrollPos(Form, 1)
    setVScrollPos(Form, 1)

    if isChecked(MenuColorNoSuppress) then
        if controls[selectedControl][BkColor] then
            if controls[selectedControl][BkColor]<0 then
                setPenColor(tile, Black)
            else
                setPenColor(tile, controls[selectedControl][BkColor])
            end if
        else
            setPenColor(tile, getSysColor(COLOR_BTNFACE))
        end if
    else
        setPenColor(tile, getSysColor(COLOR_BTNFACE))
    end if

    drawRectangle(tile, w32True, 0, 0, sizeS[3], sizeS[4])
    drawGrid(GridBlit)
    copyBlt(ControlBlit, 0, 0, GridBlit)

    -- paint the window
    selectedControl = TheWindow

    if getCount(TheTabItemCombo) then
        ok = invokeHandler(TheTabItemCombo, w32HChange,{})
    end if

    delayDraw = w32False

    call_proc(drawIt_id, {})

    bitBlt(Design, 0, 0, ControlBlit,0,0, gridX, gridY, SRCCOPY)

    --empty offscreen winodw
    copyBlt(OffScreenBlit, 0, 0, GridBlit)
    haveOffscreen = w32False

    --now find any negative controls for offscreen
    for i=1 to length(controls) do
        if not equal(controls[i][Class], "Window") then
            if controls[i][X]<0
            or controls[i][Y]<0 then
                haveOffscreen = w32True
                controlsOff = controls[i]
                if controlsOff[X]<0 then
                    controlsOff[X] *= -1
                end if
                if controlsOff[Y]<0 then
                    controlsOff[Y] *= -1
                end if
                drawControl(OffScreenBlit, controlsOff, Normal,i, 0)
            end if
        end if
    end for

    if haveOffscreen then
        bitBlt(OffScreen, 0, 0, OffScreenBlit,0,0, gridX, gridY, SRCCOPY)
    end if

end procedure
------------------------------------------------------------------------------
global procedure newProject(integer id)
-- create a new project
-- should have option to save current project...
integer at, index
sequence includeModuleData, path, filename, layerTabInfo, data

    if id then end if

    includeModuleData = {"","","",0}
    eraseItems(CodeModules)
    eraseItems(PathModules)
    setEnable(CodeModules, w32False)

    -- reset counter
    counter = 0
    winCounter = 0
    IDE_Changed = w32False
    userReorderControls = w32False

    crashfile = {}

    zeroEvent = w32True

    -- clear the controls and menus
    controls = {}

    --clear tab caption seq
    layerTabInfo = {{IDEText[984][1] & " 0",0,0,0}}
    layerCaptionSeq = {layerTabInfo}
    layerNumber = 0

    --clear tabs
    for i=1 to length(layerTabItemSeq) do
--      destroy(layerTabItemSeq)
        destroy(layerTabItemSeq[i])
    end for
    layerTabItemSeq = {}

    dCX = DesignCX
    dCY = DesignCY

    selectedWindow = 1  --Josef Jindra

    -- create the design window properties
    newWindow("Window1", "Window1", dCX, dCY)
    --scroll to top
    setHScrollPos(Form, 1)
    setVScrollPos(Form, 1)
    -- resize the Design window
    setRect(Design, dX, dY, dCX, dCY, 1)

    -- no selected control
    selectedControl = TheWindow
    selectedWindow = 0

    -- normal state
    state = Normal

    -- clear window title    
    setText(Controls, Application & " - Untitled")

    setFocus(ToolboxTabItem2)
    setFocus(ToolboxTabItem)

    -- clear file name
    openFileName = ""

    textOrigName = ""

    -- update window list
    rebuildWindowList()

    -- select the window
    pickWindow(1)

    --clear program information
    config_Title = ""
    config_Version = ""
    config_Author = ""
    config_Date = ""
    config_Desc = ""
    config_Comment = ""
    config_WinLibVer = ""

    bindingIconName = {}
    bindingOptions = {}
    HintsExtra = {}
    otherKeywords = {}
    localKeywords = {}
    ceKeywords = {}
    data = synGetSavable()
    if length(data) then
        index = find("Module",data[1])
        if index then
            data[2][index] = {}
            synSetSavableCorrected(data)
        end if
    end if

    --clear fonts from any prior project for Table
    tableFontName = {}
    tableFontAttrib = {}
    tableFontPts = 0
    tableFontBold = 0
    tableFontUnderline = 0
    tableFontStrikeout = 0

    --if default MIS add to includeModules now
    includeModules = {}
    if length(settingsBuffer[cfgDefaultMIS]) then
        for i=1 to length(settingsBuffer[cfgDefaultMIS]) do
            filename = settingsBuffer[cfgDefaultMIS][i]
            filename = reverse(settingsBuffer[cfgDefaultMIS][i])
            at = match("\\",filename)
            if at then
                path = filename[at+1..length(filename)]
                path = reverse(path)
            end if
            filename = reverse(filename)
            includeModuleData[1] = filename
            includeModuleData[2] = ""
            includeModuleData[3] = path
            includeModuleData[4] = w32True
            includeModules &= {includeModuleData}
            --get its keywords/hints
            call_proc(readModuleFile_id,{filename})
        end for
    end if
end procedure
-------------------------------------------------------------------------------
procedure findControl_eventNames(sequence input)
sequence line,buffer,keywordType,keywordRoutine
integer at,keyType

--read control-event and find all procedure and
--function statements
    buffer = {}
    for i=1 to length(input) do
        line = input[i]
        --remove \n
        if length(line) then
            if line[length(line)]='\n' then
                line = line[1..length(line)-1]
            end if

            --remove comments                           
            at = match("--",line)
            if at then
                line = line[1..at-1]
            end if

            --remove hard tab
            while w32True do
                at = find('\t', line)
                if at then
                    line[at] = ' '
                else
                    exit
                end if
            end while

            line = trimL(line)
            line = trimR(line)

            if match("end procedure", line)
            or match("end function", line) then
                --skip
            else
                if match("procedure", line)
                or match("function", line) then
                    if length(line)>9 then
                        buffer &= {line}
                    else
                        --look for routine name on next line not a comment line
                        for j=i+1 to length(input) do
                            --ignore comment line
                            at = match("--",input[j])
                            if at then
                                input[j] = input[j][1..at-1]
                            end if
                            input[j] = w32trim(input[j])
                            if length(input[j]) then
                                line = line&" "&input[j]
                                buffer &= {line}
                                exit
                            end if
                        end for
                    end if
                end if
            end if
        end if
    end for

    for i=1 to length(buffer) do
        --rearange the statement to look like Hints
        --take off global
        keyType = w32False   --local
        if equal(buffer[i][1..6],"global") then
            buffer[i] = buffer[i][8..length(buffer[i])]
            keyType = w32True
        end if

        --find procedure or function, save and strip
        keywordType = {}
        if match("procedure", buffer[i][1..9]) then
            keywordType = "procedure"
            buffer[i] = buffer[i][10..length(buffer[i])]
        elsif match("function", buffer[i][1..8]) then
            keywordType = "function"
            buffer[i] = buffer[i][9..length(buffer[i])]
        end if

        if length(keywordType) then
            --find the first paranthesis
            at = find('(', buffer[i])
            if not at then
                --I goofed stop
                ok = displayErrorMessage(145,{})
                exit
            else
                keywordRoutine = buffer[i][1..at-1]
                keywordRoutine = trimL(keywordRoutine)
                keywordRoutine = trimR(keywordRoutine)
                if keyType then
                    if not find(keywordRoutine, otherKeywords) then
                        otherKeywords &= {keywordRoutine}
                    end if
                else
                    if not find(keywordRoutine, ceKeywords) then
                        ceKeywords &= {keywordRoutine}
                    end if
                end if
                if CodeWinExists then
                    updateKeywords()
                end if
            end if
        end if

    end for

end procedure
--------------------------------------------------------------------------------
procedure findRoutineNames(integer handle, sequence filename)
object line
integer at, needNext, needProcedure, kind
sequence buffer, keywordType, keywordRoutine, keywordParams, newBufferData,
            newKeywordParams, cleanKeyword

    needNext = w32False
    needProcedure = w32False
    --read include file and find all global procedure and
    --global function statements
    buffer = {}

    while 1 do
        line = gets(handle)
        if atom(line) then
            exit   -- -1 is returned at end of file
        end if

        --remove \n
        if line[length(line)]='\n' then
            line = line[1..length(line)-1]
        end if

        --remove comments
        if length(line) then
            for j=1 to length(line)-1 do
                if line[j]='-'
                and line[j+1]='-' then
                    line = line[1..j-1]
                    exit
                end if
            end for
        end if

        --remove hard tab
        while w32True do
            at = find('\t', line)
            if at then
                line[at] = ' '
            else
                exit
            end if
        end while

        line = trimL(line)
        line = trimR(line)

        if needProcedure then
            at = match("procedure", line)
            if at then
                line = "global " & line
                needProcedure = w32False
                at = match(")", line)
                if not at then
                    needNext = w32True
                end if
            else
                at = match("function", line)
                if at then
                    line = "global " & line
                    needProcedure = w32False
                    at = match(")", line)
                    if not at then
                        needNext = w32True
                    end if
                end if
            end if
        else
            at = match("procedure", line)
            if at=1 then
                buffer &= {line}
                needNext = w32False
                at = match(")", line)
                if not at then
                    needNext = w32True
                end if
            end if
            at = match("function", line)
            if at=1 then
                buffer &= {line}
                needNext = w32False
                at = match(")", line)
                if not at then
                    needNext = w32True
                end if
            end if
        end if

        if needNext
        and length(line) then
            at = match(")", line)
            if at then
                needNext = w32False
            end if
            buffer[length(buffer)] = buffer[length(buffer)] & line
        end if

        at = match("global", line)
        if at
        and length(line)=6 then
            needProcedure = w32True
        end if

        at = match("global procedure", line)
        if at=1 then
            buffer &= {line}

            --does it have ending )?
            needNext = w32False
            if match(")", line) then
                --got all params
            else
                needNext = w32True
            end if
        end if

        at = match("global function", line)
        if at=1 then
            buffer &= {line}

            needNext = w32False
            if match(")", line) then
                --done
            else
                needNext = w32True
            end if
        end if
    end while

    close(handle)

    for i=1 to length(buffer) do
        --rearange the statement to look like Hints
        --take off global
        kind = 2
        if equal(buffer[i][1..6],"global") then
            buffer[i] = buffer[i][8..length(buffer[i])]
            kind = 1
        end if
        --find procedure or function, save and strip
        if match("procedure", buffer[i]) then
            keywordType = "procedure"
            buffer[i] = buffer[i][10..length(buffer[i])]
        else
            keywordType = "function"
            buffer[i] = buffer[i][9..length(buffer[i])]
        end if

        --find the first paranthesis
        at = find('(', buffer[i])
        if not at then
            --I goofed stop
            ok = displayErrorMessage(145,{})
            exit
        else
            keywordRoutine = buffer[i][1..at-1]
            keywordRoutine = trimL(keywordRoutine)
            keywordRoutine = trimR(keywordRoutine)
            if kind=1 then --global
                if not find(keywordRoutine,otherKeywords) then
                    otherKeywords &= {keywordRoutine}
                    jumpToKeywords &= {{filename,otherKeywords}}
                else
                    kind = 0    --will skip making hint
                end if
            else
                if not find(keywordRoutine, localKeywords) then
                    localKeywords &= {keywordRoutine}
                    jumpToKeywords &= {{filename,localKeywords}}
                end if
            end if
            if CodeWinExists then
                updateKeywords()
            end if
        end if

        if kind=1 then  --global routines produce Hints
            --if the next letter is ) then there are no params
            if buffer[i][at+1]=')' then
                --done
                keywordParams = {}
            else
                keywordParams = {}
                for j=at+1 to length(buffer[i]) do
                    if buffer[i][j]=')' then
                        --done
                        exit
                    else
                        keywordParams = append(keywordParams, buffer[i][j])
                    end if
                end for
            end if

            --build statement
            newBufferData = {keywordRoutine}

            newKeywordParams = ""

            while length(keywordParams) do
                at = find(',', keywordParams)
                if at then
                    cleanKeyword = trimL(keywordParams[1..at-1])
                    cleanKeyword = trimR(cleanKeyword)
                    newKeywordParams = append(newKeywordParams, cleanKeyword)
                    keywordParams = keywordParams[at+1..length(keywordParams)]
                else
                    exit
                end if
            end while

            if length(keywordParams) then
                cleanKeyword = trimL(keywordParams)
                cleanKeyword = trimR(cleanKeyword)
                newKeywordParams = append(newKeywordParams, cleanKeyword)
            end if

            newBufferData &= {newKeywordParams}

            newBufferData &= {keywordType}

            HintsExtra = HintsExtra[1..length(HintsExtra)]
                         & newBufferData

            editorUpdateHintsList()

        end if
    end for

end procedure
-----------------------------------------------------------------------------
global procedure readModuleFile(sequence fName)
integer handle, at
object isOk

--is there a path?
    at = match("\\", reverse(fName))
    if not at then

        --check the current directory
        isOk = dir(fName)
        if atom(isOk) then
            --maybe file is in IDE dir?
            isOk = chdir(the_current_dir)
            isOk = dir(fName)
        end if

        if atom(isOk) then
            --maybe file is in project dir?
            isOk = chdir(projectDir)
            isOk = dir(fName)
        end if

        if atom(isOk) then
            --check EuInc files
            for i=1 to length(euIncFiles) do
                isOk = chdir(euIncFiles[i])
                isOk = dir(fName)
                if sequence(isOk) then
                    exit
                end if
            end for
        end if

        if atom(isOk) then
            --maybe file is an EU include file?
            euDir = whereEu
            isOk = chdir(euDir & "\\include")
            isOk = dir(fName)
        end if
    end if


    --read the file
    handle = open(fName, "r")

    if handle= -1 then
        ok = displayErrorMessage(146,{fName})
        return
    end if

    findRoutineNames(handle,fName)

end procedure
readModuleFile_id = routine_id("readModuleFile")
------------------------------------------------------------------------------
global procedure readProject(integer id, sequence fName)

integer file, event, ignore, index, countControls, needProc, foundAWindow, needToSort,
            bar, YCounter, at, haveSysTray, skipSysTrayHide,
            tabindex,haveTabCaptions
sequence shortName, projectFileTypeTest, data, openModuleAt1
object text, isOk, euDir
sequence iconFilename, includeModuleData, fileNamePath, fileNameWithoutPath
sequence fileNameExistingPath, layerTabInfo, usedTabs,slot
sequence versione
sequence ver1,ver2,ver3
object Ver1,Ver2,Ver3,finalVer
integer at1,checkLayer
sequence lastMenuName, lastSubmenuName, lastSub2menuName, lastSub3menuName,
                        lastPopupName, lastSubpopupName, lastSub2popupName, lastSub3popupName

    ver1 = {}
    ver2 = {}
    ver3 = {}
    checkLayer = w32False

    includeModuleData = {"","","",0,0}
    openModuleAt1 = {"",0,0,0}
    eraseItems(CodeModules)
    eraseItems(PathModules)
    setEnable(CodeModules, w32False)
    crashfile = {}

    countControls = 0
    YCounter = 0

    zeroEvent = w32True

    otherKeywords = {}
    localKeywords = {}
    ceKeywords = {}
    CWindowBars = {}

    HintsExtra = {}
    data = synGetSavable()
    if length(data) then
        index = find("Module",data[1])
        if index then
            data[2][index] = {}
            synSetSavableCorrected(data)
        end if
    end if

    foundAWindow = w32False
    needToSort = w32False

    skipSysTrayHide = w32False

    projectFileTypeTest = reverse(projectFileType)
    projectFileTypeTest = append(projectFileTypeTest,'.')

    -- truncate path from name
    shortName = fName
    for i=length(fName) to 1 by -1 do
        if fName[i]='\\' then
            shortName = fName[i+1..length(fName)]
            exit
        end if
    end for

    shortName = reverse(shortName)
    if match(projectFileTypeTest, lower(shortName)) then
        --is good
    else
        ok = displayErrorMessage(147,{projectFileType})
        return
    end if

    -- open the file
    file = open(fName, "r")
    if file= -1 then
        --try appending the_current_dir
        fName = the_current_dir & "\\" & fName
        file = open(fName, "r")
        if file= -1 then
            -- give message and exit
            ignore = displayErrorMessage(148,{fName})
            return
        end if
    end if

    -- clear the controls
    openModuleAt = {}
    counter = 0
    winCounter = 0
    index   = 0
    tabindex = 0
    windows = {}
    controls = {}
    selectedControl = TheWindow
    state = Normal

    prjWin32lib = {}
    config_Winlib_Name = {}
    config_Title = {}
    config_Author = {}
    config_Date = {}
    config_Version = {}
    config_Desc = {}
    config_Comment = {}
    config_WinLibVer = {}
    checkDebug = w32False
    checkList = w32False
    checkQuiet = w32False
    checkCon = w32False
    bindingOutName = {}
    bindingIconName = {}
    bindingOptions = {}
    commandLineRun = {}
    layerCaptionSeq = {}
    layerTabInfo = {}
    usedTabs = {}
    haveTabCaptions = w32False

    --clear fonts from any prior project for Table
    tableFontName = {}
    tableFontAttrib = {}
    tableFontPts = 0
    tableFontBold = 0
    tableFontUnderline = 0
    tableFontStrikeout = 0

    --clear modules list
    includeModules = {}

    treatAsInclude = w32False
    config_Ew = w32False
    config_Exw = w32True
    addCrashFile = w32False

    config_has_Winlib = w32True
    haveSysTray = w32False         --lets know if IDE created or user hard coded    

    -- parse the file
    while 1 do

        -- get a line of text
        text = gets(file)
        if atom(text) then
            exit
        end if

        -- remove line feed
        text = Replace(text, "\n", "")

        if match("ClassDefaults", text)=1 then
            --this produces an error so switch wording
            text = "DefaultsClass" & text[14..length(text)]
        end if

        if length(text)=0 then
            -- ignore blank lines

        elsif match("#Version ", text)=1 then
            versione = text[10..length(text)]
            at = match(".",versione)
            if at then
                ver1 = versione[1..at-1]
                versione = versione[at+1..length(versione)]
                at1 = match(".",versione)
                if at1 then
                    ver2 = versione[1..at1-1]
                    ver3 = versione[at1+1..length(versione)]
                    Ver1 = value(ver1)
                    Ver2 = value(ver2)
                    Ver3 = value(ver3)

                    if Ver1[1]=GET_SUCCESS then
                        Ver1 = Ver1[2]
                        Ver1 *= 1000000
                        if Ver2[1]=GET_SUCCESS then
                            Ver2 = Ver2[2]
                            Ver2 *= 1000
                            if Ver3[1]=GET_SUCCESS then
                                Ver3 = Ver3[2]
                                finalVer = Ver1+Ver2+Ver3
                                if finalVer<000018009 then
                                    checkLayer = w32True
                                end if
                            end if
                        end if
                    end if
                end if
            end if

        elsif match("#Counter", text)=1 then
            counter = extractNumber(text)

        elsif match("#BindDebug", text)=1 then
            checkDebug = w32True

        elsif match("#BindList", text)=1 then
            checkList = w32True

        elsif match("#BindQuiet", text)=1 then
            checkQuiet = w32True

        elsif match("#BindCon", text)=1 then
            checkCon = w32True

        elsif match("#BindIcoName", text)=1 then
            iconFilename = extractText(text)
            bindingIconName = iconFilename

        elsif match("#BindOutName", text)=1 then
            iconFilename = extractText(text)
            bindingOutName = iconFilename

        elsif match("#NoWin32libInclude", text)=1 then
            config_has_Winlib = w32False

        elsif match("#Win32libInclude", text)=1 then
            iconFilename = extractText(text)
            if equal("ew", iconFilename) then
                treatAsInclude = w32True
                config_Ew = w32True
                config_Exw = w32False
            end if
        elsif match("#AddCrashFile", text) then
            addCrashFile = w32True

        elsif match("#Win32libName", text)=1 then
            iconFilename = extractText(text)
            prjWin32lib = iconFilename
            config_Winlib_Name = prjWin32lib

        elsif match("#CommandLine:", text)=1 then
            commandLineRun = extractText(text)

        elsif match("#WinCounter", text)=1 then
            winCounter = extractNumber(text)

        elsif match("#PgmTitle :", text)=1 then
            config_Title = extractText(text)

        elsif match("#PgmAuthor :", text)=1 then
            config_Author = extractText(text)

        elsif match("#PgmDate :", text)=1 then
            config_Date = extractText(text)

        elsif match("#PgmVersion :", text)=1 then
            config_Version = extractText(text)

        elsif match("#ReqWinlib :", text)=1 then
            config_WinLibVer = extractText(text)

        elsif match("#PgmDesc", text)=1 then
            while 1 do
                -- read the next line
                text = gets(file)

                if match("#EndPgmDesc", text)=1 then
                    exit
                end if

                -- replace { ... \n } with { ... \r, \n }
                text = text[1..length(text)-1] & CrLf

                -- add to code
                config_Desc &= text
            end while

        elsif match("#PgmComment", text)=1 then
            while 1 do
                -- read the next line
                text = gets(file)

                if match("#EndPgmComment", text)=1 then
                    exit
                end if

                -- replace { ... \n } with { ... \r, \n }
                text = text[1..length(text)-1] & CrLf

                -- add to code
                config_Comment &= text
            end while

        elsif match("#OpenModuleAt", text)=1 then
            openModuleAt = {}
            while 1 do
                -- read the next line
                text = gets(file)

                if match("#EndOpenModuleAt", text)=1 then
                    exit
                end if

                if match("moduleAtControlEvent :", text)=1 then
                    openModuleAt1 = {{},0,0,0}
                    openModuleAt1[1] = extractText(text)
                    openModuleAt1[1] = w32trim(openModuleAt1[1])
                end if

                if match("moduleAtCol :", text)=1 then
                    openModuleAt1[2] = extractNumber(text)
                end if

                if match("moduleAtRow :", text)=1 then
                    openModuleAt1[3] = extractNumber(text)
                end if

                if match("moduleAtTop :", text)=1 then
                    openModuleAt1[4] = extractNumber(text)
                    openModuleAt &= {openModuleAt1}
                end if

            end while

        elsif match("#Window", text)=1 then
            -- new window

            -- any controls already read?
            if length(controls) then
                if equal(controls[length(controls)][Class],"Table") then
                    if controls[length(controls)][TableCols]*controls[length(controls)][TableRows]
                                                          >length(controls[length(controls)][SeqChildName]) then
                        ignore = displayErrorMessage(250,{controls[length(controls)][Name]})
                    end if
                end if
                if not foundAWindow
                or needToSort then
                    controls = sort(controls)
                end if

                -- append to the window list
                windows &= {controls}

            end if

            if length(layerTabInfo) then
                layerCaptionSeq &= {layerTabInfo}
            end if

            if length(usedTabs) then
                if not haveTabCaptions then
                    usedTabs = sort(usedTabs)
                    for i=1 to length(usedTabs) do
                        slot = {"",0,0,0}
                        slot[1] = IDEText[984][1] & " " & sprint(usedTabs[i])
                        slot[3] = usedTabs[i]
                        layerTabInfo &= {slot}
                    end for
                    layerCaptionSeq &= {layerTabInfo}
                end if
            elsif length(controls) then
                if not haveTabCaptions then
                    slot = {"",0,0,0}
                    slot[1] = IDEText[984][1] & " 0"
                    layerTabInfo = {slot}
                    layerCaptionSeq &= {layerTabInfo}
                end if
            end if
            usedTabs = {}
            layerTabInfo = {}
            haveTabCaptions = w32False

            if length(controls) then
                -- clear the controls
                controls = {}
                index = 0
                foundAWindow = w32False
                needToSort = w32False
                haveSysTray = w32False
                skipSysTrayHide = w32False
            end if

            lastMenuName = {}
            lastSubmenuName = {}
            lastSub2menuName = {}
            lastSub3menuName = {}
            lastPopupName = {}
            lastSubpopupName = {}
            lastSub2popupName = {}
            lastSub3popupName = {}

        elsif match("#TabInfo", text)=1 then
            haveTabCaptions = w32True
            tabindex = 0

        elsif match("TabText", text)=1 then
            if tabindex=0 then
                layerTabInfo = {{"",0,0,0}}
            else
                layerTabInfo &= {{"",0,0,0}}
            end if
            tabindex += 1
            layerTabInfo[tabindex][1] = extractText(text)

        elsif match("TabRenamed", text)=1 then
            layerTabInfo[tabindex][2] = extractNumber(text)

        elsif match("TabNumber", text)=1 then
            layerTabInfo[tabindex][3] = extractNumber(text)

        elsif match("TabsetLayer", text)=1 then
            layerTabInfo[tabindex][4] = extractNumber(text)

        elsif match("#Control", text)=1 then
            --if last control was Table need to examine TableCols and TableRows to number
            --of childrne
            if length(controls) then
                if equal(controls[length(controls)][Class],"Table") then
                    if controls[length(controls)][TableCols]*controls[length(controls)][TableRows]
                                                          >length(controls[length(controls)][SeqChildName]) then
                        ignore = displayErrorMessage(250,{controls[length(controls)][Name]})
                    end if
                end if
            end if
            -- increment the counter
            --stopped doing this when it was discovered wrong counter may be
            --assigned when controls are deleted.
            --So assign this way only for older IDE prj files.
            if counter=0 then
                counter += 1
            end if

            -- increment the index
            index += 1

            -- create a new control            
            -- allocate space for a control
            controls &= {repeat(0, ControlSize)}

            --initialize those fields that are sequences or not zero
            controls[length(controls)][AWindow] = 30    --will be adjusted below
            controls[length(controls)][SubClass] = {}
            controls[length(controls)][ControlParent] = {}
            controls[length(controls)][ParentClass] = {}
            controls[length(controls)][Parent] = {}
            controls[length(controls)][StyleType] = {}
            controls[length(controls)][Buddy] = {}
            controls[length(controls)][IcoFile] = {}
            controls[length(controls)][TwoIcoFile] = {}
            controls[length(controls)][TriIcoFile] = {}
            controls[length(controls)][BitmapFile] = {}
            controls[length(controls)][HintText] = {}
            controls[length(controls)][HintFontName] = {}
            controls[length(controls)][FontName] = {}
            controls[length(controls)][ExStyle] = "0"
            controls[length(controls)][XPM] = {}
            controls[length(controls)][XPMmember] = {}
            controls[length(controls)][XpmObject] = {}
            controls[length(controls)][XpmDisableObject] = {}
            controls[length(controls)][InitialVal] = {}
            controls[length(controls)][SetEvent] = {}
            controls[length(controls)][SetControl] = {}
            controls[length(controls)][KillEvent] = {}
            controls[length(controls)][KillControl] = {}
            controls[length(controls)][CCWinStyle] = {}
            controls[length(controls)][WidthTitle] = {}
            controls[length(controls)][ExtExStyle] = {}
            controls[length(controls)][SelectWidth] = {}
            controls[length(controls)][SystemBkColor] = {}
            controls[length(controls)][OutX] = {}
            controls[length(controls)][OutY] = {}
            controls[length(controls)][OutCX] = {}
            controls[length(controls)][OutCY] = {}
            controls[length(controls)][ControlComment] = {}
            controls[length(controls)][DEFIndex] = {}
            controls[length(controls)][SysTrayIcon] = {}
            controls[length(controls)][SysTrayHint] = {}
            controls[length(controls)][SysTrayText] = {}
            controls[length(controls)][IndexParent] = {}
            controls[length(controls)][SeqParentName] = {}
            controls[length(controls)][SeqParentClass] = {}
            controls[length(controls)][SeqChildName] = {}
            controls[length(controls)][GridFormat] = {}
            controls[length(controls)][GridDataArrayName] = {}
            controls[length(controls)][GridColListValues] = {}
            controls[length(controls)][WinOpenAtCtrl] = {}
            controls[length(controls)][ClassDefaults] = {}
            controls[length(controls)][ValueEdit] = {}
            controls[length(controls)][OrigTitle] = {}
            controls[length(controls)][ControlPartners] = {}
            controls[length(controls)][FontVarName] = {}
            controls[length(controls)][FontVarPts] = {}
            controls[length(controls)][FontVarItalic] = {}
            controls[length(controls)][FontVarBold] = {}
            controls[length(controls)][FontVarUnderline] = {}
            controls[length(controls)][FontVarStrikeout] = {}
            controls[length(controls)][HintFontVarName] = {}
            controls[length(controls)][HintFontVarPts] = {}
            controls[length(controls)][HintFontVarItalic] = {}
            controls[length(controls)][HintFontVarBold] = {}
            controls[length(controls)][HintFontVarUnderline] = {}
            controls[length(controls)][HintFontVarStrikeout] = {}
            controls[length(controls)][FontVarColor] = {}
            controls[length(controls)][HintVarText] = {}
            controls[length(controls)][GenFromName] = {}

            -- the code
            controls[index][Code] = repeat({}, length(Events))

            -- name
            controls[index][Name] = extractText(text)

            -- give it an id
            countControls += 1
            controls[index][Id] = countControls

            fileNameExistingPath = {}

        elsif match("AWindow", text)=1 then
            controls[index][AWindow] = extractNumber(text)

        elsif match("X", text)=1 then
            controls[index][X] = extractNumber(text)

        elsif match("Y", text)=1 then
            controls[index][Y] = extractNumber(text)

        elsif match("CX", text)=1 then
            controls[index][CX] = extractNumber(text)

        elsif match("CY", text)=1 then
            controls[index][CY] = extractNumber(text)

        elsif match("LastListHeight", text)=1 then
            controls[index][LastListHeight] = extractNumber(text)

        elsif match("ControlLayer", text)=1 then
            controls[index][ControlLayer] = extractNumber(text)
            at = find(controls[index][ControlLayer],usedTabs)
            if not at then
                usedTabs &= controls[index][ControlLayer]
            end if
            if checkLayer then
                controls[index][SetLayerOK] = w32True
            end if

        elsif match("SetLayerOK", text)=1 then
            controls[index][SetLayerOK] = extractNumber(text)

        elsif match("SetLayerAll", text)=1 then
            --this is obsolete but here for conversion from older projects
            layerTabInfo[1][4] = w32True
            if checkLayer then
                controls[index][SetLayerOK] = w32True
            end if

        elsif match("ToolRowCY", text)=1 then
            controls[index][ToolRowCY] = extractNumber(text)

        elsif match("SuppressCell", text)=1 then
            controls[index][SuppressCell] = extractNumber(text)

        elsif match("Title", text)=1 then
            controls[index][Title] = extractText(text)

        elsif match("Valueedit", text)=1 then
            controls[index][ValueEdit] = extractText(text)

        elsif match("Labelextent", text)=1 then
            controls[index][LabelExtent] = extractNumber(text)

        elsif match("TableGenBorder", text)=1 then
            controls[index][TableGenBorder] = extractNumber(text)

        elsif match("TableGenInExw", text)=1 then
            controls[index][TableGenInExw] = extractNumber(text)

        elsif match("WidthTitle", text)=1 then
            controls[index][WidthTitle] = extractText(text)
        elsif match("SeqParentName", text)=1 then
            controls[index][SeqParentName] = extractText(text)
            if not length(controls[index][SeqParentName]) then
                --v0.20.0 begins assigning Menu and Popup parenting when save their
                --editors so when read older project need to assign
                if equal(controls[index][Class], "Menu") then
                    --save the name for following menuitems.
                    lastMenuName = controls[index][Name]
                    controls[index][SeqParentName] = {}
                end if

                if equal(controls[index][Class], "Submenu") then
                    --save the name for following submenuitems.
                    lastSubmenuName = controls[index][Name]
                end if

                if equal(controls[index][Class], "Sub2menu") then
                    --save the name for following sub2menuitems.
                    lastSub2menuName = controls[index][Name]
                end if

                if equal(controls[index][Class], "Sub3menu") then
                    --save the name for following sub3menuitems.
                    lastSub3menuName = controls[index][Name]
                end if
                --now set parenting                         
                if equal(controls[index][Class], "MenuItem")
                or equal(controls[index][Class], "Submenu") then
                                                --use the last menu name
                    controls[index][SeqParentName] = lastMenuName
                end if

                if equal(controls[index][Class], "SubmenuItem")
                or equal(controls[index][Class], "Sub2menu") then
                    --use the last Submenu name
                    controls[index][SeqParentName] = lastSubmenuName
                end if

                if equal(controls[index][Class], "Sub2menuItem")
                or equal(controls[index][Class], "Sub3menu") then
                    --use the last Sub2menu name
                    controls[index][SeqParentName] = lastSub2menuName
                end if

                if equal(controls[index][Class], "Sub3menuItem") then
                    --use the last Sub3menu name
                    controls[index][SeqParentName] = lastSub3menuName
                end if

                if equal(controls[index][Class], "Popup") then
                --save the name for following popupitems
                    lastPopupName = controls[index][Name]
                    controls[index][SeqParentName] = {}
                end if

                if equal(controls[index][Class], "Subpopup") then
                    --save the name for following subpopupitems
                    lastSubpopupName = controls[index][Name]
                end if

                if equal(controls[index][Class], "Sub2popup") then
                    --save the name for following sub2popupitems
                    lastSub2popupName = controls[index][Name]
                end if

                if equal(controls[index][Class], "Sub3popup") then
                    --save the name for following sub2popupitems
                    lastSub3popupName = controls[index][Name]
                end if

                if equal(controls[index][Class], "PopupItem")
                or equal(controls[index][Class], "Subpopup") then
                --use the last popup name
                    controls[index][SeqParentName] = lastPopupName
                end if

                if equal(controls[index][Class], "SubpopupItem")
                or equal(controls[index][Class], "Sub2popup") then
                --use the last Subpopup name
                    controls[index][SeqParentName] = lastSubpopupName
                end if

                if equal(controls[index][Class], "Sub2popupItem")
                or equal(controls[index][Class], "Sub3popup") then
                --use the last Sub2popup name
                    controls[index][SeqParentName] = lastSub2popupName
                end if

                if equal(controls[index][Class], "Sub3popupItem") then
                --use the last Sub3popup name
                    controls[index][SeqParentName] = lastSub3popupName
                end if
            end if

        elsif match("SeqParentClass", text)=1 then
            controls[index][SeqParentClass] = extractText(text)

        elsif match("SeqChildName", text)=1 then
            if length(extractText(text)) then
                controls[index][SeqChildName] &= {extractText(text)}
            end if

        elsif match("TabOrder",text)=1 then
            controls[index][TabOrder] = extractNumber(text)

        elsif match("SubClass", text)=1 then
            if length(text) then
                controls[index][SubClass] = extractText(text)
            end if

        elsif match("Class", text)=1 then
            controls[index][Class] = extractText(text)
            --one time conversion to fix 0.19.n files

            if equal(controls[index][Class], "Window") then
                controls[index][AWindow] = 0
            end if

            --conversion didn't catch popups so protect here again
            if find(controls[index][Class], {"Menu","MenuItem","Submenu",
                                             "SubmenuItem","Sub2menu",
                                             "Sub2menuItem","Sub3menu",
                                             "Sub3menuItem"}) then
                controls[index][AWindow] = 1

            elsif find(controls[index][Class], {"Popup","PopupItem","Subpopup",
                                                "SubpopupItem","Sub2popup",
                                                "Sub2popupItem","Sub3popup",
                                                "Sub3popupItem"}) then
                controls[index][AWindow] = 2

            elsif equal(controls[index][Class], "Timer") then
                controls[index][AWindow] = 3
            end if

            if not foundAWindow then        --will become w32True when reading an already converted 

                if find(controls[index][Class], {"Menu","MenuItem","Submenu",
                                                 "SubmenuItem","Sub2menu",
                                                 "Sub2menuItem","Sub3menu",
                                                 "Sub3menuItem"}) then
                    controls[index][AWindow] = 1

                elsif find(controls[index][Class], {"Popup","PopupItem","Subpopup",
                                                    "SubpopupItem","Sub2popup",
                                                    "Sub2popupItem","Sub3popup",
                                                    "Sub3popupItem"}) then
                    if controls[index][AWindow]=2 then
                        foundAWindow = w32True
                    else
                        controls[index][AWindow] = 2
                    end if
                    controls[index][AWindow] = 2

                elsif equal(controls[index][Class], "Timer") then
                    if controls[index][AWindow]=3 then
                        foundAWindow = w32True
                    else
                        controls[index][AWindow] = 3
                    end if
                    controls[index][AWindow] = 3

                elsif equal(controls[index][Class], "CWindow") then
                    if controls[index][AWindow]=4 then
                        foundAWindow = w32True
                    else
                        controls[index][AWindow] = 4
                        controls[index][TabOrder] = 0
                        userReorderControls = w32True
                    end if

                elsif equal(controls[index][Class], "ReBar") then
                    controls[index][AWindow] = 5

                elsif not equal(controls[index][Class], "ReBar") then
                    if controls[index][AWindow]=5 then
                        controls[index][AWindow] = 30
                    end if

                elsif equal(controls[index][Class], "ReBarBand") then
                    if controls[index][AWindow]=6 then
                        foundAWindow = w32True
                    else
                        controls[index][AWindow] = 6
                    end if

                elsif find(controls[index][Class], {"ToolBar","FlatToolBar","StatusBar"}) then
                    if controls[index][AWindow]=7 then
                        foundAWindow = w32True
                    else
                        controls[index][AWindow] = 7
                    end if

                elsif equal(controls[index][SeqParentClass], "ReBarBand") then
                    if not find(controls[index][Class], {"ToolBar","FlatToolBar"}) then
                        if controls[index][AWindow]=10 then
                            foundAWindow = w32True
                        else
                            controls[index][AWindow] = 10
                        end if
                    end if

                elsif find(controls[index][Class], {"TabControl","TabItem"}) then
                    if controls[index][AWindow]=25 then
                        foundAWindow = w32True
                    else
                        controls[index][AWindow] = 25
                        needToSort = w32True
                    end if
                    controls[index][SubClass] = controls[index][Class]
                end if
            end if

            if not controls[index][Y] then
                if find(controls[index][Class], {"Menu","Popup"}) then
                    YCounter = 1
                    controls[index][Y] = 1
                    if equal(controls[index][Class],"Menu") then
                        controls[index][AWindow] = 2
                    end if
                    if equal(controls[index][Class],"Popup") then
                        controls[index][AWindow] = 3
                    end if
                elsif find(controls[index][Class], {"MenuItem","Submenu",
                                                    "SubmenuItem","Sub2menu","Sub2menuItem",
                                                    "Sub3menu","Sub3menuItem"}) then
                    YCounter += 1
                    controls[index][Y] = YCounter
                    controls[index][AWindow] = 1
                elsif find(controls[index][Class], {"PopupItem","Subpopup",
                                                    "SubpopupItem","Sub2popup",
                                                    "Sub2popupItem","Sub3popup",
                                                    "Sub3popupItem"}) then
                    YCounter += 1
                    controls[index][Y] = YCounter
                    controls[index][AWindow] = 3
                end if
            end if

            if equal(controls[index][Class], "ToolBar") then
                bar = w32findKey("Tool Bar",ControlList)
                toolBarCY = ControlList[bar][ControlCY]
                if controls[index][ToolRowCY] then
                    toolBarCY = controls[index][ToolRowCY]
                else
                    controls[index][ToolRowCY] = ControlList[bar][ControlCY]
                end if
                toolBarOrigX  = controls[index][X]
                toolBarOrigY  = controls[index][Y]
                toolBarSubCY  = controls[index][ToolRowCY]-4
                if controls[index][CY]<toolBarCY then
                    controls[index][CY] = toolBarCY
                    toolBarY = 1
                elsif controls[index][CY]>toolBarCY then
                    --build up to next toolBarCY multiple
                    --THIS CAN BE REMOVED IF NO RESIZE FIX IS DESIRED
                    --resize the ToolBar
                    while w32True do
                        bar = floor(controls[index][CY]/controls[index][ToolRowCY])
                        toolBarY = bar
                        bar = remainder(controls[index][CY],toolBarCY)
                        if bar then
                            controls[index][CY] += 1
                            toolBarY += 1
                        else
                            exit
                        end if
                    end while
                end if

                --build the info array
                toolBarX = 0    --to force first DrawIt to recalculate
                toolBarInfo &= {controls[index][CY]&controls[index][ToolRowCY]&
                                toolBarSubCY&controls[index][X]&controls[index][Y]&
                                toolBarX&toolBarY&{controls[index][Name]}}
            end if

            if equal(controls[index][Class], "FlatToolBar") then
                bar = w32findKey("Flat Bar",ControlList)
                toolBarCY = ControlList[bar][ControlCY]
                controls[index][ToolRowCY] = toolBarCY
                toolBarSubCY = controls[index][ToolRowCY]-10
                toolBarOrigX  = controls[index][X]
                toolBarOrigY  = controls[index][Y]

                if controls[index][CY]<toolBarCY then
                    controls[index][CY] = toolBarCY
                    toolBarY = 1
                elsif controls[index][CY]>toolBarCY then
                    --build up to next toolBarCY multiple                    
                    --resize the FlatToolBar
                    while w32True do
                        bar = floor(controls[index][CY]/controls[index][ToolRowCY])
                        toolBarY = bar
                        bar = remainder(controls[index][CY],toolBarCY)
                        if bar then
                            controls[index][CY] += 1
                            toolBarY += 1
                        else
                            exit
                        end if
                    end while
                end if

                --build the info array
                toolBarX = 0
                --to force first DrawIt to recalculate
                toolBarInfo &= {controls[index][CY]&controls[index][ToolRowCY]&
                                toolBarSubCY&controls[index][X]&controls[index][Y]&
                                toolBarX&toolBarY&{controls[index][Name]}}

            end if

            if equal(controls[index][Class], "StatusBar") then
                --resize the Status Bar
                bar = w32findKey("Status Bar",ControlList)
                controls[index][CY] = ControlList[bar][ControlCY]
            end if

            if not find(controls[index][Class],{"TabControl","TabItem"}) then
                if length(controls[index][SubClass]) then
                    controls[index][SubClass] = {}
                end if
            end if

        elsif match("Checked", text)=1 then
            controls[index][Checked] = extractNumber(text)

        elsif match("Enabled", text)=1 then
            controls[index][Enabled] = extractNumber(text)

        elsif match("Parent", text)=1 then
            controls[index][ControlParent] = extractText(text)

        elsif match("PClass", text)=1 then
            controls[index][ParentClass] = extractText(text)

        elsif match("DirParent", text)=1 then
            controls[index][Parent] = extractText(text)
            --check that DirParent is a Table control
            at = 0
            for i=1 to length(controls) do
                if equal(controls[i][Name], controls[index][Parent]) then
                    at = 1
                    if not equal(controls[i][Class], "Table") then
                        controls[index][Parent] = {}
                    end if
                    exit
                end if
            end for
            if at=0 then
                controls[index][Parent] = {}
            end if

        elsif match("Active", text)=1
          and find(controls[index][Class], {"TabControl","TabItem"}) then
            controls[index][Active] = extractNumber(text)

        elsif match("DefaultsClass", text)=1 then
            controls[index][ClassDefaults] = extractText(text)

        elsif match("Style", text)=1 then
            controls[index][Style] = extractText(text)
            if find(controls[index][Class], {"Window","CWindow"}) then
                if atom(controls[index][Style]) then
                    controls[index][Style] = 0
                elsif not length(controls[index][Style]) then
                    controls[index][Style] = 0
                end if
            end if

        elsif match("TypStyle", text)=1 then
            controls[index][StyleType] = extractText(text)

        elsif match("Visible", text)=1 then
            controls[index][Visible] = extractNumber(text)

        elsif match("Upper", text)=1 then
            controls[index][Upper] = extractNumber(text)

        elsif match("Lower", text)=1 then
            controls[index][Lower] = extractNumber(text)

        elsif match("ReadOnly", text)=1 then
            controls[index][ReadOnly] = extractNumber(text)

        elsif match("Pswd", text)=1 then
            controls[index][Pswd] = extractNumber(text)

        elsif match("Limit", text)=1 then
            controls[index][Limit] = extractNumber(text)

        elsif match("TxtColor", text)=1 then
            controls[index][TxtColor] = extractNumber(text)

        elsif match("BkColor", text)=1 then
            controls[index][BkColor] = extractNumber(text)
            if controls[index][BkColor]<0 then
                controls[index][BkColor] = -2
            end if
            if equal(controls[index][Class], "Window") then
                if controls[index][BkColor]=0 then
                    controls[index][BkColor] = getSysColor(COLOR_BTNFACE)
                end if
            end if
            if find(controls[index][Class], controlsWithOutColor) then
                controls[index][BkColor] = 0
            end if
            if equal(controls[index][Class], "EuGrid")
            and controls[index][BkColor]=0 then
                controls[index][BkColor] = getSysColor(COLOR_BTNFACE)
            end if
        elsif match("BkBarColor", text)=1 then      --for progress bar only
            controls[index][BkBarColor] = extractNumber(text)

        elsif match("SystemBkColor", text)=1 then
            controls[index][SystemBkColor] = extractText(text)
            --coming from old project where systemBkColor was numeric:

            if val(controls[index][SystemBkColor]) then
                --is numeric
                for xx=1 to length(validColors) do
                    if val(controls[index][SystemBkColor])=getSysColor(numColors[xx]) then
                        controls[index][SystemBkColor] = validColors[xx]
                        exit
                    end if
                end for
            end if

            if length(controls[index][SystemBkColor]) then
                if not find(controls[selectedControl][SystemBkColor], validColors) then
                    --garbage in field?
                    controls[selectedControl][SystemBkColor] = {}
                end if
            end if

            if equal(controls[selectedControl][SystemBkColor], validColors[1]) then
                controls[selectedControl][SystemBkColor] = {}
            end if

            --in case user has switched Theme, recalc value
            --of SystemBkColor, if any, and reset BkColor accordingly
            if length(controls[selectedControl][SystemBkColor]) then
                for x=2 to length(validColors) do
                    if equal(controls[selectedControl][SystemBkColor], validColors[x]) then
                        controls[selectedControl][BkColor] = getSysColor(numColors[x])
                        if controls[selectedControl][BkColor]=0 then
                            controls[selectedControl][BkColor] = -2
                            --change tile
                        end if
                        exit
                    end if
                end for
            end if

        elsif match("EnableC", text)=1 then
            controls[index][EnableC] = extractNumber(text)

        elsif match("Numeric", text)=1 then
            controls[index][Numeric] = extractNumber(text)

        elsif match("Multline",text)=1 then
            controls[index][Multiline] = extractNumber(text)

        elsif match("cbMultline",text)=1 then
            controls[index][cbMultiline] = extractNumber(text)

        elsif match("Hscrolls",text)=1 then
            controls[index][Hscrolls] = extractNumber(text)

        elsif match("Vscrolls",text)=1 then
            controls[index][Vscrolls] = extractNumber(text)

        elsif match("Buddy",text)=1 then
            controls[index][Buddy] = extractText(text)

        elsif match("IcoFile",text)=1 then
            controls[index][IcoFile] = extractText(text)

        elsif match("#IcoFile", text)=1 then
            text = extractText(text)
            --read the values
            controls[index][IcoFile] = {}
            while 1 do

                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndIcoFile", text)=1 then
                    exit
                end if

                -- add to code
                controls[index][IcoFile] &= {text}
            end while

        elsif match("TwoIcoFile",text)=1 then
            controls[index][TwoIcoFile] = extractText(text)

        elsif match("TriIcoFile",text)=1 then
            controls[index][TriIcoFile] = extractText(text)

        elsif match("BitmapFile",text)=1 then
            controls[index][BitmapFile] = extractText(text)
            addResource(controls[index][Name],controls[index][BitmapFile],"Bitmap","")

        elsif match("TableCols",text)=1 then
            controls[index][TableCols] = extractNumber(text)

        elsif match("PreserveName",text)=1 then
            controls[index][PreserveName] = extractNumber(text)

        elsif match("FitToTable",text)=1 then
            controls[index][FitToTable] = extractNumber(text)

        elsif match("DontDraw",text)=1 then
            controls[index][DontDraw] = extractNumber(text)

        elsif match("TableHScroll",text)=1 then
            controls[index][TableHScroll] = extractNumber(text)

        elsif match("TableVScroll",text)=1 then
            controls[index][TableVScroll] = extractNumber(text)

        elsif match("TableResizable",text)=1 then
            controls[index][TableResizable] = extractNumber(text)

        elsif match("TableRows",text)=1 then
            controls[index][TableRows] = extractNumber(text)

        elsif match("TableSpaceCols",text)=1 then
            controls[index][TableColsSpace] = extractNumber(text)

        elsif match("TableSpaceRows",text)=1 then
            controls[index][TableRowsSpace] = extractNumber(text)

        elsif match("TableCell",text)=1 then
            controls[index][TableCell] = extractNumber(text)

        elsif match("TableArray",text)=1 then
            controls[index][TableArray] = extractNumber(text)

        elsif match("FontHintName",text)=1 then
            controls[index][HintFontName] = extractText(text)

        elsif match("FontHintPts",text)=1 then
            controls[index][HintFontPts] = extractNumber(text)

        elsif match("FontHintAttrib",text)=1 then
                --HintFontAttrib used to contain the word Italic 
            controls[index][HintFontAttrib] = w32True--extractNumber ( text )            

        elsif match("FontHintBold",text)=1 then
            controls[index][HintFontBold] = extractNumber(text)

        elsif match("FontHintUnderline",text)=1 then
            controls[index][HintFontUnderline] = extractNumber(text)

        elsif match("FontHintStrikeout",text)=1 then
            controls[index][HintFontStrikeout] = extractNumber(text)

        elsif match("HintText",text)=1 then
            controls[index][HintText] = extractText(text)

        elsif match("ShowHintFontVar",text)=1 then
            controls[index][ShowHintFontVar] = extractNumber(text)

        elsif match("ShowFontVar",text)=1 then
            controls[index][ShowFontVar] = extractNumber(text)

        elsif match("HintFontVarName",text)=1 then
            controls[index][HintFontVarName] = extractText(text)

        elsif match("HintFontVarPts",text)=1 then
            controls[index][HintFontVarPts] = extractText(text)

        elsif match("HintFontVarItalic",text)=1 then
            controls[index][HintFontVarItalic] = extractText(text)
        elsif match("HintFontVarBold",text)=1 then
            controls[index][HintFontVarBold] = extractText(text)

        elsif match("HintFontVarUnderline",text)=1 then
            controls[index][HintFontVarUnderline] = extractText(text)

        elsif match("HintFontVarStrikeout",text)=1 then
            controls[index][HintFontVarStrikeout] = extractText(text)

        elsif match("HintVarText",text)=1 then
            controls[index][HintVarText] = extractText(text)

        elsif match("FontName",text)=1 then
            controls[index][FontName] = extractText(text)

        elsif match("setCreateFont", text)=1 then
            controls[index][setCreatefont] = extractNumber(text)

        elsif match("FontPts",text)=1 then
            controls[index][FontPts] = extractNumber(text)

        elsif match("FontAttrib",text)=1 then
                --FontAttrib used to contain the word Italic
            controls[index][FontAttrib] = w32True--extractNumber ( text )

        elsif match("FontBold",text)=1 then
            controls[index][FontBold] = extractNumber(text)

        elsif match("FontUnderline",text)=1 then
            controls[index][FontUnderline] = extractNumber(text)

        elsif match("FontStrikeout",text)=1 then
            controls[index][FontStrikeout] = extractNumber(text)

        elsif match("FontColor", text)=1 then
            controls[index][FontColor] = extractNumber(text)

        elsif match("FontVarName",text)=1 then
            controls[index][FontVarName] = extractText(text)

        elsif match("FontVarPts",text)=1 then
            controls[index][FontVarPts] = extractText(text)

        elsif match("FontVarItalic",text)=1 then
            controls[index][FontVarItalic] = extractText(text)

        elsif match("FontVarBold",text)=1 then
            controls[index][FontVarBold] = extractText(text)

        elsif match("FontVarUnderline",text)=1 then
            controls[index][FontVarUnderline] = extractText(text)

        elsif match("FontVarStrikeout",text)=1 then
            controls[index][FontVarStrikeout] = extractText(text)

        elsif match("FontVarColor",text)=1 then
            controls[index][FontVarColor] = extractText(text)

        elsif match("CreateEx",text)=1 then
            --ignore it

        elsif match("ExStyle",text)=1 then
            controls[index][ExStyle] = extractText(text)
            if equal(controls[index][ExStyle], "{0}") then
                controls[index][ExStyle] = "0"
            end if

        elsif match("SETLvInsert",text)=1 then
            controls[index][SETLVInsert] = extractNumber(text)

        elsif match("Indexed",text)=1 then
            controls[index][Indexed] = extractNumber(text)

        elsif match("IndexParent",text)=1 then
            controls[index][IndexParent] = extractText(text)

        elsif match("#SelectWidth",text)=1 then
            text = extractText(text)
            --read the values
            controls[index][SelectWidth] = {}
            while 1 do

                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndSelectWidth", text)=1 then
                    exit
                end if

                -- add to code
                controls[index][SelectWidth] &= {text}
            end while

        elsif match("#ExtExStyle",text)=1 then
            text = extractText(text)
            --read the values
            controls[index][ExtExStyle] = {}
            while 1 do

                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndExtExStyle", text)=1 then
                    exit
                end if

                -- add to code
                controls[index][ExtExStyle] &= {text}
            end while

        elsif match("DefaultXY",text)=1 then
            controls[index][DefaultXY] = extractNumber(text)

        elsif match("NameXPM",text)=1 then
            controls[index][XPM] = extractText(text)
            if match(".xpm",lower(controls[index][XPM])) then
                addResource(controls[index][Name],controls[index][XPM],"XPM","")
            end if
        elsif match("Showcap",text)=1 then
            controls[index][Showcap] = extractNumber(text)

        elsif match("Local",text)=1 then
            controls[index][Local] = extractNumber(text)

        elsif match("MemberXPM",text)=1 then
            controls[index][XPMmember] = extractText(text)
            addResource(controls[index][Name],controls[index][XPM],"XPM",controls[index][XPMmember])

        elsif match("#XpmObject",text)=1 then
            text = extractText(text)
            --read the values
            controls[index][XpmObject] = {}

            while 1 do
                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndXpmObject", text)=1 then
                    exit
                end if

                controls[index][XpmObject] &= {text}
            end while

            addResource(controls[index][Name],controls[index][XpmObject],"XpmObject",
                        controls[index][Name] & "_xpm")

        elsif match("#XpmDisableObject",text)=1 then
            text = extractText(text)
            --read the values
            controls[index][XpmDisableObject] = {}

            while 1 do
                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndXpmDisableObject", text)=1 then
                    exit
                end if

                controls[index][XpmDisableObject] &= {text}
            end while

            addResource(controls[index][Name],controls[index][XpmDisableObject],"XpmDisableObject",
                        controls[index][Name] & "D_xpm")

        elsif match("MinValue",text)=1 then
            controls[index][MinValue] = extractNumber(text)

        elsif match("MaxValue",text)=1 then
            controls[index][MaxValue] = extractNumber(text)

        elsif match("LineChg",text)=1 then
            controls[index][LineChg] = extractNumber(text)

        elsif match("PageChg",text)=1 then
            controls[index][PageChg] = extractNumber(text)

        elsif match("MultiSel",text)=1 then
            controls[index][MultiSel] = extractNumber(text)

        elsif match("ExtendSel",text)=1 then
            controls[index][ExtendSel] = extractNumber(text)

        elsif match("RBBSBREAK",text)=1 then
            controls[index][RBBSBREAK] = extractNumber(text)

        elsif match("TimerInt",text)=1 then
            controls[index][TimerInt] = extractNumber(text)

        elsif match("SetEvent",text)=1 then
            controls[index][SetEvent] = extractText(text)

        elsif match("SetControl",text)=1 then
            controls[index][SetControl] = extractText(text)

        elsif match("KillEvent",text)=1 then
            controls[index][KillEvent] = extractText(text)

        elsif match("KillControl",text)=1 then
            controls[index][KillControl] = extractText(text)

        elsif match("Clickable", text)=1 then
            controls[index][Clickable] = extractNumber(text)

        elsif match("UseInWinMain", text)=1 then
            controls[index][UseInWinMain] = extractNumber(text)

        elsif match("WinMainOpen", text)=1 then
            controls[index][WinMainOpen] = extractNumber(text)

        elsif match("WinOpenAtCtrl", text)=1 then
            controls[index][WinOpenAtCtrl] = extractText(text)

        elsif match("WinPos :", text)=1 then
            controls[index][WinPos] = extractNumber(text)

        elsif match("Integers", text)=1 then
            controls[index][Integers] = extractNumber(text)

        elsif match("CCWinStyle", text)=1 then
            controls[index][CCWinStyle] = extractText(text)

        elsif match("WinPosTaskBar", text)=1 then
            controls[index][WinPosTaskBar] = extractNumber(text)

        elsif match("MCS_multiselect", text)=1 then
            controls[index][MCS_multiselect] = extractNumber(text)

        elsif match("PBS_smooth", text)=1 then
            controls[index][PBS_smooth] = extractNumber(text)

        elsif match("BS_flat", text)=1 then
            controls[index][BS_flat] = extractNumber(text)

        elsif match("cbFlat", text)=1 then
            controls[index][cbFlat] = extractNumber(text)

        elsif match("cbCentVert", text)=1 then
            controls[index][cbCentVert] = extractNumber(text)

        elsif match("NoIntegralHeight", text)=1 then
            controls[index][NoIntegralHeight] = extractNumber(text)

        elsif match("AdjCenter", text)=1 then
            controls[index][AdjCenter] = extractNumber(text)

        elsif match("AdjRight", text)=1 then
            controls[index][AdjRight] = extractNumber(text)

        elsif match("UpDownLeft", text)=1 then
            controls[index][UpDownLeft] = extractNumber(text)

        elsif match("TabsBottom", text)=1 then
            controls[index][TabsBottom] = extractNumber(text)

        elsif match("UpDownHorz", text)=1 then
            controls[index][UpDownHorz] = extractNumber(text)

        elsif match("OutX", text)=1 then
            controls[index][OutX] = extractText(text)

        elsif match("OutY", text)=1 then
            controls[index][OutY] = extractText(text)

        elsif match("OutCX", text)=1 then
            controls[index][OutCX] = extractText(text)

        elsif match("OutCY", text)=1 then
            controls[index][OutCY] = extractText(text)

        elsif match("ControlComment", text)=1 then
            controls[index][ControlComment] = extractText(text)

        elsif match("DEFIndex", text)=1 then
            controls[index][DEFIndex] = extractText(text)

        elsif match("SysTrayIcon", text)=1 then
            controls[index][SysTrayIcon] = extractText(text)
            haveSysTray = w32True

        elsif match("SysTrayHint", text)=1 then
            controls[index][SysTrayHint] = extractText(text)

        elsif match("SysTrayHide", text)=1 then
            --user wants to code his own sysTray_Hide statement
            controls[index][SysTrayHide] = w32True
            skipSysTrayHide = w32True    --for other controls in this window that might use systray_Hide

        elsif match("GridActiveHeaders", text)=1 then
            controls[index][GridActiveHeaders] = extractNumber(text)

        elsif match("GridAllowColResize", text)=1 then
            controls[index][GridAllowColResize] = extractNumber(text)

        elsif match("GridAllowColSort", text)=1 then
            controls[index][GridAllowColSort] = extractNumber(text)

        elsif match("GridCellBorder", text)=1 then
            controls[index][GridCellBorder] = extractNumber(text)

        elsif match("GridHighlightText", text)=1 then
            controls[index][GridHighlightText] = extractNumber(text)

        elsif match("GridRowHeaderCX", text)=1 then
            controls[index][GridRowHeaderCX] = extractNumber(text)

        elsif match("GridColHeaderCY", text)=1 then
            controls[index][GridColHeaderCY] = extractNumber(text)

        elsif match("GridHeaderColor", text)=1 then
            controls[index][GridHeaderColor] = extractNumber(text)
            if equal(controls[index][Class], "EuGrid")
            and controls[index][GridHeaderColor]=0 then
                controls[index][GridHeaderColor] = getSysColor(COLOR_BTNFACE)
            end if

        elsif match("GridCellColorBorder", text)=1 then
            controls[index][GridCellBorderColor] = extractNumber(text)

        elsif match("GridBkSelectColor", text)=1 then
            controls[index][GridBkSelectColor] = extractNumber(text)

        elsif match("GridTextColorSelect", text)=1 then
            controls[index][GridTextColorSelect] = extractNumber(text)

        elsif match("GridHeaderType", text)=1 then
            controls[index][GridHeaderType] = extractNumber(text)

        elsif match("GridHeaderInCol", text)=1 then
            controls[index][GridHeaderInCol] = extractNumber(text)

        elsif match("GridLineColor", text)=1 then
            controls[index][GridLineColor] = extractNumber(text)

        elsif match("GridTextColor", text)=1 then
            controls[index][GridTextColor] = extractNumber(text)

        elsif match("GridColTextColor", text)=1 then
            controls[index][GridColTextColor] = extractNumber(text)

        elsif match("GridBkColorRows", text)=1 then
            controls[index][GridBkColorRows] = extractNumber(text)

        elsif match("GridRowSelect", text)=1 then
            controls[index][GridRowSelect] = extractNumber(text)

        elsif match("GridColListDataCol", text)=1 then
            controls[index][GridColListDataCol] = extractNumber(text)

        elsif match("GridRowCY", text)=1 then
            controls[index][GridRowCY] = extractNumber(text)

        elsif match("GridTextAlign", text)=1 then
            controls[index][GridTextAlign] = extractNumber(text)

        elsif match("GridFormat", text)=1 then
            controls[index][GridFormat] = extractText(text)

        elsif match("GridDataArrayName", text)=1 then
            controls[index][GridDataArrayName] = extractText(text)

        elsif match("GridColListValues", text)=1 then
            controls[index][GridColListValues] = extractText(text)

        elsif match("Transparency", text)=1 then
            controls[index][WinTransparency] = extractNumber(text)

        elsif match("LastEditorEvent", text)=1 then
            controls[index][LastEditorEvent] = extractNumber(text)

        elsif match("LastEditorNameEvent", text)=1 then
            --ignore

        elsif match("OrigTitle", text)=1 then
            controls[index][OrigTitle] = extractText(text)

        elsif match("FrozenParent", text)=1 then
            controls[index][ParentIsFrozen] = extractNumber(text)

        elsif match("PBCAPPOS",text)=1 then
            controls[index][PB_Caption_Pos] = extractNumber(text)

        elsif match("GenFromName",text)=1 then
            controls[index][GenFromName] = extractText(text)

        elsif match("CommonSetHandler", text)=1 then
            controls[index][CommonSetHandler] = extractNumber(text)

        elsif match("CommonRow", text)=1 then
            controls[index][CommonRow] = extractNumber(text)

        elsif match("CommonCol", text)=1 then
            controls[index][CommonCol] = extractNumber(text)

        elsif match("cbColor", text)=1 then
            controls[index][cbColor] = extractNumber(text)

        elsif match("cbCaptionColor", text)=1 then
            controls[index][cbCaptionColor] = extractNumber(text)

        elsif match("cbPressColor", text)=1 then
            controls[index][cbPressColor] = extractNumber(text)

        elsif match("cbPressCaptionColor", text)=1 then
            controls[index][cbPressCaptionColor] = extractNumber(text)

        elsif match("cbThickness", text)=1 then
            controls[index][cbThickness] = extractNumber(text)

        elsif match("cbCaptionPos", text)=1 then
            controls[index][cbCaptionPos] = extractNumber(text)

        elsif match("cbGraphicPos", text)=1 then
            controls[index][cbGraphicPos] = extractNumber(text)

        elsif match("TableButtonAllColor", text)=1 then
            controls[index][TableButtonAllColor] = extractNumber(text)

        elsif match("TreatAsColorButton", text)=1 then
            controls[index][TreatAsColorButton] = extractNumber(text)

        elsif match("MC_background", text)=1 then
            controls[index][MC_background] = extractNumber(text)

        elsif match("MC_text", text)=1 then
            controls[index][MC_text] = extractNumber(text)

        elsif match("MC_titleBK", text)=1 then
            controls[index][MC_titleBK] = extractNumber(text)

        elsif match("MC_titleText", text)=1 then
            controls[index][MC_titleText] = extractNumber(text)

        elsif match("MC_monthBK", text)=1 then
            controls[index][MC_monthBK] = extractNumber(text)

        elsif match("MC_trailingText", text)=1 then
            controls[index][MC_trailingText] = extractNumber(text)

        elsif match("#Partners", text)=1 then
            text = extractText(text)
            --read the values
            controls[index][ControlPartners] = {}

            while 1 do
                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndPartners", text)=1 then
                    exit
                end if

                controls[index][ControlPartners] &= {text}
            end while

        elsif match("#PathModule ", text)=1 then
            --new with v0.18.0
            if length(text)>12 then
                fileNameExistingPath = text[13..length(text)]
            end if

        elsif match("#Module ", text)=1 then
            --I had a problem reloading modules names at one time. I was
            --including the space before the name. It is now critical that this
            --be removed in order for module to Code Editor processing to work.

            text = text[8..length(text)]

            for i=1 to length(text) do
                if text[i]!=' ' then
                    text = text[i..length(text)]
                    exit
                end if
            end for
            if length(text) and text[1]='\\' then
                text = text[2..length(text)]
            end if
            --is there a path?
            isOk = w32False
            fileNamePath = ""

            if length(fileNameExistingPath) then
                fileNamePath = fileNameExistingPath
                if fileNamePath[length(fileNamePath)]!='\\' then --Josef
                    fileNamePath &= "\\"    --Josef
                end if                  --josef
            end if

            fileNameWithoutPath = reverse(text)
            at = match("\\", fileNameWithoutPath)
            if at then
                if not length(fileNameExistingPath) then
                    fileNamePath = fileNameWithoutPath[at..length(fileNameWithoutPath)]
                    fileNamePath = reverse(fileNamePath)
                end if
                fileNameWithoutPath = fileNameWithoutPath[1..at-1]
                fileNameWithoutPath = reverse(fileNameWithoutPath)

                isOk = w32True
                text = fileNamePath & fileNameWithoutPath
            else
                fileNameWithoutPath = reverse(fileNameWithoutPath)
                if not length(fileNameExistingPath) then
                    fileNamePath = projectDir & "\\"
                end if
                text = fileNameWithoutPath
                isOk = w32True
            end if


            if not isOk then
--              if atom(isOk) then
                --maybe file is in project dir?
                isOk = chdir(projectDir)
                isOk = dir(text)
                if not atom(isOk) then
                    fileNamePath = projectDir & "\\"
                    fileNameWithoutPath = text
                    text = fileNamePath & text
                end if
--              end if

                --might be an old PRJ file module
                --check the current directory
                isOk = dir(text)
                if atom(isOk) then
                    --maybe file is in IDE dir?
                    isOk = chdir(the_current_dir)
                    isOk = dir(text)
                    if not atom(isOk) then
                        fileNamePath = the_current_dir & "\\"
                        fileNameWithoutPath = text
                        text = fileNamePath & text
                    end if
                end if

                if atom(isOk) then
                    --check EuInc files
                    for i=1 to length(euIncFiles) do
                        isOk = chdir(euIncFiles[i])
                        isOk = dir(text)
                        if sequence(isOk) then
                            fileNamePath = euIncFiles[i] & "\\"
                            fileNameWithoutPath = text
                            text = fileNamePath & text
                            exit
                        end if
                    end for
                end if

                if atom(isOk) then
                    --maybe file is an EU include file?
                    euDir = whereEu
                    isOk = chdir(euDir & "\\include")
                    isOk = dir(text)
                    if not atom(isOk) then
                        fileNamePath = euDir & "\\include\\"
                        fileNameWithoutPath = text
                        text = fileNamePath & text
                    end if
                end if

                if atom(isOk) then
                    --well I give up!
                    ok = displayErrorMessage(151,{isModule})
                end if
            end if

            includeModuleData[1] = text
            includeModuleData[2] = ""
            includeModuleData[3] = fileNamePath
            includeModuleData[4] = 0

            if length(includeModuleData[3]) then
                --strip final "\\" on path if present
                if equal(includeModuleData[3][length(includeModuleData[3])], "\\") then
                    includeModuleData[3] = includeModuleData[3][1..length(includeModuleData[3])-1]
                end if
            end if
            if length(includeModuleData[1]) and includeModuleData[1][1]='\\' then
                includeModuleData[1] = includeModuleData[1][2..length(includeModuleData[1])-1]
            end if
            --is this a default include file?
            if length(settingsBuffer[cfgDefaultMIS]) then
                for i=1 to length(settingsBuffer[cfgDefaultMIS]) do
                    if equal(includeModuleData[3] & "\\" & includeModuleData[1],
                             settingsBuffer[cfgDefaultMIS][i]) then
                        includeModuleData[4] = w32True
                        exit
                    end if
                end for
            end if

            includeModules &= {includeModuleData}
            --add to modules combo for editor
            addItem(CodeModules, fileNameWithoutPath)
            setIndex(CodeModules, getCount(CodeModules))
            addItem(PathModules,fileNamePath[1..length(fileNamePath)-1])
            setEnable(CodeModules, w32True)

            --read the module and extract global routines for colorazation
            readModuleFile(text)

        elsif match("#ModuleAppend ", text)=1 then
            includeModuleData = includeModules[length(includeModules)]
            includeModuleData[2] = text[15..length(text)]
            includeModules[length(includeModules)] = includeModuleData


        elsif match("#ListValues", text)=1 then
            text = extractText(text)
            --read the values
            controls[index][InitialVal] = {}
            while 1 do

                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndListValues", text)=1 then
                    exit
                end if

                -- add to code
                controls[index][InitialVal] &= {text}
            end while

        elsif match("#SysTrayText", text)=1 then
            text = extractText(text)
            --read the values
            controls[index][SysTrayText] = {}
            while 1 do

                -- read the next line
                text = gets(file)

                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndSysTrayText", text)=1 then
                    exit
                end if

                -- add to code
                controls[index][SysTrayText] &= {text}
            end while

        elsif match("#Proc", text)=1 then

            text = extractText(text)

            -- what event is it?
            event = w32findKey(text, Events)

            needProc = w32True
            if event=General
            or event=Begin
            or event=Intro
            or event=Final then
                needProc = w32False
            end if

            -- read the code
            while 1 do

                -- read the next line
                text = gets(file)
                if atom(text) then      --this should never happen
                    text = "#EndProc"
                end if
                -- remove line feed
                text = Replace(text, "\n", "")

                if match("#EndProc", text)=1 then
                    if needProc then
                        w32HName = "w32H"
                        for i=3 to length(Events[event][1]) do
                            w32HName = append(w32HName, Events[event][1][i])
                        end for
                        controls[index][Code][event] &= {"setHandler(" & controls[index][Name] & ","
                                                         & w32HName & ",routine_id(\""
                                                         & controls[index][Name]
                                                         &"_"
                                                         & Events[event][1]
                                                         & "\"))"}
                        controls[index][Code][event] = {"procedure "
                                                        & controls[index][Name]
                                                        & "_"
                                                        & Events[event][1]      -- event name
                                                        & " "
                                                        & "( integer self, integer event, sequence params )"}
                                                       & controls[index][Code][event][1..length(controls[index][Code][event])]
                    end if
                    exit
                end if

                --check for procedure statement
                if event!=General
                and event!=Begin
                and event!=Intro
                and event!=Final then
                    if not match("end procedure", text)
                    and match("procedure", text) then
                        needProc = w32False
                    end if
                end if

                --strip systray code left from prior IDE version
                if haveSysTray then
                    if match("systray_Show", text) then
                        --skip
                    elsif match("systray_Hide", text) then
                        if not controls[index][SysTrayHide]
                        and not skipSysTrayHide then
                            --skip
                        else
                            -- add to code; user has elected to code his own statement so don't toss it out not
                            controls[index][Code][event] &= {text}
                        end if
                    elsif match("onsystray", text) then
                        while w32True do
                            --start skipping lines
                            text = gets(file)

                            -- remove line feed
                            text = Replace(text, "\n", "")
                            if match("end procedure", text) then
                                --end of skiping
                                exit
                            end if
                        end while
                    elsif match("systray_SetEvent", text) then
                        --skip
                    else
                        -- add to code
                        controls[index][Code][event] &= {text}
                    end if
                else
                    -- add to code
                    controls[index][Code][event] &= {text}
                end if
            end while
            if event=General
            or event=Begin
            or event=Intro
            or event=Final then
                findControl_eventNames(controls[index][Code][event])
            end if
        else
            -- error
        end if
    end while

    -- close the file
    close(file)

    if length(controls) then
        if equal(controls[length(controls)][Class],"Table") then
            if controls[length(controls)][TableCols]*controls[length(controls)][TableRows]
                                          >length(controls[length(controls)][SeqChildName]) then
                ignore = displayErrorMessage(250,{controls[length(controls)][Name]})
            end if
        end if
    end if

    -- save the set of controls
    if not foundAWindow
    or needToSort then
        controls = sort(controls)
    end if

    -- save as file
    setOpenFileName(id, fName)

    windows &= {controls}

    if length(layerTabInfo) then
        layerCaptionSeq &= {layerTabInfo}
    end if

    if length(usedTabs) then
        if not haveTabCaptions then
            usedTabs = sort(usedTabs)
            for i=1 to length(usedTabs) do
                slot = {"",0,0,0}
                slot[1] = IDEText[984][1] & " " & sprint(usedTabs[i])
                slot[3] = usedTabs[i]
                layerTabInfo &= {slot}
            end for
            layerCaptionSeq &= {layerTabInfo}
        end if
    elsif length(controls) then
        if not haveTabCaptions then
            slot = {"",0,0,0}
            slot[1] = IDEText[984][1] & " 0"
            layerTabInfo = {slot}
            layerCaptionSeq &= {layerTabInfo}
        end if
    end if

    selectedWindow = 0

    -- update window list
    rebuildWindowList()

    -- select the window
    pickWindow(1)

    if autoLoad then
        buildProjectFolders()
    end if

end procedure
---------------------------------------------------------------------------
global sequence ConfigFile

global procedure LoadSavedControlList()

integer fn, ignore, cnt
object data, d
sequence FirstConfigFile, SB, thedata

    ConfigFile = the_current_dir & "\\Files\\IDE.cfg"

    cnt = 0

    cfgWin32lib = {}

    saveLocal = w32True
    setCheck(ClickLocal, w32True)
    setCheck(ClickGlobal, w32False)

    waitForKeys = {}
    setEnable(MenuClearRecent, w32False)

    -- open the file
    fn = open(ConfigFile, "r")
    if fn= -1 then
        --pick up IDEFirstTime.cfg
        FirstConfigFile = the_current_dir & "\\Files\\IDEFirstTime.cfg"
        fn = open(FirstConfigFile, "r")
        if fn= -1 then
            ignore = displayErrorMessage(149,{ConfigFile,FirstConfigFile})
            closeWindow(splash)
            abort(1)
        end if
    end if

    --read the records
    thedata = get(fn)
    if thedata[1]!=GET_SUCCESS then
        ok = displayErrorMessage(49,{})
        abort(1)
    end if
    settingsBuffer = thedata[2]
    --add for v0.16.0 new slot for saving state of CopyIndex Button
    if length(settingsBuffer)=43 then
        settingsBuffer &= {"CopyIndexActive"}
    end if
    if length(settingsBuffer)=44 then
        --add a new configuration items
        settingsBuffer &= {{"LanguagePref","English"}}
        settingsBuffer &= {{"RegisterStyle",{"LBS_NOINTEGRALHEIGHT","PBS_VERTICAL"}}}
    end if
    if length(settingsBuffer)=46 then
        --add new configuration item
        settingsBuffer &= {""}
        setCheck(MenuAutoComplete, w32True)
        synAutoComplete(w32True)
    end if
    if length(settingsBuffer)=47 then
        --add new configuration item
        settingsBuffer &= {""}
    end if
    if length(settingsBuffer)=48 then
        --add new configuration item
        settingsBuffer &= {""}
        setCheck(NoIndexing,w32False)
    end if
    if length(settingsBuffer)=49 then
        --add new configuration item
        settingsBuffer &= {0}
    end if
    if length(settingsBuffer)=50 then
        --add new configuration item
        settingsBuffer &= {""}
    end if
    if length(settingsBuffer)=51 then
        settingsBuffer &= {""}
    end if
    if length(settingsBuffer)=52 then
        settingsBuffer &= {0}
        settingsBuffer &= {0}
    end if
    if length(settingsBuffer)=54 then
        settingsBuffer &= {0}
    end if
    if length(settingsBuffer)=55 then
        settingsBuffer &= {0}
    end if
    if length(settingsBuffer)=56 then
        settingsBuffer &= {0}
    end if
    if length(settingsBuffer)=57 then
        settingsBuffer &= {"NoBackupAfterSave"}
    end if
    if length(settingsBuffer)=58 then
        --when add new slot to reuse backup filename, auto check
        --but if user is not asking for backup after save, uncheck
        settingsBuffer &= {1}
        setCheck(ReuseBak1File, w32True)
        if equal(settingsBuffer[cfgNoBackupsave],"NoBackupSave")  then
            settingsBuffer[cfgReuseBak1File] = 0
            setCheck(ReuseBak1File, w32False)
        end if
    end if
    if length(settingsBuffer)=59 then
        settingsBuffer &= {0}
    end if
    if length(settingsBuffer)=60 then
        settingsBuffer &= {""}
    end if
    if length(settingsBuffer)=61 then
        settingsBuffer = append(settingsBuffer,{0,0,0,0,0})
    end if
    if length(settingsBuffer)=62 then
        settingsBuffer &= {0}
    end if
    if length(settingsBuffer)=63 then
        settingsBuffer &= {5}
    end if
    if length(settingsBuffer)=64 then
        settingsBuffer &= {""}
    end if
    if length(settingsBuffer)=65 then
        settingsBuffer &= {""}
    end if

    if length(settingsBuffer)!=maxSlots then
        ignore = displayErrorMessage(150,{maxSlots,length(settingsBuffer)})
        abort(1)
    end if
    close(fn)

    --interrogate the buffer
    tempRadioKeepNever = w32True
    setCheck(MenuIgnoreHints, w32True)
    setCheck(MenuHintsStatus, w32False)
    setCheck(IDE_R4, w32True)
    setCheck(Design_R4, w32True)
    setCheck(Design_CB1, w32False)
    setCheck(Code_R4, w32True)
    setCheck(Code_CB1, w32False)
    setCheck(PV_R1, w32False)
    setCheck(PV_R2, w32True)
    setCheck(PV_CB1, w32False)
    setCheck(PV_CB2, w32False)
    setCheck(Prop_R1, w32False)
    setCheck(Prop_R2, w32True)
    setCheck(Prop_CB1, w32False)
    setCheck(Prop_CB2, w32False)
    setCheck(CB_WantDefault, w32False)
    setCheck(CB_Start, w32False)
    setCheck(SaveToProject, w32False)
    setCheck(AskSaveToProject, w32False)
    setText(EditPrjDef,"")
    setCheck(MenuInstance, w32True)
    setCheck(MenuBackupSave, w32True)
    setCheck(MenuBackupAfterSave, w32True)
    setCheck(MenuAutoComplete, w32True)
    setCheck(NoIndexing, w32False)
    setCheck(NoMinMenuRun, w32False)
    setCheck(MenuAutoSave, w32False)
    setCheck(AutosaveCheckbox, w32False)
    setScrollPos(AutosaveMinChg, 5)
    controlsPosition = {0,0,0,0}
    formPosition = {0,0,0,0}
    codePosition = {0,0,0,0}
    propertyPosition = {0,0,0,0}
    projectPosition = {0,0,0,0}
    CB_StartFileName = {}
    copyIndexSw = w32True
    setCheck(MenuFirstEvent, w32False)
    setCheck(MenuLastEvent, w32False)
    setCheck(MenuThisLastEvent, w32False)
    synSetColor(w32False)
    setCheck(MenuHideGutter, w32False)
    setCheck(MenuColorFile, w32False)
    setCheck(MenuColorLocals, w32False)
    setCheck(ChangeName, w32False)

    if length(settingsBuffer[cfgGridColor]) then
        if equal(settingsBuffer[cfgGridColor][1], "Grid Color") then
            GridColor = settingsBuffer[cfgGridColor][2]
        end if
    end if
    if length(settingsBuffer[cfgGridColorname]) then
        if equal(settingsBuffer[cfgGridColorname][1], "Grid Color Name") then
            GridColorName = settingsBuffer[cfgGridColorname][2]
        end if
    end if
    if length(settingsBuffer[cfgGridPixel]) then
        if equal(settingsBuffer[cfgGridPixel][1], "Grid Pixel") then
            SnapSize = settingsBuffer[cfgGridPixel][2]
        end if
    end if
    if length(settingsBuffer[cfgGridStyle]) then
        if equal(settingsBuffer[cfgGridStyle][1], "Grid Style") then
            if equal(settingsBuffer[cfgGridStyle][2], "dots") then
                GridDots = w32True
            else
                GridDots = w32False
            end if
        end if
    end if
    if length(settingsBuffer[cfgFiles]) then
        if equal(settingsBuffer[cfgFiles][1], "Files") then
            SB = settingsBuffer[cfgFiles][2]
            for j=1 to length(SB) do
                d = dir(SB[j])
                if sequence(d) then
                    data = {"",""}
                    data[1] = SB[j]
                    data[2] = {}
                    FileBuffer &= {data}
                end if
            end for
            setEnable(MenuClearRecent, w32True)
        end if
    end if
    if length(settingsBuffer[cfgIdeDocs]) then
        if equal(settingsBuffer[cfgIdeDocs][1], "IdeDocs") then
            IdeDocs = settingsBuffer[cfgIdeDocs][2]
            if equal(upper(IdeDocs), "DOCS\\IDE.HTM") then
                IdeDocs = the_current_dir & "\\" & IdeDocs
            end if
        end if
    end if
    if length(settingsBuffer[cfgRulerDocs]) then
        if equal(settingsBuffer[cfgRulerDocs][1], "RulerDocs") then
            RulerDocs = settingsBuffer[cfgRulerDocs][2]
            if equal(upper(RulerDocs), "DOCS\\RULER.CHM") then
                RulerDocs = the_current_dir & "\\" & RulerDocs
            end if
        end if
    end if
    if length(settingsBuffer[cfgCbDocs]) then
        if equal(settingsBuffer[cfgCbDocs][1], "CbDocs") then
            CbDocs = settingsBuffer[cfgCbDocs][2]
            if equal(upper(CbDocs), "DOCS\\COLOREDBUTTON.HTM") then
                CbDocs = the_current_dir & "\\" & CbDocs
            end if
        end if
    end if
    if length(settingsBuffer[cfgWin32libDocs]) then
        if equal(settingsBuffer[cfgWin32libDocs][1], "Win32libDocs") then
            Win32libDocs = settingsBuffer[cfgWin32libDocs][2]
        end if
    end if
    if length(settingsBuffer[cfgWin32libName]) then
        if equal(settingsBuffer[cfgWin32libName][1], "Win32libName") then
            cfgWin32lib = settingsBuffer[cfgWin32libName][2]
        end if
    end if

    if equal(settingsBuffer[cfgGlobal], "Global") then
        setCheck(ClickLocal, w32False)
        setCheck(ClickGlobal, w32True)
        saveLocal = w32False
    end if

    if equal(settingsBuffer[cfgNoBackupsave], "NoBackupSave") then
        setCheck(MenuBackupSave, w32False)
        setCheck(ReuseBak1File, w32False)
    end if

    if equal(settingsBuffer[cfgNoBackupAftersave],"NoBackupAfterSave") then
        setCheck(MenuBackupAfterSave, w32False)
        setCheck(ReuseBak2File, w32False)
    end if

    if length(settingsBuffer[cfgTempRules1]) then
        if equal(settingsBuffer[cfgTempRules1][1], "TempRules1") then
            tempRules1 = settingsBuffer[cfgTempRules1][2]
            if settingsBuffer[cfgTempRules1][2]=1 then
                tempRadioReplace = w32True
            elsif settingsBuffer[cfgTempRules1][2]=2 then
                tempRadioStop = w32True
            elsif settingsBuffer[cfgTempRules1][2]=3 then
                tempRadioAsk = w32True
            end if
        end if
    end if
    if length(settingsBuffer[cfgTempRules2]) then
        if equal(settingsBuffer[cfgTempRules2][1], "TempRules2") then
            tempRules2 = settingsBuffer[cfgTempRules2][2]
            if settingsBuffer[cfgTempRules2][2]=1 then
                tempRadioKeepBad = w32True
                tempRadioKeepNever = w32False
            elsif settingsBuffer[cfgTempRules2][2]=2 then
                tempRadioKeepGood = w32True
                tempRadioKeepNever = w32False
            elsif settingsBuffer[cfgTempRules2][2]=3 then
                tempRadioKeepAlways = w32True
                tempRadioKeepNever = w32False
            elsif settingsBuffer[cfgTempRules2][2]=4 then
                tempRadioKeepNever = w32True
            end if
        end if
    end if
    if equal(settingsBuffer[cfgHintStatusBar], "HintStatusBar") then
        setCheck(MenuHintsStatus, w32True)
    end if

    if equal(settingsBuffer[cfgHintDisabled], "HintDisabled") then
        setCheck(MenuIgnoreHints, w32False)
    end if

    if equal(settingsBuffer[cfgMultipleInstance], "MultipleInstance") then
        setCheck(MenuInstance, w32False)
         --turn on multiple instance
        w32Proc(xCloseHandle,{hMutex})
    end if
    if length(settingsBuffer[cfgWaitKey]) then
        if equal(settingsBuffer[cfgWaitKey][1], "WaitKey") then
            waitForKeys = settingsBuffer[cfgWaitKey][2]
        end if
    end if
    if length(settingsBuffer[cfgProjectFileType]) then
        if equal(settingsBuffer[cfgProjectFileType][1], "ProjectFileType") then
            projectFileType = settingsBuffer[cfgProjectFileType][2]
        end if
    end if

    if equal(settingsBuffer[cfgIDE_R1], "IDE_R1") then
        setCheck(IDE_R1, w32True)
        setCheck(IDE_R4, w32False)
    end if
    if length(settingsBuffer[cfgIDE_R2]) then
        if equal(settingsBuffer[cfgIDE_R2][1], "IDE_R2") then
            setCheck(IDE_R2, w32True)
            setCheck(IDE_R4, w32False)
            --set variable for IDE to test when open
            controlsWasMaxed = settingsBuffer[cfgIDE_R2][2]
        end if
    end if
    if length(settingsBuffer[cfgIDE_R3]) then
        if equal(settingsBuffer[cfgIDE_R3][1], "IDE_R3") then
            setCheck(IDE_R3, w32True)
            setCheck(IDE_R4, w32False)
            --set position for IDE to test when open
            controlsPosition[1] = settingsBuffer[cfgIDE_R3][2]
            controlsPosition[2] = settingsBuffer[cfgIDE_R3][3]
            controlsPosition[3] = settingsBuffer[cfgIDE_R3][4]
            controlsPosition[4] = settingsBuffer[cfgIDE_R3][5]
            controlsWasMaxed    = settingsBuffer[cfgIDE_R3][6]
        end if
    end if
    if length(settingsBuffer[cfgDesign_R1]) then
        if length(settingsBuffer[cfgDesign_R1])=1 then
            if equal(settingsBuffer[cfgDesign_R1], "Design_R1") then
                setCheck(Design_R1, w32True)
                setCheck(Design_R4, w32False)
            end if
        else
            if equal(settingsBuffer[cfgDesign_R1][1], "Design_R1") then
                setCheck(Design_R1, w32True)
                setCheck(Design_R4, w32False)
                if length(settingsBuffer[cfgDesign_R1])>1 then
                    formDiff = settingsBuffer[cfgDesign_R1][2]
                end if
                if length(settingsBuffer[cfgDesign_R1])>2 then
                    formPosition[3] = settingsBuffer[cfgDesign_R1][3]
                end if
            end if
        end if
    end if
    if length(settingsBuffer[cfgDesign_R2]) then
        if equal(settingsBuffer[cfgDesign_R2][1], "Design_R2") then
            setCheck(Design_R2, w32True)
            setCheck(Design_R4, w32False)
            --set variable for IDE to test when open
            formWasMaxed = settingsBuffer[cfgDesign_R2][2]
            if length(settingsBuffer[cfgDesign_R2])>2 then
                formDiff = settingsBuffer[cfgDesign_R2][3]
            end if
            if length(settingsBuffer[cfgDesign_R2])>3 then
                formPosition[3] = settingsBuffer[cfgDesign_R2][4]
            end if
        end if
    end if
    if length(settingsBuffer[cfgDesign_R3]) then
        if equal(settingsBuffer[cfgDesign_R3][1], "Design_R3") then
            setCheck(Design_R3, w32True)
            setCheck(Design_R4, w32False)
            --set position for IDE to test when open                                                      
            formPosition[1] = settingsBuffer[cfgDesign_R3][2]
            formPosition[2] = settingsBuffer[cfgDesign_R3][3]
            formPosition[3] = settingsBuffer[cfgDesign_R3][4]
            formPosition[4] = settingsBuffer[cfgDesign_R3][5]
            formWasMaxed    = settingsBuffer[cfgDesign_R3][6]
            --new fields for 0.19.0            
            if length(settingsBuffer[cfgDesign_R3])>6 then
                formWasUndocked = settingsBuffer[cfgDesign_R3][7]
            end if
            if length(settingsBuffer[cfgDesign_R3])>7 then
                formDiff = settingsBuffer[cfgDesign_R3][8]
                formPosition[3] += formDiff
            end if
        end if
    end if
    if equal(settingsBuffer[cfgDesign_CB1], "Design_CB1") then
        setCheck(Design_CB1, w32True)
    end if

    if equal(settingsBuffer[cfgCode_R1], "Code_R1") then
        setCheck(Code_R1, w32True)
        setCheck(Code_R4, w32False)
    end if
    if length(settingsBuffer[cfgCode_R2]) then
        if equal(settingsBuffer[cfgCode_R2][1], "Code_R2") then
            setCheck(Code_R2, w32True)
            setCheck(Code_R4, w32False)
            --set variable for IDE to test when open
            codeWasMaxed = settingsBuffer[cfgCode_R2][2]
        end if
    end if
    if length(settingsBuffer[cfgCode_R3]) then
        if equal(settingsBuffer[cfgCode_R3][1], "Code_R3") then
            setCheck(Code_R3, w32True)
            setCheck(Code_R4, w32False)
            --set position for IDE to test when open
            codePosition[1] = settingsBuffer[cfgCode_R3][2]
            codePosition[2] = settingsBuffer[cfgCode_R3][3]
            codePosition[3] = settingsBuffer[cfgCode_R3][4]
            codePosition[4] = settingsBuffer[cfgCode_R3][5]
            codeWasMaxed    = settingsBuffer[cfgCode_R3][6]
            if length(settingsBuffer[cfgCode_R3])>6 then
                codeWasMined    = settingsBuffer[cfgCode_R3][7]
            end if
        end if
    end if
    if equal(settingsBuffer[cfgCode_CB1], "Code_CB1") then
        setCheck(Code_CB1, w32True)
    end if

    if length(settingsBuffer[cfgPV_R1]) then
        if equal(settingsBuffer[cfgPV_R1][1], "PV_R1") then
            setEnable(PV_R1, w32True)
            setCheck(PV_R1, w32True)
            setCheck(PV_R2, w32False)
            --set position of ProjectWindow if undocked and open
            projectPosition[1] = settingsBuffer[cfgPV_R1][2]
            projectPosition[2] = settingsBuffer[cfgPV_R1][3]
            projectPosition[3] = settingsBuffer[cfgPV_R1][4]
            projectPosition[4] = settingsBuffer[cfgPV_R1][5]
            pvWasUnDocked      = settingsBuffer[cfgPV_R1][6]
        end if
    end if
    if equal(settingsBuffer[cfgPV_CB1], "PV_CB1") then
        setCheck(PV_CB1, w32True)
    end if

    if equal(settingsBuffer[cfgPV_CB2], "PV_CB2") then
        setCheck(PV_CB2, w32True)
    end if
    if length(settingsBuffer[cfgProp_R1]) then
        if equal(settingsBuffer[cfgProp_R1][1], "Prop_R1") then
            setEnable(Prop_R1, w32True)
            setCheck(Prop_R1, w32True)
            setCheck(Prop_R2, w32False)
            --set position of propertysheet if undocked and open
            propertyPosition[1] = settingsBuffer[cfgProp_R1][2]
            propertyPosition[2] = settingsBuffer[cfgProp_R1][3]
            propertyPosition[3] = settingsBuffer[cfgProp_R1][4]
            propertyPosition[4] = settingsBuffer[cfgProp_R1][5]
            propWasUnDocked     = settingsBuffer[cfgProp_R1][6]
        end if
    end if
    if equal(settingsBuffer[cfgProp_CB1], "Prop_CB1") then
        setCheck(Prop_CB1, w32True)
    end if

    if equal(settingsBuffer[cfgProp_CB2], "Prop_CB2") then
        setCheck(Prop_CB2, w32True)
    end if
    if length(settingsBuffer[cfgCB_Start]) then
        if equal(settingsBuffer[cfgCB_Start][1], "CB_Start") then
            setCheck(CB_Start, w32True)
            CB_StartFileName = settingsBuffer[cfgCB_Start][2]
        end if
    end if
    if equal(settingsBuffer[cfgCB_WantDefault], "CB_WantDefault") then
        setCheck(CB_WantDefault, w32True)
    end if
    if length(settingsBuffer[cfgEditPrjDef]) then
        if equal(settingsBuffer[cfgEditPrjDef][1], "EditPrjDef") then
            setText(EditPrjDef, settingsBuffer[cfgEditPrjDef][2])
        end if
    end if

    if equal(settingsBuffer[cfgSaveToProject], "SaveToProject") then
        setCheck(SaveToProject, w32True)
    end if

    if equal(settingsBuffer[cfgNoIndexing], "noIndexing") then
        if copyIndexSw then
            ok = invokeHandler(ToolCopyIndex, w32HClick, {})
            copyIndexSw = w32False
        end if
    end if

    if settingsBuffer[cfgControlEventBehavior]=1 then
        setCheck(MenuFirstEvent, w32True)
    elsif settingsBuffer[cfgControlEventBehavior]=2 then
        setCheck(MenuLastEvent, w32True)
    elsif settingsBuffer[cfgControlEventBehavior]=3 then
        setCheck(MenuThisLastEvent, w32True)
    end if

    if equal(settingsBuffer[cfgHideGutter], "HideGutter") then
        setCheck(MenuHideGutter, w32True)
    end if

    if equal(settingsBuffer[cfgNoMinMenuRun], "NoMinMenuRun") then
        setCheck(NoMinMenuRun, w32True)
    end if

    if equal(settingsBuffer[cfgAskSaveToProject], "AskSaveToProject") then
        setCheck(AskSaveToProject, w32True)
    end if

    if equal(settingsBuffer[cfgNoEditorBackup], "noEditorBackUp") then
        setCheck(MenuCodeBackUp, w32False)
    end if

    if equal(settingsBuffer[cfgNoEditorAutoComplete], "noEditorAutoComplete") then
        setCheck(MenuAutoComplete, w32False)
        synAutoComplete(w32False)
    end if

    if length(settingsBuffer[cfgDefaultMIS]) then
        --these will be added to project file when it is opened
    end if

    if copyIndexSw
    and not equal(settingsBuffer[cfgCopyIndex], "CopyIndexActive") then
        ok = invokeHandler(ToolCopyIndex, w32HClick,{})
    end if

    if length(settingsBuffer[cfgControls]) then
        if equal(settingsBuffer[cfgControls][1], "defControls") then
            SB = settingsBuffer[cfgControls][2]
            for j=1 to length(SB) do
                if equal(SB[j][1], "StatusBar") then
                    --use metrics determined when IDE loads
                    SB[j][3] = statusBar[2]
                end if
                if equal(SB[j][1], "HScroll") then
                    --use metrics determined when IDE loads
                    SB[j][3] = scrollWide
                end if
                if equal(SB[j][1], "VScroll") then
                    --use metrics determined when IDE loads
                    SB[j][2] = scrollWide
                end if
                ControlList[j][ControlCX] = SB[j][2]
                ControlList[j][ControlCY] = SB[j][3]
                ControlList[j][ControlName] = SB[j][4]
                ControlList[j][ControlTitle] = SB[j][5]
                if not length(ControlList[j][ControlName]) then
                    ControlList[j][ControlName] = ControlList[j][ControlClass]
                    SB[j][4] = SB[j][1]
                end if
                if not length(ControlList[j][ControlTitle]) then
                    ControlList[j][ControlTitle] = ControlList[j][ControlClass]
                    SB[j][5] = SB[j][1]
                end if
            end for
        end if
    end if

    if equal(settingsBuffer[cfgRegisterStyle][1],"RegisterStyle") then
        theStyles = settingsBuffer[cfgRegisterStyle][2]
    end if

    if settingsBuffer[cfgColorEuWinlib] then
        setCheck(MenuColorFile, w32True)
    end if

    if settingsBuffer[cfgColorLocal] then
        setCheck(MenuColorLocals, w32True)
        synSetColor(w32True)
    end if
    if isChecked(MenuColorFile) then
        setEnable(MenuColorLocals, w32False)
        synSetColor(w32False)
    end if

    if settingsBuffer[cfgChangeName] then
        setCheck(ChangeName, w32True)
    end if

    if settingsBuffer[cfgAutoSave] then
        setCheck(MenuAutoSave, w32True)
    end if

    if settingsBuffer[cfgColorControlName] then
        setCheck(MenuColorControlName, w32True)
        synSetNameColor(w32True)
    end if

    if settingsBuffer[cfgReuseBak1File] then
        setCheck(ReuseBak1File, w32True)
        if not isChecked(MenuBackupSave) then
            setCheck(ReuseBak1File, w32False)
            settingsBuffer[cfgReuseBak1File] = 0
        end if
    end if

    if settingsBuffer[cfgReuseBak2File] then
        setCheck(ReuseBak2File, w32True)
        if not isChecked(MenuBackupAfterSave) then
            setCheck(ReuseBak2File, w32False)
            settingsBuffer[cfgReuseBak2File] = 0
        end if
    end if

    if settingsBuffer[cfgAutosaveMinutes] then
        setText(AutosaveMinutes,settingsBuffer[cfgAutosaveMinutes])
        autosave_time = settingsBuffer[cfgAutosaveMinutes]*60*1000
    end if

    if settingsBuffer[cfgAutosaveOnOff] then
        setCheck(AutosaveCheckbox, w32True)
        autosave_OnOff = w32True
        setTimer(Controls, 1, autosave_time)
    else
        setCheck(AutosaveCheckbox, w32False)
        autosave_OnOff = w32False
    end if

    setText(DefaultEditor,settingsBuffer[cfgDefaultEditor])
    setText(BackupFolderName, settingsBuffer[cfgBackupFolderName])
    if not length(getText(BackupFolderName)) then
        setText(BackupFolderName,"Backups")
    end if

end procedure
-------------------------------------------------------------------------
global procedure saveDefaultSettings()

integer fn, ignore, at
sequence fName, examDocs, lastPosition, size, SB, openFolder
sequence ideLastPosition

    ConfigFile = the_current_dir & "\\Files\\IDE.cfg"

    -- open the file
    fn = open(ConfigFile, "w")
    if fn= -1 then
        -- give message and exit
        ignore = displayErrorMessage(176,{ConfigFile})
        return
    end if

    settingsBuffer[cfgWin32libName] = {}
    if length(cfgWin32lib)
    and not equal(upper(cfgWin32lib), upper("win32lib.ew")) then
        settingsBuffer[cfgWin32libName] = {"",""}
        settingsBuffer[cfgWin32libName][1] = "Win32libName"
        settingsBuffer[cfgWin32libName][2] = cfgWin32lib
    end if

    settingsBuffer[cfgFiles] = {}
    if length(FileBuffer) then
        settingsBuffer[cfgFiles] = {"",""}
        settingsBuffer[cfgFiles][1] = "Files"
        --put out the list of recent files
        --currently used project is last
        SB = {}
        for i=1 to length(FileBuffer) do
            at = 1
            fName = FileBuffer[i][1]
            SB &= {fName}
        end for
        settingsBuffer[cfgFiles][2] = SB
    end if

    examDocs = IdeDocs
    at = 1

    settingsBuffer[cfgIdeDocs] = {}
    if length(examDocs) then
        settingsBuffer[cfgIdeDocs] = {"",""}
        settingsBuffer[cfgIdeDocs][1] = "IdeDocs"
        settingsBuffer[cfgIdeDocs][2] = examDocs
    end if

    examDocs = RulerDocs
    at = 1

    settingsBuffer[cfgRulerDocs] = {}
    if length(examDocs) then
        settingsBuffer[cfgRulerDocs] = {"",""}
        settingsBuffer[cfgRulerDocs][1] = "RulerDocs"
        settingsBuffer[cfgRulerDocs][2] = examDocs
    end if

    examDocs = CbDocs
    at = 1

    settingsBuffer[cfgCbDocs] = {}
    if length(examDocs) then
        settingsBuffer[cfgCbDocs] = {"",""}
        settingsBuffer[cfgCbDocs][1] = "CbDocs"
        settingsBuffer[cfgCbDocs][2] = examDocs
    end if


    examDocs = Win32libDocs
    at = 1

    settingsBuffer[cfgWin32libDocs] = {}
    if length(examDocs) then
        settingsBuffer[cfgWin32libDocs] = {"",""}
        settingsBuffer[cfgWin32libDocs][1] = "Win32libDocs"
        settingsBuffer[cfgWin32libDocs][2] = examDocs
    end if

    if not saveLocal then
        settingsBuffer[cfgGlobal] = "Global"
    else
        settingsBuffer[cfgGlobal] = {}
    end if

    settingsBuffer[cfgTempRules1] = {}
    if tempRules1 then
        settingsBuffer[cfgTempRules1] = {"",""}
        settingsBuffer[cfgTempRules1][1] = "TempRules1"
        settingsBuffer[cfgTempRules1][2] = tempRules1
    end if

    settingsBuffer[cfgTempRules2] = {}
    if tempRules2 then
        settingsBuffer[cfgTempRules2] = {"",""}
        settingsBuffer[cfgTempRules2][1] = "TempRules2"
        settingsBuffer[cfgTempRules2][2] = tempRules2
    end if

    settingsBuffer[cfgNoBackupsave] = {}
    if not isChecked(MenuBackupSave) then
        settingsBuffer[cfgNoBackupsave] = "NoBackupSave"
    end if

    settingsBuffer[cfgNoBackupAftersave] = {}
    if not isChecked(MenuBackupAfterSave) then
        settingsBuffer[cfgNoBackupAftersave] = "NoBackupAfterSave"
    end if

    settingsBuffer[cfgWaitKey] = {}
    if length(waitForKeys) then
        settingsBuffer[cfgWaitKey] = {"",""}
        settingsBuffer[cfgWaitKey][1] = "WaitKey"
        settingsBuffer[cfgWaitKey][2] = waitForKeys
    end if

    settingsBuffer[cfgHintDisabled] = {}
    if not isChecked(MenuIgnoreHints) then
        settingsBuffer[cfgHintDisabled] = "HintDisabled"
    end if

    settingsBuffer[cfgHintStatusBar] = {}
    if isChecked(MenuHintsStatus) then
        settingsBuffer[cfgHintStatusBar] = "HintStatusBar"
    end if
    settingsBuffer[cfgMultipleInstance] = {}
    if not isChecked(MenuInstance) then
        settingsBuffer[cfgMultipleInstance] = "MultipleInstance"
    end if

    settingsBuffer[cfgProjectFileType] = {}
    if not equal(projectFileType, "prj") then
        settingsBuffer[cfgProjectFileType] = {"",""}
        settingsBuffer[cfgProjectFileType][1] = "ProjectFileType"
        settingsBuffer[cfgProjectFileType][2] = projectFileType
    end if

    settingsBuffer[cfgNotSetHandler] = {}

    settingsBuffer[cfgIDE_R1] = {}
    settingsBuffer[cfgIDE_R2] = {}
    settingsBuffer[cfgIDE_R3] = {}
    if isChecked(IDE_R1) then
        settingsBuffer[cfgIDE_R1] = "IDE_R1"
    elsif isChecked(IDE_R2) then
        settingsBuffer[cfgIDE_R2] = {"",0}
        settingsBuffer[cfgIDE_R2][1] = "IDE_R2"
        settingsBuffer[cfgIDE_R2][2] = isMaximized(Controls)
    elsif isChecked(IDE_R3) then
        if not isMinimized(Controls) then
            settingsBuffer[cfgIDE_R3] = {"",0,0,0,0,0}
            lastPosition = getPosition(Controls)
            size = getCtlSize(Controls)
            settingsBuffer[cfgIDE_R3][1] = "IDE_R3"
            settingsBuffer[cfgIDE_R3][2] = lastPosition[1]
            settingsBuffer[cfgIDE_R3][3] = lastPosition[2]
            settingsBuffer[cfgIDE_R3][4] = size[1]
            settingsBuffer[cfgIDE_R3][5] = size[2]
            settingsBuffer[cfgIDE_R3][6] = isMaximized(Controls)
        end if
    end if
    settingsBuffer[cfgDesign_R1] = {}
    settingsBuffer[cfgDesign_R2] = {}
    settingsBuffer[cfgDesign_R3] = {}

    if not isChecked(MenuUndockProperty) then
        size = getCtlSize(PropertySheet)
    elsif not isChecked(MenuUndockProject) then
        size = getCtlSize(ProjectWindow)
    else
        size = {0,0}
    end if
    if size[1]<=180 then
        formDiff = 0
    end if

    size = getCtlSize(Form)

    if isChecked(Design_R1) then
        settingsBuffer[cfgDesign_R1] = {"Design_R1",0,0}
        settingsBuffer[cfgDesign_R1][2] = formDiff
        size = getCtlSize(Form)
        settingsBuffer[cfgDesign_R1][3] = size[1]
    elsif isChecked(Design_R2) then
        settingsBuffer[cfgDesign_R2] = {"",0,0,0}
        settingsBuffer[cfgDesign_R2][1] = "Design_R2"
        settingsBuffer[cfgDesign_R2][2] = isMaximized(Form)
        settingsBuffer[cfgDesign_R2][3] = formDiff
        size = getCtlSize(Form)
        settingsBuffer[cfgDesign_R2][4] = size[1]
    elsif isChecked(Design_R3) then
        settingsBuffer[cfgDesign_R3] = {"",0,0,0,0,0,0,0}
        if isChecked(MenuUndockForm) then
            lastPosition = getRect(FormUndockWindow)
            size = getCtlSize(FormUndockWindow)
        else
            lastPosition = {0,0,0,0}--getRelRect(Form,Controls)
            size = getCtlSize(Form)
        end if
        settingsBuffer[cfgDesign_R3][1] = "Design_R3"
        settingsBuffer[cfgDesign_R3][2] = lastPosition[1]
        settingsBuffer[cfgDesign_R3][3] = lastPosition[2]
        settingsBuffer[cfgDesign_R3][4] = size[1]
        settingsBuffer[cfgDesign_R3][5] = size[2]
        settingsBuffer[cfgDesign_R3][6] = isMaximized(Form)
        settingsBuffer[cfgDesign_R3][7] = isChecked(MenuUndockForm)
        settingsBuffer[cfgDesign_R3][8] = formDiff
    end if
    settingsBuffer[cfgDesign_CB1] = {}
    if isChecked(Design_CB1) then
        settingsBuffer[cfgDesign_CB1] = "Design_CB1"
    end if
    settingsBuffer[cfgCode_R1] = {}
    settingsBuffer[cfgCode_R2] = {}
    settingsBuffer[cfgCode_R3] = {}
    if isChecked(Code_R1) then
        settingsBuffer[cfgCode_R1] = "Code_R1"
    elsif isChecked(Code_R2) then
        settingsBuffer[cfgCode_R2] = {"",0}
        settingsBuffer[cfgCode_R2][1] = "Code_R2"
        settingsBuffer[cfgCode_R2][2] = isMaximized(CodeWin)
        codeWasMaxed = settingsBuffer[cfgCode_R2][2]
    elsif isChecked(Code_R3) then
        if not isMinimized(CodeWin) then
            settingsBuffer[cfgCode_R3] = {"",0,0,0,0,0,0}
            lastPosition = getPosition(CodeWin)--getRelRect(CodeWin, Controls)
            lastPosition[2] -= toolBar
            if isChecked(IDE_R4) then
                ideLastPosition = getPosition(Controls)
--                lastPosition[1]+=ideLastPosition[1]
--                lastPosition[2]+=ideLastPosition[2]
            end if
            size = getCtlSize(CodeWin)
            if size[1]
            and size[2] then
                settingsBuffer[cfgCode_R3][1] = "Code_R3"
                settingsBuffer[cfgCode_R3][2] = lastPosition[1]
                settingsBuffer[cfgCode_R3][3] = lastPosition[2]
                settingsBuffer[cfgCode_R3][4] = size[1]
                settingsBuffer[cfgCode_R3][5] = size[2]
                settingsBuffer[cfgCode_R3][6] = isMaximized(CodeWin)
            else
                settingsBuffer[cfgCode_R3][1] = "Code_R3"
                settingsBuffer[cfgCode_R3][2] = lastPosition[1]
                settingsBuffer[cfgCode_R3][3] = lastPosition[2]
                settingsBuffer[cfgCode_R3][4] = codeLastSize[1]
                settingsBuffer[cfgCode_R3][5] = codeLastSize[2]
                settingsBuffer[cfgCode_R3][6] = isMaximized(CodeWin)
            end if
        else
            settingsBuffer[cfgCode_R3] = {"",0,0,0,0,0,0}
            size = getCtlSize(CodeWin)
            settingsBuffer[cfgCode_R3][1] = "Code_R3"
            settingsBuffer[cfgCode_R3][2] = 0
            settingsBuffer[cfgCode_R3][3] = 0
            settingsBuffer[cfgCode_R3][4] = size[1]
            settingsBuffer[cfgCode_R3][5] = size[2]
            settingsBuffer[cfgCode_R3][7] = w32True
        end if
        codePosition[1] = settingsBuffer[cfgCode_R3][2]
        codePosition[2] = settingsBuffer[cfgCode_R3][3]
        codePosition[3] = settingsBuffer[cfgCode_R3][4]
        codePosition[4] = settingsBuffer[cfgCode_R3][5]
        codeWasMaxed    = settingsBuffer[cfgCode_R3][6]
        codeWasMined    = settingsBuffer[cfgCode_R3][7]
    end if
    settingsBuffer[cfgCode_CB1] = {}
    if isChecked(Code_CB1) then
        settingsBuffer[cfgCode_CB1] = "Code_CB1"
    end if
    settingsBuffer[cfgPV_R1] = {}
    if isChecked(PV_R1) then
        settingsBuffer[cfgPV_R1] = {"",0,0,0,0,0}
        if isChecked(MenuUndockProject) then
            lastPosition = getRect(ProjectUndockWindow)
            size = getCtlSize(ProjectUndockWindow)
        else
            lastPosition = getRect(ProjectWindow)--getRelRect(ProjectWindow, Controls)
            size = getCtlSize(ProjectWindow)
        end if
        settingsBuffer[cfgPV_R1][1] = "PV_R1"
        settingsBuffer[cfgPV_R1][2] = lastPosition[1]
        settingsBuffer[cfgPV_R1][3] = lastPosition[2]
        settingsBuffer[cfgPV_R1][4] = size[1]
        settingsBuffer[cfgPV_R1][5] = size[2]
        settingsBuffer[cfgPV_R1][6] = isChecked(MenuUndockProject)
    end if
    settingsBuffer[cfgPV_CB1] = {}
    if isChecked(PV_CB1) then
        settingsBuffer[cfgPV_CB1] = "PV_CB1"
    end if
    settingsBuffer[cfgPV_CB2] = {}
    if isChecked(PV_CB2) then
        settingsBuffer[cfgPV_CB2] = "PV_CB2"
    end if
    settingsBuffer[cfgProp_R1] = {}
    if isChecked(Prop_R1) then
        settingsBuffer[cfgProp_R1] = {"",0,0,0,0,0}
        if isChecked(MenuUndockProperty) then
            lastPosition = getRect(PropertyUndockWindow)
            size = getCtlSize(PropertyUndockWindow)
        else
            lastPosition = getRect(PropertySheet)--getRelRect(PropertySheet, Controls)
            size = getCtlSize(PropertySheet)
        end if
        settingsBuffer[cfgProp_R1][1] = "Prop_R1"
        settingsBuffer[cfgProp_R1][2] = lastPosition[1]
        settingsBuffer[cfgProp_R1][3] = lastPosition[2]
        settingsBuffer[cfgProp_R1][4] = size[1]
        settingsBuffer[cfgProp_R1][5] = size[2]
        settingsBuffer[cfgProp_R1][6] = isChecked(MenuUndockProperty)
    end if
    settingsBuffer[cfgProp_CB1] = {}
    if isChecked(Prop_CB1) then
        settingsBuffer[cfgProp_CB1] = "Prop_CB1"
    end if
    settingsBuffer[cfgProp_CB2] = {}
    if isChecked(Prop_CB2) then
        settingsBuffer[cfgProp_CB2] = "Prop_CB2"
    end if
    settingsBuffer[cfgCB_WantDefault] = {}
    if isChecked(CB_WantDefault) then
        settingsBuffer[cfgCB_WantDefault] = "CB_WantDefault"
    end if
    settingsBuffer[cfgEditPrjDef] = {}
    if length(getText(EditPrjDef)) then
        settingsBuffer[cfgEditPrjDef] = {"",""}

        examDocs = getText(EditPrjDef)
        at = 1

        settingsBuffer[cfgEditPrjDef][1] = "EditPrjDef"
        settingsBuffer[cfgEditPrjDef][2] = examDocs
    end if
    settingsBuffer[cfgCB_Start] = {}
    if isChecked(CB_Start) then

        settingsBuffer[cfgCB_Start] = {"",""}
        examDocs = openFileName
        at = 1

        settingsBuffer[cfgCB_Start][1] = "CB_Start"
        settingsBuffer[cfgCB_Start][2] = examDocs

        if length(examDocs) then
            openFolder = examDocs
        else
            openFolder = the_current_dir
        end if
        --tell Code Editor that user has changed default folder since opened CodeWin
        synSetCurrentFolder(openFolder)
    end if
    settingsBuffer[cfgSaveToProject] = {}
    if isChecked(SaveToProject) then
        settingsBuffer[cfgSaveToProject] = "SaveToProject"
    end if
    settingsBuffer[cfgAskSaveToProject] = {}
    if isChecked(AskSaveToProject) then
        settingsBuffer[cfgAskSaveToProject] = "AskSaveToProject"
    end if
    settingsBuffer[cfgAutoSave] = 0
    if isChecked(MenuAutoSave) then
        settingsBuffer[cfgAutoSave] = w32True
    end if
    settingsBuffer[cfgNoEditorBackup] = {}
    if not isChecked(MenuCodeBackUp) then
        settingsBuffer[cfgNoEditorBackup] = "noEditorBackUp"
    end if
    settingsBuffer[cfgNoIndexing] = {}
    if isChecked(NoIndexing) then
        settingsBuffer[cfgNoIndexing] = "noIndexing"
    end if
    settingsBuffer[cfgCopyIndex] = {}
    if copyIndexSw then
        settingsBuffer[cfgCopyIndex] = "CopyIndexActive"
    end if
    settingsBuffer[cfgNoEditorAutoComplete] = {}
    if not isChecked(MenuAutoComplete) then
        settingsBuffer[cfgNoEditorAutoComplete] = "noEditorAutoComplete"
    end if
    settingsBuffer[cfgReuseBak1File] = 0
    if isChecked(ReuseBak1File) then
        settingsBuffer[cfgReuseBak1File] = 1
    end if
    if not isChecked(MenuBackupSave) then
        settingsBuffer[cfgReuseBak1File] = 0
    end if
    settingsBuffer[cfgReuseBak2File] = 0
    if isChecked(ReuseBak2File) then
        settingsBuffer[cfgReuseBak2File] = 1
    end if
    if not isChecked(MenuBackupAfterSave) then
        settingsBuffer[cfgReuseBak2File] = 0
    end if
    if isChecked(MenuFirstEvent) then
        settingsBuffer[cfgControlEventBehavior] = 1
    elsif isChecked(MenuLastEvent) then
        settingsBuffer[cfgControlEventBehavior] = 2
    elsif isChecked(MenuThisLastEvent) then
        settingsBuffer[cfgControlEventBehavior] = 3
    else
        settingsBuffer[cfgControlEventBehavior] = 0
    end if
    settingsBuffer[cfgHideGutter] = {}
    if isChecked(MenuHideGutter) then
        settingsBuffer[cfgHideGutter] = "HideGutter"
    end if
    settingsBuffer[cfgNoMinMenuRun] = {}
    if isChecked(NoMinMenuRun) then
        settingsBuffer[cfgNoMinMenuRun] = "NoMinMenuRun"
    end if
    settingsBuffer[cfgColorEuWinlib] = 0
    if isChecked(MenuColorFile) then
        settingsBuffer[cfgColorEuWinlib] = w32True
    end if
    settingsBuffer[cfgColorLocal] = 0
    if isChecked(MenuColorLocals) then
        settingsBuffer[cfgColorLocal] = w32True
    end if
    settingsBuffer[cfgColorControlName] = 0
    if isChecked(MenuColorControlName) then
        settingsBuffer[cfgColorControlName] = w32True
    end if
    settingsBuffer[cfgChangeName] = 0
    if isChecked(ChangeName) then
        settingsBuffer[cfgChangeName] = w32True
    end if
    settingsBuffer[cfgDefaultMIS] = {}
    for i=1 to length(includeModules) do
        if includeModules[i][4] then
            if match(includeModules[i][3], includeModules[i][1]) then
                --filename has path already
                settingsBuffer[cfgDefaultMIS] &= {includeModules[i][1]}
            else
                settingsBuffer[cfgDefaultMIS] &= {includeModules[i][3] & "\\" & includeModules[i][1]}
            end if
        end if
    end for
    settingsBuffer[cfgDefaultEditor] = getText(DefaultEditor)
    settingsBuffer[cfgAutosaveOnOff] = isChecked(AutosaveCheckbox)
    settingsBuffer[cfgAutosaveMinutes] = getScrollPos(AutosaveMinChg)
    settingsBuffer[cfgBackupFolderName] = getText(BackupFolderName)

    print(fn, settingsBuffer)
    close(fn)
end procedure
saveDefaultSettingsId = routine_id("saveDefaultSettings")

