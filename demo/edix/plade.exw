--
-- pGUI-IDE.exw (Phix/pGUI Layout Designer/IDE)
-- ============
--  plc - Phix Layout Constructor (pronounced pluck)
--  pluck - Phix Layout Constructor Kickstarter (pronounced pluck)
--  pdle - no!
--  IupLade.exw -  ugh
--  IupLaDe.exw -  ugh
--  ILD.exw -  ugh
--  IuPlade.exw -  ugh
--  pGlade.exw -  erm
--  pGalde.exw -  erm
--  pGuilade.exw -  erm
--  pGuialde.exw -  erm
--  pGuild.exw -    erm
--  guild.exw - erm/nah
--  pGUId.exw - erm
--  pide.exw -  erm
--  pIDE.exw -  erm - maybe...
--  pGLIDE.exw -    erm - maybe...
--  pGlide.exw -    nah
--  pGLADE.exw -    erm - maybe...
--  pGlade.exw -    nah
--  pGUIDE.exw -    erm - maybe  (pronounced with a silent p?)  <== best so far...
--    (pronounced puh-guide, similar to pagoda, but definately not pee-guide, the rival to the she-wee)
--  pguide.exw -    erm - maybe
--  GUIDE.exw -     erm - maybe
--  guide.exw -     erm - maybe
--  Guide.exw -     erm - maybe
--  GUIde.exw -     nah
--  pGUIde.exw -    nah
--  pGUI-IDE.exw -  actually, that probably wins (pronounced "pea-gooey-eyed", or sometimes just "Guide")

constant SPACE = 0  -- disabled for this release (full investigation/analysis rqd)

--TODO (10/11/17):
-- remove menus from hierarchytree [DONE]
-- finish set_add_modes[2] testing [DONE, now to start using it... DONE]
-- remove menus from right-click menu [DONE]
-- when >1 window exists, initial focus should be on the drop-down. [DONE]
-- add a resize thing between ht & props [DONE]
-- add a TITLE and input field on the create window when appropriate. [DONE]
-- double-click on properties/new button pop-up [new_attr_cb & dblclick_cb => edit_attrib] [DONE]
-- actually delete (delete_cb)
-- when integrated with edix, edit definition (button/tools menu on the properties window?)
-- another tool: the full list of attributes, as per IupLayoutDialog() (selectable)
-- SUG: File/Open?? (or from Edix-only?)
-- start the manual(s)
-- [OT] get pGUI-IDE to launch from Edix, and the (F1) help keys working
-- Qu: should Esc on liveview close the thing? - yes, for now...

--SUG use the USERDATAid attribute / IupTreeSetUserId / IupTreeGetUserId / IupTreeGetId
--SUG use IupTreeAddNodes instead:
--constant USEADDNODES = 01
--DEV DRAGDROPTREE / DROPFILESTARGET / DROPEQUALDRAG / SHOWDRAGDROP / DRAGDROP_CB / DROPFILES_CB at the
--   very least (if used) need rethinking.
--One small glitch...
--dragging onto a container:
--if the branch is expanded the dragged item is added as the first child
--if the branch is collapsed the dragged item is added as the next sibling
--AH: if it is say an IupFrame, you cannot add a child to expand/add - it just don't work.... you need to ask.
--Update: dropping into an empty branch seems more sensible...
--  Actually, drag and drop works just fine for all non-container target nodes, however when the target
--  is a container then a child/sibling question needs asking. Technically we don't need them all, but
--  we may as well have them:
-- [Confirm move] [The IupButton("OK") element was dragged onto IupFrame(), move as:]
--      first child of container    -- (grey out/remove if not a container) [default if]
--      last child of container     --              ""
--      previous sibling            -- (a four-way radio would probably be clearest)
--      next sibling                -- [the default on non-container targets]
-- Of course when I say non-container, that also includes any single-child-only-already-there elements.
-- QU: can we disable drop on containers dynamically? (esp IupDialog) [using CHILDCOUNTid, KINDid, PARENTid/DEPTHid?]
--******AH*****: (from IupTree.htm) [make this a <b>TIP:</b>]
--If the drop node is a branch and it is expanded, then the drag node is inserted as the first child of the node. 
--If the branch is not expanded or the node is a leaf, then the drag node is inserted as the next brother of the drop node. 
--=> Antonio,
--from IupTree, MOVENODE:
--"If the destination node is a branch and it is expanded, then the specified node is inserted as the first child of the destination node. "
--"If the branch is not expanded or the destination node is a leaf, then it is inserted as the next brother of the leaf. "
--and similarly from DRAGDROP_CB:
--"If the drop node is a branch and it is expanded, then the drag node is inserted as the first child of the node. "
--"If the branch is not expanded or the node is a leaf, then the drag node is inserted as the next brother of the drop node. "
--Problem: if the branch is empty, you cannot expand it to trigger drop as child. If the branch can only have a single child,
-- eg an IupFrame, you cannot add a dummy child so that you can expand and then drop (and then delete the dummy). It makes
-- more sense to me that a drop on an empty branch should make it a child. If you genuinely want the drop to create a 
-- sibling to an empty node (as now), I accept that change would mean you would then need to perform multiple drags, but
-- at least it wouldn't be completely impossible like the "drop as child in an empty node" currently is.
-- I believe (cmiiw) this situation also applies to and can easily be shown in IupLayoutDialog() - what I'm actually trying
-- to do is write a similar but my-programming-language-specific IDE.
--***AH*** THE PENNY FINALLY DROPS. Always add empty containers as expanded nodes. This may mean you have to add and delete
--a dummy child:
constant USETREEIMAGES = 0  -- (0 for debugging expanded/closed node settings)

--SUG (30/10/17): make a right-click menu of controls... (just to see, for now) [DONE]
--      ""      : take a hint from wpaint; that is still pretty much the user experience we want,
--                  except for the fact it is a tree/properties rather than that dropdown.
--                  (demo_controls.exw [still] worked fine)
--also blag/reuse the layout designer icon from edix.
--SUG: "spacing only" checkbox on the properties window, limits attributes to PAD/GAP/MARGIN/SIZE etc.
--[DOC] 
--  The spacing only checkbox should be self-explanatory - it lets you focus on padding, gaps, margins
--  and the like, by hiding all the other attributes such as font, colour, image, style, etc. It is in 
--  fact a tri-state toggle, with then NOTDEF state also hiding any otherwise distracting read-only 
--  attributes that you cannot actually set. Note that modifying creation-only attributes may require
--  the live-view dialog to be rebuilt, which can be forced via the Test menu option.
--  (it is a 3STATE button) 
--DOC The space checkbox (tri-state) has been disabled for this release. [DEV constant SPACE]
-- The intention is for OFF to show all attributes, ON to show just those
-- relating to spacing, and NOTDEF further restricts to those that can
-- actually be set. While the proof of concept seems to work fine, I have
-- not had time to investigate/build the lists of attributes to use. Both
-- trawling through the documents looking for likely attributes and read-only
-- markers, and running IupLayoutDialog() (eg fill.exw) would be required.

--  The Test menu option displays 7 buttons, Up, Left, Ontop, Right, Down, Rebuild, and Cancel.
--  The first five move the created window to one side, to avoid confusion that can arise when the 
--  center Ontop button is selected, in which case it overlays the existing live view window exactly. 
--  The Rebuild button simply destroys and recreates the live view, which may be necessary when you
--  modify some creation-only settings. 
--  All those 6 buttons overwrite the content of pGtest.exw, which may then be used for standard 
--  (source code) cut and paste purposes.
--  The Cancel button simply closes the Test window (as opposed to discarding any changes, which is
--  what the File/Cancel menu entry does).
--  (see ealtest.exw) ***<==*** get this working first!!

constant SHOWBRANCHINFO = 0     -- (printf(1,"IupSetAttributeId"...)
constant SHOWCONTROLS = 01      -- (printf(1,"[not] call_proc()/func()...)
--constant SHOWTABS = 0         -- (never looked right)
constant SHOWDESIRED = 0        -- (special on fill.exw)
constant SHOWDETAILS = 01       -- DEV - as you move about in the tree... (properties)
if SHOWDETAILS and SHOWDESIRED then ?9/0 end if

integer errorcount = 0

without trace
include builtins\VM\pcfunc.e
with trace
include pGUI.e

Ihandle hierarchytree,
--      hierarchytreE,  -- temp!
        properties
--
-- I really need to finish the documentation before I can do this... [DONE]
--/*
IupFill                                                                                                             [plade_fill.png]
IupNormalizer[?]                                                                                                    [plade_normal.png]
IupGridBox                                                                                                          [plade_grid.png]
IupCbox [maybe... quick and dirty...]                                                                               [plade_cbox.png]
IupHbox                                                                                                             [plade_hbox[2].png]
IupVbox                                                                                                             [plade_vbox[2/3].png]
IupZbox                                                                                                             [plade_zbox.png]
IupScrollBox                                                                                                        [plade_scroll.png]
IupBackgroundBox                                                                                                    [plade_backgroundbox.png]
IupDialog                                                                                                           [application.png]
IupButton  - Creates an interface element that is a button, that can contain a text and/or an image.                [plade_button.png]
IupFlatButton                                                                                                       [plade_flatbutton.png]
IupCanvas  - Creates an interface element that is a canvas - a working area for your application.                   [plade_canvas.png]
IupFrame  - Creates a native container, which draws a frame with a title around its child.                          [plade_frame[2].png]
IupImage[?]  - Creates an image to be shown on a label, button, toggle, or as a cursor.                             [plade_image.png]
IupLabel  - Creates a label interface element, which displays a separator, a text or an image.                      [plade_label[2].png]
IupList  - Creates an interface element that displays a list of items.                                              [plade_list.png]
IupMatrix  - Creates a matrix of alphanumeric fields.                                                               [plade_matrix.png]
IupMenu  - Creates a menu element, which groups 3 types of interface elements: item, submenu and separator.         [plade_menu.png]
IupMenuItem  - Creates an item of the menu interface element. Aka IupItem.                                          [plade_menuitem.png]
IupSeparator  - Creates the separator interface element. It shows a line between two menu items.                    [plade_sep.png]
IupSubmenu  - Creates a menu item that, when selected, opens another menu.                                          [plade_submenu.png]
IupProgressBar  - Creates a progress bar control.                                                                   [plade_progress.png]
IupPlot  - Creates a plot control.                                                                                  [plade_plot.png]
IupRadio  - Creates a void container for grouping mutual exclusive toggles.                                         [plade_radio[s].png]
IupSbox  - Creates a void container that allows its child to be resized.                                            [plade_resize.png]
IupSplit  - Creates a void container that split its client area in two.                                             [plade_split.png]
IupTabs  - Creates a tab control (like IupZbox, but interactively visibile)                                         [plade_tabs.png]
IupText  - Creates an editable text field.                                                                          [plade_text[2].png]
IupToggle  - Creates a toggle interface element                                                                     [plade_check.png]
IupTree  - Creates a tree containing nodes of branches or leaves.                                                   [plade_tree.png]
IupValuator  - Creates a Valuator control (aka Scale, Slider, or Trackbar).                                         [plade_slider.png]
IupLink (note below)                                                                                                [plade_link.png]
IupSpinBox                                                                                                          [plade_spin.png]
IupDetachBox                                                                                                        [plade_detach[2].png]
IupExpander                                                                                                         [plade_expand.png]
IupDial                                                                                                             [plade_dial.png]
IupCells                                                                                                            [plade_cells.png]
IupCalendar                                                                                                         [plade_calendar.png]
IupDatePick                                                                                                         [plade_date_picker.png]

OMG:: I am missing a **HUGE** trick here. Just load a gui from source and leave the whole thing on the clipboard!!
That would allow you to browse for something similar, nick it, tweak it, and put it in a new project!!!!!!!
An interface to Edix might go more like (on the clipboard, or perhaps ipc shared memory):
"""
Original:
3176,21:IupDialog(vbox)
<lots more lines>
Replacement:
[3176,21:]IupDialog(vbox)
<lots more lines>
"""
And it is up to Edix to sort that mess out!! (the replacement can optionally have line/col indicating origin, but that may not help much)

Instructions:
pGUI(/IUP) uses abstract layout positioning. The easiest way to think of this is that instead of using explicit x,y co-ordinates,
if you want a message with two buttons in a row beneath it, you might do something like this:
    
<!--eucode>
include pGUI.e

    IupOpen("demo\\pGUI\\")

    Ihandle text = IupLabel("Hello"),
            okbtn = IupButton("OK"),
            cancel = IupButton("Cancel"),

            hbox = IupHbox({okbtn,cancel}),
            vbox = IupVbox({text,
                            hbox}),

            dlg = IupDialog(vbox)

    IupShow(dlg)

    IupShow(dlg)

    IupMainLoop()
    IupClose()
</eucode-->
<pre>
</pre>

Which show the basic idea, but looks pretty ropey, 
<img>
until you add some padding:

<!--eucode>
include pGUI.e

    IupOpen("demo\\pGUI\\")

    Ihandle text = IupLabel("Hello"),
            okbtn = IupButton("OK"),
            cancel = IupButton("Cancel"),

            hbox = IupHbox({IupFill(),okbtn,IupFill(),cancel,IupFill()}),
            vbox = IupVbox({IupFill(),
                            IupHbox({IupFill(),text,IupFill(),IupFill()}),
                            IupFill(),
                            hbox,
                            IupLabel()}),

            dlg = IupDialog(vbox)

    IupSetAttribute(dlg, "MINSIZE", "180x120")
    IupSetAttribute(dlg, "SHRINK", "YES")

    IupShow(dlg)

    IupMainLoop()
    IupClose()
</eucode-->
<pre>
</pre>

<img>

It is in fact the need to add all those IupFill(), the extra IupHbox(), and set various attributes, that is the most
compelling reason that a program like plade is required, and what it concentrates on. Sure, (over time) there will be
a way to locate that OK button and edit/insert a template for the code that will be executed when it is clicked, but
doing so [will close plade and] plant you back in edix, hopefully with such context switches being fast and efficient
in both directions. For now, though, the focus is on getting the basic appearance right.

When plade starts, you are presented with two trees: on the left is a control palette, listing all the available
containers and elements, and on the right is a hierarchy tree, which should have an IupDialog as the root node.
Simply drag nodes from the palette onto the hierarchy (or back to the trash node), or around on the hierarchy,
and right-click on nodes on the right to set properties. Nearer the center of the screen should be a live display
reflecting changes as they happen, and you can click directly on that to assist in navigating the hierarchy tree.
In future, it may be posssible to make dragging items about on the live display automatically modify the abstract 
hierarchy tree, inserting/removing Hbox/Vbox etc as it sees fit.

Selecting a node in either the control palette or the hierarchy tree updates the corresponding help button, which 
opens the relevant page in phix.chm. Having two help buttons that do basically the same thing just makes life a
little bit easier, compared to being forced to locate and select the equivalent node on the other (palette) tree.

Aside: the split between elements and controls is quite arbitrary, as suggested by the matching icon, and was
       done simply because otherwise the element branch had too many nodes to navigate/visually scan easily.


---====---

Not supported: IupGetParam - As well as being a significant technical challenge, it would almost certainly be both physically and
                             intellectually more difficult to modify string fmt and sequence param_data in a GUI than it would be
                             to edit them in a plain text file. Considerable effort for a negative gain. Instead I might suggest
                             making a copy of demo/pGUI/getparam.exw to experiment with the layout or construct the first draft.

None of the IupGL* functions are currently supported. The samples I have might be too complex for this anyway...

I am going to need lots of icons... [DONE]

note: I chose the chrome logo as it felt the most readily recognisable. 
      I suppose I should really retrieve the system html-file association... (at least on Windows/make a builtin?)

SUG: learning mode: on parse/exit show suggestions for learnt attributes and values.
                    allow accept/reject/exclude/ignore:
                    accepts are added to the drop-downs,
                    rejects trigger errors if re-encountered,
                    excludes are quietly ignored "", and
                    ignores are a one-time only thing.
    also have a learning mode default, for startup.

AHEM: we need to comprehend handles, especially for menus.  -- DONE/rework (all demos) to use IupSetAttributeHandle(),
                                                            --                    instead of IupSetHandle(), as below.
    Further, we need a list of handles used by glade itself, and auto-rename things
    when we create the dialog, so glade does not fail badly when given itself...
    (if found in the list of prohibited names, just append an X, should do it:
        if find(name,prohibited) then name &='X' end if.) [Not if we prohibit/ignore IupSetHandle!]
--*/
--sequence prohibited = {"mymenu"}
sequence prohibited = {}

--use iupnames instead??
constant IupFuncs = {"IupDialog",
                     "IupBackgroundBox",
                     "IupButton",
                     "IupCalendar",
                     "IupCanvas",
                     "IupCbox",
                     "IupCells",
                     "IupClipboard",    -- (not really)
                     "IupColorDlg",     -- (not really)
                     "IupConfig",       -- (not really)
                     "IupDatePick",
                     "IupDetachBox",
                     "IupDial",
                     "IupExpander",
                     "IupFill",
                     "IupFileDlg",      -- (not really)
                     "IupFontDlg",      -- (not really)
                     "IupFrame",
                     "IupGridBox",
                     "IupHbox",
--                   "IupImage",
--                   "IupItem", (IupMenuItem) [DEV we should really]
                     "IupLabel",
                     "IupLink",
                     "IupList",
                     "IupMatrix",
                     "IupMenu",
                     "IupMenuItem",
                     "IupMessageDlg",   -- (not really)
                     "IupMultiLine",    -- maybe..
                     "IupScrollBox",
                     "IupSeparator",
                     "IupSubmenu",
                     "IupProgressBar",
                     "IupPlot",
                     "IupRadio",
                     "IupSbox",
                     "IupSpinBox",
                     "IupSplit",
                     "IupTabs",
                     "IupText",
                     "IupToggle",
                     "IupTree",
                     "IupValuator",
                     "IupVbox",
                     "IupZbox",
                     "Icallback"}

function nr(string name, integer rid = routine_id(name))
--DEV otherwise string gets damaged... (same may be needed for IupSetAttributeId and IupMatSetAttribute?)
--DEV (this may be the wrong place to substitute, a second [half of this] list would perhaps be better,
-- eg function ns(string name) return {name,IupProcIds[find(name,IupProcs)]}
--                                 or {name,??[find(name,??)+1]}
    if name="IupSetAttribute" then rid = routine_id("IupSetStrAttribute") end if
    return {name,rid}
end function

--DOC Note that pGUIDE uses IupSetStrAttribute in place of IupSetAttribute, because it does things
--    such as sprintf() all over the place, and it does not bother to try and distinguish when that
--    routine substitution is necessary, either internally or in the code it analyses. Should your
--    application mismatch that seen in pGUIDE, with the latter being correct, then maybe you need
--    the same substitution in your appplication code.

-- (obviously set only, we don't care about get)
constant {IupProcs,IupProcIds} = columnize({nr("IupSetAttribute"),
                                            nr("IupSetAttributes"),
                                            nr("IupSetAttributeHandle"),
                                            nr("IupSetAttributeId"),
--                                          nr("IupSetHandle"),         -- ignored?? (removed for listview.exw)
                                            nr("IupSetInt"),
                                            nr("IupSetCallback"),
                                            nr("IupMatSetAttribute"),
                                            nr("IupSetStrAttribute"),
                                            nr("IupStoreAttribute"),
                                            nr("IupAppend")})


--Searching for: iupdialog
-- Files scanned 61, Directories scanned 7, Lines 43042
--Start with this one:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\fill.exw"--:38 dialog = IupDialog(IupVbox({frame_left,frame_center,frame_right,NULL}))
--IupAppend: (12 errors detected)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\edix\\plade.exw"--:165  dlg = IupDialog(canvas)
--attributes:RASTERSIZE (now ok)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\GraphR.exw"--:165   dlg = IupDialog(canvas)
--MT (good, well needs "0 windows found." and OK disabled)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\alarm.exw"--:19       IupShow(IupDialog(NULL)) -- show an empty dialog [otherwise IupMessage fails, fixed in SVN]
-- (as GraphR)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\buffer.exw"--:79   dlg = IupDialog(canvas)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\calendar.exw"--:44 dlg = IupDialog(box)
--simple:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\cdtest.exw"--:84   hDialog = IupDialog(hIupCanvas)
--attributes:ACTIVE, RESTORE, DETACH, new_parent
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\detachbox.exw"--:44     dlg = IupDialog(IupVbox({dbox, lbl, restore_btn, txt}),
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\dialog2.exw"--:24   dialog = IupDialog(vbox,"TITLE=\"Dialog Title\"")
--attributes:ACTIVE, TITLE, ORIGIN, VALUEPOS also: Icallback(cb_exit), IupAppend
--**menu broken...** (26 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\filedump.exw"--:9983 maindlg = IupDialog(IupVbox({tabs,
--unresolved: attrtext, labeltext (may be a good thing) (6 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\frame.exw"--:25       Ihandle dialog = IupDialog(IupFrame(IupVbox({IupLabel(labeltext),
--IupGLMake: (otherwise ok)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\gears.exw"--:373   dialog = IupDialog(box)
--IupGL*:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\glcanvas_cube.exw"--:217   dialog = IupDialog(box);
--(similar to fill.exw)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\hbox.exw"--:43 dialog = IupDialog(IupVbox({fr1,fr2,fr3}),"TITLE=IupHbox")
--sprintf:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\image.exw"--:111   Ihandle dlg = IupDialog(IupVbox({
--erm..
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\imgdisp.exw"--:78 hDlg = IupDialog(IupHbox({hImg1Lbl, hImg2Lbl}))
--IupGL*:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\iup3Dctrls.exw"--:567   dlg = IupDialog(box)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\iup3Dgl.exw"--:147   dialog = IupDialog(canvas, "SIZE=640x480");
--attribute:MARK,REDRAW,FOCUSCELL,sortc(var),SORTSIGN,TITLE,RASTERWIDTH
--sprint,sprintf etc: (24 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\listview.exw"--:208       Ihandle dlg = IupDialog(vbox)
--(3 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\mandelbrot.exw"--:89   hDialog = IupDialog(hIupCanvas)
--bare w/o the callback...
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\matrix.exw"--:71   dlg = IupDialog(mat)
--C:\Program Files (x86)\Phix\demo\pGUI\matrix.exw:112   Ihandle dlg = IupDialog(mat)
--C:\Program Files (x86)\Phix\demo\pGUI\matrix.exw:173   Ihandle dlg = IupDialog(IupVbox({mat},"MARGIN=10x10"),"TITLE=\"IupMatrix Example\"")
--C:\Program Files (x86)\Phix\demo\pGUI\matrix.exw:215   Ihandle dlg = IupDialog(IupVbox({mat},"MARGIN=10x10"),"TITLE=\"IupMatrix Example\"")
--C:\Program Files (x86)\Phix\demo\pGUI\matrix.exw:438 Ihandle dlg = IupDialog(matrix, "TITLE=\"IupMatrix in Callback Mode\"")
--C:\Program Files (x86)\Phix\demo\pGUI\matrix.exw:486   Ihandle dlg = IupDialog(IupVbox({mat}, "MARGIN=10x10"))
--C:\Program Files (x86)\Phix\demo\pGUI\matrix.exw:532   Ihandle dlg = IupDialog(matrix,"TITLE=\"teste\"")
--C:\Program Files (x86)\Phix\demo\pGUI\matrix.exw:799   dlg = IupDialog(
--IupSetHandle:[FIXED] **DEV menus should be shown but not on the hierarchy tree...
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\menu.exw"--:33   dlg = IupDialog(IupCanvas(),"MENU=mymenu, TITLE=IupMenu, SIZE=200x100")
--IupMultiLine does not work... (1st arg NULL...)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\multiline1.exw"--:35   dlg = IupDialog(ml, "TITLE=IupMultiline, SIZE=QUARTERxQUARTER")
--warning - cb_run,cb_help,tab2 unresolved: (29 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\pdemo.exw"--:202   dlg = IupDialog(vbox)
--not a chance! (116 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\plot.exw"
--(2 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\plot1.exw"
--error: iff()
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\radio.exw"--:38       dialog = IupDialog(IupHbox({IupFill(),frame,IupFill()})) 
--data/rot13, IupStore(IupGet)... (as menu.exw)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\rot13.exw"--:111 hDialog = IupDialog(hMainBox)
--warning - ih unresolved (line 264) [errorcount +=1, line 2939]    (IupSetCallback)
--warning - ih unresolved (line 272) [errorcount +=1, line 2939]    (IupSetCallback)
--warning - img unresolved (line 393) [errorcount +=1, line 2939]   (IupSetAttribute)
--warning - img unresolved (line 394) [errorcount +=1, line 2939]       "
--warning - img unresolved (line 395) [errorcount +=1, line 2939]       "
--warning - img unresolved (line 396) [errorcount +=1, line 2939]       "
----call_proc(IupSetAttribute,{75594024,"TABTITLE1","Tab Title 1"})
--{"resolve_arg",0,"img","(allargsvalid:=false) [errorcount +=1, line 3547]"}
----handles[79] = call_func(IupTree,{})
--{"resolve_arg",0,"id","(allargsvalid:=false) [errorcount +=1, line 3547]"}    -- (IupSetAttributeId?)
--(8 errors, as above) [not too shabby though]
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\sample.exw"--:517   dlg = IupDialog(vbox_1);
--experiments with MENU: (ok)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\separator.exw"--:172   dlg = IupDialog(text)
--significantly reworked, now 0 unresolved! 3 dialogs (goto/find/main):
--**broken** (ok if last dialog(3) only)
--{"resolve_arg",0,"line_count","(allargsvalid:=false) [errorcount +=1, line 3547]"}    -- (?IupSetStrAttribute?)
--{"resolve_arg",0,"IUP_MASK_UINT","(allargsvalid:=false) [errorcount +=1, line 3547]"}  (IupSetAttribute)
--{"PARENTDIALOG",{15130056,"PARENTDIALOG",{10,"dlg",0,363,53,55}},"(allargsvalid:=false) [errorcount +=1, line 3658]"}
--[not] call_proc(IupSetAttributeHandle,{15130056,"PARENTDIALOG",{10,"dlg",0,363,53,55}})
--(3 errors - oh, they could be on different dialogs!) [none too shabby]
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\simple_notepad.exw"--:371   goto_dlg = IupDialog(box);
--C:\Program Files (x86)\Phix\demo\pGUI\simple_notepad.exw:512   find_dlg = IupDialog(box);
--C:\Program Files (x86)\Phix\demo\pGUI\simple_notepad.exw:897   dlg = IupDialog(vbox);
--IupGL* reworked as per simple_notepad 3 dialogs (text/toolbox/main):
--**broken**
--(3 errors)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\simple_paint.exw"--:767       dlg = IupDialog(text)
--C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:2096   toolbox = IupDialog(vbox)
--C:\Program Files (x86)\Phix\demo\pGUI\simple_paint.exw:2193   dlg = IupDialog(vbox)
--DULL:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\submenu.exw"--:127   dlg = IupDialog(text)
--NO (hack of pGUI.e, now gives error)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\t.exw"--:52       xIupDialog              = define_c_func(iup, "IupDialog", {P}, P),
--C:\Program Files (x86)\Phix\demo\pGUI\t.exw:137 function IupDialog(atom child)
--C:\Program Files (x86)\Phix\demo\pGUI\t.exw:138 atom result = c_func(xIupDialog, {child})
--C:\Program Files (x86)\Phix\demo\pGUI\t.exw:206   atom dialog = IupDialog(toolbar)
--ditto:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\t2.exw"--:76   xIupDialog              = define_c_func(iup, "IupDialog", {P}, P),
--C:\Program Files (x86)\Phix\demo\pGUI\t2.exw:127 function IupDialog(Ihandln child)
--C:\Program Files (x86)\Phix\demo\pGUI\t2.exw:128   Ihandle ih = c_func(xIupDialog, {child})
--C:\Program Files (x86)\Phix\demo\pGUI\t2.exw:219   atom dialog = IupDialog(toolbar)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\tabs.exw"--:41 dlg = IupDialog(box)
--NO: (ifdef)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\tee.exw"--:1815 atom dialog = IupDialog(vbox)
--IupGLCanvas:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\teselation.exw"
--FIXME:
--      atom {x,y,z} = points[i],
--           denom = (1-z/d)
--THEN:
--procedure vertices(integer wx, wh, sequence points, face)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\test.exw"--:37   dlg = IupDialog(vbx)
--2 errors, both password:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\text.exw"--:66   dlg = IupDialog(IupVbox({text, pwd}))
--img1,img2:
--4 errors
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\toggle.exw"--:109   dlg = IupDialog(toggles, "TITLE=IupToggle, MARGIN=5x5, GAP=5, RESIZE=NO")
--IupGLCanvas
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\triangle.exw"--:70   dialog = IupDialog(canvas, "TITLE=Triangle, SHRINK=YES")
--IupGLCanvas
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\vol_fog.exw"--:263   dialog = IupDialog(box);
--IupWebBrowser:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\webbrowser.exw"--:56   hDialog = IupDialog(IupVbox({hToolBar, hWebBrowser}, "MARGIN=5x5,GAP=5"))
--Split over multiple files... but should be able to do the amend_dlg...
--40 errors...
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\pGUI\\pdemo\\demo.ew"--:815      amend_dlg = IupDialog(vbox);

--OK:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\rosetta\\7guis\\Counter.exw"

--OK:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\rosetta\\7guis\\Booker.exw"
--Broken (mat_attr):
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\rosetta\\7guis\\Cells.exw"
--{"resolve_arg",0,"mat_attr","(allargsvalid:=false) [errorcount +=1, line 3547]"}
--[not]handles[3] = call_func(IupMatrix,{"invalid"})
--[not]res = call_func(IupVbox,{{-2},"MARGIN=10x10"})
--[not]handles[7] = call_func(IupDialog,{-2,"TITLE=Cells"})
--handles: {0,0,-2,0,0,0,-2,0,0}
--=>type check failure, livedisplay is -2
--I tried this, to no avail:
--  --constant mat_attr = sprintf("""
--  --NUMCOL=%d, NUMCOL_VISIBLE=%d,
--  --NUMLIN=%d, NUMLIN_VISIBLE=%d,
--  --WIDTHDEF=60, RESIZEMATRIX=YES,
--  --WIDTH0=10, HEIGHT0=10, ALIGNMENT=ALEFT""",
--  --{MAXCOL-1,min(MAXCOL-1,5),
--  -- MAXLIN-1,min(MAXLIN-1,20)})
--
--  --DEV for plade:
--  constant mat_attr = """
--  NUMCOL=26, NUMCOL_VISIBLE=5,
--  NUMLIN=100, NUMLIN_VISIBLE=20,
--  WIDTHDEF=60, RESIZEMATRIX=YES,
--  WIDTH0=10, HEIGHT0=10, ALIGNMENT=ALEFT"""

--IupGLCanvas (on one of the 2 windows)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\rosetta\\7guis\\CircleDraw.exw"
-- maybe:
-- ok: handles[8] = call_func(IupLabel,{}), but then:
--  {"resolve_arg",0,"cx","(allargsvalid:=false) [errorcount +=1, line 3547]"}
--  {"resolve_arg",0,"cy","(allargsvalid:=false) [errorcount +=1, line 3547]"}
--  [not 3835] call_proc(IupSetStrAttribute,{15153400,"TITLE","Adjust diameter of circle at (%d,%d)","invalidinvalid"})
--==>? call_proc(IupSetStrAttribute,{15153400,"TITLE","Adjust diameter of circle at (%d,%d)"})??? [DONE]
--OK:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\rosetta\\7guis\\Converter.exw"
--OK:
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\rosetta\\7guis\\CRUD.exw"
--OK (3 errors re IupTimer)
--constant src = "C:\\Program Files (x86)\\Phix\\demo\\rosetta\\7guis\\Timer.exw"

--DEV not here!!
constant srcname = get_file_name(src)

integer fn = open(src,"r")
sequence text = get_text(fn,GT_LF_STRIPPED)
close(fn)
--?text
--/*
try2:
Obviously plade should understand any output it has generated. There should be no need for
separate "project" files (or the nightmare of trying to merge them). When presented with a
layout not originally generated by itself, it should offer some explanation - for instance 
if it says "warning - mymenu not resolved" then you at least have something to search for.

Likewise plade is deliberately targetted at relatively simple static layouts - complicated
dialogs that are perhaps dynamically generated from a table or file, or rely on dynamically
visible overlapping elements, and so on, are probably forver destined to be unsupported.

An important goal, for me, is to be able to find a C code snippet, translate it to Phix, and then
be able to amend the layout, and likewise should someone send me some modified source code. 
Many similar utilities require a "project" file, and if it gets even slightly out of synch the
whole thing stops working - and that kind of nonsense is most definitely not part of my plan.
That said, plade is meant, and probably forever destined, to only support relatively simple static
layouts - as soon as elements are made dynamically visible (especially when they overlap) or are
created from tables or files, this will cease to cope. A classic example can be found in this
source - constant iupnamerids etc below implement a table-driven approach to building the gui, and
populating other tables as needed, with minimal repetition, and I would consider it a great success
if glade managed to show a single blank lable/toggle in the "Controls" groupbox, in place of the 40
or so that appear when it is actually run. For me, the real purpose of glade is to get all the
containers, fillers, padding, margins, gaps, and what have you, all right and sorted, whereas the
"checkbox", "label", etc stuff (ie visible elements) is relatively trivial in my opinion.
It would also be considered acceptable to whip up a temporary layout quickly, and apply whatever
I had just learnt to the real/dynamic code.

The following limitations are noted:
1)  Obviously standard dialogs such as IupAlarm and IupFileDlg are ignored.
2)  IupSetHandle is ignored (and never generated by plade).
        A specific case is:
            IupSetHandle("menu",menu)
            IupSetAttributes(dlg,"MENU=menu")
        whereas this is fine:
            IupSetAttributeHandle(dlg,"MENU",menu)
[DEV add warnings]

Strategy:
Write new routines, based on rein/wpaint, in such a way they can replace the ones currently in rein.
Flaws: rein works directly off filetext[currfile], tabs are treated as a single space.
       This program should baulk when it finds ifdef (and IupDialog(NULL)).
       (aside: if you want any windows of plade itself to be editable, they may have to be hived off 
        into a separate file.)

Rather than make this smarter, tweak the api (ie pGUI.e) to make things easier. For instance, instead of
get_image() as used in Edix, add IupGetImage(or whatever you want to call it) so that plade can call it
too. Likewise menu_item(), if possible. And maybe fix pdemo so all the GUI is in one file.

Whitespace:
    Treat tab characters as single spaces through this program.
    When you have decided what needs updating, calculate column by treating all multiple spaces/tabs as 1,
    and when Edix applies, it does likewise, eg
        "  constant text  = `Title`"
         12345678901234567890123456
         1 23456789012345 678901234
    might attract Replace columns 19..23 (was "Title") with "Whatever", rather than columns 21..25.
    Obviously all updates are applied last to first, right to left.
    The following seem to work (not that we really need colend):

function replace_at(string s, integer col, integer colend, string oldtext, string newtext)
integer start = 0, ch
    if colend-col+1!=length(was) then ?9/0 end if
    for i=1 to col do
        start += 1
        ch = s[start]
        if ch=' ' or ch='\t' then
            for j=start+1 to length(s) do
                ch = s[j]
                if ch!=' ' and ch!='\t' then exit end if
                start = j
            end for
        end if
    end for
    ?{s[start..start+length(oldtext)-1],oldtext}
    s[start..start+length(oldtext)-1] = newtext
    return s
end function
?replace_at("  constant text  = `Title`",19,23,"Title","Whatever")

function colidx(string s, integer col)
integer res = col, ch, last='x'
    for i=1 to col do
        ch = s[i]
        if ch=' ' or ch='\t' then
            res -= (last=' ')
            ch = ' '
        end if
        last = ch
    end for
    return res
end function
?colidx("  constant text  = `Title`",21)

    

Shared memory:
Edix creates a block of shared memory, named "Edix", and sets the state to 0 (waiting), possibly along with some file that
can be used for locking (eg C:\Program Files (x86)\Phix\demo\edix\help\Phix.txt).
Other apps can write to the shared memory, setting the state to 2 (in progress) then 1 (ready), along with a specific key
(similar to eg CD_ISENS) to identify the precise contents. One message may of course be the unique name of another block
of shared memory, should Edix want/need to write back. Edix will poll for 1 and read/reset things, likewise other apps
should, especially if sending multiple messages, poll for 0 and lock and clobber.
There should be a fixed size limit that everyone has to adhere to.

enum ATTRIBUTE, CONTAINER, ELEMENT

(not entirely dissimilar to simple_paint.exw, which of course has the pixel-level handling we need)
plade: 
Menu: File (Open/Save/Test/Cancel/Exit), Edit (Undo/Redo/Properties), Tools (?), Options (?), Help (Manual, About)..
[Parse] [Designer]
Hierarchy       dialog      Containers
<------------- Elements ------------->

The Parse tab is more like filedump, showing source fragments, sortable by column, and possibly with
a drop-down list of important multi-key orderings. For use during development of plade itself.
--> Make it a pop-up window (Tools (or File or Options) menu)
There may want to be a Current tab, or maybe Replace/Insert/Delete entries on Parse will suffice.

It may be better to have Containers and Elements on the Menu (checkbox) <== Yep, do that. Or dropdown <== better.
Likewise the dialog can be standalone <== Yep, do that.

The Hierarcy is an IupTree, with full drag and drop support. Individual items can be right clicked 
on and an IupElementPropertiesDialog for them opened. Some elements (eg IupCbox) in the dialog may
also support drag and drop, some will probably not. The dialog will be a real IupDialog, constructed
dynamically. As the cursor moves around the dialog, set the focus in the IupTree, and if possible 
update the IupElementPropertiesDialog (or close and reopen in the same place).

Containers and Elements will be IupList?

SUG:
WARNING: Leaving controls with generic names (such as button1) will made code difficult to understand.
Click resume to return to the IDE and enter something more meaningful (offending control names are shown
in red), unless this is a one-off quick and dirty which will never need any maintainance (clicking ignore 
exits and saves your work, with the unhelpful generic names). [Resume] [Ignore]
-- and/or --
have/use a function that does "Load" -> "btn_load", with a clever way (isense-based?) to ensure that
btn_load does not already exist.

The aim of this program is to knock up a simple layout and get things going. It has no further ambitions 
beyond being a very simple utility of limited use at the start of a project, and will cease being useful
once you have configurable layouts, common routines to create elements, more than one variable scope, or 
code spread out over more than one source file. Most effort, and thinking, should be done elsewhere.

pGUI-IDE is usually run from Edix. You can run it standalone, but you get a warning at startup that Edix 
is not running, and errors when you exit, unless you cancel, if Edix is still not running. It is Edix 
which actually performs the save, so that you can try something and then undo it, plus Edix has run(F5) 
logic, which pGUI-IDE does not, but instead passes an F5 to Edix. Also note that pGUI-IDE does not have 
any undo logic, other than a simple "cancel all", and within Edix changes are applied, and hence undone, 
from the last line to the first, rather than chronologically or in any form of logical order.

DEV/DOC: (decision time...)
Note that opening plade from Edix causes save to transmit updates back to Edix, which can then undo/redo 
them one at a time. Conversely, opening a file from within plade causes save to directly overwrite the
file...

Once a dialog exceeds a certain complexity, or starts using clever tricks, it is likely to have outgrown 
plade and require any further modifications to be performed by hand. The real target is getting from a 
blank screen to something resembling what you want, rather than forever mollycoddling the programmer and
that way slowly turning this into a huge lumbering creaking beast. Besides, every new release of IUP is
likely to have new elements and attributes that this has no knowledge of, and you do not want to sit and
twiddle your thumbs while this plays catch up.

--DEV noe removed anyway...
IupSetAttributesf is not supported. (Obviously the dialog was not originally created via plade.) You can
try changing say btn=IupSetAttributesf(IupButton(title),xx) to btn=IupButton(title,xx), and
often such changes will require additional (local) vars and moving the element creation up a few lines.
With a bit of luck, paranormalised functions will allow btn=IupButton(..,xx) direct.  [BLIMEY, that's old.....]

--*/
--with trace
--
-- src/plscan.ew    -- (source code scanner part of plade)
-- =============
--
-- Ideally this program should only be run on programs that compile cleanly.
--  This is not a full-featured compiler, and hence there will always be 
--  some things that it does not cope particularly well with, eg:
--
--  * Generally speaking this program is designed to be able to reload any
--    code it originally wrote out. While it is impractical to attempt to
--    support any possibly pre-existing code, some limited attempts are
--    made to offer suggestions of things that would need to change.
--    (As a quick example, this might support {btnOK,btnCancel} but just
--     simply not recognise btnOK&btnCancel as being equivalent.)
--
--  * If it is not immediately obvious what some error is, try running the
--      compiler proper (possibly with -norun) against the source.
--
--  * Externally defined types. This program does not scan included files, or
--     for that matter the file(s) that include it. Hence it must sometimes
--     assume an external type and display a warning. You can specify eg:
--          --#withtype boolean
--     (strictly for the benefit of this & rein) to eliminate the warning.
--
--  * Overloaded types. While "integer integer integer = 1" is technically
--     legal, don't expect this to cope. Likewise procedure p(flag boolean)
--     where boolean is also a type, is quite likely to trip this up. (The
--     latter, being quite legal according to RDS Eu/Phix language rules, 
--     declares a /variable/ named boolean of type flag, and is nothing 
--     whatsoever to do with some previously declared boolean type.)
--
--  * This program does not recognise ifdef (which the Phix compiler only 
--      supports in a bare minimum compability fashion anyway).
--
--  * code such as
--          Ihandle frm_3 = IupFrame(..)
--          frm_3 = IupExpander(frm_3)
--      will confuse plade, which obviously cannot treat frm_3 as both an
--      IupFrame and an IupExpander. Use more (local) variables, or nest.

--
-- There are three main parts to this program:
--
-- Part 1. Tokeniser and error routines.
-- Part 2. The (highly simplified) parser.
-- Part 3. The main control routine.
--

--DEV/SUG:
--include pGPARSE.e

--
-- Part 1. Tokeniser and error routines
--

integer textlen
integer CurrLine, col, tokline, tokstart, tokend, toktype
string token
atom tokint
atom tokatm

integer returnexpr          --   1 for function/type "return <expr>",
        returnexpr = -1     --   0 for procedure "return",
                            --  -1 for toplevel statements (return is illegal)

sequence vartypes

-- (There is no particular need for these to be kept in step with ptok.e,
--  on which this was based, except that doing so may ease porting of new
--  features.)
constant SYMBOL  = 1,
         DQUOTE  = 2,
         BKTICK  = 3,   -- Back tick (string with no escape characters)
         SQUOTE  = 4,
         ELLIPSE = 5,
         HEXDEC  = 6,
         DIGIT   = 7,
         FLOAT   = 8,
         USCORE  = 9,
         LETTER  = 10,
--       SLICE   = 11,
--       SUBSCR  = 12,
         ILLEGAL = 99

--eg: {20, "IupCanvas", 159, 14,22, {{-1, "NULL", 159,24,27}}, {-1, "canvas", 159,5,10}},
--     type,name,      line,bgn,end,args,                      tgt
--     1    2          3    4   5   6                          7
--
--#without reformat
constant FUNC = 20, --DEV
             TYPE = 1,
             NAME = 2,
             IDX = 3,
             LINE = 4,
--           BEGIN = 5,
--           END = 6,
--DEV ARGS should probably be like SEQ, with all the (,,) included.
             ARGS = 7,
             TARGET = 8,
         PROC = 21,
         SEQ = -5,
--       IDENT = -1         -- or use LETTER?
         IDENT = 10 --LETTER    -- or use LETTER?
--SUG:   IDECL = 19         -- identifier declaration (if not aod?)
--#with reformat

--
-- The parse_data is a list of possibly relevant procedure and function calls, eg
--   IupSetAttribute() -> {PROC,"IupSetAttribute",idx,line,begin,end,args}, and
--   button = IupButton() -> {FUNC,"IupButton",idx,line,begin,end,args,target}, 
--                            where target is {IDENT,"button",0,line,begin,end}.
-- Each element of parse_data should correspond to a single statement in the source.
-- Some elements are nested, typically args is a mix of IDENT and FUNC, maybe in a SEQ.
-- The main (visual) complication is the {idx,line,begin,end} scattered throughout, which
--  will obviously be required (much later) for any subsequent update/replacement.
-- Naturally this can get quite big and ugly, and trimming down the source "source code"
--  as much as possible would be a very sensible step, should you need to debug this.
--
global sequence parse_data
                parse_data = {}

--DEV not sure we really need this...
--/*
sequence insertion_points = {}

sequence insertion_point,
         next_insertion_point
         next_insertion_point = {1,1}
--*/

function setCharClass()
sequence charClass = repeat(ILLEGAL,255)
    charClass['!'] = SYMBOL
    charClass['\"'] = DQUOTE
    charClass['#'] = HEXDEC
    charClass['&'] = SYMBOL
    charClass['\''] = SQUOTE
    charClass['('..'/'] = SYMBOL    -- ()*+,-./
    charClass['.'] = ELLIPSE
    charClass['0'..'9'] = DIGIT
    charClass[':'..'?'] = SYMBOL    -- :;<=>?
--  charClass['@'] = SYMBOL
    charClass['A'..'Z'] = LETTER
    charClass['['] = SYMBOL
    charClass[']'] = SYMBOL
    charClass['_'] = USCORE
    charClass['`'] = BKTICK
    charClass['a'..'z'] = LETTER
    charClass['{'] = SYMBOL
    charClass['}'] = SYMBOL
    return charClass
end function
sequence charClass = setCharClass()

integer Ch

--DEV tokline??
procedure Abort(string msg)
    if tokline>=1 and tokline<=textlen then
        printf(1,"Error in line %d\n%s\n%s^ %s.\n",
               {tokline,
                substitute(text[tokline],"\t"," "),
                repeat(' ',tokstart-1),msg})
    else
        printf(1,"%s.\n",{msg})
        ?9/0
    end if
?9/0
    {} = wait_key()
    abort(0)
end procedure

procedure SkipBlockComment()
-- Skip nested /!* block comments *!/
-- Note that "*!/" inside a string is interpreted as end of comment, 
--  (since it is technically text not code, and for example we must
--   treat '/!* if x="*!/" then' as '" then'), though a "/!*" and "*!/" 
--   pair (of strings/within a string) behave as expected.
-- The opening /!* has already been processed; if we cannot find a 
-- matching *!/ before EOF then display an error.
integer oline, ocol
--trace(1)
    ocol = col
    oline = CurrLine
-- if line!=0 then ?9/0 end if  -- we must maintain this!
    while CurrLine<=textlen do
        if col>=length(text[CurrLine]) then
            CurrLine += 1
            col = 1
        else
            Ch = text[CurrLine][col]
            if Ch='*' then
                if text[CurrLine][col+1]='/' then
                    col += 2
                    if col>length(text[CurrLine]) then
                        CurrLine += 1
                        col = 1
                    else
                        Ch = text[CurrLine][col]
                    end if
                    return
                end if
            elsif Ch='/' then
                if text[CurrLine][col+1]='*' then
                    col += 2
                    SkipBlockComment()
                    col -= 1
                end if
            end if
            col += 1
        end if
    end while
    tokline = oline
    tokstart = ocol
    Abort("missing closing block comment")
end procedure

procedure SkipSpacesAndComments()
-- Note: To skip "include", we just increment CurrLine and set col to 1.
--       We also set col to 1:
--          * if we fall off the end of a line (see nextCh()), and 
--          * at the very start.
--       Thus if col=1 we *must* set Ch.
sequence oneline, wtoken
integer onelen, k, l
--  insertion_point = next_insertion_point
--  next_insertion_point = {CurrLine,col}
    while 1 do -- until eof or non-blank/comment char found
        while 1 do -- until eof or non-blank line (with Ch set)
            if CurrLine>textlen then
                Ch = -1
                return
            end if
--          if next_insertion_point[2]>1 then
--              next_insertion_point = {CurrLine,1}
--          end if
            oneline = text[CurrLine]
            onelen = length(oneline)

            if col!=1 then exit end if

            if onelen>=1 then -- (equivalent to col<=onelen)
                Ch = oneline[1] -- (equivalent to Ch=oneline[col])
                exit
            end if
            CurrLine += 1
            col = 1
        end while
        if Ch=' ' or Ch='\t' then
            k = col
            while 1 do -- until Ch!=' '|'\t'
                col += 1
                if col>onelen then
                    CurrLine += 1
                    col = 1
                    exit
                end if
                Ch = oneline[col]
                if Ch!=' ' and Ch!='\t' then
                    exit
                end if
            end while
        elsif Ch='-'
          and col<onelen
          and oneline[col+1]='-' then
            -- This line is a comment (-- just found), check for
            -- --/!* (block comment) and --# directives
            if col+2<onelen
            and oneline[col+2]='/'
            and oneline[col+3]='*' then
                col += 4
                SkipBlockComment()
            else
                if col+6<=onelen
                and equal(oneline[col+2..col+6],"#with") then
                    oneline = oneline[col..length(oneline)]
                    if match("--#without reformat",oneline)=1 then
--                          reformat = 0
                    elsif match("--#with reformat",oneline)=1 then
--                          reformat = 1
                    else
                        if match("--#withdef",oneline)=1 then
                            k = 11
                        elsif match("--#withtype",oneline)=1 then
                            k = 12
                        else
                            k = 0
                        end if
                        wtoken = ""
                        if k and find(oneline[k]," \t") then
                            while k<length(oneline) do
                                k += 1
                                if not find(oneline[k]," \t") then
                                    l = k+1
                                    while l<=length(oneline) do
                                        if find(oneline[l]," \t") then exit end if
                                        l += 1
                                    end while
                                    wtoken = oneline[k..l-1]
                                    exit
                                end if
                            end while
                        end if
                        if length(wtoken) then
                            if oneline[8]='d' then -- withdef
--                              if not find(wtoken,withdefs) then
--                                  withdefs = append(withdefs,wtoken)
--                              end if
                            elsif oneline[8]='t' then -- withtype
                                if not find(wtoken,vartypes) then
                                    vartypes = append(vartypes,wtoken)
                                end if
                            else
                                ?9/0
                            end if
                        elsif k then
                            Abort("a name is expected here")
                        else
                            Abort("unrecognised --#with directive")
                        end if
                    end if
                end if
                CurrLine += 1
                col = 1
            end if
        elsif Ch='/' then
            if col<onelen
            and oneline[col+1]='*' then
                col += 2
                SkipBlockComment()
            else -- (we just found a divide symbol then)
                exit
            end if
        else
            exit
        end if
    end while
end procedure

procedure nextCh()
    tokend = col-1
    if col<=length(text[CurrLine]) then
        Ch = text[CurrLine][col]
    else
        CurrLine += 1
        col = 1
    end if
    SkipSpacesAndComments()
end procedure

procedure getFloat()
-- finish off a float. The first few DIGITS (if any) have been processed;
-- continue from '.' or 'eE'
integer lenTC, exponent, esign
atom dec, fraction
sequence oneline
    oneline = text[CurrLine]
    lenTC = length(oneline)
    tokatm = tokint
    if Ch='.' then
        -- make sure it is not an ellipse
        if col<lenTC
        and text[CurrLine][col+1]='.' then
--          col -= 1
        else
            toktype = FLOAT
            dec = 1
            fraction = 0
            while 1 do
                col += 1
                if col>lenTC then exit end if
                Ch = oneline[col]
                if charClass[Ch]!=DIGIT then
                    if Ch!='_' then exit end if
                else
                    fraction = fraction*10+(Ch-'0')
                    dec *= 10
                end if
            end while
            tokatm += fraction/dec
        end if
    end if
    if find(Ch,"eE")
    and col<lenTC then
        toktype = FLOAT
        Ch = oneline[col+1]
        esign = iff(Ch='-'?-1:+1)
        if Ch='-' or Ch='+' then
            col += 1
            Ch = oneline[col+1]
        end if
        exponent = 0
        while 1 do
            col += 1
            if col>lenTC then exit end if
            Ch = oneline[col]
            if charClass[Ch]!=DIGIT then
                if Ch!='_' then exit end if
            else
                exponent = exponent*10+Ch-'0'
            end if
        end while
        tokatm = tokatm*power(10,exponent*esign)
    end if
--  token = text[CurrLine][tokstart..col-1]
    nextCh()
end procedure

constant bases = {8,16,2,10}    -- NB: oxbd order
integer base
        base = -1

procedure loadBase()
integer lenTC
sequence oneline
    oneline = text[CurrLine]
    lenTC = length(oneline)
    if base=5 then      -- 0(nn) case
        base = 0
        while 1 do
            col += 1
            if col>lenTC then exit end if
            Ch = oneline[col]
            if Ch<'0' or Ch>'9' then exit end if
            base = (base*10)+(Ch-'0')
        end while
        if base<2 or base>36 then
            Abort("unsupported number base")
        end if
        if Ch!=')' then
            Abort("')' expected")
        end if
    else
        base = bases[base]
    end if
    col += 1
    if col>lenTC then Abort("number expected") end if
    Ch = oneline[col]
    if base=8 and Ch='b' then
        col += 1
        if col>lenTC then Abort("number expected") end if
        Ch = oneline[col]
    end if
    while 1 do
        if Ch!='_' then
            if Ch>='0' and Ch<='9' and Ch<='0'+base-1 then
                Ch -= '0'
            elsif Ch>='A' and Ch<='Z' and Ch<='A'+base-11 then
                Ch -= 'A'+10
            elsif Ch>='a' and Ch<='z' and Ch<='a'+base-11 then
                Ch -= 'a'+10
            else
                exit
            end if
            tokint = tokint*base+Ch
        end if
        col += 1
        if col>lenTC then exit end if
        Ch = oneline[col]
    end while
    nextCh()
end procedure

integer mapEndToMinusOne
        mapEndToMinusOne = 0

--constant Operators={"<","<=",">",">=","=","!=",
--                  "+","+=","-","-=","*","*=",
--                  "/","/=","..","&","&="}
--DEV rename as TwoCharOps?
constant Operators = {"==",":=","<=",">=","!=","+=","-=","*=","/=","&=","@="}

function escMap(integer escChar)
    if escChar='t' then return '\t' end if
    if escChar='r' then return '\r' end if
    if escChar='n' then return '\n' end if
    if escChar='0' then return '\0' end if
    if escChar='\"' then return '\"' end if
    if escChar='\'' then return '\'' end if
    if escChar='\\' then return '\\' end if
    -- oops!
    Abort("invalid escape character")
end function

procedure getToken()
integer nxtCh, lenTC
string oneline
    if Ch=-1 then return end if
    oneline = text[CurrLine]
    tokline = CurrLine
    tokstart = col
    token = ""
    toktype = charClass[Ch]
    lenTC = length(oneline)
    if col<lenTC then
        nxtCh = oneline[col+1]
    else
        nxtCh = -1
    end if
    if toktype=LETTER then
        while 1 do
            col += 1
            if col>lenTC then exit end if
            nxtCh = charClass[oneline[col]]
            if nxtCh<DIGIT then exit end if
            if nxtCh>LETTER then exit end if
        end while
        tokend = col-1
        token = oneline[tokstart..tokend]
        if mapEndToMinusOne and equal(token,"end") then
--??    if mapEndToMinusOne=1 and equal(token,"end") then
            token = "-1"
            toktype = DIGIT
        elsif token="ifdef" then
            Abort("not supported")
        end if
        nextCh()
    elsif toktype=SYMBOL then
        if find({Ch,nxtCh},Operators) then
            col += 1
        elsif Ch='?' then
            toktype = LETTER
        end if
        col += 1
        token = text[CurrLine][tokstart..col-1]
        nextCh()
    elsif toktype=DQUOTE then
        if col+2<=lenTC
        and oneline[col+1]='\"'
        and oneline[col+2]='\"' then
--DEV should be a TQUOTE? (no line/col info)
            -- multiline (""") string. (no point doing trim handling) [??]
            token = ""
            col += 3
            while 1 do -- until closing """ found
                while col>lenTC do
                    CurrLine += 1
--                  if CurrLine>length(text) then
                    if CurrLine>textlen then
                        Abort("missing \"\"\"")
                        exit
                    end if
                    token &= '\n'
                    oneline = text[CurrLine]
                    lenTC = length(oneline)
                    col = 1
                end while
                token &= nxtCh
                nxtCh = oneline[col]
                if nxtCh='\"'
                and col+2<=lenTC
                and oneline[col+1]='\"'
                and oneline[col+2]='\"' then
                    col += 3
                    exit    -- (closing """ found)
                end if
                col += 1
            end while
        else
            -- normal/traditional DQUOTE
            while 1 do
                col += 1
                if col>lenTC then
                    Abort("missing \"")
                    exit
                end if
                nxtCh = oneline[col]
                if nxtCh='\\' then
                    col += 1
                elsif nxtCh='\"' then
                    col += 1
                    exit
                end if
            end while
            token = oneline[tokstart..col-1]
        end if
        nextCh()
    elsif toktype=BKTICK then
--DEV ditto, not DQUOTE but BKTICK/TQUOTE, no line/col info...
        token = ""
        while 1 do
            col += 1
            while col>lenTC do  -- convert any blank lines to \n
                CurrLine += 1
--              if CurrLine>length(text) then
                if CurrLine>textlen then
                    Abort("missing `")
                    exit
                end if
                token &= '\n'
                oneline = text[CurrLine]
                lenTC = length(oneline)
                col = 1
            end while
            -- otherwise add chars unaltered, to closing tick
            nxtCh = oneline[col]
            if nxtCh='`' then
                col += 1
                exit        -- (closing ` found)
            end if
            token &= nxtCh
        end while
        toktype = DQUOTE
        nextCh()
    elsif toktype=SQUOTE then
        if nxtCh='\\' then
            tokint = escMap(text[CurrLine][col+2])
            col += 4
        else
            tokint = text[CurrLine][col+1]
            col += 3
        end if
        nextCh()
    elsif toktype=HEXDEC then
--DEV #456ilasm?
--/* (see below)
        if col<lenTC and nxtCh='i' then
            col += 1
            nextCh()
            -- #ilasm{inline assembly},
            -- #istype{var_id,var_type}, or
            -- #isinit{var_id,0/1}.
--          toktype = ILASM
            toktype = LETTER
--DEV: (be gone ??)
            token = "#i"
            return
        end if
--*/
        tokatm = 0
        while 1 do
            col += 1
            if col>lenTC then exit end if
            nxtCh = oneline[col]
            if nxtCh!='_' then
                if nxtCh<'0' then exit end if
                if nxtCh>'9' then
                    if nxtCh<'A' then exit end if
                    if nxtCh>'F' then
                        if nxtCh<'a' then exit end if
                        if nxtCh>'f' then exit end if
                        tokatm = tokatm*16+nxtCh-'W'
                    else
                        tokatm = tokatm*16+nxtCh-'7'
                    end if
                else
                    tokatm = tokatm*16+nxtCh-'0'
                end if
            end if
        end while
-- 19/03/10 (gave up)
-- 18/07/13 (made it happen)
        if nxtCh='i' and tokstart=col-1 then
--          Abort("Sorry, #ilasm etc should be hidden from eawpaint with --/**/")
            nextCh()
            getToken()
            if toktype!=LETTER
            or not find(token,{"ilasm","ilASM"}) then
                Abort("ilASM expected")
            end if
            getToken()
            if toktype!=SYMBOL
            or not equal(token,"{") then
                Abort("{ expected")
            end if
            while 1 do
                getToken()
                if toktype=SYMBOL then
                    if equal(token,"}") then exit end if
                end if
                while find(Ch,"%@") do
                    col += 1
                    nextCh()
                end while
            end while
            getToken()
        else
            nextCh()
        end if
--      token = text[CurrLine][tokstart..col-1]
--      nextCh()
    elsif toktype=ELLIPSE then
        if nxtCh='.' then
            col += 2
--          token = text[CurrLine][tokstart..col-1]
            nextCh()
        else
            tokint = 0
            getFloat()
        end if
    elsif toktype=DIGIT then
        tokint = Ch-'0'
        if Ch='0' then  -- check for 0x/o/b/d formats
            if col<lenTC then
                Ch = oneline[col+1]
                base = find(Ch,"toxbd(")
                if base then
                    if base>1 then base -= 1 end if
                    col += 1
                    loadBase()
                    return
                end if
            end if
        end if
        while 1 do
            col += 1
            if col>lenTC then exit end if
            Ch = oneline[col]
            if charClass[Ch]!=DIGIT then
                if Ch!='_' then exit end if
            else
                tokint = tokint*10+Ch-'0'
            end if
        end while
        if find(Ch,".eE") then
            getFloat() -- (checks for ellipse)
        else
            nextCh()
        end if
    elsif toktype=ILLEGAL
      and mapEndToMinusOne
      and Ch='$' then
        mapEndToMinusOne = '$'
        token = "-1"
        toktype = DIGIT
        col += 1
        nextCh()
    else
        Abort("unrecognised")
    end if
--pp(token)
end procedure

procedure Match(sequence text)
    if not equal(token,text) then
        Abort(text&" expected")
    end if
    getToken()
end procedure

--
-- Part 2. The (highly simplified) parser.
--
forward function Expression()
forward procedure Block()

function DoSequence(integer vch)
-- Process a sequence
-- vch is from DoMultipleAssignment, ie/eg {a,?,b} [@]= <expr>.
--      (if non-0, both the ? and @ are allowed)
-- token=="{" on entry
integer wasMapEndToMinusOne -- allow {1,2,3,$} [==={1,2,3}]
sequence res = {}
    wasMapEndToMinusOne = mapEndToMinusOne
    mapEndToMinusOne = 1
    Match("{")
    res = {}
    while not equal(token,"}") do
        if mapEndToMinusOne='$' then
            getToken()
            exit
        end if
        mapEndToMinusOne = 0
        if vch!=0 then
            if token="?" then
                getToken()
            else
                {} = Expression()
            end if
        else
            res = append(res,Expression())
            -- Aside: this can leave us with a trailing "," instead of "}".
            res = append(res,{SYMBOL,token,0,tokline,tokstart,tokend})
            --               {TYPE,   NAME,IDX, LINE,   BEGIN,   END}
--DEV/SUG:
--          res = append(res,{SYMBOL,token,tokline,tokstart,tokend,Expression()})
        end if
        if not equal(token,",") then exit end if
        if Ch='$' then
            mapEndToMinusOne = 1
            Match(",")
            getToken()
            exit
        end if
        mapEndToMinusOne = 1
        Match(",")
    end while
    if vch!=0 then
        charClass['@'] = SYMBOL
    end if
    mapEndToMinusOne = wasMapEndToMinusOne
    Match("}")
    if token=";" then
        getToken()
    end if
    return res
end function

function Params(integer asiff)
string routinename
integer namedparams = 0
sequence res = {}
    routinename = token
--  if find(routinename,{"IupSetAttributesf","IupWebBrowser"})
    if find(routinename,{"IupWebBrowser"})
--  or match("IupGL",procname)=1 then
    or 0 then
        Abort("not supported")
--  elsif match("IupGL",procname)=1 then
--      printf(1,"Warning - "&procname&" not supported\n")
    end if
    getToken()
    Match("(")
    if not equal(token,")") then
        while Ch!=-1 do
            res = append(res,Expression())
            if asiff then
                if not find(token,{",","?",":"}) then exit end if
            else
--<25/1/17> (named and defaulted parameters)
                if find(token,{":=","="}) then
                    getToken()
                    {} = Expression()
                    namedparams = 1
                elsif namedparams then
                    Match("=")  -- trigger error
                end if
--</25/1/17>
                if not equal(token,",") then exit end if
            end if
            getToken()
        end while
    end if
    if find(routinename,IupProcs) then
        res = {PROC,routinename,0,tokline,tokstart,tokend,res}
        --    {TYPE,     NAME,IDX,   LINE,   BEGIN,  END,ARGS}
        parse_data = append(parse_data,res)
--?res
--      insert_point = 1    -- mark as valid insertion point
--/*
        if Ch=-1 then
            insertion_point = next_insertion_point
        end if
        insertion_points = append(insertion_points,insertion_point)
--*/
    elsif match("IupGL",routinename)=1 
      and not find(routinename,IupFuncs) then
        printf(1,"Warning - "&routinename&" not supported\n")
    end if
    Match(")")
    return res
end function

function DoSubScripts(object res)
integer wasMapEndToMinusOne
object subscr1, subscr2
    wasMapEndToMinusOne = mapEndToMinusOne
    mapEndToMinusOne = 1
    while 1 do
        Match("[")
        subscr1 = Expression()
        if toktype=ELLIPSE then
            getToken()
            subscr2 = Expression()
--          res = {SLICE,subscr1,subscr2,res}
            res = {}
            exit
        end if
--      res = {SUBSCR,subscr1,res}
        res = {}
        if Ch!='[' then exit end if
        Match("]")
    end while
    mapEndToMinusOne = wasMapEndToMinusOne
    Match("]")
    return res
end function

procedure skip_namespace()
    if CurrLine>textlen
    or col>=length(text[CurrLine])
    or text[CurrLine][col+1]!='=' then
        getToken()
        Match(":")
    end if
end procedure

sequence tgtname = ""   -- set by Assignment
--SUG?? (for consistency would need many more {})
--       tgtpos         -- {line,begin,end}
integer tgtline = 0,
        tgtbgn = 0,
        tgtend = 0

integer treatColonAsThen = 0

function Factor()
object res
integer k
    if toktype=LETTER then
        if not treatColonAsThen then
            if Ch=':' then skip_namespace() end if
        end if
        if Ch='(' then  -- a function, we presume
            res = {FUNC,token,0,tokline,tokstart,tokend,0,0}
            --    {TYPE,NAME,IDX,LINE,BEGIN,END,ARGS,TARGET}
            if length(tgtname) then
                res[TARGET] = {IDENT,tgtname,0,tgtline,tgtbgn,tgtend}
                --            {TYPE,  NAME,IDX,   LINE, BEGIN,   END}
                tgtname = ""
--          else
--              res = res[1..ARGS]
            end if
            k = find(token,IupFuncs)
--/*
            if k!=0 then
--              insert_point = 1    -- mark as valid insertion point
                if Ch=-1 then
                    insertion_point = next_insertion_point
                end if
                insertion_points = append(insertion_points,insertion_point)
            end if
--*/
            res[ARGS] = Params(find(token,{"iff","iif"}))
--          if find(res[2],{"IupDialog","IupVbox"}) then
--          if find(res[2],IupFuncs) then   -- name
--          if find(res[NAME],IupFuncs) then
--          if k!=0 then
            if k!=0 and res[TARGET]!=0 then
                parse_data = append(parse_data,res)
--?res
--/*
--              insert_point = 1    -- mark as valid insertion point
                if Ch=-1 then
                    insertion_point = next_insertion_point
                end if
                insertion_points = append(insertion_points,insertion_point)
--*/
            end if
        else -- a variable, we presume
            res = {IDENT,token,0,tokline,tokstart,tokend}
            --    {TYPE,NAME,IDX,   LINE,   BEGIN,   END}
            getToken()
        end if
    elsif toktype=DIGIT then
        res = {DIGIT,tokint,0,tokline,tokstart,tokend}
        --    {TYPE,value,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=FLOAT then
        res = {FLOAT,tokatm,0,tokline,tokstart,tokend}
        --    {TYPE,NAME?,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=HEXDEC then
        res = {HEXDEC,tokatm,0,tokline,tokstart,tokend}
        --    {TYPE, NAME?,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=DQUOTE then
        -- (remove quotes)
        token = token[2..length(token)-1]
        tokstart += 1
        tokend -= 1
        res = {DQUOTE,token,0,tokline,tokstart,tokend}
        --    {TYPE, NAME,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=SQUOTE then
        res = {SQUOTE,tokint,0,tokline,tokstart,tokend}
        --    {TYPE,  NAME,IDX,   LINE,   BEGIN,   END}
        getToken()
    elsif toktype=SYMBOL and equal(token,"{") then
        res = {SEQ,token,0,tokline,tokstart,tokend}
        --    {TYPE,   NAME,IDX,   LINE,   BEGIN,   END,ARGS}
        res = append(res,DoSequence(0))
    elsif toktype=SYMBOL and equal(token,"(") then
        getToken()
        res = Expression()
        Match(")")
    else
        Abort("unrecognised")
        res = -1
    end if
    if toktype=SYMBOL and equal(token,"[") then
        res = DoSubScripts(res)
    end if
    return res
end function

function Unary()
object res
    if toktype=SYMBOL and equal(token,"-") then
        Match("-")
        res = {"-",Factor(),tokline,tokstart,tokend}
    elsif toktype=SYMBOL and equal(token,"+") then -- (ignore)
        Match("+")
        res = Factor()
    elsif toktype=LETTER and equal(token,"not") then
        Match(token)
        res = {"not",Factor(),tokline,tokstart,tokend}
    else
        res = Factor()
    end if
    return res
end function

function Term()
object res
    res = Unary()
    while find(token,{"*","/"}) do
        res = {token,res}
        Match(token)
        res = append(res,Unary())
    end while
    return res
end function

function Sum()
object res
    res = Term()
    while find(token,{"+","-"}) do
        res = {token,res}
        Match(token)
        res = append(res,Term())
    end while
    return res
end function

function Concat()
object res, rhs
    res = Sum()
    while equal(token,"&") do
        Match("&")
        rhs = Sum()
        if length(res)
        and res[TYPE]=DQUOTE
        and length(rhs)
        and rhs[TYPE]=DQUOTE then
            res = {DQUOTE,res[NAME]&rhs[NAME],0}    -- (no line/col info, but IDX ok)
        else
            res = {"&",res,rhs}
        end if
    end while
    return res
end function

function Relation()
object res
    res = Concat()
    while find(token,{"<","<=","=","==","!=",">",">="}) do
        res = {token,res}
        Match(token)
        res = append(res,Concat())
    end while
    return res
end function

function Expression()
object res
    res = Relation()
    while find(token,{"and","or","xor"}) do
        res = {token,res}
        Match(token)
        res = append(res,Relation())
    end while
    return res
end function
--function Expression()
--  {} = Factor()
--  while find(token,{"<","<=","=","==","!=",">",">=","*","/","+","-","and","or","xor","&","not"}) do
--      Match(token)
--      {} = Factor()
--  end while
--  return {}
--end function

procedure DoIf()    -- Process an if construct
    Match("if")
    {} = Expression()
    Match("then")
    Block()
    while equal(token,"elsif") do
        Match("elsif")
        {} = Expression()
        Match("then")
        Block()
    end while
    if equal(token,"else") then
        Match("else")
        Block()
    end if
    Match("end")
    Match("if")
end procedure

procedure DoWhile()
    Match("while")
    {} = Expression()
    Match("do")
    Block()
    Match("end")
    Match("while")
end procedure

procedure DoSwitch()
    Match("switch")
    {} = Expression()
    if find(token,{"with","without"}) then
        while Ch!=-1 do
            getToken()
            if not find(token,{"fallthru","fallthrough","jump_table"}) then exit end if
            getToken()
            if not equal(token,",") then exit end if
        end while
    end if
    if token="do" then Match("do") end if
    while Ch!=-1 do
        if find(token,{"else","default"}) then
            getToken()
        else
            Match("case")
            if find(token,{"else","default"}) then
                getToken()
            else
                treatColonAsThen = 1
                while Ch!=-1 do
                    {} = Expression()
                    if not equal(token,",") then exit end if
                    getToken()
                end while
                treatColonAsThen = 0
            end if
        end if
        if find(token,{":","then"}) then
            getToken()
        end if
        Block()
        if find(token,{"fallthru","fallthrough","break"}) then
            getToken()
        end if
        if token=";" then
            getToken()
        end if
        if equal(token,"end") then exit end if
    end while
    Match("end")
    Match("switch")
end procedure

procedure DoFor()
    Match("for")
    getToken()
    Match("=")
    {} = Expression()
    Match("to")
    {} = Expression()
    if equal(token,"by") then
        getToken()
        {} = Expression()
    end if
    Match("do")
    Block()
    Match("end")
    Match("for")
end procedure

procedure DoReturn()
    if returnexpr=-1 then Abort("return must be inside a procedure or function") end if
    Match("return")
    if returnexpr then
        {} = Expression()
    end if
end procedure

procedure DoQu()
    getToken()
    {} = Expression()
end procedure

--Now skipped in getToken()[??]
--procedure DoIlasmEtc()
--  getToken()
--  if not find(token,{"ilasm","ilASM","istype","isinit","isginfo"}) then
--      Abort("ilasm, istype, isinit, or isginfo expected")
--      return
--  end if
--  getToken()
--  Match("{")
--  while Ch!=-1 do
--      while find(Ch,":%@") do
--          col += 1
--          nextCh()
--      end while
--      getToken()
--      if equal(token,"}") then
--          getToken()
--          exit
--      end if
--  end while
--end procedure

procedure Assignment(bool allowsubscripts)
    tgtname = token
    tgtline = tokline
    tgtbgn = tokstart
    tgtend = tokend
    getToken()
    if toktype=SYMBOL and equal(token,"[") then
        if not allowsubscripts then Abort("invalid") end if
--      tgtname &= "[?]"
        tgtname = ""
        {} = DoSubScripts(0)
    end if
    if not find(token,{"=",":="}) then
        if not allowsubscripts
        or not find(token,{"+=","-=","*=","/=","&="}) then
            Abort("assignment operator expected")
        end if
        tgtname = ""
    end if
    getToken()
    {} = Expression()
end procedure

procedure DoMultipleAssignment()
--  charClass['@'] = SYMBOL
    -- [non-0 param to DoSequence() makes it allow ?,
    --  and set '@' as valid on the final Match("}")]
    {} = DoSequence('@')
    charClass['@'] = ILLEGAL
    if not find(token,{"=",":=","@="}) then
        Abort("assignment operator expected")
        return
    end if
    getToken()
    {} = Expression()
    if token=";" then
        getToken()
    end if
end procedure

procedure WarnType()
    printf(1,"Warning: %s assumed to be external type",{token})
end procedure

--constant ifforwhileetc = {"if","for","while","continue","exit","break","switch","return","end","?","#i"}
constant ifforwhileetc = {"if","for","while","continue","exit","break","switch","return","end","?","ifdef"}
constant elseetc = {"elsif","else","end","case","default","fallthru","fallthrough"}

procedure Locals()
    while toktype=LETTER do
        if not find(token,vartypes) then    -- see Note1
            if find(token,ifforwhileetc) then exit end if
            --
            if charClass[Ch]!=LETTER then exit end if
            -- ^explanation^: word word (not word =, or word[... etc) must be
            --                a variable definition (eg boolean t), not code.
            --
            WarnType()
            vartypes = append(vartypes,token)
        end if
        while 1 do
            getToken()
            if toktype=SYMBOL and equal(token,"{") then
                DoMultipleAssignment()
                if Ch!=',' then exit end if
            end if
--SUG
--          vardecs = append(vardecs,{IDECL,token,0,tokline,tokstart,tokend,Ch='='})
--          --                       {TYPE,NAME,IDX,   LINE,   BEGIN,   END,   AOD}
            if Ch='=' then
                Assignment(False)
                if toktype!=SYMBOL or token!="," then exit end if
            else
                if Ch!=',' then getToken() exit end if
                getToken()
            end if
        end while
        if token=";" then
            getToken()
        end if
    end while
end procedure

procedure DoRoutineDef(integer rType, integer fwd)
sequence sType, tType, res

    sType = token   -- procedure/function/type
    getToken()
--?token
--if token="action_cb" then trace(1) end if

--?{"DoRoutineDef",token}
    if sType="procedure" then
        if find(token,IupProcs) then
            Abort("invalid (clash with pGUI.e)")
        end if
    elsif sType="function" then
        if find(token,IupFuncs) then
            Abort("invalid (clash with PGUI.e)")
        end if
    end if
    res = {token,tokline,0}
    tType = token   -- type name
    getToken()
    Match("(")
    if not equal(token,")") then
        while Ch!=-1 do
            if Ch=':' then skip_namespace() end if
-- 22/07/2013
--          if not find(Ch,"=,") then
            if not find(Ch,"=,)") then
                if not find(token,vartypes) then
                    if charClass[Ch]!=LETTER then
                        Abort("a type is expected here")
--                      exit
                    end if
                    WarnType()
                    vartypes = append(vartypes,token)
                end if
                getToken()
            end if
--15/2/16: (unnamed params)
            if equal(token,",") then
                while 1 do
                    getToken()
                    if toktype!=SYMBOL or not equal(token,",") then exit end if
                end while
                if equal(token,")") then exit end if
            elsif equal(token,")") then
                exit
            else
                getToken()
                if find(token,{"=",":="}) then
                    getToken()
                    {} = Expression()
                end if
                if not equal(token,",") then exit end if
                getToken()
--20/11/17:
                if equal(token,")") then exit end if
            end if
--DEV positive types..
--          while Ch=',' do
--              getToken()
--              getToken()
--          end while
        end while
    end if
    Match(")")
    if fwd then return end if
    Locals()
    returnexpr = (rType>1)
    Block()
    returnexpr = -1
    Match("end")
    Match(sType)
    if rType=3 then
        vartypes = append(vartypes,tType)
    end if
end procedure

procedure Statement()
    if toktype=LETTER then
        if find(token,vartypes) then Locals()
        elsif token="if"        then DoIf()
        elsif token="for"       then DoFor()
        elsif token="while"     then DoWhile()
        elsif token="continue"  then Match("continue")
        elsif token="exit"      then Match("exit")
        elsif token="break"     then Match("break")
        elsif token="switch"    then DoSwitch()
        elsif token="return"    then DoReturn()
        elsif token="end"       then Abort("unexpected")
        elsif token="?"         then DoQu()
--      elsif token="#i"        then DoIlasmEtc()
        elsif token="ifdef"     then Abort("invalid")
        else
            if Ch=':' then skip_namespace() end if
            if Ch='(' then
                {} = Params(0)
            else
                Assignment(True)
            end if
        end if
        if equal(token,";") then
            getToken()
        end if
    elsif toktype=SYMBOL and equal(token,"{") then
        DoMultipleAssignment()
    else
        Abort("unrecognised")
    end if
end procedure

procedure Block()
    while 1 do
        if toktype=LETTER then
            if find(token,elseetc) then exit end if
-- 13/2/14 ("declare anywhere")
            while toktype=LETTER do
                if not find(token,vartypes) then    -- see Note1
                    if find(token,ifforwhileetc) then exit end if
                    --
                    if charClass[Ch]!=LETTER then exit end if
                    -- ^explanation^: word word (not word =, or word[... etc) must be
                    --                a variable definition (eg boolean t), not code.
                    --
                    WarnType()
                    vartypes = append(vartypes,token)
                end if
                while 1 do
                    getToken()
-- 18/6/16:
                    if toktype=SYMBOL and equal(token,"{") then
                        DoMultipleAssignment()
                        if Ch!=',' then exit end if
                    end if
                    if Ch='=' or Ch=':' then
                        Assignment(False)
                        if token!="," then exit end if
                    else
                        if Ch!=',' then getToken() exit end if
                        getToken()
                    end if
                end while
                if token=";" then
                    getToken()
                end if
            end while
            if find(token,elseetc) then exit end if
            Statement()
        elsif toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
        else
            exit
        end if
    end while
end procedure

procedure TopDecls()
integer wasMapEndToMinusOne
    while Ch!=-1 do
        getToken()
        if toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
            if Ch!=',' then exit end if
        end if
        if Ch='=' then
            Assignment(False)
            if toktype!=SYMBOL or not equal(token,",") then exit end if
        else
            if Ch!=',' then getToken() exit end if
            getToken()
        end if
        if Ch='$' then
            wasMapEndToMinusOne = mapEndToMinusOne
            mapEndToMinusOne = 1
            getToken()
            mapEndToMinusOne = wasMapEndToMinusOne
            getToken()
            exit
        end if
    end while
    if token=";" then
        getToken()
    end if
end procedure

--sequence constnames = {},
--       constvals = {}
--integer constidx = 0

--integer resolvable

--with trace
--/*
function Resolve(object constval)
sequence res
integer idx
--object subscr1, subscr2, Seq
object cv1
    cv1 = constval[1]
    if cv1="+" then
        return Resolve(constval[2])+Resolve(constval[3])
    elsif sequence(cv1) then
        resolvable = 0
        return 0
    elsif cv1=IDENT then
        idx = find(constval[2],constnames)
        if idx then
            return constvals[idx]
        end if
        resolvable = 0
        return 0
    elsif cv1=FUNC then
        if equal(constval[NAME],"or_all") then
            return or_all(Resolve(constval[ARGS][1]))
        elsif equal(constval[NAME],"or_bits") then
            return or_bits(Resolve(constval[ARGS][1]),Resolve(constval[ARGS][2]))
        end if
        resolvable = 0
        return 0
--18/07/2013:
    elsif cv1=DQUOTE then
--      return constval[2][2..-2]   -- strip quotes
        return constval[2][2..$-1]  -- strip quotes
--  elsif find(cv1,{DQUOTE,SQUOTE,HEXDEC,DIGIT,FLOAT}) then
    elsif find(cv1,{SQUOTE,HEXDEC,DIGIT,FLOAT}) then
        return constval[2]
    elsif cv1=SEQ then
        res = {}
        for i=1 to length(constval[6]) by 2 do
            res = append(res,Resolve(constval[6][i]))
        end for
        return res
--  elsif cv1=SUBSCR then
--DEV this sort of works, but we can't replace it. Maybe it should be
-- {SUBSCR,{seq},{"["},{idx},{"]"}} like SEQ is.
--      if resolvable then
--          subscr1=Resolve(constval[2])
--          if resolvable and integer(subscr1) then
--              Seq=Resolve(constval[3])
--              if resolvable and sequence(Seq)
--              and subscr1>=1 and subscr1<=length(Seq) then
--                  return Seq[subscr1]
--              end if
--          end if
--      end if
--      resolvable = 0
--      return 0
--  elsif cv1=SLICE then
--DEV ditto, with ".." and {endslice}
--      if resolvable then
--          subscr1=Resolve(constval[2])
--          if resolvable and integer(subscr1) then
--              subscr2=Resolve(constval[3])
--              if resolvable and integer(subscr2) then
--                  Seq=Resolve(constval[4])
--                  if resolvable and sequence(Seq)
--                  and subscr1>=1 and subscr2<=length(Seq)
--                  and subscr2>=subscr1-1 then
--                      return Seq[subscr1..subscr2]
--                  end if
--              end if
--          end if
--      end if
--      resolvable = 0
--      return 0
    end if
--?9/0
    resolvable = 0
    return 0
end function
--*/

procedure DoConstant()
--integer insert_point = 0
integer wasMapEndToMinusOne
    getToken()  -- discard "constant".
    while Ch!=-1 do
        if toktype=LETTER
        and find(token,vartypes)
        and (charClass[Ch]=LETTER or Ch='{') then
            -- cope with typed constant definitions, eg:
            --  constant string s = "string",
            --           integer {i,j,k} @= 0
            getToken()
        end if
        if toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
        else
            Assignment(False)
        end if
        if not equal(token,",") then exit end if
        if Ch='$' then
            wasMapEndToMinusOne = mapEndToMinusOne
            mapEndToMinusOne = 1
            getToken()
            mapEndToMinusOne = wasMapEndToMinusOne
            getToken()
            exit
        end if
        getToken()
    end while
--/*
    if insert_point then
        if Ch=-1 then
            insertion_point = next_insertion_point
        end if
        insertion_points = append(insertion_points,insertion_point)
    end if
--*/
    if token=";" then
        getToken()
    end if
end procedure

procedure DoEnum()
integer wasMapEndToMinusOne -- allow enum 1,2,3,$ [=== enum 1,2,3]
    wasMapEndToMinusOne = mapEndToMinusOne
    mapEndToMinusOne = 1
    Match("enum")
    while 1 do
        if mapEndToMinusOne='$' then
            getToken()
            exit
        end if
        mapEndToMinusOne = 0
        getToken()
        if equal(token,"=") then
            getToken()
            {} = Expression()
        end if
        if not equal(token,",") then exit end if
        mapEndToMinusOne = 1
        Match(",")
    end while
    mapEndToMinusOne = wasMapEndToMinusOne
end procedure

--
-- Part 3. The main control routine.
--

global procedure parse_source()
integer t
integer fwd = 0

    CurrLine = 1
    treatColonAsThen = 0
    vartypes = {"atom","integer","bool","sequence","string","object","Ihandle","Ihandln","cdCanvas","cdCanvan","nullable_string","imImage"}
    textlen = length(text)
    if textlen
    and match("#!",text[1])=1 then  -- skip shebang
        CurrLine = 2
    end if
    col = 1
    SkipSpacesAndComments()
    getToken()
    while Ch!=-1 do
        if toktype=LETTER then
            t = find(token,{"procedure","function","type"})
            if t then
                DoRoutineDef(t,fwd)
                fwd = 0
            elsif equal(token,"constant") then
                DoConstant()
            elsif equal(token,"enum") then
                DoEnum()
            elsif find(token,{"global","public","export","override","forward"}) then
                if token="forward" then fwd = 1 end if
                getToken()  -- otherwise ignore it
            elsif find(token,{"include","with","without","namespace"}) then
                CurrLine += 1
                col = 1
                SkipSpacesAndComments()
                getToken()
            elsif token="ifdef" then
                Abort("invalid")
            else
                if Ch=':' then skip_namespace() end if
                t = find(token,vartypes)
                if not t and not equal(token,"?") then
                    if charClass[Ch]=LETTER
                    and not find(token,ifforwhileetc) then
                        -- word word (not word =, or word[... etc) /must/ be
                        --  a variable definition (eg boolean t), not code.
                        WarnType()
                        vartypes = append(vartypes,token)
                        t = length(vartypes)
                    end if
                end if
                if t then
                    TopDecls()
                else
                    if equal(token,"abort") and Ch='(' then
                        exit
                    end if
                    Statement()
                end if
            end if
        elsif toktype=SYMBOL and equal(token,"{") then
            DoMultipleAssignment()
        else
            Abort("invalid")
            exit
        end if
    end while
--  IupMessage("ReIndent", "???")
--  ?CurrLine
end procedure

-- src/rein.ew
--*!/
--/*
-- Source code scanner.
-- Builds routine lists, block start/end sets, etc.
--

--procedure appendX(sequence entry)
--integer line, k
--  line=entry[2]
--  k=length(parse_data)
--  while k and line<parse_data[k][2] do
--      k-=1
--  end while
--  if k=length(parse_data) then
--      parse_data=append(parse_data,entry)
--  else
--      parse_data=parse_data[1..k]&0&parse_data[k+1..length(parse_data)]
--      parse_data[k+1]=entry
--  end if
--end procedure

--procedure AssignOrProc()
---- Decide if a Statement is an Assignment or Procedure Call
--object Type
--integer N
----trace(1)
--  N=InAnyTable(1)
--  if N=0 then -- forward procedure call?
--      if Ch!='(' then Undefined(token) end if
--      ForwardProc(token,{'p',GetFnLn()},0)
--  else
--      Type=VarType(N)
--      if N<0 and N>=BI_BImax then --CallBuiltin(token,N,Type,"Pp")
--                                CallProc(N,Type)
--      elsif sequence(Type) then CallProc(N,Type)
--      elsif find(Type,INSPO) then Next() Assignment(N,Type)
--      else Abort("Identifier " & token & " cannot be used here")
--      end if
--  end if
--end procedure

--*/
--DEV/SUG <pGPARSE.e ends>

--DEV later??
parse_source()
ppOpt({pp_StrFmt,-2,pp_Pause,0})
--ppOpt({pp_StrFmt,-2})
--DEV (temp)
--if 01 then
--  ?"Warning (temp): parse_data[i][END] replaced with idx"
    for i=1 to length(parse_data) do
        parse_data[i][IDX] = i
    end for
--end if
pp(parse_data)
--?insertion_points
--/*
{{20, "IupCanvas", 159,14,22, {{-1, "NULL", 159,24,27}}, {-1, "canvas", 159,5,10}},
 {21, "IupSetAttribute", 162,5,18, {{-1, "canvas", 160,21,26}, {2, "\"RASTERSIZE\"", 160,29,40}, {2, "\"600x400\"", 160,43,51}}},
 {21, "IupSetCallback", 163,5,18, {{-1, "canvas", 162,20,25}, {2, "\"MAP_CB\"", 162,28,35}, {20, "Icallback", 162,41,49, {{2, "\"map_cb\"", 162,51,58}}, 0}}},
 {21, "IupSetCallback", 165,5,7, {{-1, "canvas", 163,20,25}, {2, "\"UNMAP_CB\"", 163,28,37}, {20, "Icallback", 163,41,49, {{2, "\"unmap_cb\"", 163,51,60}}, 0}}},
 {20, "IupDialog", 165,11,19, {{-1, "canvas", 165,21,26}}, {-1, "dlg", 165,5,7}},
 {21, "IupSetAttribute", 167,5,18, {{-1, "dlg", 166,21,23}, {2, "\"TITLE\"", 166,26,32}, {2, "\"GraphR\"", 166,35,42}}},
 {21, "IupSetCallback", 168,5,18, {{-1, "canvas", 167,20,25}, {2, "\"ACTION\"", 167,28,35}, {20, "Icallback", 167,38,46, {{2, "\"redraw_cb\"", 167,48,58}}, 0}}},
 {21, "IupSetCallback", 170,5,10, {{-1, "dlg", 168,20,22}, {2, "\"K_ANY\"", 168,25,31}, {20, "Icallback", 168,38,46, {{2, "\"esc_close\"", 168,48,58}}, 0}}},
 {21, "IupSetAttribute", 173,5,13, {{-1, "canvas", 171,21,26}, {2, "\"RASTERSIZE\"", 171,29,40}, {-1, "NULL", 171,43,46}}}}

Ignore: IupSetAttribute(clipboard,"TEXT",currentfilename)
Treat specially/ignore: IupSetAttribute(dlg,"RASTERSIZE",NULL)
Obviously you can have bespoke attributes (eg DIRTY in simple_notepad) - separate tab?

--*/
--constant ctrls = {
--constant {{names,rids},attrs,callbacks} = columnize({
constant {iupnamerids, cem, sigs, icons, attrs, callbacks} = columnize({
         {nr("IupBackgroundBox"),'C',"[H]AD",
                                 "plade_backgroundbox.png",
                                 {},
--"BGCOLOR","BORDER","CHILDOFFSET","EXPAND","CANFOCUS(NO)","CLIENTSIZE"
                                 {}},
         {nr("IupButton")       ,'E',"[T]AFAD",
                                 "plade_button.png",
                                 {"ACTIVE","BGCOLOR","CANFOCUS","EXPAND","FLAT","IMAGE","IMPRESS","NAME","PADDING","SIZE","TIP","VISIBLE"},
                                 {"ACTION"}},
         {nr("IupFlatButton"),   'E',"[T]AFAD",
                                 "plade_flatbutton.png",
                                 {"ACTIVE","EXPAND"},
                                 {"ACTION"}},
         {nr("IupCalendar"),     'E',"AFAD",
                                 "plade_calendar.png",
                                 {"VALUE"},
                                 {"VALUECHANGED_CB"}},
         {nr("IupDatePick"),     'E',"AD",
                                 "plade_date_picker.png",
                                 {"MONTHSHORTNAMES","VALUE","ZEROPRECED"},
                                 {}},
         {nr("IupCanvas"),       'E',"AFAD",
                                 "plade_canvas.png",
                                 {"BGCOLOR","BORDER","BUFFER","DRAWSIZE","EXPAND","MARGIN","RASTERSIZE","SCROLLBAR"},
                                 {"ACTION","BUTTON_CB","MAP_CB","MOTION_CB","RESIZE_CB","UNMAP_CB"}},
         {nr("IupCbox"),         'C',"[P]AD",
                                 "plade_cbox.png",
                                 {},
                                 {}},
         {nr("IupCells"),        'E',"AD",
                                 "plade_cells.png",
                                 {},
                                 {}},
         {nr("IupDetachBox"),    'C',"[H]AFAD",
                                 "plade_detach.png",
                                 {"DETACH","ORIENTATION","RESTORE"},
                                 {"DETACHED_CB"}},
         {nr("IupDial"),         'E',"[O]AD",
                                 "plade_dial.png",
                                 {},
                                 {}},
         {nr("IupDialog"),       'C',"[H]AD",
                                 "application.png",
                                 {"BACKGROUND","CURSOR","DEFAULTENTER","DEFAULTESC","DIALOGFRAME","GAP","MARGIN","MAXBOX","MENU","MINBOX","MINSIZE",
                                  "PARENTDIALOG","RASTERSIZE","RESIZE","SHRINK","SIZE","TITLE"},
                                 {"CLOSE_CB","COPYDATA_CB","DROPFILES_CB","K_ANY","K_cV","K_cF3","K_F3","K_cG","K_cH","K_cF","K_cS","K_cO","K_cN","RESIZE_CB"}},
         {nr("IupExpander"),     'C',"[H]AD",
                                 "plade_expand.png",
                                 {"BARPOSITION","EXTRABUTTONS","TITLE"},
                                 {"ACTION","EXTRABUTTON_CB","IMAGEEXTRAid","IMAGEEXTRAPRESSid","IMAGEEXTRAHIGHLIGHTid"}},
         {nr("IupFill"),         'E',"AD",
                                 "plade_fill.png",
                                 {},
                                 {}},
--       {nr("IupFileDlg"),      'E',"",
--                               "plade_filedlg.png",   --DEV
--                               {"ALLOWNEW","DIALOGTYPE","PARENTDIALOG","TITLE"},
--                               {}},
         {nr("IupFrame"),        'C',"[H]AD",
                                 "plade_frame.png",
                                 {"ALIGNMENT","GAP","POSITION","SIZE","TITLE"},
                                 {}},
--       {nr("IupGridBox"),      'E',"[P]AD",
         {nr("IupGridBox"),      'C',"[P]AD",
                                 "plade_grid.png",
                                 {},
                                 {}},
         {nr("IupHbox"),         'C',"[P]AD",
                                 "plade_hbox.png",
                                 {"CMARGIN","FLOATING","GAP","MARGIN","NORMALIZESIZE","SIZE","TABTITLE","VISIBLE"},
                                 {}},
--       {nr("IupImage"),        'E',"WHP",
--                               "plade_image.png",
--                               {},
--                               {}},
--       {nr("IupItem"),         '?!E',"[T]AFAD",
--                               "plade_menuitem.png",
--                               {},
--                               {}},
         {nr("IupLabel"),        'E',"[T]AD",
                                 "plade_label.png",
                                 {"ALIGNMENT","EXPAND","FLOATING","IMAGE","MAXSIZE","NAME","PADDING","SEPARATOR","TITLE","VISIBLE"},
                                 {}},
         {nr("IupLink"),         'E',"[TT]AFAD",
                                 "plade_link.png",
                                 {},
                                 {}},
         {nr("IupList"),         'E',"AFAD",
                                 "plade_list.png",
                                 {"n","DROPDOWN","EDITBOX","TIP","VALUE"},
                                 {}},
         {nr("IupMatrix"),       'E',"AD",
                                 "plade_matrix.png",
                                 {"ALIGNMENT","ALIGNMENTLIN0","BORDER","CURSOR","FGCOLOR2:2","FOCUSCELL","FRAMECOLOR","HEIGHT0","HIDEFOCUS",
                                  "MARKl:c","MARKAREA","MARKED","MARKMODE","NUMCOL","NUMCOL_VISIBLE","NUMLIN","NUMLIN_VISIBLE","ORIGIN",
                                  "RASTERWIDTHn","RESIZEMATRIX","SORTSIGNn","TYPE*:1","WIDTHn","WIDTHDEF"},
                                 {"CLICK_CB","COLRESIZE_CB","ENTERITEM_CB","RELEASE_CB","VALUE_CB"}},
         {nr("IupMenu"),         'M',"[P]AD",
                                 "plade_menu.png",
                                 {},
                                 {"OPEN_CB"}},
--alias IupItem
         {nr("IupMenuItem"),     'm',"[T]AFAD",
                                 "plade_menuitem.png",
                                 {"ACTIVE","AUTOTOGGLE","IMAGE","NAME?","VALUE"},
                                 {"ACTION"}},
         {nr("IupSeparator"),    'm',"",
                                 "plade_sep.png",
                                 {},
                                 {}},
--alias IupSubMenu
         {nr("IupSubmenu"),      'M',"[TH]AD",
                                 "plade_submenu.png",
                                 {},
                                 {}},
--       {nr("IupNormalizer"),   'C',"PAD",
--                               "plade_normal.png",
--                               {},
--                               {}},
         {nr("IupProgressBar"),  'E',"AD",
                                 "plade_progress.png",
                                 {"VALUE"},
                                 {}},
         {nr("IupPlot"),         'E',"AD",
                                 "plade_plot.png",
                                 {"AXS_XCROSSORIGIN","AXS_YCROSSORIGIN","GRID","MARGIN"},
                                 {}},
         {nr("IupRadio"),        'C',"[H]AD",
                                 "plade_radio.png",
                                 {"VALUE"},
                                 {}},
         {nr("IupToggle"),       'E',"[T]AFAD",
                                 "plade_check.png",
                                 {"ACTIVE","FGCOLOR","FONT","IMAGE","IMPRESS","NAME","TIP"},
                                 {"ACTION"}},
         {nr("IupSbox"),         'C',"[H]AD",
                                 "plade_resize.png",
                                 {},
                                 {}},
         {nr("IupScrollBox"),    'C',"[H]AD",
                                 "plade_scroll.png",
                                 {},
                                 {}},
--alias IupSpinbox:
         {nr("IupSpinBox"),      'C',"[H]AD",
                                 "plade_spin.png",
                                 {},
                                 {}},
         {nr("IupSplit"),        'C',"[HH]AD",
                                 "plade_split.png",
                                 {},
                                 {}},
         {nr("IupTabs"),         'C',"[P]AD",
                                 "plade_tabs.png",
                                 {"RASTERSIZE","TABIMAGEn","TABTITLEn","TABTYPE","SIZE"},
                                 {"TABCHANGE_CB"}},
         {nr("IupText"),         'E',"AFAD",
                                 "plade_text.png",
                                 {"EXPAND","FONT","INSERT?","MASK","MULTILINE","READONLY","SELECTEDTEXT?","SELECTION?","SELECTIONPOS",
                                  "SIZE","SCROLLBAR","VALUE","VISIBLECOLUMNS","VISIBLELINES","WORDWRAP"},
                                 {"ACTION","CARET_CB","DROPFILES_CB","K_ANY","VALUECHANGED_CB"}},
         {nr("IupMultiLine"),    'E',"AFAD",
                                 "plade_textm.png",
                                 {"EXPAND","FONT","INSERT?","NAME?","SELECTEDTEXT?","SELECTION?","SELECTIONPOS","SIZE","VALUE","VISIBLECOLUMNS"},
                                 {"ACTION","CARET_CB","DROPFILES_CB","VALUECHANGED_CB"}},
         {nr("IupTree"),         'E',"AD",
                                 "plade_tree.png",
                                 {"ADDLEAFid","ADDBRANCHid","RASTERSIZE","SHOWRENAME","TITLEid"},
                                 {}},
         {nr("IupValuator"),     'E',"[O]AFAD",
                                 "plade_slider.png",
                                 {},
                                 {}},
         {nr("IupVbox"),         'C',"[P]AD",
                                 "plade_vbox.png",
                                 {"ALIGNMENT","GAP","MARGIN","POSITION","SHRINK","TABTITLE","TITLE"},
                                 {}},
         {nr("IupZbox"),         'C',"[P]AD",
                                 "plade_zbox.png",
                                 {},
                                 {}},
         $})

--sigs:
--          ("IupBackgroundBox"),"[H]AD",       -- one-only (p)
--          ("IupButton")       ,"[T]AFAD",
--          ("IupFlatButton"),   "[T]AFAD",
--          ("IupCalendar"),     "AFAD",
--          ("IupDatePick"),     "AD",
--          ("IupCanvas"),       "AFAD",
--          ("IupCbox"),         "[P]AD",       -- (p)
--          ("IupCells"),        "AD",
--          ("IupDetachBox"),    "[H]AFAD",     -- one-only (p)
--          ("IupDial"),         "[O]AD",
--          ("IupDialog"),       "[H]AD",       -- one-only [p]
--          ("IupExpander"),     "[H]AD",       -- one-only (p)
--          ("IupFill"),         "AD",
--          ("IupFrame"),        "[H]AD",       -- one-only (p)
--          ("IupGridBox"),      "[P]AD",       -- (p)
--          ("IupHbox"),         "[P]AD",       -- (p)
--X --      ("IupImage"),        "WHP",
--X --      ("IupItem"),         "[T]AFAD",
--          ("IupLabel"),        "[T]AD",
--          ("IupLink"),         "[TT]AFAD",
--          ("IupList"),         "AFAD",
--          ("IupMatrix"),       "AD",
--          ("IupMenu"),         "[P]AD",       -- [p]
--          ("IupMenuItem"),     "[T]AFAD",
--          ("IupSeparator"),    "",
--          ("IupSubmenu"),      "[TH]AD",      -- [p]
--X --      ("IupNormalizer"),   "PAD",
--          ("IupProgressBar"),  "AD",
--          ("IupPlot"),         "AD",
--          ("IupRadio"),        "[H]AD",       -- one-only (p)
--          ("IupToggle"),       "[T]AFAD",
--          ("IupSbox"),         "[H]AD",       -- one-only (p)
--          ("IupScrollBox"),    "[H]AD",       -- one-only (p)
--          ("IupSpinBox"),      "[H]AD",       -- one-only (p)
--          ("IupSplit"),        "[HH]AD",      -- two-only (p)
--          ("IupTabs"),         "[P]AD",       -- (p)
--          ("IupText"),         "AFAD",
--          ("IupMultiLine"),    "AFAD",
--          ("IupTree"),         "AD",
--          ("IupValuator"),     "[O]AFAD",
--          ("IupVbox"),         "[P]AD",       -- (p)
--          ("IupZbox"),         "[P]AD",       -- (p)


-- strip AFAD/AD, then (if not ""):
-- "[H]" - Ihandle/n    (single [HH double])
-- "[T]" - TITLE[1]/null
-- "[TT]" - URL[1]/TITLE[2]
-- "[TH]" - TITLE[1]/Ihandle/n  (single)
-- "[P]" - Ihandles
-- "[O]" - ORIENTATION[1] (nullable string. [HORIZONTAL/VERTICAL/CIRCULAR(IupDial only)])

--erm:
--"ACTIVE=YES,NO,Yes"
--"ALIGNMENT=ACENTER,ALEFT,ATOP,ABOTTOM"
--"ALIGNMENTLIN0=ALEFT,"
--"ALLOWNEW=YES,NO"
--"AUTOTOGGLE=YES,NO"
--"BACKGROUND=\"240 240 240\""
--"AXS_XCROSSORIGIN=YES,NO"
--"AXS_YCROSSORIGIN=YES,NO"
--"BARPOSITION=TOP,BOTTOM,LEFT,RIGHT"
--"BGCOLOR="\"128 255 0\""
--"BORDER=NO,"
--"BUFFER=DOUBLE"
--"CANFOCUS=No,"
--"CMARGIN=13x3"
--"CURSOR=ARROW"
--"CURSOR=img_cursor" (via IupSetHandle("img_cursor", img_cursor)
--"DIALOGFRAME=Yes,YES,NO"
--"DIALOGTYPE=OPEN,SAVE,DIR"
--"DROPDOWN=YES,NO"
--"EDITBOX=YES,NO"
--"EXPAND=YES,HORIZONTAL,VERTICAL,NO"
--"FGCOLOR2:2=\"200 0 0\""
--"FLAT=Yes,"
--"FLOATING=YES,NO,IGNORE"
--"FRAMECOLOR=\"220 220 220\""
--"GAP=5"
--"GRID=YES,NO"
--"HEIGHT0=10"
--"HIDEFOCUS=YES,NO"
--"ORIENTATION=VERTICAL"
--"MARKl:c=1,0" (Also via IupMatSetAttribute(matrix,"MARK", lin, 0, "Yes")
--"MARKAREA=CONTINUOUS,"
--"MARKMODE=LIN,"
--"MARGIN=10x10"
--"MASK=IUP_MASK_UINT"
--"MAXBOX=NO"
--"MAXSIZE=150"
--"MENU=mymenu" (via IupSetHandle("mymenu", IupMenu({IupSubmenu("File", file_menu)}))   <== cannot do??
-- MENU=<atom> (via IupSetAttributeHandle(hDialog,"MENU",hMenu)                         <== can do
--"MINBOX=NO"
--"MINSIZE=862x705"
--"MOVEABLE=Yes"
--"MULTILINE=YES,NO"
--"NAME=<any>"
--"NORMALIZESIZE=HORIZONTAL,VERTICAL"
--"NUMCOL=3"
--"NUMCOL_VISIBLE=3"
--"NUMLIN=13"
--"NUMLIN_VISIBLE=3"
--"PADDING=10x5"
--"PARENTDIALOG=<atom>" (via IupSetAttributeHandle(hDlg,"PARENTDIALOG",hDialog)
--"POSITION="250,350"
--"RASTERSIZE=100x150,100x,x100"    (100x=100x0,x100=0x100)
--"READONLY=YES,NO"
--"REDRAW=ALL,(L|C)n[-n]"
--"RESIZE=NO"
--"RESIZEMATRIX=YES,NO"
--"SCROLLBAR=YES,NO"
--"SEPARATOR=HORIZONTAL,VERTICAL"
--"SELECTION?=l,c:l,c|ALL"
--"SELECTIONPOS=n:n"
--"SHOWRENAME=YES,NO"
--"SHRINK=YES,NO"
--"SIZE=120[x300]"
--"SIZE=HALFxQUARTER,HALFxHALF,QUARTERxQUARTER,QUARTERxEIGHTH" (IupDialog only)
--"SORTSIGNn=NO,UP,DOWN"
--"TABTYPE=LEFT,"
--"TIP=<any>"
--"TITLE=<any>"
--"TYPE*:C=IMAGE"   (C is column; 1 etc)
--"VALUE=<any>" (ON/OFF on an IupToggle,IupMenuItem)
--"VISIBLE=YES,NO"
--"VISIBLECOLUMNS=20"
--"VISIBLELINES=5"
--"WIDTH1=60"
--"WIDTHDEF=60"
--"WORDWRAP=YES,NO"


--IupGLExpander MOVEABLE
--IupGLFrame MOVEABLE
--IupExpander TITLE only shown when BARPOSITION=TOP
--IupWebBrowser EXPAND, NAVIGATE_CB, COMPLETED_CB


--constant {{names,rids},attrs,callbacks} = columnize(ctrls)
--constant {iuprids,attrs,callbacks} = columnize(ctrls)
--constant {iupnames,iuprids} = columnize(iupnamerids)
sequence {iupnames,iuprids} = columnize(iupnamerids)

function clean_sig(integer id)
    string sig = sigs[id]
    -- strip AFAD and AD suffixes:
    if  length(sig)>=4 and sig[-4..-1]="AFAD" then sig = sig[1..-5]
    elsif length(sig)>=2 and sig[-2..-1]="AD" then sig = sig[1..-3] end if
    return sig
end function

function get_max_children()
sequence res = repeat(0,length(sigs))
    for id=1 to length(sigs) do 
        integer children
        string sig = clean_sig(id)
        if find(sig,{"[H]","[TH]"}) then
            children = 1
        elsif sig="[HH]" then
            children = 2
        elsif sig="[P]" then
            children = -1
        elsif find(sig,{"","[T]","[O]","[TT]"}) then
            children = 0
        else
            ?9/0
        end if
        res[id] = children
    end for
    return res
end function

sequence max_children = get_max_children()

?"=="
if 0 then
?iupnames
?iuprids
?sigs
?icons
?attrs
?callbacks
end if
--{} = wait_key()

--/*
--40 (all lines processed)
sequence testr = 
{{20, "IupFrame", 20,18,25,
  {{20, "IupHbox", 20,27,33,
    {{-5, "{", 20,35,35,
      {{20, "IupButton", 20,36,44, {{2, "\"Ok\"", 20,46,49}}, 0},
       {1, ",", 20,51,51}, 
       {20, "IupFill", 20,52,58, {}, 0},
       {1, "}", 20,61,61}
      }
     }
    },
    0},
   {2, "\"TITLE=\\\"Left aligned\\\"\"", 20,64,87}
  },
  {-1, "frame_left", 20,5,14}},
 {20, "IupFrame", 23,20,27,
  {{20, "IupHbox", 23,29,35,
    {{-5, "{", 23,37,37,
      {{20, "IupFill", 23,38,44, {}, 0},
       {1, ",", 23,47,47},
       {20, "IupButton", 23,48,56, {{2, "\"Ok\"", 23,58,61}}, 0},
       {1, ",", 23,63,63},
       {20, "IupFill", 23,64,70, {}, 0},
       {1, "}", 23,73,73}
      }
     }
    },
    0},
   {2, "\"TITLE=Centered\"", 23,76,91}},
  {-1, "frame_center", 23,5,16}},
 {20, "IupFrame", 26,19,26,
  {{20, "IupHbox", 26,28,34,
    {{-5, "{", 26,36,36,
      {{20, "IupFill", 26,37,43, {}, 0},
       {1, ",", 26,46,46},
       {20, "IupButton", 26,47,55, {{2, "\"Ok\"", 26,57,60}}, 0},
       {1, "}", 26,62,62}
      }
     }
    },
    0},
   {2, "\"TITLE=\\\"Right aligned\\\"\"", 26,65,89}
  },
  {-1, "frame_right", 26,5,15}},
 {20, "IupDialog", 29,14,22,
  {{20, "IupVbox", 29,24,30,
    {{-5, "{", 29,32,32,
      {{-1, "frame_left", 29,33,42},
       {1, ",", 29,43,43},
       {-1, "frame_center", 29,44,55},
       {1, ",", 29,56,56},
       {-1, "frame_right", 29,57,67},
       {1, "}", 29,68,68}
      }
     }
    },
    0
   }
  },
  {-1, "dialog", 29,5,10}},
 {21, "IupSetAttributes", 32,55,55,
  {{-1, "dialog", 32,22,27},
   {2, "\"SIZE=120, TITLE=IupFill\"", 32,30,54}}},
 {21, "IupSetCallback", 33,59,59,
  {{-1, "dialog", 33,20,25},
   {2, "\"K_ANY\"", 33,28,34},
   {20, "Icallback", 33,37,45, {{2, "\"esc_close\"", 33,47,57}}, 0}}}}
if 0 then
    ?"parse_data:=testr"
    parse_data = testr
end if

--2770
--SUG:
-- handles = {"mymenu"}
-- handledx = {3}
--Warning about IupAppend? (in plade, vbox is subject to an Append, maybe that's where it goes...)
sequence testr2 = 
{{21, "IupSetHandle", 2605,43,43,                                                   -- 1
  {{-1, "image", 2605,30,34}, {-1, "handle", 2605,37,42}}},
 {20, "IupMenu", 2622,17,23,                                                        -- 2
  {{-5, "{", 2622,25,25,
    {{20, "IupMenuItem", 2622,26,36, {{2, "\"&Cancel\"", 2622,38,46}}, 0},
     {1, ",", 2622,48,48},
     {20, "IupSeparator", 2624,26,37, {}, 0},
     {1, ",", 2624,40,40},
     {20, "IupMenuItem", 2626,26,36,
      {{2, "\"Save and E&xit\"", 2626,38,53},
       {20, "Icallback", 2626,56,64, {{2, "\"exit_cb\"", 2626,66,74}}, 0}},
      0},
     {1, "}", 2626,77,77}}}},
  {-1, "file_menu", 2622,5,13}},
 {21, "IupSetHandle", 2628,68,68,                                                   -- 3
  {{2, "\"mymenu\"", 2628,18,25},
   {20, "IupMenu", 2628,28,34,
    {{-5, "{", 2628,36,36,
      {{20, "IupSubmenu", 2628,37,46,
        {{2, "\"File\"", 2628,48,53}, {-1, "file_menu", 2628,56,64}}, 0},
       {1, "}", 2628,66,66}}}},
    0}}},
 {20, "IupVbox", 2630,20,26, {{-5, "{", 2630,28,28, {}}},                           -- 4 c
  {-1, "vbox", 2630,13,16}},
 {20, "IupRadio", 2631,21,28, {{-1, "vbox", 2631,30,33}},                           -- 5 c
  {-1, "radio", 2631,13,17}},
 {20, "IupLabel", 2636,23,30, {{2, "\"NULL\"", 2636,32,37}},                        -- 6 (only used via IupAppend)
  {-1, "lbl", 2636,17,19}},
 {21, "IupSetStrAttribute", 2637,57,57,                                             -- 7
  {{-1, "lbl", 2637,28,30}, {2, "\"IMAGE\"", 2637,33,39},
   {20, "get_image", 2637,42,50, {{-1, "icon", 2637,52,55}}, 0}}},
 {20, "IupToggle", 2638,23,31, {{-1, "iupname", 2638,33,39}},                       -- 8 (only used via IupAppend)
  {-1, "tgl", 2638,17,19}},
 {21, "IupAppend", 2670,66,66,
  {{-1, "vbox", 2670,19,22},
   {20, "IupHbox", 2670,24,30,
    {{-5, "{", 2670,32,32,
      {{-1, "lbl", 2670,33,35}, {1, ",", 2670,36,36},
       {-1, "tgl", 2670,37,39}, {1, "}", 2670,40,40}}},
     {2, "\"NORMALSIZE=HORIZONTAL\"", 2670,42,64}}, 0}}},
 {21, "IupSetAttributeHandle", 2641,52,52,                                          -- 9
  {{-1, "radio", 2641,35,39}, {2, "\"VALUE\"", 2641,41,47},
   {-1, "tgl", 2641,49,51}}},
 {20, "IupFrame", 2645,21,28,                                                       -- 10
  {{-1, "radio", 2645,30,34},
   {2, "\"TITLE=Controls, PADDING=5x\"", 2645,36,63}},
  {-1, "frame", 2645,13,17}},
 {20, "IupDialog", 2648,11,19,                                                      -- 11
  {{20, "IupHbox", 2648,21,27,
    {{-5, "{", 2648,29,29,
      {{-1, "frame", 2648,30,34},
       {1, ",", 2648,35,35},
       {20, "IupFill", 2648,36,42, {}, 0},
       {1, "}", 2648,45,45}}},
     {2, "\"MARGIN=5x\"", 2648,47,57}}, 0},
   {2, "\"MENU=mymenu, SIZE=250x370\"", 2649,21,47}},
  {-1, "dlg", 2648,5,7}},
 {21, "IupSetAttribute", 2650,65,65,                                                -- 12
  {{-1, "dlg", 2650,21,23}, {2, "\"TITLE\"", 2650,26,32},
   {2, "\"plade - Phix Layout Designer\"", 2650,35,64}}},
 {21, "IupSetCallback", 2651,56,56,                                                 -- 13
  {{-1, "dlg", 2651,20,22}, {2, "\"K_ANY\"", 2651,25,31},
   {20, "Icallback", 2651,34,42, {{2, "\"esc_close\"", 2651,44,54}}, 0}}}}
if 0 then
    ?"parse_data:=testr2"
    parse_data = testr2
end if
--*/
--"=="
--/*
dialogs: {11}
--       1 2 3  4  5 6 7 8  9 10 11 12 13
dialog: {0,0,0,11,11,0,0,0,11,11,11,11,11}
dlevel: {0,0,0, 4, 3,0,0,0, 3, 2, 1, 1, 1}
names: {"file_menu","vbox","radio","lbl","tgl","frame","dlg"}
namedx: {2,4,5,6,8,10,11}
children: {{},{},{},{},{4},{},{},{},{},{5},{10},{},{}}
--*/
--"=="

--DEV/SUG:
--include pG??, or make part of pGPARSE.e?

sequence dialogs = {}
sequence dialoglines = {}
sequence names = {},
         namedx = {}

--sequence clean    --DEV incomplete
--sequence trees
--DEV setup later??
sequence children = repeat({},length(parse_data))
sequence updates = repeat({},length(parse_data))
sequence dialogN = repeat(0,length(parse_data)) -- DEV to go? (not as useful as I thought? [may yet have use in clash avoidance])
sequence dlevel = repeat(0,length(parse_data))  -- DEV to go? (not as useful as I thought)

--function mark_dialog(integer d, integer di, sequence ri, integer level)
procedure mark_dialog(integer d, integer di, sequence ri, integer level)
integer k, kdx
string name
--sequence childrenL = {}
--?{"mark_dialog",d,di,ri,level}
    if ri[TYPE]!=FUNC then ?9/0 end if
    -- ri is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
    if dialogN[di]!=0
    and dialogN[di]!=d then
?"?? errorcount +=1 line 2776"
        dialogN[di]=-1
--      return 0
        errorcount += 1
    else
        dialogN[di] = d
        dlevel[di] = level
--?{dialogN,dlevel}
        sequence args = ri[ARGS]
        for i=1 to length(args) do
            sequence argi = args[i]
--          integer aitype = argi[TYPE]
            object aitype = argi[TYPE] -- (can be eg "&")
            if aitype=FUNC then
                -- argi is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
--              childrenL = append(childrenL,mark_dialog(d,di,argi,level))
--              childrenL &= mark_dialog(d,di,argi,level)[2]
                mark_dialog(d,di,argi,level)
            elsif aitype=SEQ then
                -- argi is {TYPE=SEQ,NAME="{",LINE,BEGIN,END,ARGS}
                --         (where LINE,BEGIN,END locate the source "{")
                if argi[NAME]!="{" then ?9/0 end if
                if length(argi)!=ARGS then ?9/0 end if
                argi = argi[ARGS]
                -- argi is {[odd,{",",odd}],"}"}
                -- where "," and "}" are really {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
                --  (and odd are as per argii with and_bits(ai,1)=1 below)
                --  (actually, a trailing "," is also allowed (and no "}"), for ",$" etc.)
                if and_bits(length(argi),1) then ?9/0 end if
                for ai=1 to length(argi) do
                    sequence argii = argi[ai]
                    name = argii[NAME]
                    if and_bits(ai,1)=1 then
                        aitype = argii[TYPE]
                        if aitype=IDENT then
                            -- argii is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                            k = find(name,names)
if k=0 or not integer(namedx[k]) then
                            if not find(name,{"NULL"}) then
--DEV defer to a messagebox:
--                              puts(1,"warning - "&name&" unresolved\n")
                                printf(1,"warning - %s unresolved (line %d) [errorcount +=1, line 2817]\n",{name,argii[LINE]})
                                errorcount += 1
                            end if
else
                            kdx = namedx[k]
--if kdx=50 then ?9/0 end if
                            children[di] &= kdx
--                          childrenL = append(childrenL,mark_dialog(d,kdx,parse_data[kdx],level+1))
                            mark_dialog(d,kdx,parse_data[kdx],level+1)
end if
                        elsif aitype=FUNC then
                            -- argii is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
--                          childrenL = append(childrenL,mark_dialog(d,di,argii,level))
--                          childrenL &= mark_dialog(d,di,argii,level)
                            mark_dialog(d,di,argii,level)
                        else
--DEV no/temp/...?
                            ?9/0
                        end if
                    else
                        if argii[TYPE]!=SYMBOL then ?9/0 end if
                        -- argii is {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
--28/2/17
--                      if ai<length(argi) then
--                          if name!="," then ?9/0 end if
--                      else
--                          if name!="}" then ?9/0 end if
--                      end if
                        if name!="," then
                            if ai<length(argi) then ?9/0 end if
                            if name!="}" then ?9/0 end if
                        end if
                    end if
                end for
            elsif aitype=IDENT then
                -- argi is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                name = argi[NAME]
                k = find(name,names)
                if k=0 or not integer(namedx[k]) then
                    if not find(name,{"NULL"}) then
--DEV defer to a messagebox:
--                      puts(1,"warning - "&name&" unresolved\n")
                        printf(1,"warning - %s unresolved (line %d) [errorcount +=1, line 2859]\n",{name,argi[LINE]})
                        errorcount += 1
                    end if
                else
                    kdx = namedx[k]
--if kdx=50 then ?9/0 end if
                    children[di] &= kdx
--                  childrenL = append(childrenL,mark_dialog(d,kdx,parse_data[kdx],level+1))
                    mark_dialog(d,kdx,parse_data[kdx],level+1)
                end if
--          elsif aitype="&" then
--              -- argi = {TYPE="&",lhs,rhs}
----DEV we should glue these together ourselves...
--              if argi[2][TYPE]!=DQUOTE
--              or argi[3][TYPE]!=DQUOTE then
--                  ?argi
--              end if
            elsif aitype!=DQUOTE then
                -- (argi!={TYPE=DQUOTE,NAME[,LINE,BEGIN,END]})
--DEV unknown/error
                ?argi
            end if
        end for
    end if
end procedure
--?{di,childrenL}
--  return {di,childrenL}
--end function

procedure anaylse()
string name
integer k, kdx, di
sequence ri, arg1
    for i=1 to length(parse_data) do
        ri = parse_data[i]
        if ri[TYPE]=FUNC then
            -- ri is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
            if ri[NAME]="IupDialog" then
                dialogs = append(dialogs,i)
                dialoglines = append(dialoglines,ri[LINE])
            end if
            if ri[TARGET][TYPE]!=IDENT then ?9/0 end if
            -- ri[TARGET] is {TYPE=IDENT,NAME,LINE,BEGIN,END}
            name = ri[TARGET][NAME]
            k = find(name,names)
            if k!=0 then
--              namedx[k] = -1
                namedx[k] = append(namedx[k],i)
            else
                names = append(names,name)
                namedx = append(namedx,i)
            end if
        end if
    end for
--  clean = repeat(1,length(dialogs))   --DEV incomplete
--  dialogN = repeat(0,length(parse_data))
--  dlevel = repeat(0,length(parse_data))
--  trees = repeat(0,length(dialogs))

    for i=1 to length(dialogs) do
        di = dialogs[i]
--      clean[i] = 
--      trees[i] = mark_dialog(di,di,parse_data[di],1)
        mark_dialog(di,di,parse_data[di],1)
    end for
    integer rescan = 0
    for i=1 to length(parse_data) do
        ri = parse_data[i]
        if ri[TYPE]=PROC then
            -- ri is {TYPE=PROC,NAME,LINE,BEGIN,END,ARGS}
            arg1 = ri[ARGS][1]
            if length(arg1)>0
            and arg1[TYPE]=IDENT then
                -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                name = arg1[NAME]
                k = find(name,names)
                if k=0 or not integer(namedx[k]) then
                    if not find(name,{"NULL"}) then
--DEV defer to a messagebox:
--                      puts(1,"warning - "&name&" unresolved[4]\n")
                        printf(1,"warning - %s unresolved (line %d) [errorcount +=1, line 2939]\n",{name,arg1[LINE]})
                        errorcount += 1
                    end if
                else
                    kdx = namedx[k]
                    dialogN[i]=dialogN[kdx]
                    dlevel[i]=dlevel[kdx]
--                  updates[i] &= kdx
--if i=1 then ?9/0 end if
                    updates[kdx] &= i
                end if
--          else
--              ?9/0
            end if
            name = ri[NAME]
            if name="IupAppend" then
?"IupAppend [errorcount +=1, line 2955]"
errorcount += 1
                arg1 = ri[ARGS][2]
                if arg1[TYPE]=IDENT then
                    -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                    name = arg1[NAME]
                    k = find(name,names)
                    if k!=0 then
                        kdx = namedx[k]
                        dialogN[i]=dialogN[kdx]
                        dlevel[i]=dlevel[kdx]
-- untried:
--                      updates[i] &= kdx
--                      updates[kdx] &= i
?{kdx,i}
                    end if
                elsif arg1[TYPE]=FUNC then
                    -- arg1 is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
                    di = dialogN[i]
if di!=0 then
                    mark_dialog(di,di,arg1,dlevel[i])
end if
                    rescan = 1
--              else
--                  ?9/0
                end if
--/*                
 {21, "IupAppend", 2670,66,66,
  {{-1, "vbox", 2670,19,22},
   {20, "IupHbox", 2670,24,30,
    {{-5, "{", 2670,32,32,
      {{-1, "lbl", 2670,33,35}, {1, ",", 2670,36,36},
       {-1, "tgl", 2670,37,39}, {1, "}", 2670,40,40}}},
     {2, "\"NORMALSIZE=HORIZONTAL\"", 2670,42,64}}, 0}}},
--*/
--              ?9/0
            elsif name="IupSetAttributeHandle" then
                arg1 = ri[ARGS][1]
--              arg1 = ri[ARGS][3]
                if arg1[TYPE]=IDENT then
                    -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                    name = arg1[NAME]
                    k = find(name,names)
                    if k=0 or not integer(namedx[k]) then
                        if not find(name,{"NULL"}) then
--DEV defer to a messagebox:
--                          puts(1,"warning - "&name&" unresolved[4]\n")
                            printf(1,"warning - %s unresolved (line %d) [errorcount +=1, line 3002]\n",{name,arg1[LINE]})
                            errorcount += 1
                        end if
                    else
                        kdx = namedx[k]
                        di = kdx
--?di -- 17
--                      dialogN[i]=dialogN[kdx]
--                      dlevel[i]=dlevel[kdx]
--                      updates[i] &= kdx
--                      updates[kdx] &= i
                        arg1 = ri[ARGS][2]
                        if arg1[TYPE]=DQUOTE then
                            -- argi={TYPE=DQUOTE,NAME[,LINE,BEGIN,END]}
                            if arg1[NAME]="MENU" then
                                arg1 = ri[ARGS][3]
                                if arg1[TYPE]=IDENT then
                                    -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                                    name = arg1[NAME]
                                    k = find(name,names)
                                    if k!=0 then
                                        kdx = namedx[k]
--16:
                                        dialogN[kdx]=dialogN[di]
                                        dlevel[kdx]=dlevel[di]
--                                      updates[di] &= kdx
--if kdx=50 then ?9/0 end if
                                        children[di] &= kdx
                                        arg1 = parse_data[kdx]
--?arg1
                                        if arg1[TYPE]=FUNC then
                                            -- arg1 is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
--                                          di = dialogN[kdx]
--                                          mark_dialog(di,di,arg1,dlevel[di])
                                            mark_dialog(di,kdx,arg1,dlevel[di])
                                            rescan = 1
                                        end if
                                    end if
                                end if
                            end if
                        end if
                    end if
--              else
--                  ?9/0
                end if
            end if
        end if
    end for
    if rescan then
        for i=1 to length(parse_data) do
            if dialogN[i]=0 then
                ri = parse_data[i]
                if ri[TYPE]=PROC then
                    -- ri is {TYPE=PROC,NAME,LINE,BEGIN,END,ARGS}
                    arg1 = ri[ARGS][1]
                    if length(arg1)>0
                    and arg1[TYPE]=IDENT then
                        -- arg1 is {TYPE=IDENT,NAME,LINE,BEGIN,END}
                        name = arg1[NAME]
                        k = find(name,names)
                        if k!=0 and integer(namedx[k]) then
                            kdx = namedx[k]
                            dialogN[i]=dialogN[kdx]
                            dlevel[i]=dlevel[kdx]
--                          updates[i] &= kdx
--if i=1 then ?9/0 end if
if not find(i,updates[kdx]) then
                            updates[kdx] &= i
end if
                        end if
                    end if
                end if
            end if
        end for
    end if

    -- finally, a little helper display:
    string cud = repeat('?',length(parse_data))
    for i=1 to length(parse_data) do
        for j=1 to length(children[i]) do
            integer c = children[i][j]
--          cud[c] = 'c'
--          cud[c] = iff(dialogN[c]=i?'c':'C')
            cud[c] = iff(dialogN[c]=dialogN[i]?'c':'C')
        end for
        for j=1 to length(updates[i]) do
            integer u = updates[i][j]
--          cud[u] = 'u'
--          cud[u] = iff(dialogN[u]=i?'u':iff(dialogN[u]=0?'-':'U'))
--          cud[u] = iff(dialogN[u]=dialogN[i]?'u':iff(dialogN[u]=0?'-':'U'))
            cud[u] = iff(dialogN[u]=0?'-':iff(dialogN[u]=dialogN[i]?'u':'U'))
        end for
    end for
    for i=1 to length(dialogs) do
        integer d = dialogs[i]
--      cud[d] = 'd'
        cud[d] = iff(dialogN[d]=d?'d':'D')
    end for

    puts(1,"dialogs: ")     ?dialogs
    puts(1,"dialoglines: ") ?dialoglines
    puts(1,"dialogN: ")     ?dialogN
    puts(1,"dlevel: ")      ?dlevel
--  puts(1,"clean: ")       ?clean
--  puts(1,"trees: ")       ?trees
    puts(1,"names: ")       ?names
    puts(1,"namedx: ")      ?namedx
    puts(1,"children: ")    ?children
    puts(1,"updates: ")     ?updates
    puts(1,"cud: ")         ?cud
--  pp(trees,{pp_Nest,10})
end procedure
--DEV later...?
anaylse()


-- parse attribute strings as passed to IupSetAttributes etc
--  (code translated from the C internals of IUP itself)

string attr_str
integer asdx

string ap_res

procedure iAttribCapture(string delims)
integer i = 0, c
    ap_res = ""
    while asdx<=length(attr_str) do
        c = attr_str[asdx]
        asdx += 1
        if find(c,delims) then
            asdx -= 1
            exit
        end if
        if (i<256) then
            ap_res &= c
        end if
    end while
end procedure

procedure iAttribSkipComment()
integer c = 0
    while asdx<=length(attr_str) and c!='\n' do
        c = attr_str[asdx]
        asdx += 1
    end while
end procedure

enum TK_END, TK_SET, TK_COMMA, TK_NAME

function iAttribToken()
    while 1 do
        if asdx>length(attr_str) then return TK_END end if
        integer c = attr_str[asdx]
        asdx += 1
--      if find(c,"#%") then
        if find(c,"#") then
            iAttribSkipComment();
        elsif not find(c," \t\n\r") then
            switch c do
                case '=':
                    return TK_SET
                case ',':
                    return TK_COMMA
                case '\"':
                    iAttribCapture("\"")    -- string
                    asdx += 1
                    return TK_NAME
                default:
                    if c>' ' then
                        -- identifier
                        asdx -= 1
                        iAttribCapture("=, \t\n\r")
                        return TK_NAME
                    end if
            end switch
        end if
    end while
end function

--DEV global function iup_parse_attributes, in pGUI.e itself:
function parse_attributes(string attribute_string)
sequence names = {}, vals = {}
string name = "", val
integer state = 'a'     -- get attribute

    attr_str = attribute_string
    asdx = 1
    if length(attr_str)!=0 then
        if find('=',attr_str)=0 then ?9/0 end if
    end if

    while 1 do
        integer tk = iAttribToken()
        switch tk do
            case TK_END,
             TK_COMMA:
                if length(name) then
                    names  = append(names,name)
                    vals = append(vals,val)
                end if
                if tk=TK_END then exit end if
                name = ""
                val = ""
                state = 'a'

            case TK_SET:
                state = 'v' -- get value
            case TK_NAME:
                if state=='a' then
                    name = ap_res
                else
                    val = ap_res
                end if
        end switch
    end while
    return {names,vals}
end function

--?parse_attributes("")
----trace(1)
--?parse_attributes("SIZE=40x50, TITLE=\"First Name\"") -- {{"SIZE","TITLE"},{"40x50","First Name"}}


--/!*
function dequote(string s)
string res
integer ch, skip
    res = ""
    skip = 0
    for i=1 to length(s) do
        ch = s[i]
        if ch='\\' and skip=0 then
            skip = 1
            if not find(s[i+1],"\\\"tn") then ?9/0 end if -- (more code rqd?)
        else
            res &= ch
            skip = 0
        end if
    end for
    return res
end function
--*!/

--/*
function unquote(string s)
    if s[1]!='\"' then ?9/0 end if
    if s[$]!='\"' then ?9/0 end if
--  s = substitute(s[2..-2],"\\n","\n")
    s = s[2..-2]
    s = dequote(s)
    return s
end function
--*/

constant string initialcurrentdir = get_proper_dir(command_line()[2])

function get_image(string image)
-- images are loaded from the icons subdirectory (demo/edix/icons/xxx.png).
--  ( almost of them were obtained from http://www.iconarchive.com )
nullable_string res

    if length(image)=0 then
        res = NULL
    elsif platform()=WINDOWS
      and IupGetHandle(image)!=NULL then    -- (already loaded)
        res = image
    else
        string path = join_path({initialcurrentdir,"icons",image})
        if platform()=WINDOWS then

            -- use IM library to load image
            Ihandln handle = IupLoadImage(path)
            if handle=NULL then
--?path
                res = NULL
            else
                -- store the image handle
--erm??
--              if not find(image,prohibited) then ?9/0 end if
                prohibited = append(prohibited,image)
                IupSetHandle(image, handle)
                return image
            end if
        else -- LINUX
            -- natively supports PNG images
            res = path
        end if
    end if
    return res
end function

--NOTE: we will [also] need a full list of handles, not just those matching top-level elements in parse_data..
sequence all_handles = {},
         all_tags = {},
         all_funcdx = {},
         all_properties = {}

--DEV POSITION not on IupDialog (or maybe it is..)
--    SCREENPOSITION not on IupVbox, IupRadio, IupGridBox
--    CLIENTOFFSET only for IupFrame, IupTabs and IupDialog (/containers only) read-only
--    CLIENTSIZE read-only except on IupDialog, containers only
--constant IPROPS = {"SIZE","RASTERSIZE","FLOATING"}
--"USERSIZE"    -- blank on everything???

function iprops(integer funcdx)
--, sequence args)
--sequence res = IPROPS
sequence res = {"SIZE","RASTERSIZE","FLOATING","VISIBLE"}
    if upper(cem[funcdx])='C' then
        res &= {"CLIENTSIZE","CLIENTOFFSET"}
    end if
    if iupnames[funcdx]!="IupDialog" then
        res &= {"POSITION"}
    end if
    if iupnames[funcdx]="IupDialog"
    or iupnames[funcdx]="IupFrame"
    or iupnames[funcdx]="IupTabs"
    or upper(cem[funcdx])='E' then
        res &= {"SCREENPOSITION"}
    end if
    string sig = clean_sig(funcdx)
    if iupnames[funcdx]="IupDialog"
    or iupnames[funcdx]="IupExpander"
    or iupnames[funcdx]="IupFrame"
    or iupnames[funcdx]="IupPlot"
    or find(sig,{"[T]","[TH]"}) then
--?{"args[3804]",args}
--DEV this sort of thing is probably more appropriate in the write-back phase...
--      if length(args)>=1 
--      and string(args[1])
--      and args[1]!="" then
            res = append(res,"TITLE")
--      end if
    elsif sig="[TT]" then
        res = append(res,"URL")
        res = append(res,"TITLE")
    elsif sig="[O]" then
        res = append(res,"ORIENTATION")
    end if
    return res
end function

if 0 then
    for i=1 to length(iupnames) do
        sequence s = iprops(i)
        if not find("TITLE",s)
        and upper(cem[i])!='M'
        and not find(iupnames[i],{"IupBackgroundBox","IupFill","IupMatrix","IupTabs","IupTree"}) then
            ?iupnames[i]
        end if
    end for
    {} = wait_key()
    abort(0)
--/*
"IupCalendar"
"IupDatePick"
"IupCanvas"
"IupCbox"
"IupCells"
"IupDetachBox"
"IupDial"
"IupGridBox"
"IupHbox"
"IupList"
"IupProgressBar"
"IupRadio"
"IupSbox"
"IupScrollBox"
"IupSpinBox"
"IupSplit"
"IupText"
"IupMultiLine"
"IupValuator"
"IupVbox"
"IupZbox"
--*/
end if

--sequence handles = repeat(0,length(names))
sequence handles = repeat(0,length(parse_data))

integer lastbranch, lastnode

forward function create_control(integer i, sequence pdi, integer pid, bool aschild)

bool allargsvalid

with trace
function resolve_arg(integer adx, sequence arg, integer pid, bool aschild)
object res
integer k, kdx
--, aitype
string name
integer newpid
--?{"resolve_arg",arg}
    if length(arg)=0
    or not integer(arg[TYPE]) then
        allargsvalid = false
--DEV (and elsewhere) - may be a lesser error for some routines/flag per??
--also, for the properties window, we should not rely on IupGetAttribute(handle[x],xxx) but attributes[x][i] instead...
        ?{"resolve_arg",arg,"(allargsvalid:=false), errorcount+=1 line 3530"}
        errorcount += 1
        return "invalid"
    end if
    switch arg[TYPE] do
        case DQUOTE:
--          res = arg[NAME]
--          res = unquote(arg[NAME])
            res = dequote(arg[NAME])
--      case LETTER: --(10)
        case IDENT: --(10)
            name = arg[NAME]
            k = find(name,names)
            if k=0 or not integer(namedx[k]) then
                if not find(name,{"NULL"}) then
--                  ?9/0
                    allargsvalid = false
                    ?{"resolve_arg",k,name,"(allargsvalid:=false) [errorcount +=1, line 3547]"}
                    errorcount += 1
                    return "invalid"
                end if
                res = NULL
            else
--if k=13 then trace(1) end if
                kdx = namedx[k]
--?{"?ra?",parse_data[k]}
                res = handles[kdx]
                if res=0 then
--              if 1 then   -- creates 43 not 13 entries!!
                    handles[kdx]=-1
--                  res = create_control(k,parse_data[k],pid,aschild)
--?k
--                  res = resolve_arg(parse_data[k],pid,aschild)
                    res = resolve_arg(kdx,parse_data[kdx],pid,aschild)
--                  res = resolve_arg(parse_data[k],pid,0)  -- NO
--                  res = resolve_arg(parse_data[k],lastnode,aschild)   -- NO
                    handles[kdx] = res
                end if
--              if res=NULL then
--                  allargsvalid = false
--              end if
            end if
        case SEQ:   -- (-5)
            -- arg is {TYPE=SEQ,NAME="{",LINE,BEGIN,END,ARGS}
            --         (where LINE,BEGIN,END locate the source "{")
            res = {}
            name = arg[NAME]
            if name!="{" then ?9/0 end if
            if length(arg)!=ARGS then ?9/0 end if
            arg = arg[ARGS]
            -- arg is {[odd,{",",odd}],"}"}
            -- where "," and "}" are really {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
            --  (and odd are as per argi with and_bits(ai,1)=1 below)
            --  (actually, a trailing "," is also allowed (and no "}"), for ",$" etc.)
            if and_bits(length(arg),1) then ?9/0 end if
            for ai=1 to length(arg) do
                sequence argi = arg[ai]
--              name = argi[NAME]
                if and_bits(ai,1)=1 then
--                  aitype = argi[TYPE]
--                  if not find(aitype,{IDENT,FUNC}) then ?9/0 end if
                    if find(argi[TYPE],{IDENT,FUNC}) then
--                  if aitype=IDENT then
                        newpid = lastnode+1
--                      res &= resolve_arg(argi,pid,aschild)
                        res &= resolve_arg(0,argi,pid,ai=1)
--                      res &= resolve_arg(argi,pid,0)  -- OK (or the one above???)
--                      res &= resolve_arg(argi,newpid,aschild)
--                      res &= resolve_arg(argi,lastnode,aschild)   -- NO
                        pid = newpid
--                  elsif aitype=FUNC then
--                      -- argi is {TYPE=FUNC,NAME,LINE,BEGIN,END,ARGS,TARGET}
----                        ?9/0
--                      newpid = lastnode+1
----                        res &= create_control(0,argi,pid,aschild)
--                      res &= resolve_arg(argi,pid,aschild)
----                        res &= resolve_arg(argi,pid,0)  -- NO
----                        res &= create_control(0,argi,newpid,aschild)
----                        res &= create_control(0,argi,lastnode,aschild)
--                      pid = newpid
--                  else
--                      ?9/0
                    end if
                else
                    if argi[TYPE]!=SYMBOL then ?9/0 end if
                    -- argii is {TYPE=SYMBOL,NAME=(","|"}"),LINE,BEGIN,END}
                    name = argi[NAME]
                    if name!="," then
                        if ai<length(arg) then ?9/0 end if
                        if name!="}" then ?9/0 end if
                    end if
                end if
            end for
        case DIGIT:
            -- arg is {TYPE=DIGIT,tokint,LINE,BEGIN,END,ARGS}
            res = arg[2]
        case FUNC:
--          res = create_control(0,arg,pid,aschild)
            res = create_control(adx,arg,pid,aschild)
--          res = create_control(0,arg,pid,0)   --NO
--          res = create_control(0,arg,lastnode,aschild)    -- NO
        default:
--          ?{"resolve_arg",arg}
            ?{"resolve_arg",arg,"(allargsvalid:=false), errorcount+=1 line 3770"}
            allargsvalid = false
            errorcount += 1
            res = -3
    end switch
--?{"<<resolve_arg",arg}
    return res
end function

--SUG make pGUI.e/paramormalise global, for use here.

sequence RASTERSIZENULL = {}

--procedure apply_update(Ihandle ih, integer i)
procedure apply_update(integer ih, integer i, integer hdx)
    if parse_data[i][TYPE]!=PROC then ?{"9/0p",i,"!=PROC"} end if
    if length(children[i]) then ?9/0 end if
    if length(updates[i]) then ?9/0 end if
    string procname = parse_data[i][NAME]
--if procname="IupSetCallback" then trace(1) end if
--  integer procdx = find(procname,iupnames)
    integer procdx = find(procname,IupProcs)
    sequence args = parse_data[i][ARGS]
    allargsvalid = true
    for k=1 to length(args) do
        args[k] = resolve_arg(0,args[k],0,false)
        if k=2 and args[2]="PARENTDIALOG" then
            allargsvalid = false
            ?{"PARENTDIALOG",args,"(allargsvalid:=false) [errorcount +=1, line 3658]"}
            errorcount += 1
            exit
        end if
    end for
--20/11/17 (for CircleDraw):
--{">>IupSetStrAttribute",{14244952,"TITLE","Adjust diameter of circle at (%d,%d)","invalidinvalid"}}
    if procname="IupSetStrAttribute"
    and not allargsvalid
    and length(args)=4
    and Ihandle(args[1])
    and string(args[2])
    and string(args[3]) then
--      ?{">>IupSetStrAttribute",args}
        args = args[1..3]
        allargsvalid = true
    end if

    if procname="IupSetAttribute"
    and length(args)>=3
    and args[2]="RASTERSIZE"
    and args[3]=NULL then
        -- A very specific requirement/assumption:
        -- IupSetAttribute(ih,"RASTERSIZE",NULL) to be done after IupMap().
--      printf(1,"IupSetAttribute(%d,\"RASTERSIZE\",NULL) [deferred]\n",{ih})
--      RASTERSIZENULL = append(RASTERSIZENULL,{ih,dialogs[i]})
        RASTERSIZENULL = append(RASTERSIZENULL,{ih,dialogN[i]})
--      RASTERSIZENULL = append(RASTERSIZENULL,{ih,i})
    elsif procname!="IupSetCallback"
      and allargsvalid then
--?{procname,procdx,ih}
--  printf(1,"call_proc(%s[%d],%s)\n",{procname,iuprids[procdx],sprint(args)})
--  printf(1,"call_proc(%s[%d],%s)[%d]\n",{procname,iuprids[procdx],sprint(args),ih})
if SHOWCONTROLS then
--      printf(1,"call_proc(%s[%d],%s)[%d]\n",{procname,procdx,sprint(args),ih})
        printf(1,"call_proc(%s,%s)\n",{procname,sprint(args)})
end if
--      call_proc(iuprids[procdx],args)
        if find(args[1],{-1,-2}) then
            ?"oops, args[1] is -1/-2 [errorcount +=1, line 3681]"
            errorcount += 1
        else
            call_proc(IupProcIds[procdx],args)
            if hdx!=0 then
                if procname="IupSetAttribute"
                or procname="IupSetStrAttribute" then
                    all_properties[hdx] = append(all_properties[hdx],args[2])
                elsif procname="IupSetAttributes" then
                    sequence {names,vals} = parse_attributes(args[2])
                    all_properties[hdx] &= names
                elsif procname!="IupSetAttributeHandle" then
                    ?{"???[3935]"&procname}
                end if
            end if
        end if
    else -- (not allargsvalid)
if SHOWCONTROLS then
--      printf(1,"[not] call_proc(%s[%d],%s)[%d]\n",{procname,procdx,sprint(args),ih})
        printf(1,"[not 3835] call_proc(%s,%s)\n",{procname,sprint(args)})
end if
    end if
end procedure

integer once = 0
--procedure create_control(integer i)
function create_control(integer i, sequence pdi, integer pid, bool aschild)
--
-- i is 0 from resolve_arg(ie nested), else from dialogs[] or children[] (an index to parse_data)
-- pdi is from arg (if nested), else parse_data[i]
-- pid is -1 for root, else passed through (do we need a separate field??)
-- aschild is
--
atom res
--integer wasnode = nextnode
bool bBranch
string aibl
integer newpid
integer newpid2 = pid
integer thisnode
integer hdx = 0
--?{"create_control",i,pdi}
    if pdi[TYPE]!=FUNC then ?9/0 end if
    string funcname = pdi[NAME]
    integer funcdx = find(funcname,iupnames)
--  if funcdx=0 or find(funcname,{"Icallback","length","get_image","sprintf","buildDummyData"}) then
    if funcdx=0 then
        if not find(funcname,{"Icallback"}) then
            allargsvalid = false
            if once=0 then
                ?{funcname,"(argsvalid:=false) [errorcount +=1, line 3719]"}
                once = 1
            end if
            errorcount += 1
        end if
        res = NULL
    else
        string nodename = funcname
        if upper(cem[funcdx])!='M' then
--          res = NULL
--          bBranch = (find(cem[funcdx],"CM")!=0)
            bBranch = (cem[funcdx]='C')
            integer kdx = find(i,namedx)
            if kdx then
                nodename &=" ("&names[kdx]&")"
--          elsif find(funcname,{"IupSubMenu","IupSubmenu","IupMenuItem","IupItem"})
--            and pdi[ARGS][1][TYPE]=DQUOTE then
--              nodename &=" ("&pdi[ARGS][1][NAME]&")"
            end if
            aibl = iff(aschild?"ADD":"INSERT")&iff(bBranch?"BRANCH":"LEAF")
--printf(1,"IupSetAttributeId(hierarchytree, \"%s\", %d, \"%s\")  -- [pid=%d,bBranch=%d,aschild=%d,i=%d,kdx=%d]\n",{aibl,lastnode,nodename,pid,bBranch,aschild,i,kdx})
--          IupSetAttributeId(hierarchytree, aibl, lastnode, nodename);
--          newpid = iff(kdx?pid:lastnode)
if SHOWBRANCHINFO then
printf(1,"IupSetAttributeId(hierarchytree, \"%s\", %d, \"%s\")  -- [pid=%d,lastnode=%d,bBranch=%d,aschild=%d,i=%d,kdx=%d]\n",{aibl,pid,nodename, pid,lastnode,bBranch,aschild,i,kdx})
end if
--if lastnode=5 then ?9/0 end if
--if pid=9 then ?9/0 end if
            IupSetAttributeId(hierarchytree, aibl, pid, nodename);
--          string icon = icons[funcdx]
            string icon = get_image(icons[funcdx])
            lastnode += 1
            thisnode = lastnode
            if USETREEIMAGES then
                IupSetAttributeId(hierarchytree, "IMAGE", thisnode, icon)
                if bBranch then
                    IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", thisnode, icon)
                end if
            end if
        end if -- (not menus)
        sequence args = pdi[ARGS]
        allargsvalid = true
--?funcname
        integer childk = iff(find(funcname,{"IupSubMenu","IupSubmenu","IupMenuItem","IupItem"})?2:1)
        for k=1 to length(args) do
            newpid = lastnode
            args[k] = resolve_arg(0,args[k],newpid,k=childk)
        end for
        string lhs = iff(i=0?"res":sprintf("handles[%d]",{i}))
--?{"<<",funcname}
        if not allargsvalid then
            lhs = "[not]" & lhs
--          errorcount += 1 (already accounted for?)
        end if
--DEV we might want to build the dialog from the tree...
if SHOWCONTROLS then
--      printf(1,"%s = call_func(%s[%d],%s)\n",{lhs,funcname,iuprids[funcdx],sprint(args)})
        printf(1,"%s = call_func(%s,%s)\n",{lhs,funcname,sprint(args)})
end if
        res = -2    --DEV fake/temp
        if allargsvalid then
            if length(args) and (args[1]=-2 or (sequence(args[1]) and find(-2,args[1]))) then
                ?"oops, -2 in args 1 [errorcount +=1, line 3802]"
                errorcount += 1 
            else
--DEV...
--  (eg) args = {"Restore me!",0,"EXPAND=YES, ACTIVE=NO"}
--sequence wasargs
--DEV can we do this on sig[funcdx]?
                if find(funcname,{"IupButton","IupToggle"})
--              if find(funcname,{"IupButton","IupToggle","IupText"})   -- maybe, didne help...
-- (but what I think might help (Booker.exw) is
--      handles[9] = call_func(IupText,{"VALUECHANGED_CB",0})
--  ==> handles[9] = call_func(IupText,{}) - which is a different thing...)
                and length(args)>=2 
                and args[2]=NULL then
-- wasargs = args
                    args[2..2] = {}
                elsif find(funcname,{"IupList"})
                and length(args)>=1 
                and args[1]=NULL then
-- wasargs = args
                    args[1..1] = {}
                end if

                res = call_func(iuprids[funcdx],args)
                all_handles = append(all_handles,res)
                all_funcdx = append(all_funcdx,funcdx)
                hdx = length(all_handles)
                all_tags = append(all_tags,hdx)
                if upper(cem[funcdx])!='M' then
                    IupTreeSetUserId(hierarchytree, thisnode, hdx) 
                    nodename = sprintf("[%d] %s",{hdx,nodename})
                    IupSetAttributeId(hierarchytree,"TITLE",thisnode,nodename)
--                  printf(1,"IupTreeSetUserId(hierarchytree,%d,%d)\n",{thisnode, hdx})
                end if
--              all_properties = append(all_properties,IPROPS)
                all_properties = append(all_properties,iprops(funcdx))
                integer a1 = 1
                --ditto:
                if funcname="IupLabel" then
                    a1 = 2
                end if
                for ai=a1 to length(args) do
                    object arg = args[ai]
                    if string(arg) 
                    and find('=',arg)!=0 then
                        sequence {names,vals} = parse_attributes(arg)
                        all_properties[hdx] &= names
                    end if
                end for
--wasargs = {}
            end if
            if i!=0 then
                handles[i] = res
--20/11/17:
integer wasvalid = allargsvalid,
        waserrorcount = errorcount
                for k=1 to length(updates[i]) do
                    apply_update(res,updates[i][k],hdx)
                end for
allargsvalid = wasvalid
errorcount = waserrorcount
            end if
        end if
    end if
--?{"<<create_control",i}
    return res
end function

--/*
procedure show_dialog(integer di)
    IupShow(handles[di])
    for i=1 to length(RASTERSIZENULL) do
        if sequence(RASTERSIZENULL[i])
        and RASTERSIZENULL[i][2]=di then
            Ihandle ih = RASTERSIZENULL[i][1]
--          if ih!=NULL then
            IupSetAttribute(ih,"RASTERSIZE",NULL)
            RASTERSIZENULL[i] = 0
        end if
    end for
end procedure
--RASTERSIZENULL = {}
--*/


--{} = wait_key()

Ihandle dlg
Ihandln livedisplay = NULL

function live_key_cb(Ihandle /*ih*/, atom c)
    if    c=K_F1 then ?"F1(live)"
    elsif c=K_ESC then IupHide(dlg) return IUP_CLOSE
    end if
    return IUP_CONTINUE
end function
constant cb_live_key = Icallback("live_key_cb")

function live_close_cb()
-- prevent (accidental) closure... [DEV should we?? - probably not!]
--DEV IupAlarm?
    return IUP_IGNORE
end function
constant cb_live_close = Icallback("live_close_cb")

function close_cb()
    if livedisplay!=NULL then
        -- otherwise app keeps running...
        -- (and as livedisdplay cannot be closed...)
        IupHide(livedisplay)
    end if
    return IUP_CLOSE
end function
constant cb_close = Icallback("close_cb")

string default_property = ""

Ihandln p_element = NULL,
        p_new,
        p_space_only,
        p_desc = NULL,
        p_attrib_list

--DEV [SPACE] to be filled in... (requires a thorough investigation...)
constant ONSET = {"SIZE","USERSIZE","RASTERSIZE","CLIENTSIZE"},
         NOTDEF = {"MINSIZE"}

function filter_sort(sequence properties)
string space_only = IupGetAttribute(p_space_only,"VALUE")
integer k = find(space_only,{"OFF","ON","NOTDEF"})
sequence res = {}
    for i=1 to length(properties) do
        string pi = properties[i]
        if  k=1
        or (k=2 and find(pi,ONSET))
        or (k=3 and find(pi,NOTDEF)) then
            if not find(pi,res) then
                res = append(res,pi)
            end if
        end if
    end for
    res = sort(res)
    return res
end function

--DOC:
-- The leading numbers shown on elements are not meant to be particularly meaningful, other than
-- to confirm that "[7] IupFill" is not the same as "[9] IupFill". They are in fact indexes to
-- the internal table of handles, initially in the order of creation but that can change with
-- insertions/deletions and drag/drop, so typically expect 1 and 2 to be on leaf nodes and the
-- top level IupDialog to have (at least initially) the highest allocated number.

function selection_cb(Ihandle /*hierarchytree*/, integer id, status) 
--?{"selection_cb",id,status}
    if status=1 then    -- selected
        -- set properties as the tree nodes are selected:
        integer userdata = IupTreeGetUserId(hierarchytree, id) 
        p_element = all_handles[userdata]

--      ?{"id",id,"userdata",userdata}  -- (OK)
        if p_desc!=NULL then
--          property_id = userdata
            string title = IupGetAttributeId(hierarchytree, "TITLE", id)
--DEV/test:
if IupGetAttributePtr(p_element,"WID")=NULL then
    title &= "*** NOT MAPPED ***"
end if
--          title = sprintf("[%d] %s",{userdata,title})
            IupSetAttribute(p_desc,"TITLE",title)
            IupRedraw(p_desc)
--if userdata!=0 then
--?{all_handles[userdata],all_properties[userdata]}
----?{"all_handles[userdata],all_properties[userdata]"}
--else
--?{"selection_cb,[0],[0]"}
--end if
            sequence properties = all_properties[userdata]
--          if IupGetInt(p_space_only,"VALUE")
--?{"toggle",IupGetInt(p_space_only,"VALUE")}   -- only does 1/0
--?{"toggle",IupGetAttribute(p_space_only,"VALUE")}
            properties = filter_sort(properties)
            IupSetStrAttribute(p_attrib_list,"REMOVEITEM","ALL")
            string p1 = ""
            integer l = length(properties)
            if l!=0 then
--              p_element = all_handles[userdata]
                for i=1 to l do
                    string pi = properties[i]
                    pi &= " = "&IupGetAttribute(p_element,pi)
                    IupSetStrAttributeId(p_attrib_list,"",i,pi)
                end for
--SUG if we can find the last property, select that... [DONE]
--DOC/help:
-- Selecting a property from the list makes it the default; if that
-- property can be found when a different tree node is selected, it
-- is displayed as the selected list item, otherwise the first item
-- in the list is shown selected. However, should you then select a
-- different list item that /does/ have that property, it will once
-- again become the selected entry. This makes it easier to compare 
-- the same thing on several different elements.

--              p1 = properties[1]
--              if find(default_property,properties) then
--                  p1 = default_property
--              end if
--              IupSetAttribute(p_attrib_list,"VALUE",p1)
--              integer k = find(default_property,properties)
                integer k = max(1,find(default_property,properties))
--              if k=0 then k = 1 end if
                IupSetInt(p_attrib_list,"VALUE",k)

--              Ihandle hud = all_handles[userdata]
--              p1 = IupGetAttribute(hud,p1)
            end if
        end if
    end if
    return IUP_CONTINUE
end function
constant cb_selection = Icallback("selection_cb")

function rightclick_cb(Ihandle /*hierarchytree*/, integer id) 
    IupSetInt(hierarchytree,"VALUE",id)
    return selection_cb(hierarchytree, id, 1)
end function
constant cb_rightclick = Icallback("rightclick_cb")


function space_cb(Ihandle /*p_space_only*/, integer state)
--?{"space",state}
    integer id = IupGetInt(hierarchytree,"VALUE")
    {} = selection_cb(hierarchytree, id, 1) 
    return IUP_CONTINUE
end function
constant cb_space = Icallback("space_cb")


function list_action_cb(Ihandle /*p_attrib_list*/, atom pText, integer /*item*/, state)
    if state=1 then -- selected
        string property = peek_string(pText)
        property = property[1..match(" = ",property)-1]
        default_property = property
    end if
    return IUP_CONTINUE
end function
constant cb_list_action = Icallback("list_action_cb")

bool enable_globalmotion = true -- (false while popups showing)

Ihandln attrib_dlg = NULL,
        attrib_name,
        attrib_value

Ihandln insert_dlg = NULL

bool error_showing = false

procedure re_enable_globalmotion()
    if (insert_dlg=NULL or IupGetAttribute(insert_dlg,"VISIBLE")="NO")
    and (attrib_dlg=NULL or IupGetAttribute(attrib_dlg,"VISIBLE")="NO")
    and not error_showing then
        enable_globalmotion = true
    end if      
end procedure

integer attrib_id  -- the tree node when edit attributes window opened

function attrib_ok_cb(Ihandle /*attrib_ok*/)
    string name = upper(IupGetAttribute(attrib_name,"VALUE")),
           val = IupGetAttribute(attrib_value,"VALUE")
    if length(name) then
        integer id = IupTreeGetUserId(hierarchytree, attrib_id) 
        Ihandle ih = all_handles[id]
        IupSetStrAttribute(ih,name,val)
        if not find(name,all_properties[id]) then
            all_properties[id] = append(all_properties[id],name)
        end if
        -- refresh
        {} = selection_cb(hierarchytree, attrib_id, 1) 
IupSetAttribute(ih, "SIZE", NULL)
IupUnmap(ih)
IupMap(ih)
IupSetAttribute(ih, "VISIBLE", "YES")
        IupRefresh(ih)
    end if
    IupHide(attrib_dlg)
    re_enable_globalmotion()
    return IUP_CONTINUE
end function
constant cb_attrib_ok = Icallback("attrib_ok_cb")

function attrib_escape_cb(Ihandle /*attrib_dlg*/, atom c)
    if c=K_ESC then
        IupHide(attrib_dlg)
        re_enable_globalmotion()
    end if
    return IUP_CONTINUE
end function
constant cb_attrib_escape = Icallback("attrib_escape_cb")


procedure edit_attrib(string name, string val)

    if attrib_dlg=NULL then
        Ihandle lbl1 = IupLabel("Attribute:")
        attrib_name = IupText("EXPAND=HORIZONTAL")
        Ihandle lbl2 = IupLabel("Value:")
        attrib_value = IupText("EXPAND=HORIZONTAL")
        Ihandle hbox1 = IupHbox({lbl1,attrib_name},
                        "MARGIN=5x5,NORMALIZESIZE=VERTICAL")
        Ihandle hbox2 = IupHbox({lbl2,attrib_value},
                        "MARGIN=5x5,NORMALIZESIZE=VERTICAL")
        Ihandle attrib_ok = IupButton("Ok",cb_attrib_ok)
        Ihandle hbox3 = IupHbox({IupFill(),attrib_ok,IupFill()})
        Ihandle vbox = IupVbox({IupFill(),hbox1,IupFill(),hbox2,IupFill(),hbox3},
                        "MARGIN=5x5")
        attrib_dlg = IupDialog(vbox,"MINSIZE=400x150")
        IupSetCallback(attrib_dlg,"K_ANY",cb_attrib_escape)
        IupSetAttributeHandle(attrib_dlg,"DEFAULTENTER",attrib_ok)
        IupMap(attrib_dlg) -- (set NATURALSIZE for first use)
    end if  -- (p_edit=NULL)

    -- first save the item this attribute is for...
    attrib_id = IupGetInt(hierarchytree,"VALUE")

    string ref_title = IupGetAttributeId(hierarchytree,"TITLE",attrib_id)

    IupSetStrAttribute(attrib_dlg,"TITLE","Attribute for "&ref_title)
    IupSetStrAttribute(attrib_name,"VALUE",name)
    IupSetStrAttribute(attrib_value,"VALUE",val)

    Ihandle start_focus = iff(length(name)?attrib_value:attrib_name)
    IupSetAttributeHandle(attrib_dlg,"STARTFOCUS",start_focus)

    enable_globalmotion = false

    integer {x,y} = IupGetIntInt(NULL,"CURSORPOS")
    integer {rx,ry} = sq_floor_div(IupGetIntInt(attrib_dlg,"NATURALSIZE"),2)
    x = max(0,x-rx)
    y = max(0,y-ry)
    IupShowXY(attrib_dlg,x,y)
end procedure

function dblclick_cb(Ihandle /*p_attrib_list*/, integer /*item*/, atom pText)
--?{"dblclick_cb",peek_string(pText)}
    string text = peek_string(pText)
    integer k = match(" = ",text)
    edit_attrib(text[1..k-1],text[k+3..$])
    return IUP_CONTINUE
end function
constant cb_dblclick = Icallback("dblclick_cb")


function key_cb(Ihandle /*ih*/, atom c)
    if c=K_F1 then ?"F1" end if
    return iff(c=K_ESC?IUP_CLOSE:IUP_CONTINUE)
end function

function exit_cb(Ihandle /*ih*/)
--DEV talk to edix!! (move IUP_CLOSE to some later dialog??)
    return IUP_CLOSE
end function

function test_cb(Ihandle /*ih*/)
--DEV (create pguide_test.exw, with mods, and run it)
?9/0
    IupMessage("test","not implemented")
    return IUP_CONTINUE
end function

function help_cb(Ihandle /*ih*/)
--DEV (or open phix.chm, on a specific (new) page, possibly via edix...)
    IupMessage("help","some help text")
    return IUP_CONTINUE
end function
constant cb_help = Icallback("help_cb")


--DEV/SUG add this to pGUI?
--procedure IupSetAttributeIds(Ihandle ih, sequence names, integer id, atom_string v)
--  for i=1 to length(names) do
--      IupSetAttributeId(ih, names[i], id, v)
--  end for
--end procedure

--/*
procedure setup_tree()
--DEV (temp)
--  IupSetAttribute(tree, "TITLE0",     "Dialogs")
if SHOWDESIRED then
?srcname
    if srcname="fill.exw" then
--/*
1:{20, "IupFrame", 1,23,18,25,
2:  {{20, "IupHbox", 0,23,27,33,
    {{-5, "{", 0,23,35,35,
3:    {{20, "IupButton", 0,23,36,44, {{2, "Ok", 0,23,47,48}}, 0},
4:     {1, ",", 0,23,51,51}, {20, "IupFill", 0,23,52,58, {}, 0},
       {1, "}", 0,23,61,61}}}}, 0},
   {2, "TITLE=\\\"Left aligned\\\"", 0,23,65,86}},
  {10, "frame_left", 0,23,5,14}},
1[1]:frame_left, IupFrame, "TITLE=\\\"Left aligned\\\""
2:IupHbox
3:IupButton,"Ok"
4:IupFill
5: {20, "IupFrame", 2,26,20,27,
6:  {{20, "IupHbox", 0,26,29,35,
    {{-5, "{", 0,26,37,37,
7:    {{20, "IupFill", 0,26,38,44, {}, 0}, {1, ",", 0,26,47,47},
8:     {20, "IupButton", 0,26,48,56, {{2, "Ok", 0,26,59,60}}, 0},
9:     {1, ",", 0,26,63,63}, {20, "IupFill", 0,26,64,70, {}, 0},
       {1, "}", 0,26,73,73}}}}, 0}, {2, "TITLE=Centered", 0,26,77,90}},
  {10, "frame_center", 0,26,5,16}},
5[2]:frame_center, IupFrame, "TITLE=\\\"Centered\\\""
6:IupHbox
7:IupFill
8:IupButton,"Ok"
9:IupFill
10: {20, "IupFrame", 3,29,19,26,
11:  {{20, "IupHbox", 0,29,28,34,
    {{-5, "{", 0,29,36,36,
12    {{20, "IupFill", 0,29,37,43, {}, 0}, {1, ",", 0,29,46,46},
13     {20, "IupButton", 0,29,47,55, {{2, "Ok", 0,29,58,59}}, 0},
       {1, "}", 0,29,62,62}}}}, 0},
   {2, "TITLE=\\\"Right aligned\\\"", 0,29,66,88}},
  {10, "frame_right", 0,29,5,15}},
10[3]:frame_right, IupFrame, "TITLE=\\\"Right aligned\\\""
11:IupHbox
12:IupFill
13:IupButton,"Ok"
14: {20, "IupDialog", 4,32,14,22,
15:  {{20, "IupVbox", 0,32,24,30,
    {{-5, "{", 0,32,32,32,
      {{10, "frame_left", 0,32,33,42}, {1, ",", 0,32,43,43},
       {10, "frame_center", 0,32,44,55}, {1, ",", 0,32,56,56},
       {10, "frame_right", 0,32,57,67}, {1, "}", 0,32,68,68}}}}, 0}},
  {10, "dialog", 0,32,5,10}},
14[4]:dialog,IupDialog,"SIZE=120, TITLE=IupFill","K_ANY",Icallback("esc_close")
15:IupVbox
 {21, "IupSetAttributes", 5,35,55,55,
  {{10, "dialog", 0,35,22,27}, {2, "SIZE=120, TITLE=IupFill", 0,35,31,53}}},
 {21, "IupSetCallback", 6,36,59,59,
  {{10, "dialog", 0,36,20,25}, {2, "K_ANY", 0,36,29,33},
   {20, "Icallback", 0,36,37,45, {{2, "esc_close", 0,36,48,56}}, 0}}}}
==
dialogs: {4}
dialoglines: {32}
dialogN: {4,4,4,4,4,4}
dlevel: {2,2,2,1,1,1}
names: {"frame_left","frame_center","frame_right","dialog"}
namedx: {1,2,3,4}
children: {{},{},{},{1,2,3},{},{}}
updates: {{},{},{},{5,6},{},{}}
cud: cccduu
fill.exw
---*** WE NEED TO STORE THESE HANDLES SOMEWHERE!!! *** (and I vote within parse_data!)
res = call_func(IupButton,{"Ok"})
res = call_func(IupFill,{})
res = call_func(IupHbox,{{15220008,15225200}})
handles[1] = call_func(IupFrame,{15225376,"TITLE=\"Left aligned\""})
res = call_func(IupFill,{})
res = call_func(IupButton,{"Ok"})
res = call_func(IupFill,{})
res = call_func(IupHbox,{{15222912,15224848,15223440}})
handles[2] = call_func(IupFrame,{15224760,"TITLE=Centered"})
res = call_func(IupFill,{})
res = call_func(IupButton,{"Ok"})
res = call_func(IupHbox,{{15222824,15224144}})
handles[3] = call_func(IupFrame,{15223264,"TITLE=\"Right aligned\""})
res = call_func(IupVbox,{{15224672,15224232,15223176}})
handles[4] = call_func(IupDialog,{15223704})
call_proc(IupSetAttributes,{15223880,"SIZE=120, TITLE=IupFill"})
call_proc(IupSetCallback,{15223880,"K_ANY",0})
handles: {15224672,15224232,15223176,15223880,0,0}
--*/

    end if

end if

end procedure
--*/

--function valuechanged_cb(Ihandle ih)
--  printf(1,"VALUECHANGED_CB(%s)=%s\n",{IupGetClassName(ih), IupGetAttribute(ih, "VALUE")});
--  return IUP_DEFAULT;
--end function

--function esc_close(Ihandle /*ih*/, atom c)
---- (I like all my demos to close when escape is keyed)
--  return iff(c=K_ESC?IUP_CLOSE:IUP_CONTINUE)
--end function

procedure make_live(integer dx)
    if dx!=0 then
        lastbranch = -1
        lastnode = -1
        integer di = dialogs[dx]
        handles[di] = -1
        handles[di] = create_control(di,parse_data[di],lastbranch,false)
        puts(1,"handles: ") ?handles

        if errorcount!=0 then
            IupMessage("oops","%d errors detected",{errorcount})
            errorcount = 0
        end if
        if errorcount=0 then
            if Ihandle(handles[di]) then
                livedisplay = handles[di]
            end if
        end if
    else
        -- new window
        livedisplay = IupDialog(NULL,"SIZE=200x100")
        all_handles = append(all_handles,livedisplay)
        integer hdx = length(all_handles)
        all_tags = append(all_tags,hdx)
--[DEV/SUG] constant K_Dialog?
        integer funcdx = find("IupDialog",iupnames)
        all_funcdx = append(all_funcdx,funcdx)
--      all_properties = append(all_properties,IPROPS)
        all_properties = append(all_properties,iprops(funcdx))
        all_properties[hdx] = append(all_properties[hdx],"TITLE")
        IupSetStrAttributeId(hierarchytree, "INSERTBRANCH", -1, "[%d] IupDialog()",{hdx})
  if USETREEIMAGES then
        string icon = get_image(icons[funcdx])
        IupSetAttributeId(hierarchytree, "IMAGE", 0, icon)
        IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", 0, icon)
  end if
        IupTreeSetUserId(hierarchytree, 0, hdx)
--erm...
--      handles = {livedisplay}
    end if
    if livedisplay!=NULL then
        -- prevent (accidental) closure:
        IupSetCallback(livedisplay, "CLOSE_CB", cb_live_close);
        IupSetCallback(livedisplay, "K_ANY", cb_live_key);
--test: (BUST)
--      IupSetCallback(livedisplay, "MOTION_CB", Icallback("motion_cb"))
--      IupSetCallback(livedisplay, "ENTERWINDOW_CB", Icallback("enterwindow_cb"))
--  ?{livedisplay,"TITLE",IupGetAttribute(livedisplay,"TITLE")}
        IupShow(livedisplay)
    else
        IupMessage("oops","%d errors detected [livedisplay=NULL]",{errorcount})
    end if
end procedure

Ihandle window_list

function ok_cb(Ihandle /*ok_btn*/)
    make_live(IupGetInt(window_list,"VALUE"))
    return IUP_CLOSE
end function

function new_cb(Ihandle /*new_btn*/)
    make_live(0) -- new window
    return IUP_CLOSE
end function

function new_attr_cb(Ihandle /*p_new*/)
    edit_attrib("","")
    return IUP_DEFAULT
end function
constant cb_new_attr = Icallback("new_attr_cb")

function get_title(sequence args, string title)
    for i=1 to length(args) do
        if args[i][TYPE]=DQUOTE then
            string txt = dequote(args[i][NAME])
            sequence {names,vals} = parse_attributes(txt)
            integer k = find("TITLE",names)
            if k then title = vals[k] end if
        end if
    end for
    return title
end function

procedure window_selection()
Ihandle vbox1, hbox3, hbox2, 
        info, ok_btn, new_btn
integer d
sequence pdd, ud, args
string title

    window_list = IupList("DROPDOWN=YES, EXPAND=HORIZONTAL")

    -- populate window_list, with 'IupDialog("title")' entries:
    for dx=1 to length(dialogs) do
        d = dialogs[dx]
        pdd = parse_data[d]
        if pdd[TYPE]!=FUNC then ?9/0 end if
        if pdd[NAME]!="IupDialog" then ?9/0 end if
        title = ""
        title = get_title(pdd[ARGS],title)
        ud = updates[d]
        for ux=1 to length(ud) do
            d = ud[ux]
            pdd = parse_data[d]
            if pdd[TYPE]!=PROC then ?9/0 end if
            string pname = pdd[NAME]
            if pname="IupSetAttributes" then
                title = get_title(pdd[ARGS],title)
            elsif pname="IupSetStrAttribute"
               or pname="IupStoreAttribute"
               or pname="IupSetAttribute" then
                args = pdd[ARGS]
                if args[1][TYPE]!=IDENT then ?9/0 end if
--              if args[1][NAME]!=?? then ?9/0 end if
--  pdd[1..6] = {21,"IupStoreAttribute",10,108'l',45'-',45'-'}
--  pdd[7] = {{10,"hDialog",0,108'l',19,25},{2,"TITLE",0,108'l',29,33'!'},{2,"Rot 13",0,108'l',38'&',43'+'}}
                if args[2][TYPE]=DQUOTE
                and args[2][NAME]="TITLE"
                and args[3][TYPE]=DQUOTE then
                    title = args[3][NAME]
--elsif args[2][TYPE]!=DQUOTE
--   or not find(args[2][NAME],{"SIZE","TOOLFONT"}) then
----   or args[3][TYPE]!=DQUOTE then
--?{"erm...[6056]","d",d}
--?pdd
                end if
            elsif pname!="IupSetAttributeHandle"
--  pdd[1..6] = {21,"IupSetAttributeHandle",11,109'm',45'-',45'-'}
--  pdd[7] = {{10,"hDialog",0,109'm',23,29},{2,"MENU",0,109'm',33'!',36'$'},{10,"hMenu",0,109'm',40'(',44','}}
--?"erm...."
              and pname!="IupSetCallback"
              and pname!="IupSetInt" then
                ?9/0
            end if
        end for
        IupSetStrAttributeId(window_list,"",dx,sprintf("IupDialog(\"%s\")",{title}))
--DEV/SUG: When integrated with Edix, let that keep a default window per source (per session is fine),
--         which should make it much slicker/less painful to flip between source & layout editing.
        if dx=1 then IupSetInt(window_list,"VALUE",1) end if
    end for

    string itxt = sprintf("%d window%s found",{length(dialogs),iff(length(dialogs)=1?"":"s")})

    info = IupLabel(itxt)
    hbox2 = IupHbox({IupFill(),info,IupFill()})

    ok_btn = IupButton("OK", Icallback("ok_cb"), "PADDING=5x5")
    new_btn = IupButton("New Window", Icallback("new_cb"), "PADDING=5x5")
    Ihandle start_focus = ok_btn,
            default_enter = ok_btn
    if length(dialogs)=0 then
        IupSetAttribute(window_list,"ACTIVE","NO")
        IupSetAttribute(ok_btn,"ACTIVE","NO")
        start_focus = new_btn
        default_enter = new_btn
    elsif length(dialogs)>1 then
        start_focus = window_list
    end if
    hbox3 = IupHbox({IupFill(),ok_btn,IupFill(),new_btn,IupFill()})

    vbox1 = IupVbox({window_list,IupFill(),hbox2,IupFill(),hbox3},"MARGIN=5x5")

    dlg = IupDialog(vbox1,"MINSIZE=300x140")
    IupSetAttribute(dlg,"TITLE","Window to amend")
    IupSetAttributeHandle(dlg,"DEFAULTENTER",default_enter)
    IupSetAttributeHandle(dlg,"STARTFOCUS",start_focus)

--  IupSetCallback(dlg, "K_ANY", Icallback("esc_close"))
    IupCloseOnEscape(dlg)

    IupShow(dlg)

    IupMainLoop()

    IupDestroy(dlg)

end procedure

Ihandle insert_txt,
        insert_drop,
        insert_ref,
        hbox2,
        insert_title,
        insert_ok_btn,
        insert_cancel_btn

bool bTitle

procedure hide_insert()
    IupHide(insert_dlg)
    re_enable_globalmotion()
end procedure

constant add_mode_descs = {"child","sibling","parent"}
sequence add_modes
enum CHILD,SIBLING,PARENT

function insert_escape_cb(Ihandle /*insert_dlg*/, atom c)
    if c=K_ESC then
        hide_insert()
    end if
    return IUP_CONTINUE
end function
constant cb_insert_escape = Icallback("insert_escape_cb")

function insert_close_cb(Ihandle /*insert_dlg*/)
    hide_insert()
    return IUP_IGNORE
end function
constant cb_insert_close = Icallback("insert_close_cb")

integer insert_id       -- an idx to iupnames[] etc

function insert_ok_cb(Ihandle /*ok_btn*/)

    integer option = add_modes[IupGetInt(insert_drop,"VALUE")]
    integer pid = IupGetInt(hierarchytree,"VALUE")
    integer childcount = IupGetIntId(hierarchytree,"CHILDCOUNT",pid)
    Ihandle ih = call_func(iuprids[insert_id],{})
    if bTitle then
        string title = IupGetAttribute(insert_title,"VALUE")
        IupSetStrAttribute(ih,"TITLE",title)
    end if
    all_handles = append(all_handles,ih)
    all_funcdx = append(all_funcdx,insert_id)
--  all_properties = append(all_properties,IPROPS)
    all_properties = append(all_properties,iprops(insert_id))
    integer hdx = length(all_handles)
    integer uid = IupTreeGetUserId(hierarchytree, pid)
    all_tags[uid+1..uid] = {hdx}
--/*
-- or, maybe:
    all_tags &= hdx
    sort_tags()
--*/
    string nodename = sprintf("[%d] %s",{hdx,iupnames[insert_id]})
    bool bBranch = (find(cem[insert_id],"CM")!=0)
    string aibl, bl = iff(bBranch?"BRANCH":"LEAF")
--  Ihandle refh = all_handles[pid]
    Ihandle refh = all_handles[uid]
    integer {x,y} = IupGetIntInt(livedisplay,"SCREENPOSITION")
--  IupUnmap(livedisplay)
    integer thisnode

    if option=PARENT then
        if bBranch=false then ?9/0 end if
        Ihandle ph = IupGetParent(refh)
--DANG fails for single-child containers...
--IupUnmap/IupDetach...
--Simplification 1: Let IupSplit, being the only 2-child case, sometimes get it wrong...
--or: integer count = IupGetChildCount(Ihandle ih) 
-- integer pos = IupGetChildPos(Ihandle ih, Ihandle child) (returns 0/1, -1 if not found)
        integer k = find(ph,all_handles)
        if max_children[all_funcdx[k]]>0 then
--not sure this helps one jot...
            IupSaveClassAttributes(refh)
            IupDetach(refh)
            IupInsert(ph,NULL,ih)
            IupMap(ih)
--          IupInsert(ih,NULL,refh)
            IupAppend(ih,refh)
            IupMap(refh)
        else
            IupInsert(ph,refh,ih)
            IupMap(ih)
            if IupReparent(refh, ih, NULL)!=IUP_NOERROR then
                IupMessage("oops","reparent fairure")
            end if
        end if
--      IupMap(ih)
        IupSetAttributeId(hierarchytree, "INSERTBRANCH", pid, nodename)
        thisnode = IupGetInt(hierarchytree,"LASTADDNODE")
        -- bit messy but it works:
        IupSetAttributeId(hierarchytree, "ADDLEAF", thisnode, "TEMP")
        IupSetIntId(hierarchytree, "MOVENODE", pid, thisnode+1)
        IupSetAttributeId(hierarchytree, "DELNODE", pid+1, "SELECTED")
        thisnode = pid
    else
        if option=CHILD then
            IupInsert(refh,NULL,ih)
            aibl = "ADD"&bl
        elsif option=SIBLING then
            Ihandle ph = IupGetParent(refh)
            Ihandln next = IupGetNextChild(ph,refh)
            if next=NULL then
                IupAppend(ph,ih)
            else
                IupInsert(ph,next,ih)
            end if
            aibl = "INSERT"&bl
        else
            ?9/0    -- unknown option
        end if
        IupMap(ih)
        IupSetAttributeId(hierarchytree, aibl, pid, nodename)
        thisnode = IupGetInt(hierarchytree,"LASTADDNODE")
        if bBranch then
            -- add then immediately remove a child, to force expanded status:
            IupSetAttributeId(hierarchytree, "ADDLEAF", thisnode, "TEMP")
            IupSetAttributeId(hierarchytree, "DELNODE", thisnode+1, "SELECTED")
        end if
    end if

--?{"thisnode",thisnode}
    IupTreeSetUserId(hierarchytree, thisnode, hdx)
  if USETREEIMAGES then
    string icon = get_image(icons[insert_id])
    IupSetAttributeId(hierarchytree, "IMAGE", thisnode, icon)
    if bBranch then
        IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", thisnode, icon)
    end if
  end if
    IupRefresh(livedisplay)
--no help??
--  IupSaveClassAttributes(livedisplay) 
--/!*
--  IupMap(livedisplay)
--  IupShowXY(livedisplay,x,y)
--*!/

--/*
    aibl = iff(aschild?"ADD":"INSERT")&iff(bBranch?"BRANCH":"LEAF")

    IupSetAttributeId(hierarchytree, aibl, pid, nodename);

    IupSetAttributeId(hierarchytree, "IMAGE", thisnode, icon)
    if bBranch then
        IupSetAttributeId(hierarchytree, "IMAGEEXPANDED", thisnode, icon)
    end if

    string nodename = funcname
    nodename = sprintf("[%d] %s",{hdx,nodename})
    IupSetAttributeId(hierarchytree,"TITLE",thisnode,nodename)

    error = IupReparent(drag_elem, drop_elem, ref_child)

    IupTreeSetUserId(hierarchytree, thisnode, hdx) 
--*/
    hide_insert()
    return IUP_CONTINUE
end function
constant cb_insert_ok = Icallback("insert_ok_cb")

function cancel_cb(Ihandle /*ok_btn*/)
    hide_insert()
    return IUP_CONTINUE
end function
constant cb_cancel = Icallback("cancel_cb")

constant K_IupDialog = find("IupDialog",iupnames),
--       K_IupMenu   = find("IupMenu",iupnames),
--       K_IupSubmenu = find("IupSubmenu",iupnames),
--       K_IupSeparator = find("IupSeparator",iupnames),
         K_IupVbox = find("IupVbox",iupnames)


procedure set_add_modes(integer id, integer pid, integer children, integer tid, integer grandkids)
--
--  set add_modes as valid for adding id as child/sibling/parent of tid, where tid's parent is pid
--
--  id, pid, and tid are indexes to iupnames[] etc.
--  id is the element type being added (as selected from the pop-up menu)
--  pid is the type of the parent of the target node (0 if tid==K_Dialog)
--  tid is the type of the target node (as right-clicked on)
--  children is the already existing count on puid.
--   (ie whereby we got pid from all_funcdx[puid])
--  grandkids is the already existing count on tuid
--   (ie whereby we got tid from all_funcdx[tuid])
--
-- Technical note: this has been written without using (existing) Ihandles, and forcing the caller to
--  invoke IupGetParent and IupGetChildCount, etc, so that it can be fully unit tested, and in fact 
--  this whole routine was originally factored out solely for unit testing/tdd purposes.
--
    
    if id=K_IupDialog then
        add_modes = {}
    elsif tid=K_IupDialog then
        if grandkids=0 then
            add_modes = {CHILD}
        else
            add_modes = {}
        end if
    else
        integer mci = max_children[tid]
        switch mci do
            case 0:     add_modes = {SIBLING}
            case 1:     add_modes = iff(grandkids=1?{SIBLING}:{CHILD,SIBLING})
            case 2:     add_modes = iff(grandkids=2?{SIBLING}:{CHILD,SIBLING})
            case -1:    add_modes = {CHILD,SIBLING}
            else ?9/0
        end switch
    end if

    if tid!=K_IupDialog then
        if max_children[pid]=children then
            integer k = find(SIBLING,add_modes)
            if k then
                add_modes[k..k] = {}
            end if
        end if
    end if

    if max_children[tid]=grandkids then
        integer k = find(CHILD,add_modes)
        if k then
            add_modes[k..k] = {}
        end if
    end if

--  sig = clean_sig(id)


--XXX (menus gone)
    -- Aside: it is IupMenu->IupSubMenu->IupMenu, ie you cannot have an IupMenu as 
    --  a (direct) child of an IupMenu, and an IupSubMenu can only take an IupMenu
    --  as a child. Therefore PARENT (ie squidge id between pid and tid) is never 
    --  valid in any menu-related cases, ever. Drag and drop is available instead.

    if id!=K_IupDialog
    and tid!=K_IupDialog
--  and not find(cem[tid],"mM")
--  and not find(cem[id],"mM")
--  and not find(sig,{"","[T]","[O]","[TT]"}) then              -- no children
    and max_children[id]!=0 then
--wrong place! (it is sibling we must attack!)
--      if max_children[pid]=-1
--      or max_children[pid]<children then
            add_modes &= PARENT
--      end if
    end if
end procedure

procedure unit_tests()
-- (feel free to add more)
integer pid
    for id=1 to length(iupnames) do
        string idname = iupnames[id]    -- (for diagnostics only)
        bool bMenu = (upper(cem[id])='M')
        if not bMenu then
            bool bElement = (upper(cem[id])='E')
            --
            -- 1) An IupDialog cannot have any siblings, or >1 child.
            --
            set_add_modes(id,0,0,K_IupDialog,0)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            else
                if add_modes!={CHILD} then ?9/0 end if
            end if
            set_add_modes(id,0,0,K_IupDialog,1)
            if add_modes!={} then ?9/0 end if
            --
            -- 2) Nothing can take an IupDialog as a child or sibling.
            --
            set_add_modes(K_IupDialog,K_IupVbox,1,id,0)
            if add_modes!={} then ?9/0 end if
            --
            -- 3) The following containers take precisely one child:
            --
            sequence onechild = {"IupBackgroundBox","IupDetachBox","IupDialog",
                                 "IupExpander","IupFrame","IupRadio","IupSbox",
                                 "IupScrollBox","IupSpinBox"}
            for oc=1 to length(onechild) do
                pid = find(onechild[oc],iupnames)
                set_add_modes(id,K_IupVbox,1,pid,0)
                if pid=K_IupDialog then
                    if id=K_IupDialog then
                        if add_modes!={} then ?9/0 end if
                    else
                        if add_modes!={CHILD} then ?9/0 end if
                    end if
                elsif id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={CHILD,SIBLING} then ?9/0 end if
                else
                    if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
                end if
                set_add_modes(id,K_IupVbox,1,pid,1)
                if pid=K_IupDialog
                or id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={SIBLING} then ?9/0 end if
                else
                    if add_modes!={SIBLING,PARENT} then ?9/0 end if
                end if
            end for
            --
            -- 4) IupSplit takes precisely two children
            --      (the only container that does)
            --
            pid = find("IupSplit",iupnames)
            set_add_modes(id,K_IupVbox,1,pid,0)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            elsif bElement then
                if add_modes!={CHILD,SIBLING} then ?9/0 end if
            else
                if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
            end if
            set_add_modes(id,K_IupVbox,1,pid,1)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            elsif bElement then
                if add_modes!={CHILD,SIBLING} then ?9/0 end if
            else
                if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
            end if
            set_add_modes(id,K_IupVbox,1,pid,2)
            if id=K_IupDialog then
                if add_modes!={} then ?9/0 end if
            elsif bElement then
                if add_modes!={SIBLING} then ?9/0 end if
            else
                if add_modes!={SIBLING,PARENT} then ?9/0 end if
            end if
            --
            -- 5) The following containers take any number of children: ("[P]")
            --
            sequence anychild = {"IupCbox","IupGridBox","IupHbox",
                                 "IupTabs","IupVbox","IupZbox"}
            for ac=1 to length(anychild) do
                pid = find(anychild[ac],iupnames)
                set_add_modes(id,K_IupVbox,1,pid,5)
                if id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={CHILD,SIBLING} then ?9/0 end if
                else
                    if add_modes!={CHILD,SIBLING,PARENT} then ?9/0 end if
                end if
            end for
            --
            -- 6) The following are not containers/take no children:
            --
            sequence nochild = {"IupButton","IupFlatButton","IupCalendar",
                                "IupDatePick","IupCanvas","IupCells",
                                "IupDial","IupFill","IupLabel","IupLink",
                                "IupList","IupMatrix","IupMenuItem",
                                "IupSeparator","IupProgressBar","IupPlot",
                                "IupToggle","IupText","IupTree",
                                "IupMultiLine","IupValuator"}
            for nc=1 to length(nochild) do
                pid = find(nochild[nc],iupnames)
                set_add_modes(id,K_IupVbox,1,pid,0)
                if id=K_IupDialog then
                    if add_modes!={} then ?9/0 end if
                elsif bElement then
                    if add_modes!={SIBLING} then ?9/0 end if
                else
                    if add_modes!={SIBLING,PARENT} then ?9/0 end if
                end if
            end for
        end if
    end for
end procedure
unit_tests()

procedure confirm_insert(integer id)
Ihandle vbox1, hbox1, hbox3

    if insert_dlg=NULL then

        insert_txt = IupLabel() -- "Insert a new ..."
        insert_drop = IupList("DROPDOWN=YES")
        insert_ref = IupLabel() -- "of ..."
        hbox1 = IupHbox({IupFill(),insert_txt,insert_drop,insert_ref,IupFill()},
                        "MARGIN=5x5,NORMALIZESIZE=VERTICAL")

        insert_title = IupText("EXPAND=HORIZONTAL")
        hbox2 = IupHbox({IupLabel("TITLE "),insert_title},"ALIGNMENT=ACENTER")

        insert_ok_btn = IupButton("OK", cb_insert_ok, "PADDING=5x5")
        insert_cancel_btn = IupButton("Cancel", cb_cancel, "PADDING=5x5")
        hbox3 = IupHbox({IupFill(),insert_ok_btn,IupFill(),insert_cancel_btn,IupFill()})

        vbox1 = IupVbox({hbox1,IupFill(),hbox2,IupFill(),hbox3},"MARGIN=5x5")

        insert_dlg = IupDialog(vbox1,"MINSIZE=300x140")
        IupSetAttribute(insert_dlg,"TITLE","Confirm insert")

--      IupSetCallback(insert_dlg, "K_ANY", Icallback("esc_close"))     -- NO!
        IupSetCallback(insert_dlg, "K_ANY", cb_insert_escape)
--      IupCloseOnEscape(insert_dlg)    -- NO!
        IupSetCallback(insert_dlg, "CLOSE_CB", cb_insert_close);
    end if -- (insert_dlg=NULL)

    insert_id = id
    IupSetStrAttribute(insert_txt,"TITLE","Insert a new %s as ",{iupnames[id]})
    integer pid = IupGetInt(hierarchytree,"VALUE")
    integer uid = IupTreeGetUserId(hierarchytree, pid)
--?{"confirm_insert: {pid,uid}=",{pid,uid}}
--  if pid=-1 or uid<1 or uid>length(all_handles) then
----    ?{"confirm_insert - oops: {pid,uid}=",{pid,uid}}
--      IupMessage("oops",sprintf("confirm_insert - {pid,uid} is {%d,%d}",{pid,uid}))
--      return
--  end if
    string ref_title = IupGetAttributeId(hierarchytree,"TITLE",pid)
--  integer cemi = cem[id]

    IupSetStrAttribute(insert_ref,"TITLE"," of %s",{ref_title})
    
    integer children = IupGetIntId(hierarchytree, "CHILDCOUNT", pid)
    if children!=IupGetChildCount(all_handles[uid]) then ?9/0 end if
--DEV above pid should prolly be tid?
    integer p_id, siblings
if all_funcdx[uid]=K_IupDialog then
    p_id = 0
    siblings = 0
else
    Ihandle parent = IupGetParent(all_handles[uid])
    p_id = find(parent,all_handles)
--  if p_id = 0 then ?9/0 end if
    p_id = all_funcdx[p_id]
    siblings = IupGetChildCount(parent)
end if
    set_add_modes(id,p_id,siblings,all_funcdx[uid],children)
--?{"id",id,"p_id",p_id,"siblings",siblings,"fdx",all_funcdx[uid],"children",children,"add_modes",add_modes}

    Ihandle default_enter = insert_ok_btn,
            start_focus = insert_ok_btn
    IupSetAttribute(insert_drop,"REMOVEITEM","ALL")
    for i=1 to length(add_modes) do
        IupSetAttributeId(insert_drop,"",i,add_mode_descs[add_modes[i]])
    end for
    if length(add_modes)=0 then
        IupSetInt(insert_drop,"ACTIVE",false)
        IupSetInt(insert_ok_btn,"ACTIVE",false)
        default_enter = insert_cancel_btn
        start_focus = insert_cancel_btn
    else
        IupSetInt(insert_drop,"ACTIVE",true)
        IupSetInt(insert_ok_btn,"ACTIVE",true)
        IupSetInt(insert_drop,"VALUE",1)
        if length(add_modes)>1 then
            start_focus = insert_drop
        end if
    end if
--  string sig = clean_sig(id)
--?{"confirm_insert","sig",sig,"id",id,"iupnames[id]",iupnames[id]}
--  bool bTitle = find(sig,{"[T]","[TH]","[TT]"})!=0
    bTitle = find("TITLE",iprops(id))!=0
--?{"bTitle",bTitle}
    IupSetInt(hbox2,"VISIBLE",bTitle)
    IupSetAttribute(insert_dlg, "SIZE", NULL)
    IupRefresh(insert_dlg)

    IupSetAttributeHandle(insert_dlg,"DEFAULTENTER",default_enter)
    IupSetAttributeHandle(insert_dlg,"STARTFOCUS",start_focus)

    enable_globalmotion = false

    integer {x,y} = IupGetIntInt(NULL,"CURSORPOS")
    integer {rx,ry} = sq_floor_div(IupGetIntInt(insert_dlg,"NATURALSIZE"),2)
    x = max(0,x-rx)
    y = max(0,y-ry)
    IupShowXY(insert_dlg,x,y)

end procedure

--DOC[DEV]:
-- Right-clicking on or when the main (non-empty) IupDialog is selected will show a menu with
-- all elements disabled. This is because an IupDialog can only have a single child, and further
-- an IupDialog cannot have any siblings or be a child of any other element. In fact, IupDialog 
-- is always disabled on the right-click menu, because the main IupDialog cannot be deleted.
--
-- Likewise menu items can only be placed on menus. Note however that many cases will exist
-- that offer a sibling option, but if the parent is already "full" (like IupDialog many other
-- containers can only have one child, or in the case of IupSplit two) then an error occurs
-- when OK is pressed. For that to be fixed, the unit testing would need to be rewritten, and
-- that already covers over 1,500 cases - perfectly do-able, but y'know.	[ERM, done!] (greatly simplified by removing menus...)

sequence inactive

--DEV/DOC!
-- Also note that the right-click menu Containers/IupDialog is always given a no-entry icon,
-- and will also always deliver the above message. This is because you cannot delete the
-- main IupDialog entry, and an IupDialog cannot be a child of any other element. I could
-- remove that entry, but getting the error and then understanding why is probably better.
--
-- The root node of a dialog (/window) is always, not surprisingly, an IupDialog. Perhaps
-- more surprisingly, an IupDialog can only have one child. Typically that would be an
-- IupHbox or IupVbox, which can have as many children as you like, and instruct the
-- run-time to arrange them horizontally or vertically respectively. The IupVbox and
-- IupHbox will also often be alternately-nested, eg an IupHbox with two or more
-- IupVbox in it, or an IupVbox with two or more IupHbox in it. It all gets quite
-- natural, once you get used to the idea.
--

--(disjoint ramble#17:)
-- The layout hierarchy can at first be a little off-putting, especially if you are used
-- to explicitly positioning everything at explicit x,y co-ordinates. But once you get
-- used to it, it is actually very easy (especially when you are using pGUI-IDE!) and of
-- course it makes layouts much more portable across different underlying systems, far
-- easier than {+5 on Motif, -3 on GTK, +17 on WinAPI} style, with different numbers 
-- for each of the many different gui components.

function menu_cb(Ihandle menu_item)
    integer id = IupGetInt(menu_item,"ID")
    if inactive[id] then
        enable_globalmotion = false
        error_showing = true
        IupMessage("Invalid","""
________The target element cannot have any [more] elements, so you cannot add a child,
        and its parent is full, so you cannot add a sibling, and the selected element is not
        a container, or the target is the main IupDialog, so you cannot make it a parent. 

        Right-clicking on or when the main IupDialog is selected usually displays a menu
        with all no-entry icons - try clicking on a sub-element, or add more containers, 
        most commonly IupHbox and IupVbox.
        
        This message is explained in more detail right at the start of the manual.""")
        error_showing = false
        re_enable_globalmotion()
    else
        confirm_insert(id)
    end if
    return IUP_DEFAULT
end function
constant cb_menu = Icallback("menu_cb")

function delete_cb(Ihandle menu_item)
?{"delete"}
--DEV:
--  integer pid = IupGetInt(hierarchytree,"VALUE")
--  integer userdata = IupTreeGetUserId(hierarchytree, id) 
--          sequence properties = all_properties[userdata]

--  string ref_title = IupGetAttributeId(hierarchytree,"TITLE",pid)
--  IupMessage("Error","The main IupDialog cannot be deleted.")
    return IUP_DEFAULT
end function
constant cb_delete = Icallback("delete_cb")



Ihandln rmenu = NULL

--function motion_cb(Ihandle /*ih*/, integer x, y, atom pStatus)
--  ?{"motion_cb",x,y,peek_string(pStatus)}
--  return IUP_CONTINUE 
--end function

--DOC:
--  When you move the mouse over the livedisplay, it auto-selects the corresponding entry in the 
--  hierarchy tree after a short delay (0.2s). Clicking on an element works more immediately and
--  then sets that delay to a whole second. Note that hovering the mouse achieves nothing - only 
--  move or click events will ever actually make anything happen. There are a few cases where it
--  gets mildly annoying, eg it is very easy to switch tabs and then move the mouse too quickly,
--  but the tiniest of nudges, or a quick click, should sort it out.
--
--  The short delay allows you to get the mouse off the live display without selecting things on 
--  the way to the edge, and/or having to re-select things from the hierarchy tree again.
--
--  Also note that non-visible elements such as IupHbox and IupFill are never auto-selected, and
--  in particular there are quite simply are no "IupTabItem" elements on an IupTabs which can be 
--  auto-selected, no matter how much you and I might want or expect there to be - instead each
--  and every tab just auto-selects the exact same IupTabs container, even when clicked. There
--  is, thankfully, no such problem auto-selecting elements within the currently open tab.
--
--  It should be enough that auto-select easily and quickly gets you in roughly the right area,
--  and obviously that could be a significant time-saving, for hierechy trees with hundreds of
--  nodes and a fair few levels of nesting.
--

integer last_gm_crop = -1   -- click on/global mouse move result

Ihandle timer

function timer_cb(Ihandle /*timer*/)
    IupStoreAttribute(timer, "RUN", "NO")
    if IupGetInt(timer,"TIME")!=200 then
        IupSetInt(timer,"TIME",200)
        re_enable_globalmotion()
    end if      
    if enable_globalmotion then
        if last_gm_crop!=-1 then
            -- carefully re-check everything:
            integer id = IupTreeGetUserId(hierarchytree, last_gm_crop)
            Ihandle hi = all_handles[id]
            integer {x,y} = IupGetIntInt(NULL,"CURSORPOS")
            integer {px,py} = IupGetIntInt(hi,"SCREENPOSITION")
            integer {w,h} = IupGetIntInt(hi,"RASTERSIZE")
            if x>=px and y>=py 
            and x<=px+w and y<=py+h then
                IupSetInt(hierarchytree,"VALUE",last_gm_crop)
                {} = selection_cb(hierarchytree, last_gm_crop, 1) 
            end if
        end if
    end if
    return IUP_IGNORE
end function

function globalmotion_cb(integer x, y, atom /*pStatus*/)
--DEV/SUG factor out??
--  last_gm_crop = f(x,y)
bool found = false
    for i=1 to length(all_tags) do
        Ihandle hi = all_handles[all_tags[i]]
        if IupGetInt(hi,"VISIBLE")!=0
        and IupGetAttribute(hi,"SCREENPOSITION")!="" then
            integer {px,py} = IupGetIntInt(hi,"SCREENPOSITION")
            if x>=px and y>=py then
                integer {w,h} = IupGetIntInt(hi,"RASTERSIZE")
                if x<=px+w and y<=py+h then
                    integer id = IupTreeGetId(hierarchytree, all_tags[i]) 
                    if id!=last_gm_crop then 
                        last_gm_crop = id
                        if IupGetInt(timer,"RUN")=0 then
                            IupStoreAttribute(timer, "RUN", "YES")
                        end if
                    end if
                    found = true
                    exit
                end if
            end if
        end if
    end for
    if not found then last_gm_crop = -1 end if
    return IUP_CONTINUE 
end function
constant cb_globalmotion = Icallback("globalmotion_cb")

sequence mitems = {}

Ihandle cmenu,emenu,dmenu,hmenu -- (containers, elements, delete, help)

function globalbutton_cb(integer button, pressed, x, y, atom pStatus)

    if pressed=1
    and enable_globalmotion then

        {} = globalmotion_cb(x, y, pStatus) -- (set last_gm_crop)
        {} = timer_cb(timer)            -- (use last_gm_crop right now)
        IupStoreAttribute(timer, "RUN", "NO")
        enable_globalmotion = false
        IupSetInt(timer,"TIME",1000)    -- delay next auto-select a bit
        IupStoreAttribute(timer, "RUN", "YES")

    elsif button=IUP_BUTTON3        -- right mouse button (released)
      and livedisplay!=NULL then

        if rmenu=NULL then
            sequence menus = {IupMenu(),IupMenu()}
            cmenu = IupSubMenu("Containers",menus[1],"IMAGE=%s",{get_image("plade_containers.png")})
            emenu = IupSubMenu("Elements",menus[2],"IMAGE=%s",{get_image("plade_elements.png")})
            dmenu = IupMenuItem("Delete",cb_delete,"IMAGE=%s",{get_image("plade_trash.png")})
            hmenu = IupMenuItem("Help",cb_help,"IMAGE=%s",{get_image("HelpPhixCHM.png")})
            rmenu = IupMenu({cmenu,emenu,dmenu,hmenu})
            mitems = repeat(NULL,length(iupnames))
            for i=1 to length(iupnames) do
                integer cdx = find(upper(cem[i]),"CE")
                if cdx!=0 then
                    mitems[i] = IupMenuItem(iupnames[i],cb_menu,"IMAGE=%s, ID=%d",{get_image(icons[i]),i})
                    IupAppend(menus[cdx],mitems[i])
                end if
            end for
        end if

        integer pid = IupGetInt(hierarchytree,"VALUE")
        integer uid = IupTreeGetUserId(hierarchytree, pid)
        integer children = IupGetIntId(hierarchytree, "CHILDCOUNT", pid)
        if children!=IupGetChildCount(all_handles[uid]) then ?9/0 end if -- sanity check
        integer funcdx = all_funcdx[uid]
        Ihandln parent = IupGetParent(all_handles[uid])
        integer pkids, pdx
        if parent=NULL then
            if funcdx!=K_IupDialog then ?9/0 end if
            pdx = 0
            pkids = 0
        else
            pkids = IupGetChildCount(parent)
            pdx = find(parent,all_handles)
            pdx = all_funcdx[pdx]
        end if
        -- enable/disable menu entries appropriately
        inactive = repeat(false,length(iupnames))
        for id=1 to length(iupnames) do
            Ihandln mitem = mitems[id]
            if mitem!=NULL then
                set_add_modes(id,pdx,pkids,funcdx,children)
                string icon = icons[id]
                if length(add_modes)=0 then
                    icon = "plade_no_entry.png"
                    inactive[id] = true
                end if
                IupSetStrAttribute(mitem,"IMAGE",get_image(icon))
            end if
        end for
        -- Prevent main IupDialog delete
        IupSetInt(dmenu,"ACTIVE",pid!=0)

        enable_globalmotion := false
        IupStoreAttribute(timer, "RUN", "NO")
        IupPopup(rmenu, x, y)
        re_enable_globalmotion()
    end if
    return IUP_CONTINUE 
end function
constant cb_globalbutton = Icallback("globalbutton_cb")

sequence depths

procedure set_depth(integer i)
    if depths[i]=0 then
        Ihandln parent = IupGetParent(all_handles[i])
        if parent=NULL then
            depths[i] = 1
        else
            integer pdx = find(parent,all_handles)
            set_depth(pdx)
            depths[i] = depths[pdx]+1
        end if
    end if
end procedure

function depth_sort(integer i, integer j)
    return compare(depths[j],depths[i]) -- (reverse order is intentional)
end function

procedure sort_tags()
    -- sort tags, depth-first:
    depths = repeat(0,length(all_tags))
    for i=1 to length(all_tags) do
        set_depth(i)
    end for 
    all_tags = custom_sort(routine_id("depth_sort"),all_tags)
end procedure

--function button_cb(integer button, pressed, x, y, atom /*pStatus*/)
--  return IUP_CONTINUE
--end function
--constant cb_button = Icallback("button_cb")

function dragdrop_cb(Ihandle /*hierarchytree*/, integer drag_id, drop_id, /*isshift*/, iscontrol) 
integer res = IUP_IGNORE
    enable_globalmotion := false
    if iscontrol then
        IupMessage("Error","Copy not supported for drag&drop.")
--  elsif drag_id=0 then -- (root/main IupDialog being dragged? - never triggers)
--      -- likewise parent onto child etc already (quietly) prohibited internally..
--      IupMessage("not supported","You cannot drag the main IupDialog anywhere!")
    else
        integer drag_dx = IupTreeGetUserId(hierarchytree, drag_id) 
        integer drop_dx = IupTreeGetUserId(hierarchytree, drop_id) 
        Ihandle drag_elem = all_handles[drag_dx]
        Ihandle drop_elem = all_handles[drop_dx]
--      Ihandln ref_child
--      integer funcdx = all_funcdx[drop_dx]
--      integer error = IUP_INVALID, noerror = IUP_CONTINUE
        integer error = IUP_INVALID
--      bool bBranch = IupGetAttributeId(hierarchytree, "KIND", drop_id)="BRANCH", bEmpty, bExpanded
        bool bBranch = IupGetAttributeId(hierarchytree, "KIND", drop_id)="BRANCH", 
             bExpanded = IupGetAttributeId(hierarchytree, "STATE", drop_id)="EXPANDED"
--      if bBranch then
--          ref_child = IupGetNextChild(drop_elem, NULL)
--          bEmpty = IupGetIntId(hierarchytree, "CHILDCOUNT", drop_id)=0
--          bExpanded = IupGetAttributeId(hierarchytree, "STATE", drop_id)="EXPANDED"
--      end if
        if bBranch and bExpanded then
            Ihandln ref_child = IupGetNextChild(drop_elem, NULL)
            if drop_elem==IupGetParent(drag_elem) 
            and ref_child==drag_elem then
--DEV/SUG write a positional messagebox... (ie CURSORPOS/IupShowXY)
                IupMessage("Error", "Dropped at same place.")
            else
                -- If the drop node is a branch and it is expanded or
                --  empty, add as first child, before the reference
                error = IupReparent(drag_elem, drop_elem, ref_child)
            end if
--      elsif bBranch and bEmpty then
----this may no longer be necessary... (and noerror can go too)
--?"bEmpty"
--?9/0
--          -- Need to do the move ourselves and return IUP_IGNORE...
--          error = IupReparent(drag_elem, drop_elem, ref_child)
--          if error=IUP_NOERROR then
--              IupSetAttributeId(hierarchytree, "ADDLEAF", drop_id, "TEMP")
--              drag_id = IupTreeGetId(hierarchytree, drag_dx)
--              IupSetIntId(hierarchytree, "MOVENODE", drag_id, drop_id+1)
----                drop_id = IupTreeGetId(hierarchytree, drop_dx)
--              integer temp = IupTreeGetId(hierarchytree, 0)
--              IupSetAttributeId(hierarchytree, "DELNODE", temp, "SELECTED")
----IupUnmap(drop_elem)
----IupMap(drop_elem)
----IupUnmap(drag_elem)
----IupMap(drag_elem)
----
----DOH! This is /exactly/ the problem I was trying to avoid...
----                IupSetIntId(hierarchytree,"MOVENODE",drag_id,drop_id)
----                drop_id = IupTreeGetId(hierarchytree, drop_dx)
----No help...
----                IupSetAttributeId(hierarchytree,"STATE",drop_id,"EXPANDED")
----                IupRefresh(hierarchytree)
----                IupUpdate(hierarchytree)
--          end if
--          noerror = IUP_IGNORE
--
        else
            Ihandln drop_parent = IupGetParent(drop_elem),
                    drag_parent = IupGetParent(drag_elem),
                    drop_brother = IupGetBrother(drop_elem)
            if drop_parent=NULL then
                IupMessage("Error", "Cannot drop here as brother.")
            elsif drop_parent==drag_parent 
              and drop_brother==drag_elem then
                IupMessage("Error", "Dropped at same place.")
            else
                -- If the branch is not expanded or the drop node is a leaf,
                --  add as brother, after the reference (can be NULL here)
                error = IupReparent(drag_elem, drop_parent, drop_brother)   
            end if
        end if

        if error==IUP_ERROR then

            IupMessage("Error", "Drop failed. Invalid operation for this node.")

        elsif error=IUP_NOERROR then

            -- This seems to do the trick:
            IupUnmap(drop_elem)
            IupMap(drop_elem)
            IupUnmap(drag_elem)
            IupMap(drag_elem)

            IupRefresh(livedisplay)

--          res = noerror
            res = IUP_CONTINUE
        end if

    end if -- (iscontrol)

    sort_tags()

    re_enable_globalmotion()
    return res
end function
constant cb_dragdrop = Icallback("dragdrop_cb")


procedure main()
Ihandle dlg, file_menu, test_menu, help_menu, main_menu, vboxp

    IupOpen()

    timer = IupTimer(Icallback("timer_cb"), 200, 1)

--SUG: warnings (6) - disabled with "(0)" or "" if none, creates warnings.txt file?
    file_menu = IupMenu({IupMenuItem("&Cancel"),
--                       IupMenuItem("&Save"),
                         IupSeparator(),
--                       IupMenuItem("&Undo", "ACTIVE=NO"),
                         IupMenuItem("Save and E&xit", Icallback("exit_cb"))})
-- possibly via edix, disable if not running?
    test_menu = IupMenuItem("&Test", Icallback("test_cb"))
    help_menu = IupMenuItem("&Help", cb_help)
    
    main_menu = IupMenu({IupSubmenu("&File", file_menu),test_menu,help_menu})

--Ihandle tabframe
--if SHOWTABS then
--  Ihandle vboxc = IupVbox({})
--  Ihandle radioc = IupRadio(vboxc)
--  Ihandle vboxe = IupVbox({})
--  Ihandle radioe = IupRadio(vboxe)
--  Ihandle vboxm = IupVbox({})
--  Ihandle radiom = IupRadio(vboxm)
--  sequence vboxes = {vboxc,vboxe,vboxm}
--  Ihandle tabs = IupTabs({radioc,radioe,radiom})
--  IupSetAttribute(tabs,"TABTITLE0","Containers")
--  IupSetAttribute(tabs,"TABTITLE1","Elements")
--  IupSetAttribute(tabs,"TABTITLE2","Menus")
--  IupSetAttribute(tabs,"SIZE","120x")
--
----DEV containers/elements/warnings tabs?
--  for i=1 to length(iupnames) do
--      string iupname = iupnames[i]
--      string icon = icons[i]
--      Ihandle lbl = IupLabel("NULL")
--      IupSetStrAttribute(lbl, "IMAGE", get_image(icon))
--      Ihandle tgl = IupToggle(iupname)
--      IupAppend(vboxes[find(upper(cem[i]),"CEM")],IupHbox({lbl,tgl},"NORMALSIZE=HORIZONTAL"))
--      if iupname="IupDialog" then
--          IupSetAttributeHandle(radioc,"VALUE",tgl)
--      end if
--  end for
--
--  tabframe = IupFrame(tabs,"TITLE=\"Controls\", PADDING=5x")
--end if

--  Ihandle tree = IupTree()--"")
--  Ihandle tree = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=205x416, EXPAND=HORIZONTAL")
--  hierarchytree = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=225x416, EXPAND=HORIZONTAL")
    hierarchytree = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=225x416, EXPAND=YES")
--DEV so.. my controls should be a tree!! (with a delete branch)
    IupSetAttribute(hierarchytree, "SHOWDRAGDROP", "YES");
    IupSetCallback(hierarchytree,"SELECTION_CB",cb_selection)
    IupSetCallback(hierarchytree,"RIGHTCLICK_CB",cb_rightclick)
    IupSetCallback(hierarchytree,"DRAGDROP_CB",cb_dragdrop)

--  Ihandle tree = IupTree("DRAGDROPTREE=YES, RASTERSIZE=205x416, EXPAND=HORIZONTAL")
--  Ihandle tframe = IupFrame(IupVbox({IupVbox({tree,IupLabel()}),IupLabel()}),
    Ihandle treeframe, right
--if SHOWDESIRED then
--  hierarchytreE = IupTree("ADDROOT=NO, DRAGDROPTREE=YES, RASTERSIZE=225x416, EXPAND=HORIZONTAL")
--  right = IupHbox({hierarchytree,hierarchytreE})
----    treeframe = IupFrame(IupVbox({IupHbox({hierarchytree,hierarchytreE}),IupLabel("")}),
------                    "TITLE=Hierarchy, PADDING=5x, RASTERSIZE=150x275, EXPAND=NO")
----                      "TITLE=Hierarchy, PADDING=5x")
----DEV
if SHOWDETAILS then
    p_new = IupButton("New",cb_new_attr)
    p_space_only = IupToggle("spacing only",cb_space,"VALUE=OFF, RIGHTBUTTON=YES, 3STATE=YES")
    if not SPACE then
        IupSetInt(p_space_only,"ACTIVE",0)
    end if
    p_desc = IupLabel("(desc)","EXPAND=HORIZONTAL")
    p_attrib_list = IupList(cb_list_action,"EDITBOX=NO, EXPAND=YES")
    IupSetCallback(p_attrib_list, "DBLCLICK_CB", cb_dblclick)
    vboxp = IupVbox({IupHbox({p_new,IupFill(),p_space_only}),p_desc,p_attrib_list})
    properties = IupFrame(vboxp,"TITLE=Properties, RASTERSIZE=225x416, EXPAND=YES")
    right = IupSplit(hierarchytree,properties)
else
    right = hierarchytree
end if
    treeframe = IupFrame(right,"TITLE=Hierarchy, PADDING=5x")

--  dlg = IupDialog(frame,"MENU=mymenu, TITLE=plade, SOIZE=200x100, GOAP=5x5")
--  dlg = IupDialog(IupHbox({frame,IupFill(),treeframe,IupFill()},"MARGIN=5x"),
--if SHOWTABS then
-- if SHOWDESIRED or SHOWDETAILS then
--  dlg = IupDialog(IupHbox({tabframe,treeframe},"MARGIN=5x"),"SIZE=553x275") 
-- else
--  dlg = IupDialog(IupHbox({tabframe,treeframe},"MARGIN=5x"),"SIZE=328x275") 
-- end if
--else
-- if SHOWDESIRED or SHOWDETAILS then
--  dlg = IupDialog(treeframe,"SIZE=553x275") 
-- else
--  dlg = IupDialog(treeframe,"SIZE=328x275") 
-- end if
    dlg = IupDialog(treeframe)
--end if
    IupSetAttributeHandle(dlg,"MENU",main_menu)
    IupSetStrAttribute(dlg, "TITLE", "plade - Phix Layout Designer (%s)",{srcname})
    IupSetCallback(dlg, "K_ANY", Icallback("key_cb"));
--  IupCloseOnEscape(dlg)
--DEV/SUG:
--  IupCloseOnEsc(dlg)
    IupSetCallback(dlg, "CLOSE_CB", cb_close)
--  IupSetCallback(matrix, "RELEASE_CB",    demo:cb_release)
--INPUTCALLBACKS    Turns on/off ("YES" or "NO") the global callbacks used to intercept global mouse and keyboard events. 
--The callbacks must be set using the IupSetGlobalFunction function using the following names: GLOBALKEYPRESS_CB, GLOBALMOTION_CB, GLOBALBUTTON_CB and GLOBALWHEEL_CB (Windows Only). 
--Their parameters are the same as the standard callbacks, but without the Ihandle parameter. 
--(ie/see KEYPRESS_CB, MOTION_CB, BUTTON_CB, and WHEEL_CB)  
    IupSetGlobal("INPUTCALLBACKS","YES")
--  IupSetGlobalFunction("GLOBALBUTTON_CB",cb_button)
--works, but...
--if 01 then
    IupSetGlobalFunction("GLOBALMOTION_CB",cb_globalmotion)
    IupSetGlobalFunction("GLOBALBUTTON_CB",cb_globalbutton)
--end if
    IupMap(dlg)

--if 0 then
--  setup_tree()    -- in hierarchytreE / temp
--end if

--if 01 then
    window_selection()
--else
----    make_live(1)
--  make_live(0)
--end if

--  IupShow(dlg)
--  free_console()
--sleep(1)
    if livedisplay!=NULL then
        IupShowXY(dlg,IUP_LEFT,IUP_TOP)
        -- start with the dialog selected:
        {} = selection_cb(hierarchytree, 0, 1) 
        IupMainLoop()
    end if
    IupClose()
end procedure
--if 01 then
main()
--end if

--/*
SUG: as we click on tree items, IupSetFocus the matching Controls toggle?
SUG: "warnings" button, with the red flag of filedump, disabled if none. (opens a popup)
SUG? Please delete xxx line nnn manually (you can/should leave this open while you do)
     and/or: error line nnn: each element should be declared on a single line
    (eg IupHbox({
                 IupFill(),
                 IupButton(OK),
                 IupFill()
                })
    not
       IupHbox({IupFill(),IupButton(OK),IupFill()})
    Note the same applies for any trailing brackets/braces.
    [plade could delete the whole IupHbox, but not ...])
    NO:<< just do it!. (what about static Ihandles that are no longer used?)

Obvious:
    Make the changes locally, ensure it will still scan. Prior to both Save and Test.
    Have a Test button which writes to plade_test.exw (warn before overwrite?), run, then delete.
    If it won't scan, write to plade_test.exw, leave, and prompt to that effect.
--
-- radio.exw
--  Creates a dialog for the user to select his/her gender. 
--  In this case, the radio element is essential to prevent the user from selecting both options.
--

Ihandle male, female, exclusive, frame, dialog 

function action_cb(Ihandle ih, integer state)
    -- this gets the 0 first, then the 1:
--  ?{iff(ih=male?"MALE":iff(ih=female?"FEMALE":"???")),state}
    IupSetAttribute(dialog,"TITLE",iff(ih=male?"MALE":iff(ih=female?"FEMALE":"???")))
    return IUP_DEFAULT
end function


    IupOpen()

    male = IupToggle("Male",Icallback("action_cb"))
    female = IupToggle("Female",Icallback("action_cb"))

    exclusive = IupRadio(IupVbox({male,female})) 
    IupSetHandle("male", male) 
    IupSetHandle("female", female) 
    IupSetAttribute(exclusive, "VALUE", "female") 
    IupSetAttribute(male, "TIP",     "Two state button - Exclusive - RADIO") 
    IupSetAttribute(female, "TIP",   "Two state button - Exclusive - RADIO") 

    frame = IupFrame(exclusive, "TITLE=Gender")

    dialog = IupDialog(IupHbox({IupFill(),frame,IupFill()})) 

    IupSetAttributes(dialog, "SIZE=140x55, TITLE=IupRadio, RESIZE=NO, MINBOX=NO, MAXBOX=NO") 
    IupSetCallback(dialog, "K_ANY", Icallback("esc_close"));

    IupShow(dialog) 
    IupMainLoop() 
    IupClose() 


--
-- detachbox.exw
-- =============
--

Ihandle detach_btn, restore_btn, dbox

function detached_cb(Ihandle /*ih*/, Ihandle new_parent, integer /*x*/, integer /*y*/)
    IupSetAttribute(new_parent, "TITLE", "New Dialog");
    IupSetAttribute(restore_btn, "ACTIVE", "YES");
    IupSetAttribute(detach_btn, "ACTIVE", "NO");
    return IUP_DEFAULT
end function

function btn_restore_cb(Ihandle /*restore_btn*/)
  IupSetAttribute(dbox, "RESTORE", NULL);
  IupSetAttribute(restore_btn, "ACTIVE", "NO");
  IupSetAttribute(detach_btn, "ACTIVE", "Yes");
  return IUP_DEFAULT;
end function

function btn_detach_cb(Ihandle /*detach_btn*/)
  IupSetAttribute(dbox, "DETACH", NULL);
  IupSetAttribute(detach_btn, "ACTIVE", "NO");
  IupSetAttribute(restore_btn, "ACTIVE", "Yes");
  return IUP_DEFAULT
end function

procedure DetachBoxTest()
  Ihandle dlg, lbl, ml, hbox, txt;

  detach_btn = IupButton("Detach Me!", Icallback("btn_detach_cb"))
  ml = IupText("MULTILINE=YES, EXPAND=YES, VISIBLELINES=5")
  hbox = IupHbox({detach_btn, ml},"MARGIN=10x0")
  dbox = IupDetachBox(hbox);
  IupSetAttribute(dbox, "ORIENTATION", "VERTICAL");
  IupSetCallback(dbox, "DETACHED_CB", Icallback("detached_cb"));
  lbl = IupLabel("Label","EXPAND=VERTICAL")
  restore_btn = IupButton("Restore me!", Icallback("btn_restore_cb"),"EXPAND=YES, ACTIVE=NO")
  txt = IupText("EXPAND=HORIZONTAL")

  dlg = IupDialog(IupVbox({dbox, lbl, restore_btn, txt}),
                  "TITLE=\"IupDetachBox Example\", MARGIN=10x10, GAP=10, RASTERSIZE=300x300")

  IupShow(dlg);
end procedure

We need to process the thing into a flat list, and verify flags/idx are all ok.
plade is not able to handle say:
    Ihandle box
    if show_vertical then   -- (some application-defined setting/flag)
        box = IupVbox({ctrl1,ctrl2})
    else
        box = IupHbox({ctrl1,ctrl2})
    end if
plade will get confused, unless:
    a) "box" is defined/created in one and only one place, and 
    b) "ctrl1" and "ctrl2" are used once and only once in the tree,
    c) obviously if "ctrl2" is not defined/found, we must give up.
plade should, however, cope with multiple IupDialog -> select. [DONE]
--*/

