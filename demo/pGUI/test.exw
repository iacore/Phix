--
-- general scratch area
--
?""

include pGUI.e

-- For Edita/Tools/Re-indent source:
--#withtype Ihandle
--#withtype Ihandln
--#withtype cdCanvas

Ihandle dlg, canvas
cdCanvas cd_canvas

constant USE_OPENGL = 01

--
-- define 8 corners equidistant from {0,0,0}:
--
--          6-----2
--      5-----1   3
--      8-----4  
--
-- ie the right face is 1-2-3-4 clockwise, and the left face
--  is 5-6-7-8 counter-clockwise (unless using x-ray vision).
--
enum X, Y, Z
constant l = 100
constant corners = {{+l,+l,+l},
                    {+l,+l,-l},
                    {+l,-l,-l},
                    {+l,-l,+l},
                    {-l,+l,+l},
                    {-l,+l,-l},
                    {-l,-l,-l},
                    {-l,-l,+l}}


constant faces = {{CD_RED,      1,2,3,4},   -- right
                  {CD_YELLOW,   1,5,6,2},   -- top/upper
                  {CD_GREEN,    1,4,8,5},   -- front
                  {CD_BLUE,     2,3,7,6},   -- back
                  {CD_WHITE,    3,4,8,7},   -- btm/down
                  {CD_ORANGE,   5,6,7,8}}   -- left

constant centres = {{ l, 0, 0},
                    { 0, l, 0},
                    { 0, 0, l},
                    { 0, 0,-l},
                    { 0,-l, 0},
                    {-l, 0, 0}}

--
-- rotation angles, 0..359
--  Note that these values aren't really meaningful or worth inspecting - 
--  there are literally an infinite number of ways to twist and turn such
--  that a camera initially above London ends up above New York, however 
--  applying them in the same order(nb) always ends up in the same place.
--  Also, the keys do not rotate about x/y/z but (anti-clockwise) about 
--  the current back/left/top, which switch places, from the camera pov, 
--  as the cube is rotated.
--
--DEV
constant use_rxyz = 01
sequence rxyz = {0,0,0}
atom rx = 0,
     ry = 0,
     rz = 0

string pov_sides = "RUFBDL" -- (re-assigned on every re-draw)
--                  YxZzXy  -- (upper=clockwise, lower=anti-clockwise)

constant naxes = {{Y,Z},    -- (rotate about the X-axis)
                  {X,Z},    -- (rotate about the Y-axis)
                  {X,Y}}    -- (rotate about the Z-axis)

function rotate(sequence points, atom angle, integer axis)
--
-- rotate points by the specified angle about the given axis
--   eg when rotating about the X-axis, all X values stay
--   exactly the same, while the other two [Y & Z] change.
--
    atom radians = angle*CD_DEG2RAD,
         sin_t = sin(radians),
         cos_t = cos(radians)
    integer {nx,ny} = naxes[axis] -- (the 2 of XYZ != axis)
    for i=1 to length(points) do
        atom x = points[i][nx],
             y = points[i][ny]
        points[i][nx] = x * cos_t - y * sin_t
        points[i][ny] = y * cos_t + x * sin_t
    end for
    return points
end function

function projection(sequence points, atom d)
--
-- project points from {0,0,d} onto the perpendicular plane through {0,0,0}
--
    for i=1 to length(points) do
        atom {x,y,z} = points[i],
             denom = (1-z/d)
        points[i][X] = x/denom
        points[i][Y] = y/denom
    end for
    return points
end function

--/*
function nearest(sequence points, integer axis=Z, integer d=+1)
--
-- return the index of the furthest point from {0,0,0}
--  (as viewed in the rotated/perspective adjusted model,
--   ie the highest/lowest value in the specified axis)
--
--  nearest(points,Z,1) yields max z value (nearest),
--  nearest(points,Z,-1) should always be hidden,
--  nearest(points,X,1) yeilds rightmost point,
--  nearest(points,X,-1) yeilds leftmost point,
--  nearest(points,Y,1) yeilds topmost point,
--  nearest(points,Y,-1) yeilds lowest point.
--   (all from the camera's point of view)
--
--  some ambiguity is to be expected when the camera is
--   edge-on, eg top/right might be one and the same.
--   (if necessary, constrain all angles to be odd)
--   (or, grey out rotate controls at some angles)
--
    integer np = 1
    atom maxv = points[1][axis]
    for i=2 to length(points) do
        atom pix = points[i][axis]
        if compare(pix,maxv)=d then
            maxv = pix
            np = i
        end if
    end for
    return np
end function
--*/
function nearest(sequence points)
--
-- return the index of the max Z value (as 
--  rotated to make the camera be {0,0,d}).
--
    integer np = 1
    atom maxz = points[1][Z]
    for i=2 to length(points) do
        atom piz = points[i][Z]
        if piz>maxz then
            maxz = piz
            np = i
        end if
    end for
    return np
end function

procedure vertices(integer wx, wh, sequence points, face)
-- (common code for line/fill drawing)
    for i=2 to length(face) do
        integer fi = face[i]
--      cdCanvasVertex(cd_canvas,wx+points[fi][X],wh-points[fi][Y])
        cdCanvasVertex(cd_canvas,wx+points[fi][X],wh+points[fi][Y])
    end for
end procedure

constant CD_TOPAZ       = #FFC87C,  -- and RGB code 255, 200, 124.
         CD_RUBY        = #E0115F,  -- 224, 17, 95
         CD_LIME        = #BFFF00,  -- 191, 255, 0
--       CD_FORESTGREEN = #014421   -- 1, 68, 33
         CD_FORESTGREEN = #008000   -- 1, 68, 33

if CD_TOPAZ or CD_RUBY or CD_LIME or CD_FORESTGREEN then end if

procedure draw_cube(integer wx, wh)
sequence points, cpoints

    points = corners
if use_rxyz then
    points = rotate(points,rxyz[X],X)
    points = rotate(points,rxyz[Y],Y)
    points = rotate(points,rxyz[Z],Z)
else
    points = rotate(points,rx,X)    -- (cube should now look like a H)
--  atom zr = 90-arctan(sqrt(2))*CD_RAD2DEG
--  points = rotate(points,zr,Z)    -- (cube should now look like an italic H)
    points = rotate(points,ry,Y)    -- (timed, two corners should remain static)
    points = rotate(points,rz,Z)
end if

-- Alt3: (define these colours locally)
--  draw a cross on the top in CD_TOPAZ, on the right in CD_RUBY, and on the front in CD_FORESTGREEN.
--  perhaps on the bottom in CD_BROWN, and perhaps left in CD_LIME
--  xColour("forestgreen",              #22, #8B, #22)
--      Topaz   #FFC87C and RGB code 255, 200, 124.
--      Ruby    #E0115F 224, 17, 95
--      Forest green    #014421 1, 68, 33
--      Bronze  #CD7F32 205, 127, 50 (bottom)
--      Bazaar  #98777B 152, 119, 123 (back??)
--      Lime    #BFFF00 191, 255, 0

--/*
OK, I've drawn a cube, quite nicely, I think:\\
I have identified the nearest corner, and draw three faces, in the correct order such that the one or even two faces I didn't actually need to draw get obscured properly.\\
I have (naievely) added up/down/left/right to rotate about the x and y axix, and +/- to rotate about the z axis.\\
Initially that works fine, but as some of you may already know, gets very odd as the pov changes.\\
I have investigated "arcball" and concluded three points:\\
1) it is a bit complicated (I could probably cope, but...)\\
2) I have other plans for using the mouse, I want to use the keyboard\\
3) what I really want to know is, from any pov, which is the top/left/front/right/bottom (and the never-drawn back).

So, focusing on point 3, of the 3 sides I draw, with the 7 {x,y} needed all present and correct, and knowing the nearest corner, how best can I assign top/left etc to those three faces?\\
I am not worried about "edge" case ambiguities, eg a rotation of exactly 45 degrees could equivalently be called left-front or front-right (or top-front or front-bottom).

AHA: the *nearest centre* of the 3 faces should be front, plus /one/ of:
--  left-top,
--  top-right,
--  right-bottom,
--  bottom-left
AHA2: front is the last one we draw (obviously!)

--*/

    points = projection(points,1000)
--  ,
--          highest = nearest(points,Y,-1),
--          lowest = nearest(points,Y,-1),
--          rightmost = nearest(points,X,1),
--          leftmost = nearest(points,X,-1)
--  IupSetStrAttribute(dlg,"TITLE","Draw a Rotating Cube (highest=%d, rightmost=%d, leftmost=%d)",{highest,rightmost,leftmost})

    --
    -- find the three faces that contain the nearest point
    --
    integer np = nearest(points), 
            front, up, left, diag
    sequence faceset = {}
    for i=1 to length(faces) do
        sequence fi = faces[i]
        integer k = find(np,fi)
        if k then
            diag = mod(k,4)+2
            diag = fi[diag]
            faceset = append(faceset,{points[diag][Z],i,diag})
        end if
    end for
    if length(faceset)!=3 then ?9/0 end if
    --
    -- order by/draw them furthest (diag) away first.
    --
    faceset = sort(faceset)
    --
    -- label them with F/B/U/D/L/R appropriately.
    -- look at the diagonal on the front to decide which other two sides are
    -- being drawn (one or even two of which may be completely obscured by 
    -- nearer faces, from some angles).
    --
    {front,diag} = faceset[3][2..3]     -- deciding the front is easy!
    pov_sides[front] = 'F'
    pov_sides[7-front] = 'B'
    if points[np][Y]>points[diag][Y] then   -- top(up) must be showing
        if points[np][X]>points[diag][X] then
            -- right must be showing (faceset[1..2] is TR or RT)
            if points[faceset[1][3]][Y]>points[faceset[2][3]][Y] then
                up = faceset[1][2]
                left = 7-faceset[2][2]
            else
                left = 7-faceset[1][2]
                up = faceset[2][2]
            end if
        else
            -- left must be showing (faceset[1..2] is LT or TL)
            if points[faceset[1][3]][Y]>points[faceset[2][3]][Y] then
                up = faceset[1][2]
                left = faceset[2][2]
            else
                left = faceset[1][2]
                up = faceset[2][2]
            end if
        end if
    else                                    -- down must be showing
        if points[np][X]<points[diag][X] then
            -- left must be showing (faceset[1..2] is LD or DL)
            if points[faceset[1][3]][Y]<points[faceset[2][3]][Y] then
                up = 7-faceset[1][2]
                left = faceset[2][2]
            else
                left = faceset[1][2]
                up = 7-faceset[2][2]
            end if
        else
            -- right must be showing (faceset[1..2] is RD or DR)
            if points[faceset[1][3]][Y]<points[faceset[2][3]][Y] then
                up = 7-faceset[1][2]
                left = 7-faceset[2][2]
            else
                left = 7-faceset[1][2]
                up = 7-faceset[2][2]
            end if
        end if
    end if
    pov_sides[up] = 'U'
    pov_sides[7-up] = 'D'
    pov_sides[left] = 'L'
    pov_sides[7-left] = 'R'
    --
    -- and work out the centre positions properly:
    --
    cpoints = centres
if use_rxyz then
    cpoints = rotate(cpoints,rxyz[X],X)
    cpoints = rotate(cpoints,rxyz[Y],Y)
    cpoints = rotate(cpoints,rxyz[Z],Z)
else
    cpoints = rotate(cpoints,rx,X)
    cpoints = rotate(cpoints,ry,Y)
    cpoints = rotate(cpoints,rz,Z)
end if
    cpoints = projection(cpoints,1000)
--?cpoints

--string f123="000"
--for i=1 to length(faceset) do
--  f123[i] += faceset[i][2]
--end for
--IupSetStrAttribute(dlg,"TITLE","Draw a Rotating Cube (%s, %s)",{pov_sides,f123})
IupSetStrAttribute(dlg,"TITLE","Draw a Rotating Cube (%s)",{pov_sides})

    for i=1 to length(faceset) do
        integer fdx = faceset[i][2]
        sequence fi = faces[fdx]
        cdCanvasSetForeground(cd_canvas,fi[1])
        -- draw edges (anti-aliased)
        cdCanvasBegin(cd_canvas,CD_CLOSED_LINES)
        vertices(wx,wh,points,fi)
        cdCanvasEnd(cd_canvas)
        -- fill sides (else would get bresenham edges)
        cdCanvasBegin(cd_canvas,CD_FILL)
        vertices(wx,wh,points,fi)
        cdCanvasEnd(cd_canvas)
--DEV a much better plan is to drawn F/U/R/L/D in the centres...
-- (and the centre is mid-point of 1 and 3, == 2 and 4, irrespective of np being 1/2/3/4)
----            -- draw cross
--          integer clr = CD_BLACK
----            if find(highest,fi) then
----                clr = CD_TOPAZ
----            elsif find(rightmost,fi) then
--          if i=1 then
--              clr = CD_RUBY
----            elsif find(leftmost,fi) then
--          elsif i=2 then
--              clr = CD_LIME
--          elsif i=3 then
--              clr = CD_FORESTGREEN
--          end if
--          cdCanvasSetForeground(cd_canvas,clr)
--          for j=2 to 3 do
--              integer fj = fi[j],
--                      fk = fi[j+2]
--              cdCanvasLine(cd_canvas,wx+points[fj][X],wh+points[fj][Y],
--                                     wx+points[fk][X],wh+points[fk][Y])
--          end for
        cdCanvasSetForeground(cd_canvas,CD_BLACK)
--      diag = faceset[i][3]
--      integer fi = faceset[i][2]
--      atom mx = wx+(points[np][X]+points[diag][X])/2,
--           my = wh+(points[np][Y]+points[diag][Y])/2
--      atom mx = wx+points[np][X],
--           my = wh+points[np][Y]
--?fdx
        atom mx = wx+cpoints[fdx][X],
             my = wh+cpoints[fdx][Y]
--?{fdx,mx,my,pov_sides[fdx..fdx]}
        cdCanvasText(cd_canvas, mx, my, pov_sides[fdx..fdx]) 
--
--      for i=2 to length(fi) do
--          integer fi = fi[i]
--          cdCanvasVertex(cd_canvas,wx+points[fi][X],wh-points[fi][Y])
--      end for
    end for
end procedure

function canvas_action_cb(Ihandle canvas)
--  if USE_OPENGL then
--      IupGLMakeCurrent(canvas)    -- (no diff?)
--  end if
    cdCanvasActivate(cd_canvas)
    cdCanvasClear(cd_canvas)
    integer {wx, wh} = sq_floor_div(IupGetIntInt(canvas, "DRAWSIZE"),2)
    draw_cube(wx,wh)
    cdCanvasFlush(cd_canvas)
--  if USE_OPENGL then
--      IupGLSwapBuffers(canvas)    -- (no diff?)
--  end if
    return IUP_DEFAULT
end function

function canvas_map_cb(Ihandle canvas)
    if USE_OPENGL then
        atom res = IupGetDouble(NULL, "SCREENDPI")/25.4
        IupGLMakeCurrent(canvas)    -- *** BIG DIFFERENCE! ***
        cd_canvas = cdCreateCanvas(CD_GL, "10x10 %g", {res})
    else
        cd_canvas = cdCreateCanvas(CD_IUPDBUFFER, canvas)
    end if
    cdCanvasSetBackground(cd_canvas, CD_PARCHMENT)
--  cdCanvasSetBackground(cd_canvas, CD_BLACK)
--  cdCanvasSetForeground(cd_canvas, CD_BLUE)
    {} = cdCanvasTextAlignment(cd_canvas, CD_CENTER) 
    return IUP_DEFAULT
end function

function canvas_unmap_cb(Ihandle canvas)
    cdKillCanvas(cd_canvas)
    return IUP_DEFAULT
end function

function canvas_resize_cb(Ihandle /*canvas*/)
    if USE_OPENGL then
        integer {canvas_width, canvas_height} = IupGetIntInt(canvas, "DRAWSIZE")
        atom res = IupGetDouble(NULL, "SCREENDPI")/25.4
--      IupGLMakeCurrent(canvas)    -- (no diff?)
        cdCanvasSetAttribute(cd_canvas, "SIZE", "%dx%d %g", {canvas_width, canvas_height, res})
    end if
    return IUP_DEFAULT
end function

--/*
#include <iostream>
#include <cmath> 
 
using namespace std; 
 
typedef struct {
    float x;
    float y;
    float z;
}Point;
Point points; 
 
float rotationMatrix[4][4];
float inputMatrix[4][1] = {0.0, 0.0, 0.0, 0.0};
float outputMatrix[4][1] = {0.0, 0.0, 0.0, 0.0}; 
 
void showPoint(){
    cout<<"("<<outputMatrix[0][0]<<","<<outputMatrix[1][0]<<","<<outputMatrix[2][0]<<")"<<endl;
} 
 
void multiplyMatrix()
{
    for(int i = 0; i < 4; i++ ){
        for(int j = 0; j < 1; j++){
            outputMatrix[i][j] = 0;
            for(int k = 0; k < 4; k++){
                outputMatrix[i][j] += rotationMatrix[i][k] * inputMatrix[k][j];
            }
        }
    }
}
void setUpRotationMatrix(float angle, float u, float v, float w)
{
    float L = (u*u + v * v + w * w);
    angle = angle * M_PI / 180.0; //converting to radian value
    float u2 = u * u;
    float v2 = v * v;
    float w2 = w * w; 
 
    rotationMatrix[0][0] = (u2 + (v2 + w2) * cos(angle)) / L;
    rotationMatrix[0][1] = (u * v * (1 - cos(angle)) - w * sqrt(L) * sin(angle)) / L;
    rotationMatrix[0][2] = (u * w * (1 - cos(angle)) + v * sqrt(L) * sin(angle)) / L;
    rotationMatrix[0][3] = 0.0; 
 
    rotationMatrix[1][0] = (u * v * (1 - cos(angle)) + w * sqrt(L) * sin(angle)) / L;
    rotationMatrix[1][1] = (v2 + (u2 + w2) * cos(angle)) / L;
    rotationMatrix[1][2] = (v * w * (1 - cos(angle)) - u * sqrt(L) * sin(angle)) / L;
    rotationMatrix[1][3] = 0.0; 
 
    rotationMatrix[2][0] = (u * w * (1 - cos(angle)) - v * sqrt(L) * sin(angle)) / L;
    rotationMatrix[2][1] = (v * w * (1 - cos(angle)) + u * sqrt(L) * sin(angle)) / L;
    rotationMatrix[2][2] = (w2 + (u2 + v2) * cos(angle)) / L;
    rotationMatrix[2][3] = 0.0; 
 
    rotationMatrix[3][0] = 0.0;
    rotationMatrix[3][1] = 0.0;
    rotationMatrix[3][2] = 0.0;
    rotationMatrix[3][3] = 1.0;
} 
 
int main()
{
    float angle;
    float u, v, w;
    cout<<"Enter the initial point you want to transform:";
    cin>>points.x>>points.y>>points.z;
    inputMatrix[0][0] = points.x;
    inputMatrix[1][0] = points.y;
    inputMatrix[2][0] = points.z;
    inputMatrix[3][0] = 1.0; 
 
    cout<<"Enter axis vector: ";
    cin>>u>>v>>w; 
 
    cout<<"Enter the rotating angle in degree: ";
    cin>>angle; 
 
    setUpRotationMatrix(angle, u, v, w);
    multiplyMatrix();
    showPoint(); 
 
    return 0;
}
--*/

function esc_close(Ihandle /*ih*/, atom c)
-- (I like all my demos to close when escape is keyed)
    if c=K_ESC then 
        return IUP_CLOSE
--SUG
--  else
    elsif use_rxyz then
        --
        -- Note that up/right/+ keys do not rotate about x/y/z but (anti-clockwise)  
        -- about the current left/top/front, from the camera pov, as assigned when
        -- the cube was last drawn.
        --
--      integer d = 1,
--              fdx = find(c,{K_DOWN,K_LEFT,'+'})
--      if fdx then
--          d = 359
--      else
--          fdx = find(c,{K_UP,K_RIGHT,'-'})
--      end if
        integer d = 1,
--              fdx = find(c,{K_UP,K_DOWN,K_LEFT,K_RIGHT,'+','-'})
--              fdx = find(c,{K_LEFT,K_DOWN,'-',K_UP,'+',K_RIGHT})
                fdx = find(c,{K_RIGHT,K_DOWN,'-','+',K_UP,K_LEFT})
        if fdx then
?"DRFBLU"[fdx..fdx]
--          fdx = find("UDLRFB"[fdx],pov_sides)
--          fdx = find("DRFBLU"[fdx],pov_sides)
            fdx = find(pov_sides[fdx],"ULBFRD")
?"DRFBLU"[fdx..fdx]
--          if and_bits(fdx,1)=0 then
            if fdx>3 then
                fdx = 7-fdx
                d = 359
            end if
--          fdx = floor((fdx+1)/2)
--string pov_sides = "RUFBDL" -- (re-assigned on every re-draw)
-- -                  YxZzXy    -- (upper=clockwise, lower=anti-clockwise)

--          fdx = find("UDLRFB"[fdx],pov_sides)
?{fdx,d}
            rxyz[fdx] = mod(rxyz[fdx]+d,360)            
            IupRedraw(canvas)
        end if
--  end if
    elsif c=K_UP then
--      dy = 1
        rx = mod(rx+359,360)
    elsif c=K_DOWN then
--      dy = -1
        rx = mod(rx+1,360)
    elsif c=K_LEFT then
        ry = mod(ry+359,360)
    elsif c=K_RIGHT then
        ry = mod(ry+1,360)
    elsif c='+' then
?find('U',pov_sides)
        rz = mod(rz+359,360)
    elsif c='-' then
        rz = mod(rz+1,360)
    end if
--  IupSetStrAttribute(dlg,"TITLE","Draw a Rotating Cube (rx=%d, ry=%d, rz=%d)",{rx,ry,rz})
    IupRedraw(canvas)
    return IUP_CONTINUE
end function

--function timer_cb(Ihandle /*ih*/)
--  ry = mod(ry+359,360)
--  IupRedraw(canvas)
--  return IUP_IGNORE
--end function

procedure main()
    IupOpen()
    IupImageLibOpen()
--  if USE_OPENGL then
--      IupGLCanvasOpen()   -- (no diff)
--  end if
    if USE_OPENGL then
        canvas = IupGLCanvas()
--      IupSetAttribute(canvas, "BUFFER", "DOUBLE") -- (no diff?)
    else
        canvas = IupCanvas()
    end if
    IupSetAttribute(canvas, "RASTERSIZE", "640x480")
    IupSetCallback(canvas, "ACTION", Icallback("canvas_action_cb"))
    IupSetCallback(canvas, "MAP_CB", Icallback("canvas_map_cb"))
    IupSetCallback(canvas, "UNMAP_CB", Icallback("canvas_unmap_cb"))
    IupSetCallback(canvas, "RESIZE_CB", Icallback("canvas_resize_cb"))
    dlg = IupDialog(IupVbox({canvas}))
    IupSetAttribute(dlg,"TITLE","Draw a Rotating Cube")
    IupSetCallback(dlg, "K_ANY",  Icallback("esc_close"))
    IupShow(dlg)
    IupSetAttribute(canvas, "RASTERSIZE", NULL)
--  Ihandle hTimer = IupTimer(Icallback("timer_cb"), 40)
    IupMainLoop()
    IupClose()
end procedure

main()

