--
-- demo\rosetta\3D_turtle_graphics.exw
-- ===================================
--
--  Fairly straightforward extension of Simple_turtle_graphics.exw, apart from
--  the time spent staring at my own hand figuring out the sequences of angles.
--
--  The turtle itself always draws in normal space, ie with the y axis vertical,
--  the x axis horizontal, and the z axis effectively a point, with any and all
--  3D effects generated by projection onto a camera plane, which can be moved
--  about with the usual four arrow and +/- keys. Note the camera handling was 
--  cribbed from demo/pGUI/rubik.e, less than perfect here but will have to do.
--
--  Invoking turn() (aka yaw) does pretty much what you would expect, whereas 
--  roll() rotates about the direction of travel. To simulate pitch() (aka to 
--  climb or nosedive) perform a roll(90), turn(pitch) sequence, avoiding any
--  temptation to "level off" before moving, as that just complicates angles.
--
with javascript_semantics
include turtle.e -- (common code for 2D and 3D versions)
include turtle_projection.e -- (final 3D projection stuff)

atom px = 0, py = 0, pz = 0,    -- position
     hx = 1, hy = 0, hz = 0,    -- heading
     nx = 0, ny = 0, nz = 1     -- normal

procedure walk3D(atom d)
    //
    // Move forward by distance d pixels.
    //
    // Aside: not entirely sure why rounding to 4dp (and normalising
    //  to 8dp) helps, but without it errors seem to build quickly..
    //  Of course in my opinion regularly teleporting the turtle back 
    //  to {0,0,0} would just be cheating whereas this makes it exact
    //
    sequence p1 = {px,py,pz}
    px = round(px+d*hx,10000)
    py = round(py+d*hy,10000)
    pz = round(pz+d*hz,10000)
    if pen_down then
        -- (not entirely sure why it's "{y,x} =" either, but it is.)
        atom {{y1,x1},{y2,x2}} = rotate_and_project({p1,{px,py,pz}})
        cdCanvasLine(cdcanvas,x1,y1,x2,y2)
    end if
end procedure

function left_unit_vector()
    return {ny*hz-nz*hy,nz*hx-nx*hz,nx*hy-ny*hx}
end function

function normalize(sequence v)
    v = sq_round(sq_mul(v,1/sqrt(sum(sq_power(v,2)))),100000000)
    return v
end function

enum ROLL,TURN

procedure rot3D(atom angle, integer tp)
    angle *= CD_DEG2RAD
    atom cos_a = cos(angle),
         sin_a = sin(angle),
         {ux,uy,uz} = left_unit_vector()
    if tp=ROLL then
        -- aka rotation about the heading
        {nx,ny,nz} = normalize({nx*cos_a-ux*sin_a,
                                ny*cos_a-uy*sin_a,
                                nz*cos_a-uz*sin_a})
        
    else -- tp=TURN
        -- aka rotation about the normal
        {hx,hy,hz} = normalize({hx*cos_a+ux*sin_a,
                                hy*cos_a+uy*sin_a,
                                hz*cos_a+uz*sin_a})
    end if
end procedure

procedure rtm3D(sequence s)
    -- s is a list of {roll,turn,dist}, any of which can be 0.
    for i=1 to length(s) do
        atom {roll,turn,dist} = s[i]
        if roll then rot3D(roll,ROLL) end if
        if turn then rot3D(turn,TURN) end if
        if dist then walk3D(dist) end if
    end for
end procedure
    
procedure rectangle(atom width, height, depth=width)
    rtm3D({{ 0, 0,height},{  0,90,width},{0,90,height},{0,90,width},
           {90,-90,depth},{-90,90,height},{0,90,depth},{0,90,height},{0,90,depth},
           {90,-90,width},{-90,90,height},{0,90,width},{0,90,height},{0,90,width},
           {90,-90,depth},{-90,90,height},{0,90,depth},{0,90,height},{0,90,depth},
           {-90,90,width},{ 90,90,0}})
end procedure

procedure draw_house(atom width, height)
    //
    // Draw a house at the current position
    // heading must be {1,0,0} for house to be upright
    //
    // house walls
    pendown()
    rectangle(width, height)

    // door
    penup()
    rtm3D({{0,90,width/7},{0,-90,0}})
    pendown(CD_GREEN)
    rectangle(width/8,height/2.5,0)
    penup()
    rtm3D({{0,-90,width/7},{0,90,0}})

    // roof
    walk3D(height)
    pendown(CD_ORANGE)
    rtm3D({{-45,45,width},{0,90,width}})
    penup()
    rtm3D({{0,-45,0},{90,-135,width},{0,45,0}})
    pendown(CD_ORANGE)
    rtm3D({{90,135,width},{0,90,width}})

    // return to original position and direction
    penup()
    rtm3D({{0,-45,0},{90,135,width},{90,90,-height}})

end procedure

procedure draw_barchart(sequence nums, atom w, h)
    // draw a barchart occupying the middle 60% of w,h
    // nums can contain +ve and/or -ve values.
    integer n = length(nums)
    atom mx = max(max(nums),0),
         mn = min(min(nums),0),
         r = mx-mn,                 -- range
         zl = abs(mn)/r*h*0.6+h/5,  -- zero line
         bw = w*0.6/n               -- bar width
    rtm3D({{0,90,w/5},{0,-90,zl}})
    pendown()
    for i=1 to n do
        atom ni = nums[i]/r*h*0.6
        pendown(iff(ni<0?CD_ORANGE:CD_NAVY))
        rectangle(bw,ni)
        rtm3D({{0,90,bw},{0,-90,0}})
    end for
    penup()
    // return to origin({w/2,0}) and direction 0:
    rtm3D({{0,180,zl},{0,90,w/5+bw*n},{0,90,0}})
end procedure

function redraw_cb(Ihandle /*ih*/)
    integer {width, height} = IupGetIntInt(canvas, "DRAWSIZE")
    atom hw = width/2, qw = width/4, qh = height/4
    cdCanvasActivate(cdcanvas)
    cdCanvasClear(cdcanvas)
    rtm3D({{0,0,qh},{0,90,qw},{0,-90,0}})

    draw_house(qw,qh)               -- house in the left half

    rtm3D({{0,180,qh},{0,90,qw},{0,90,0}}) -- return to {0,0}

    rtm3D({{0,90,hw},{0,-90,0}})    -- barchart in the right half

    draw_barchart({0.5, -4/3, 2, 1.3, 0.5},width/2,height)

    rtm3D({{0,-90,hw},{0,90,0}})    -- return to {0,0}

    -- sanity checks (but I got a 0.0002 under pwa/p2js when dev tools open...)
    if platform()!=JS then
        assert({px,py,pz}={0,0,0})
        assert({hx,hy,hz}={1,0,0})
        assert({nx,ny,nz}={0,0,1})
    end if

    cdCanvasFlush(cdcanvas)
    return IUP_DEFAULT
end function

function key_cb(Ihandle ih, atom c)
    if c=K_ESC then return IUP_CLOSE end if -- (standard practice for me)
    if c=K_F5 then return IUP_DEFAULT end if -- (let browser reload work)
    integer axis = find(c,{K_RIGHT,K_DOWN,'+',K_LEFT,K_UP,'-'})
    if axis then
        integer angle = 1
        if axis>3 then
            angle = 359
            axis -= 3
        end if
        if length(view_rotations) 
        and view_rotations[$][1] = axis then
            view_rotations[$][2] = mod(view_rotations[$][2]+angle,360)
        else
            view_rotations = append(view_rotations,{axis,angle})
        end if  
        IupRedraw(canvas)
    elsif c='0' then
        view_rotations = {}
        IupRedraw(canvas)
    end if      
    return IUP_CONTINUE
end function

IupOpen()
canvas = IupCanvas(Icallback("redraw_cb"),"RASTERSIZE=600x400")
dlg = IupDialog(canvas,`TITLE="3D turtle graphics"`)
IupMap(dlg)
cdcanvas = cdCreateCanvas(CD_IUP, canvas)
IupShow(dlg)
IupSetAttribute(canvas, "RASTERSIZE", NULL) -- release minimum limit
IupSetCallback(dlg, "KEY_CB",  Icallback("key_cb"))
IupSetAttributeHandle(NULL, "PARENTDIALOG", dlg)
if platform()!=JS then
    IupMainLoop()
    IupClose()
end if

