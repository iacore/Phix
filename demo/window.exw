--****
-- === win32/window.exw
--
-- A Standard Windows Window coded at the primitive API level
-- Most Euphoria programmers should simply use Win32Lib, wxWidgets, EuGTK or EuIUP!
--

--/*
include std/os.e
include std/machine.e
include std/dll.e
--*/

constant cbSize = 0,
         style  = 4,
         lpfnWndProc = 8,
         cbClsExtra = 12,
         cbWndExtra = 16,
         hInstance  = 20,
         hIcon      = 24,
         hCursor    = 28,
         hbrBackground = 32,
         lpszMenuName  = 36,
         lpszClassName = 40,
         hIconSm = 44,
         SIZE_OF_WNDCLASS = 48

constant SIZE_OF_MESSAGE = 40

constant CS_HREDRAW = 2,
         CS_VREDRAW = 1

constant SW_SHOWNORMAL = 1

constant WM_CREATE = #01,
         WM_PAINT  = #0F,
         WM_DESTROY = #02,
         WM_CHAR = 258,
         VK_ESCAPE = 27

constant SND_FILENAME = #00020000,
         SND_ASYNC    = #00000001

constant DT_SINGLELINE = #0020,
         DT_CENTER     = #0001,
         DT_VCENTER    = #0004

function or_all(sequence s)
-- or together all elements of a sequence
atom result

    result = 0
    for i=1 to length(s) do
        result = or_bits(result, s[i])
    end for
    return result
end function

constant WS_OVERLAPPED  = #00000000,
         WS_CAPTION     = #00C00000,
         WS_SYSMENU     = #00080000,
         WS_THICKFRAME  = #00040000,
         WS_MINIMIZEBOX = #00020000,
         WS_MAXIMIZEBOX = #00010000

constant IDC_ARROW = 32512,
         WHITE_BRUSH = 0,
         CW_USEDEFAULT = #80000000,
         WS_OVERLAPPEDWINDOW = or_all({WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU,
                                       WS_THICKFRAME, WS_MINIMIZEBOX,
                                       WS_MAXIMIZEBOX}),
         DT_SINGLECENTER = or_all({DT_SINGLELINE, DT_CENTER, DT_VCENTER}),
         SND_FILEASYNC = or_bits(SND_FILENAME,SND_ASYNC)

integer xLoadIcon, LoadCursor, GetStockObject, RegisterClassEx,
        xCreateWindowEx, ShowWindow, UpdateWindow, xGetMessage,
        TranslateMessage, DispatchMessage, PlaySound, BeginPaint,
        GetClientRect, DrawText, EndPaint, xPostQuitMessage, DefWindowProc

procedure not_found(sequence name)
    puts(1, "Couldn't find " & name & '\n')
    abort(1)
end procedure

function link_dll(sequence name)
-- dynamically link a dll
atom lib = open_dll(name)
    if lib=NULL then not_found(name) end if
    return lib
end function

function link_c_func(atom dll, sequence name, sequence args, atom result)
-- dynamically link a C routine as a Euphoria function
integer handle = define_c_func(dll, name, args, result)
    if handle=-1 then not_found(name) end if
    return handle
end function

function link_c_proc(atom dll, sequence name, sequence args)
-- dynamically link a C routine as a Euphoria function
integer handle = define_c_proc(dll, name, args)
    if handle=-1 then not_found(name) end if
    return handle
end function

procedure link_dll_routines()
-- get handles to all dll routines that we need
atom user32, gdi32, winmm

    user32 = link_dll("user32.dll")
    gdi32 = link_dll("gdi32.dll")
    winmm = link_dll("winmm.dll")

    xLoadIcon = link_c_func(user32, "LoadIconA", {C_POINTER, C_INT}, C_INT)
    LoadCursor = link_c_func(user32, "LoadCursorA", {C_POINTER, C_INT}, C_INT)
    GetStockObject = link_c_func(gdi32, "GetStockObject", {C_INT}, C_INT)
    RegisterClassEx = link_c_func(user32, "RegisterClassExA", {C_POINTER}, C_INT)
    xCreateWindowEx = link_c_func(user32, "CreateWindowExA",
                                  {C_INT, C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT},
                                  C_INT)
    ShowWindow = link_c_proc(user32, "ShowWindow", {C_INT, C_INT})
    UpdateWindow = link_c_proc(user32, "UpdateWindow", {C_INT})
    xGetMessage = link_c_func(user32, "GetMessageA",
                             {C_INT, C_INT, C_INT, C_INT}, C_INT)
    TranslateMessage = link_c_proc(user32, "TranslateMessage", {C_INT})
    DispatchMessage = link_c_proc(user32, "DispatchMessageA", {C_INT})
    PlaySound = link_c_proc(winmm, "PlaySound", {C_INT, C_INT, C_INT})
    BeginPaint = link_c_func(user32, "BeginPaint", {C_INT, C_POINTER}, C_INT)
    GetClientRect = link_c_proc(user32, "GetClientRect", {C_INT, C_POINTER})
    DrawText = link_c_proc(user32, "DrawTextA",
                           {C_INT, C_INT, C_INT, C_INT, C_INT})
    EndPaint = link_c_proc(user32, "EndPaint", {C_INT, C_INT})
    xPostQuitMessage = link_c_proc(user32, "PostQuitMessage", {C_INT})
    DefWindowProc = link_c_func(user32, "DefWindowProcA",
                                {C_INT, C_INT, C_INT, C_INT}, C_INT)
end procedure

link_dll_routines()

global function WndProc(atom hwnd, atom iMsg, atom wParam, atom lParam)
-- callback routine to handle Window class
atom hdc, wav_file, Euphoria, ps, rect

    if iMsg=WM_CREATE then
        wav_file = allocate_string("\\Windows\\Media\\tada.wav")
        c_proc(PlaySound, {wav_file,NULL,SND_FILEASYNC})
        free(wav_file)
        return 0

    elsif iMsg=WM_PAINT then
        ps = allocate(64)
        rect = allocate(16)
        hdc = c_func(BeginPaint, {hwnd, ps})
        c_proc(GetClientRect, {hwnd, rect})
        Euphoria = allocate_string("A Plain Vanilla Window using Euphoria!")
        c_proc(DrawText, {hdc, Euphoria, -1, rect,DT_SINGLECENTER})
        free(Euphoria)
        c_proc(EndPaint, {hwnd, ps})
        free(ps)
        free(rect)
        return 0

    elsif iMsg=WM_DESTROY or (iMsg=WM_CHAR and wParam=VK_ESCAPE) then
        c_proc(xPostQuitMessage, {0})
        return 0

    end if

    return c_func(DefWindowProc, {hwnd, iMsg, wParam, lParam})
end function

procedure WinMain()
atom wndclass
atom szAppName
integer id
atom WndProcAddress
atom hwnd
atom msg
atom class
atom icon_handle
atom my_title

    wndclass = allocate(SIZE_OF_WNDCLASS)
    szAppName = allocate_string("HelloWin")

    id = routine_id("WndProc")
    if id=-1 then
        puts(1,"routine_id failed!\n")
        abort(1)
    end if
    WndProcAddress = call_back(id) -- get 32-bit address for callback

    poke4(wndclass+cbSize, SIZE_OF_WNDCLASS)
    poke4(wndclass+style, or_bits(CS_HREDRAW, CS_VREDRAW))
    poke4(wndclass+lpfnWndProc, WndProcAddress)
    poke4(wndclass+cbClsExtra, 0)
    poke4(wndclass+cbWndExtra, 0)
    poke4(wndclass+hInstance, 0) --hInstance

    -- set icon in top-left of window
    icon_handle = c_func(xLoadIcon, {instance(), 10})
    poke4(wndclass+hIcon, icon_handle)
    poke4(wndclass+hIconSm, icon_handle)

    -- Wolfgang Fritz observes that you can set an icon dynamically using:
    -- junk = sendMessage(hwnd, WM_SETICON, 1, icon_handle) 
    -- where WM_SETICON is 128, 1=big icon, 0 for small icon

    poke4(wndclass+hCursor, c_func(LoadCursor, {NULL, IDC_ARROW}))
    poke4(wndclass+hbrBackground, c_func(GetStockObject, {WHITE_BRUSH}))
    poke4(wndclass+lpszMenuName, NULL)
    poke4(wndclass+lpszClassName, szAppName)

    class = c_func(RegisterClassEx, {wndclass})
    free(szAppName)
    free(wndclass)
    if class=0 then
        puts(1, "Couldn't register class\n")
        abort(1)
    end if
    my_title = allocate_string("Euphoria for WIN32")
    hwnd = c_func(xCreateWindowEx, {
                                    0,                   -- extended style
                                    class,               -- window class name
                                    my_title,            -- window caption
                                    WS_OVERLAPPEDWINDOW, -- window style
                                    CW_USEDEFAULT,       -- initial x position
                                    CW_USEDEFAULT,       -- initial y position
                                    CW_USEDEFAULT,       -- initial x size
                                    CW_USEDEFAULT,       -- initial y size
                                    NULL,                -- parent window handle
                                    NULL,                -- window menu handle
                                    0 ,                  -- hInstance // program instance handle
                                    NULL})               -- creation parameters
    free(my_title)
    if hwnd=0 then
        puts(1, "Couldn't CreateWindow\n")
        abort(1)
    end if
    c_proc(ShowWindow, {hwnd, SW_SHOWNORMAL})
    c_proc(UpdateWindow, {hwnd})

    msg = allocate(SIZE_OF_MESSAGE)
    while c_func(xGetMessage, {msg, NULL, 0, 0}) do
        c_proc(TranslateMessage, {msg})
        c_proc(DispatchMessage, {msg})
    end while
    free(msg)
end procedure

WinMain()

--added to prevent false positives... [DEV, reported]
--include ..\test\t01type.exw
include ..\test\t02parms.exw

