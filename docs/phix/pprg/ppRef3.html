<html><head><title>Print Preview and Report Generator Reference Section</title></head>
<style type="text/css">
<!--
body        {background-color: "#D0D0D0";}
a           {text-decoration: none;}
a:link      {color: "#0033BB"; text-decoration: underline;}
a:visited   {color: "#006699"; text-decoration: underline;}
a:active    {color: red; text-decoration: underline;}
a:hover     {color: red; text-decoration: underline;}
a.blue    {text-decoration: none;}
a.blue:link      {color: "#5500FF"; text-decoration: underline;}
a.blue:visited   {color: "#5500FF"; text-decoration: underline;}
a.blue:active    {color: red; text-decoration: underline;}
a.blue:hover     {color: red; text-decoration: underline;}
a.brown      {text-decoration: none;}
a.brown:link      {color: "#993333"; text-decoration: underline;}
a.brown:visited   {color: "#993333"; text-decoration: underline;}
a.brown:active    {color: red; text-decoration: underline;}
a.brown:hover     {color: red; text-decoration: underline;}
OL.n        { list-style-type: arabic-numbers }
OL.ua       { list-style-type: upper-alpha }
-->
</style>
<style>
BODY {SCROLLBAR-FACE-COLOR: #330066; SCROLLBAR-HIGHLIGHT-COLOR: #CCCCFF; 
      SCROLLBAR-SHADOW-COLOR: #CCCCFF; SCROLLBAR-3DLIGHT-COLOR: #CCCCFF; 
      SCROLLBAR-ARROW-COLOR:    #FFFFFF; SCROLLBAR-TRACK-COLOR: #CCCCFF; 
      SCROLLBAR-DARKSHADOW-COLOR: #330066; }
</style>
<body>
<a href="pprg.html">Table of Contents</a>
<a href="ppRef2.html">Previous Page - Reference Section Part 2</a>
<a href="ppRef4.html">Next Page - Reference Section Part 4</a>
<p><hr></p>
<p align=center>
<h2>Print Preview and Report Generator</h2>
<h3>Reference Section Part 3</h3></p>
<p><hr><p>
<p>
<a name=CalcDef></a>
<h3>Calculated Field Definition</h3>
<!--------------------------------->
<a name=jcalcdef></a>
<a href="ppRef2.html#jsummations">Previous ScreenShot</a>
<a href="ppRef3.html#jfunctions">Next ScreenShot</a><p>
<img src="images/calculated.jpg"
     alt="The Calculated Field Definition Window.">
<br>
The Calculated Field Definition Window.
<p>
<h5>Name</h5>
Press F1 or press the button to the right of the name field to list the existing calculated
field definitions, or enter the name of an existing field for editing, or enter
a new, unique name to define a new calculation.<p>
Note that calculated fields are listed in alphanumeric order (capital letters before lowercase),
in the <a href="ppRef2.html#Calculated">Calculated Fields Lookup</a> window, so careful choice 
of name should be used to group related calculations. It is also sensible to consider whether
or not a calculation is general purpose, or specific to the current layout or a particular 
record.
<p>
When typing in a calculation name, if the calculation already exists, the Formula is updated
and the field background set to Gray as a warning that you are editing an existing field (but
returned to white when editing the formula).<br>
The text of the default button is also changed between Add and Replace to indicate whether
an existing expression is being amended or a new field is being defined.
<p>
<h5>Default Format</h5>
This value will be used when the calculation name is copied back to the format and fields
list.
<p>
<h5>Formula</h5>
Enter the calculation formula, for example OHnet+OHvat.<p>
Either type the expression manually, or:<p>
Press F1 or click on the first button to the right of the formula field to display the
dictionary fields lookup. Select OHnet.<p>
Type +<p>
Press F1 and select OHvat. The expression is now complete.<p>
Standard fields, previously defined calculations, summations, and functions may be selected in 
much the same way:
<p>
The six buttons to the right of the formula window correspond to pressing F1 to F6 in the
Formula field. The fifth button is always present, but disabled on this window, to be
consistent with the <a href=#F1F6>Field Details Window</a>.<p>
<p>
Application developers should already know that calculations are far easier to perform in
the datastream creation program. However, end users making minor ad hoc changes to reports
may not have or want access to the program source, which is mainly why calculated fields 
exist.
<p>
See also the sections on 
<a href="#StdValues">Standard Values</a>,
<a href="#OPA">Operators, Precedence and Associativity</a>,
<a href="#NegIdx">Negative Indexes</a>,
<a href="#formats">A Brief Introduction to sprintf</a>,
<a href="#Complex">Complexity Example</a>, and
<a href="#Error">Calculation Errors</a>.
<p>
<h5>Add/Replace</h5>
Pressing Enter or clicking on this button validates the formula, saves it to file, closes
the calculated field definition window, and inserts the calculation name and format into the 
field details window.
<p>
<h5>Save</h5>
The Save button validates the formula and saves it to file, but leaves the calculated field
definition window open. This can be useful when entering a complex expression which must
be entered as several distinct expressions, but only the final expression name
should be pasted back to the field list in the details window.
<p>
<h5>Cancel</h5>
Pressing Escape or clicking on this button closes the calculated field definition window 
without saving any details.
<p>
<p>
<a name=Functions></a>
<h3>Function Lookup</h3>
<!--------------------->
<a name=jfunctions></a>
<a href="ppRef3.html#jcalcdef">Previous ScreenShot</a> Thanks all folks!<p>
<img src="images/functions.jpg"
     alt="The Function Lookup Window.">
<br>
The Function Lookup Window.
<p>
Cursor to the required line and press Return, or double click on a line to select the field.<p>
<p>
The functions available are:
<p>
<pre>
    length(s)       -- length of sequence. An error occurs if not a sequence.
    integer(x)      -- 1 if integer, else 0
    atom(x)         -- 1 if atom, else 0
    object(x)       -- 1
    sequence(x)     -- 1 if sequence, else 0
    reverse(s)      -- reverse sequence
    sort(s)         -- sort sequence
    lower(x)        -- lower case
    upper(x)        -- upper case
    sqrt(x)         -- square root
    rand(x)         -- random numbers
    floor(x)        -- round down. Note that floor(-1.2) is -2.
    log(x)          -- natural logarithms
    not_bits()      -- bitwise not
    ordinal(i)      -- returns "1st", "2nd" etc  - suffixed form of integer parameter.
                    -- returns "ordinal() error" if not passed a positive integer.
    not(x)          -- logical not of x, equivalent to not x
    sprint(x)       -- returns number sequence representation. 
                    -- Eg sprint("hello") returns {104,101,108,108,111}.
                    -- For printing text, use sprintf.
    fact(i)         -- factorial, 1*2*3..i, equivalent to i!
                    -- if not passed an atom returns "fact() error".
    remainder(x1,x2)-- remainder after dividing x1 by x2
    and_bits()      -- bitwise and
    or_bits()       -- bitwise or
    xor_bits()      -- bitwise xor
    equal(x1,x2)    -- 1 if equal, else 0
    compare(x1,x2)  -- -1 if x1<x2, 0 if x1=x2, 1 if x1>x2
    append(s,x)     -- appends x to s. length is length(s)+1.
    prepend(s,x)    -- prepend x to start of s. length is length(s)+1.
    repeat(x,i)     -- create a sequence of i x's
    sprintf(s,{x})  -- print to string, see below
    find(x,s)       -- index of x in s, else 0
    match(s1,s2)    -- slice start of s1 in s2, else 0
    perm(i1,i2)     -- permutation, equivalent to i1!/(i1-i2)!
    comb(i1,i2)     -- combination, equivalent to i1!/(i2!*(i1-i2)!)
</pre>
    In the following, x1 and x2 my be integers, atoms, or sequences.
    If they are both sequences, they must be the same length.
<pre>
    or(x1,x2)       -- logical or of x1 and x2, equivalent to infix or
    and(x1,x2)      -- logical and of x1 and x2, equivalent to infix and
    xor(x1,x2)      -- logical xor of x1 and x2, equivalent to infix xor
    add(x1,x2)      -- adds x1 and x2, equivalent to infix x1+x2
    sub(x1,x2)      -- subtracts x2 from x1, equivalent to infix x1-x2
    div(x1,x2)      -- divides x1 by x2, equivalent to infix x1/x2
    mul(x1,x2)      -- multiplies x1 by x2, equivalent to infix x1*x2
    power(x1,x2)    -- x1 raised to the power of x2, equivalent to x1^x2
                    -- NB: no overflow checking on this function.
</pre>
In addition, the application developer may provide user-defined functions. The example
sources userfunc.ew and ffmt.e give examples of this. Capital(x) is defined directly
userfunc.ew (eg when passed "PETE" or "pete" it returns "Pete"). Ffmt() is defined in
ffmt.e (eg when passed {-1234567,"US$,20.2)"} it returns "   US$(1,234,657.00)").
The necessary wrapper for dealing with multiple parameters is shown in userfunc.ew.
<p> 
Application defined functions may only be passed a single parameter. If necessary, 
multiple parameters must be passed from the calculation expression as a sequence.
Each function is passed to the report generator initialisation routine (initialise_pprg)
as a triplet of {name,description,routine-id} in the 5th parameter. The first four
parameters should be (0,{},{},{}) for this initialisation.

<p>
<p>
<a name=StdValues></a>
<h3>Standard Values</h3>
<!--------------------->
<p>
    The following standard Eu values and functions are are supported:
<p>
<ul>
<li>    Integer values, eg 1
<li>    Floating point values, eg 1.2
<li>    Sequences, eg {1,2,3}
<li>    String literals, eg "Invoice"  standard escape sequences \n \r \t, \\, \", \'.
<li>    Subscripting, eg OHdate[4]. Unlike standard euphoria, subscripting is permitted on
         any expression creating a sequence, eg {"Invoice","Credit"}[XXtype].
         An error will occur if the expression does not evaluate to a sequence.
<li>    Subscripts may be nested, eg x[1][2].
<li>    Slices (eg OHaddr[1..4]) are also supported.
<li>    The standard fields, listed above, and other calculated fields.
</ul>
<p>
    Calculated fields are defined independantly of report layouts so they can be used on 
    all the different reports printed by the application.
<p>
    Calculated field names always begin with a percent sign(%).
<p>
    Naturally, the application can easily perform most calculations, and simply write the
    results to the datastream. The only values it cannot calculate are page numbering and 
    totalling, since the application, although it can force page breaks, is not otherwise 
    responsible for them.
<p>
<p>
<a name=OPA></a>
<h3>Operators, Precedence and Associativity</h3>
<!--------------------------------------------->
<p>
    Precedence and associativity are the rules used internally to ensure that an expression
    such as 8-3-2 is treated as (8-3)-2, giving 3, and not 8-(3-2), giving 7.
    Also, 2+6*3 is treated as 2+(6*3) whereas 3*2+5 is treated as (3*2)+5.
    The casual reader should understand that it is always possible to use parenthesis to be 
    explicit about the intended meaning of an expression, and ignore the technical details
    and skip to the <a href="#NegIdx">next section</a>.
<p>
    Normal syntax rules apply, with the following precedence and associativity:
<p>
<table border align="center" cellpadding=10 cellspacing=0>
<tr align="center"><th>Operator<th>Precedence<th>Associativity
<tr align="center"><td>functions         <td>11         <td>u
<tr align="center"><td>unary +,-,! not   <td>10         <td>r
<tr align="center"><td>^ (power)         <td>9          <td>u
<tr align="center"><td>*,/               <td>8          <td>l
<tr align="center"><td>+,-               <td>7          <td>l
<tr align="center"><td>&                 <td>6          <td>l
<tr align="center"><td><,>,<=,>=,..  <td>5          <td>l
<tr align="center"><td>=,!=          <td>4          <td>l
<tr align="center"><td>,                 <td>3          <td>l
<tr align="center"><td>and or xor        <td>2          <td>l
<tr align="center"><td>{},[],()          <td>1          <td>l
</table>
<p>
    For example a and b or c is treated as (a and b) or c, 2+3*4 is treated as 2+(3*4), 
    giving 14, and not (2+3)*4, giving 20.<p>
    The infix power operator is deliberately unassociated so that 2^3^4 causes the 
    message "ambiguous: add parenthesis" to be displayed.<p>
    In many senses, brackets are handled explicitly and have varying precedence and 
    associativity in different contexts.<p>
    For more details, please refer to the paper by Thomas Niemann
    (http://epaperpress.com/oper/index.html) on which expression handling is based.
    (although parseTbl is now 900 flags, not the paltry 139 shown in that paper;-)
    Note that, as admitted by Niemann, postfix notation is sometimes unexpectedly parsed 
    and evaluated successfully, eg (1)2+ generates no error (and evaluates to 3). 
    There are no plans to alter this behaviour. Gross errors in expression entry remain 
    the responsibility of the user!
<p>
<p>
<a name=NegIdx></a>
<h3>Negative Indexes</h3>
<!---------------------->
<p>
    Negative indexes may be used instead of coding length() calls. The following extract
    is taken from the draft openEU documentation, so it is written for general purpose
    programming, as opposed to calculated fields where only a single expression may be 
    entered. It is a bit long, so you may want to 
    <a href="#formats">skip to the next section</a>.
<p>
<p>
<h4>Accessing Sequence Elements</h4>
<!--------------------------------->
<p>
The number of elements in a sequence can be found by calling the 
length() function. For example:
<pre>
    s={'a','b','c','d','e'}
    j=length(s)     -- j is now 5
</pre>
Individual elements of s can be referenced using an expression which 
returns a single positive integer from 1 to length(s), for example:
<pre>
    x=s[1]          -- x is now 'a'
    s[3]='Z'        -- s is now {'a','b','Z','d','e'}
</pre>
Attempts to reference s[0] or s[6] (and above) cause an index out of 
bounds error.
<p>
Elements of s can also be referenced using -1 to -length(s), counting 
backwards from the end of the sequence, for example:
<pre>
    x=s[-1]         -- x is now 'e'
    s[-3]='c'       -- s is now {'a','b','c','d','e'}
</pre>
In this way, negative indexes are simply an exact mirror image (right 
to left) of the more common (left to right) positive indexes. 
See also the end keyword.
<p> 
Attempts to reference s[-6] and below cause an index out of bounds error.
<p>
<p>
<h4>Slicing</h4>
<!------------->
<p>
It is also possible to reference several consecutive elements using a 
slice, eg
<pre>
    x=s[3..4]           -- x is now {'c','d'}
    s[3..4]={'X','Y'}   -- s is now {'a','b','X','Y','e'}
    s[3..4]=0           -- s is now {'a','b',0,0,'e'}
</pre>
Note that assignment to a sequence slice does NOT change the length of 
the sequence. In fact,
<pre>
    s={'a','b','c','d','e','f','g'}
    s[3..4]={'X','Y','Z'}
</pre>
gives an error "lengths do not match on assignment to slice (3 != 2)".
Instead the following must be used:
<pre>
    s=s[1..2]&{'X','Y','Z'}&s[5..-1]
    -- s is now {{'a','b','X','Y','Z','e','f','g'}
</pre>
Or alternatively you may have meant:
<pre>
    s[3..4]=repeat({'X','Y','Z'},2)
    -- s is now {{'a','b',{'X','Y','Z'},{'X','Y','Z'},'e','f','g'}
</pre>
<p>
The end keyword may be used instead of -1, see below.
<p>
<p>
<h4>More Examples</h4>
<!------------------->
<pre>
    s="(0,0)"
    x=s[1..-1]      -- x is now "(0,0)"         -- length(x) is 5
    x=s[2..-2]      -- x is now  "0,0"          -- length(x) is 3
    x=s[3..-3]      -- x is now   ","           -- length(x) is 1

    s="abc.exw"
    if equal(s[1..3],"abc") then        -- this is true
    if equal(s[-3..-1],"exw") then      -- this is true

    s=s[3..-1]      -- removes the first two elements of s
    s=s[1..-3]      -- removes the last two elements of s

    s=s[1..2]       -- selects the first two elements of s
    s=s[-2..-1]     -- selects the last two elements of s
</pre>
<p>
<h4>The end keyword</h4>
<!--------------------->
<p>
The following are equivalent to the last five examples, and many 
people find them much more readable:
<pre>
    if equal(s[end-2..end],"exw") then
    s=s[3..end]
    s=s[1..end-2]
    s=s[1..2]
    s=s[end-1..end] 
</pre>
The end keyword is also used to end the definition of procedures, 
functions, types, and if, for, or while constructs. The end keyword 
only has this special meaning when used within []. Outside [], use 
length(), and/or (occasionally) -1, eg
<pre>
    for i=1 to length(s) do

    j=find(input,months)
    if j>0 and j&lt;length(months) then

    procedure zero(integer zfrm, integer zto)
        s[zfrm..zto]=0
        t[zfrm..zto]=0
        u[zfrm..zto]=0
    end procedure
    zero(1,-1)
</pre>
<p>
<h4>Special cases</h4>
<!------------------->
<pre>
s[i..i] returns {s[i]}, a sequence containing just s[i]         [1]
s[i..i-1] returns {} when i is positive (1<=i<=length(s)+1),    [2]
s[i..i+1] returns {} when i is negative (-length(s)-1<=i<=-1).  [3]
</pre>
Case [2] in particular makes sequence manipulation much easier, for 
example to replace instances of "foo" with "bar" use the following:
<pre>
    s="a foobar"
    i=match("foo",s)        -- i is now 3
    if i then
        s=s[1..i-1]&"bar"&s[i+3..end]
    end if
</pre>
When i is 3, the last expression is equivalent to:
<pre>
        s=s[1..2]  &"bar"&s[6..8]
        --  "a "    "bar"   "bar"
</pre>
which gives the required result of "a barbar"
<p>
Now, if s="foobar", then i=1 and the expression evaluates to:
<pre>
        s=s[1..0]  &"bar"&s[4..6]
        --  ""      "bar"   "bar"
</pre>
The special case [2] here allows use of the same code both when the 
matched string is at the start and when it is not.
<p>
If s="barfoo", then i=4 and the expression evaluates to:
<pre>
        s=s[1..3]  &"bar"&s[7..6]
        --  "bar"   "bar"   ""
</pre>
In summary, if length(s)=4, s[1..0], s[2..1], through to s[5..4] 
return {}. Similar rules hold for negative slices and case[3], 
however they rarely occur in practice.
<p>
<p>
<a name=formats></a>
<h3>A Brief Introduction to sprintf(st,x)</h3>
<!------------------------------------------->
Copied from the Euphoria manual:
<p>
        If x is an atom then a single value will be returned.
        If x is a sequence, then formats from st are applied to successive elements of x.
        The basic formats are:
<pre>
         %d - print an atom as a decimal integer
         %x - print an atom as a hexadecimal integer
         %o - print an atom as an octal integer
         %s - print a sequence as a string of characters, or an atom as a single character
         %e - print an atom as a floating point number with exponential notation
         %f - print an atom as a floating-point number with a decimal point but no exponent
         %g - print an atom as a floating point number using either the %f or %e format,
                whichever seems more appropriate
         %% - print the '%' character itself
</pre>
<p>
         Field widths can be added to the basic formats, e.g. %5d, %8.2f, %10s. 
         The number before the decimal point is the minimum field width to be used. 
         The number after the decimal point is the precision to be used. 
<p>
         If field width is negative, e.g. %-5d the value will be left-justified within field.
         Normally it will be right-justified. If the field width starts with a leading 0,
         e.g. %08d then leading zeros will be supplied to fill up the field.
         If the field width starts with a '+' e.g. %+7d then a plus sign will be printed for
         positive values. 
<p>
         Comments: Watch out for the following common mistake:  
<pre>
            name="John Smith"
            printf(1,"%s",name)     -- error! - Prints "J" only - applies %s to 1st element of x
            printf(1,"%s",{name})   -- correct! - applies %s to 1st element of {}, name in full.
</pre>
<p>
<p>
    One use of calculated fields worth mentioning is lookup tables. For example, define the
    calculated field %DocTypes as {"Estimate","Invoice","Credit Note"} and if OHtype holds a
    value of 1, 2, or 3 accordingly, you can then define a second calculated field with the 
    expression %DocTypes[OHtype]. Instead of using two calculated fields, you can also just
    define one as {"Estimate","Invoice","Credit Note"}[OHtype], it depends on whether you
    are going to use %DocTypes in several places indexed by different values, or not.
<p>
<p>
<p>
<a name=Complex></a>
<h3>Complexity Example</h3>
<!------------------------>
    The following expression is legal and produces the same result as standard Euphoria. 
    It is meaningless, just an example of how complex you can go if you want to. Thanks,
    (well, I guess thanks is the word!), to Derek Parnell:
<p>
        power(add(div(power(div(add(27,power(69,div(1,3))),2),div(1,3)),3),
                power(div(2,add(27,power(69,div(1,3)))),div(1,3))),3000)
<p>
    This has been tested in Euphoria using the functions<br>
        function add(atom a,atom b)
            return a+b
        end function<br>
        function div(atom a,atom b)
            return a/b
        end function
<p>
    The expression can also be written as:
<p>
        power(power((27+power(69,1/3))/2,1/3)/3+power(2/(27+power(69,1/3)),1/3),3000)
<p>
    and as:
<p>
        ((((27+69^(1/3))/2)^(1/3))/3+(2/(27+69^(1/3)))^(1/3))^3000
<p>
    All three give the same answer (3.283481206e+272)
<p>
    Of course it is much easier to write this in segments, eg:
<p>
<pre>
        %d13 = div(1,3)
        %p69 = power(69,%d13)
        %a27 = add(27,%p69)
        %phalf = power(div(%a27,2),%d13)
        %pdinv = power(div(2,%a27),%d13)
        %sum = add(div(%phalf,3),%pdinv)
        .. power(%sum,3000)
</pre>
<p>
    or:
<p>
<pre>
        %third = 1/3
        %p69 = 69^%third
        %a27 = 27+%p69)
        %phalf = (%a27/2)^%third
        %pdinv = (2/%a27)^%third
        %sum = %phalf/3+%pdinv
        .. %sum^3000
</pre>
<p>
    (OK, I suspect or at least hope that sort of breakdown would make more sense if the 
     original expression was not gibberish to start with!)
<p>
    Note that such expressions should always be written down first on paper. During the
    definition of say %phalf you realise that %a27 has not yet been defined, the error
    will prevent attempts to save the formula. If this happens, I suggest you place quote
    marks ("%a27") to save it as a string and make a note to go back and change it later.
    (There is no type error; add("the","but") is valid and produces the same value as the
    -legal- Euphoria expression "the"+"but".)
<p>
<p>
<a name=Error></a>
<h3>Calculation Errors</h3>
<!------------------------>
<p>
    If you get an error in a calculated field, the normal mechanisms of debugging and
    tracing do not apply (since it is not Euphoria code). The correct procedure is:
<ul>
<li>Try to create the smallest possible datastream that exhibits the problem.<br>
    If you are an application developer, you may want to hand code one as per pptest.exw,<br>
    if you are an end user tailoring a standard report, just try to use as many 
    selection criteria as possible (assuming the application has any).
    <p>
<li>Break the calculation down into smaller chunks, eg (repeated from above),
<pre>
        ((((27+69^(1/3))/2)^(1/3))/3+(2/(27+69^(1/3)))^(1/3))^3000
</pre>
can be rewritten as
<pre>
        %d13 = div(1,3)
        %p69 = power(69,%d13)
        %a27 = add(27,%p69)
        %phalf = power(div(%a27,2),%d13)
        %pdinv = power(div(2,%a27),%d13)
        %sum = add(div(%phalf,3),%pdinv)
        .. power(%sum,3000)
</pre>
<li>Temporarily place all those fields on the report and preview it to see where the
    calculation is going wrong.
</ul>
<p>
<p>
<a name=KnownProblems></a>
<h3>Known Problems</h3>
<!-------------------->
<p>
        There is no intention to alter the following behaviour:
        An expression such as add(3,2,3)+power(2) gives 28 with no warning.
        Pre- and Post- fix notation is parsed and evaluated without complaint, 
        for example all of the following give the answer 25.
<p>
<pre>
            power() 5 2
            power(5) 2
            power(5,2)
            5 power() 2
            5 power(2)
            5 2 power()
            ^ 5 2
            5^2
            5 2 ^
</pre>
<p>
        The expression is deemed syntactically valid if at the end of evaluation all
        operators and functions have been applied and there is only one result left on
        the stack. Expression evaluation concentrates much more on applying complex 
        precedence rules which ensure, for example, that 2+3*4 gives 14 and not 20.
<p>
        It is still the responsibility of the programmer to enter correct and valid 
        expressions, and to test them, so this boils down to the question of whether
        or not an expression which returns the correct answer, but has a slightly
        unusual construct, should be rejected as an error or not.
<p>
        This is so unlikely to cause a real problem, is surprisingly difficult to fix,
        and attempting such would almost certainly introduce far more bugs that it 
        would ever solve. Hence there are no plans to change this.
<p>
        I have released the source code for the expression evaluator, see 
        <a href="http://palacebuilders.pwp.blueyonder.co.uk/euphoria.html">
        http://palacebuilders.pwp.blueyonder.co.uk/euphoria.html</a>, for anyone 
        wanting to attempt a fix for this.
<p>
        Of course this is also just a reminder that you should print off a complete
        list of calculated fields and double verify them (against that detailed
        documentation you did write, now didn't you?) before release.
<p>
<p>
</body>
<p><p><hr></p>
<p align=center>
<a href="pprg.html">Table of Contents</a>
<a href="ppRef2.html">Previous Page - Reference Section Part 2</a>
<a href="ppRef4.html">Next Page - Reference Section Part 4</a>
</p>
<p><hr><p><p>
</html>
