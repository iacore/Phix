<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">ARM flag settings</h1>
      <div id="mainSection">

 <div class="arm_table">
|Opcode.......................................|Operation.................................|Z|C|N|V|Notes..............................|
|ADC[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = Rn + &lt;s_op&gt; + C................|s|s|s|s|...................................|
|ADD[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = Rn + &lt;s_op&gt;....................|s|s|s|s|...................................|
|AND[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = Rn & &lt;s_op&gt;....................|s|s|s| |...................................|
|b[cond] &lt;target_addr&gt;..................|PC = PC + &lt;offset&gt;..................| | | | |...................................|
|BIC[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = Rn & !&lt;s_op&gt;...................|s|s|s| |...................................|
|bl[cond] &lt;target_addr&gt;.................|LR = PC+4; PC = PC + &lt;offset&gt;.......| | | | |...................................|
|bx[cond] Rm..................................|PC = Rm; Mode=THUMB.......................|s|s|s| |...................................|
-cdp[cond] p&lt;cp#&gt;,o1,CRd,CRn,CRm,o2.....|execute coprocessor opcode................|s|s|s| |...................................|
|CMN[cond] Rn, &lt;sh_op&gt;..................|&lt;flags&gt; = Rn + &lt;s_op&gt;.........|x|x|x|x|...................................|
|CMP[cond] Rn, &lt;sh_op&gt;..................|&lt;flags&gt; = Rn - &lt;s_op&gt;.........|x|x|x|x|...................................|
|EOR[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = xor_bits(Rn,&lt;s_op&gt;)............|s|s|s| |...................................|
-ldc[cond] p&lt;cp_num&gt;, CRd, #............|load coprocessor register with #..........| | | | |...................................|
-ldm[cond]&lt;adm&gt; Rm, {reglst}^...........|special, see doc..........................| | | | |...................................|
-ldm[cond]&lt;adm&gt; Rm&lt;!&gt;, {reglst}...|for each in &lt;reglist&gt; = [Rn+=4].....| | | | |"!" Keeps last Rm Value............|
-ldm[cond]&lt;adm&gt; Rm&lt;!&gt;, {reglst}^..|special, see doc..........................| | | | |...................................|
|ldr[cond] Rd, Rn, #..........................|Rd = [Rn + #].............................| | | | |word...............................|
|ldr[cond]B Rd, Rn, #.........................|Rd = [Rn + #].............................| | | | |byte...............................|
|ldr[cond]BT Rd, Rn, #........................|Rd = [Rn + #].............................| | | | |translate byte.....................|
|ldr[cond]H Rd, &lt;address&gt;...............|Rd = [address]............................| | | | |half word..........................|
|ldr[cond]SB Rd, &lt;address&gt;..............|Rd = [address]............................| | | | |signed byte........................|
|ldr[cond]SH Rd, &lt;address&gt;..............|Rd = [address]............................| | | | |signed half word...................|
|ldr[cond]T Rd, Rn, #.........................|Rd = [Rn + #].............................| | | | |translate word.....................|
-mcr[cond] p&lt;cp#&gt;,o1,Rd,CRn,CRm,o2......|move from co-cpu reg to ARM reg...........| | | | |...................................|
-mla[cond][s] Rd, Rm, Rs, Rn..................|Rd = Rm * Rs + Rn.........................|s|s|s| |...................................|
|mov[cond][s] Rd, &lt;sh_op&gt;...............|Rd = &lt;s_op&gt;.........................|s|s|s| |...................................|
-mrc[cond] p&lt;cp#&gt;,o1,Rd,CRn,CRm,o2......|move from ARM reg to co-cpu reg ..........|*|*|*|*|if Rd = r15 then flags affected....|
-mrs[cond] Rd, CPSR...........................|Rd = CPSR.................................| | | | |...................................|
-mrs[cond] Rd, SPSR...........................|Rd = SPSR.................................| | | | |...................................|
-msr[cond] CPSR_&lt;fields&gt;, Rm............|CPSR = Rm (fields pick bytes to copy).....| | | | |...................................|
-msr[cond] CPSR_f, #..........................|CPSR = # (fields pick bytes to copy)......| | | | |...................................|
-msr[cond] SPSR_&lt;fields&gt;, Rm............|SPSR = Rm (fields pick bytes to copy).....| | | | |...................................|
-msr[cond] SPSR_f, #..........................|SPSR = # (fields pick bytes to copy)......| | | | |...................................|
|mul[cond][s] Rd, Rm, Rs......................|Rd = Rm * Rs..............................|s|s|s| |...................................|
|mvn[cond][s] Rd, &lt;sh_op&gt;...............|Rd = -&lt;s_op&gt;........................|s|s|s| |...................................|
|ORR[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = or_bits(Rn,&lt;s_op&gt;).............|s|s|s| |...................................|
|RSB[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = &lt;s_op&gt; - Rn....................|s|s|s|s|.(==neg)...........................|
|RSC[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = &lt;s_op&gt; - Rn + C................|s|s|s|s|...................................|
|SBC[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = Rn - &lt;s_op&gt; + C................|s|s|s|s|...................................|
|smlal[cond][s] RdLo, RdHi, Rm, Rs............|RdHi..RdLo = Rm*Rs+(RdHi..RdLo)...........|s|s|s|s|64bit target.......................|
|smull[cond][s] RdLo, RdHi, Rm, Rs............|RdHi..RdLo = Rm*Rs........................|s|s|s|s|64bit target.......................|
-stc[cond] p&lt;cp_num&gt;, CRd, #............|Store coprocessor Reg with #..............| | | | |...................................|
-stm[cond]&lt;adm&gt; Rm, {reglst}^...........|special, see doc..........................| | | | |...................................|
|stm[cond]&lt;adm&gt; Rm&lt;!&gt;, {reglst}...|[Rm+=4] = for each in &lt;reglist&gt;.....| | | | |"!" Keeps last Rm Value............|
|stm[cond]&lt;adm&gt; Rm&lt;!&gt;, {reglst}^..|special, see doc..........................| | | | |...................................|
|str[cond] Rd, Rn, #..........................|[Rn + #] = Rd.............................| | | | |word...............................|
|str[cond]B Rd, Rn, #.........................|[Rn + #] = Rd.............................| | | | |byte...............................|
|str[cond]BT Rd, Rn, #........................|[Rn + #] = Rd.............................| | | | |translate byte.....................|
|str[cond]H Rd, &lt;address&gt;...............|[address] = Rd............................| | | | |half word..........................|
|str[cond]T Rd, Rn, #.........................|[Rn + #] = Rd.............................| | | | |translate word.....................|
|SUB[cond][s] Rd, Rn, &lt;sh_op&gt;...........|Rd = Rn - &lt;s_op&gt;....................|s|s|s|s|...................................|
|SWI &lt;swi_number&gt;.......................|call software interrupt...................| | | | |...................................|
|swp[cond] Rd, Rm, [Rn].......................|Rd = [Rn]; [Rn] = Rm......................| | | | |...................................|
|swp[cond]B Rd, Rm, [Rn]......................|Rd = [Rn]; [Rn] = Rm......................| | | | |...................................|
|teq[cond] Rn, &lt;sh_op&gt;..................|&lt;flags&gt; = xor_bits(Rn,&lt;s_op&gt;).|x|x|x| |...................................|
|tst[cond] Rn, &lt;sh_op&gt;..................|&lt;flags&gt; = and_bits(Rn,&lt;s_op&gt;).|x|x|x| |...................................|
-UMLAL[cond][s] RdLo, RdHi, Rm, Rs............|RdHi..RdLo = Rm*Rs+(RdHi..RdLo)...........|s|s|s|s|64bit target.......................|
-UMULL[cond][s] RdLo, RdHi, Rm, Rs............|RdHi..RdLo = Rm*Rs........................|s|s|s|s|64bit target.......................|
 </div>
        <div class="clear"></div>
        <br>

 <div class="arm_table">
|Flag...|Description...|
|=Z.....|Zero Flag.....|
|=C.....|Carry Flag....|
|=N.....|Negative Flag.|
|=V.....|Overflow Flag.|
 </div>
        <div class="clear"></div>
        <br>
Note there are no specific masks for the Z/C/N/V bits, since they are part of the CSPR register and while there
are 16 condition codes and 16 possible flag states there is no direct correspondance between them, for instance
eq triggers on half of all possible flag states, rather than just one of them. In fact V and Z masks do exist,
but they refer to other bits of the instruction.
        <br>
        <br>
 <pre>
Flag settings:
s - if flag set
x - always
* - special
 </pre>
        <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
