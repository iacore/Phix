<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Object Orientation</h1>
      <div id="mainSection">
        While Phix optionally supports object orientation in the form of <a href="sandc.htm">structs and classes</a>, I have personally never 
        been a fan, but struggled to pinpoint exactly why. There are certainly some neat ideas in that paradigm, and it is possible to write 
        beautiful object oriented code, just as it is in any other paradigm, but the
<!-- abstraction, SOLID, Design patterns are a completely different thing...-->
<!-- make this tell a proper story, break it down into bullet-points: 
        My take on the four pillars of OOP: 
        <br>
        <br>
        Abstraction is, for me, the simple act of giving something a clear, meaningful, and intuitive name (there&rsquo;s a 
        <a href="glossary.htm#abstraction">matching entry</a> for that in the glossary). At least under that definition,
        abastraction isn&rsquo;t even remotely unique to object orientation. A <i>genuine</i> class name from the JDK is
        InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonPainter and you can see where that neatly
        its into the overall framework <a href="JavaUniverse.htm">here</a>.
        <br>
        <br>
        Encapsulation, 
        <br>
        <br>
        Polymorphism, 
        <br>
        <br>
        and Inheritance
        <br>
        <br>
        My take on the SOLID principles:
        <br>
        <br>
        Single responsibility is essentially just a simple rephrasing of good old fashioned divide-and-conquer. Over-zealous
        application, however, belies the simple truth that complex systems are more concerned with complex interactions, for
        instance the human brain is made entirely of comparatively trivial neurons, it is the sheer number of them and the
        myriad of intricate interconnections that makes it special. Of course beaking a problem down into smaller and more
        manageable pieces was itself first invented several centuries before object orientation.
        <br>
        <br>
        Open/Closed principle: simultaneously the most promising and most absurd and ridiculous aspect of object orientation.
        If you want to fix something, fix it where it should be fixed. If that breaks something it shouldn&rsquo;t and annoys
        your users, then you simply haven&rsquo;t got enough unit testing in that area. Using OCP to provide substitutability
        and flexibility is however an all-round good thing, but perhaps just slightly more natural in OOP rather than strictly
        unique to it, requiring a bit more deliberate conscious effort to implement in non-oop settings.
        <br>
        <br>
        Liskov substitution is just a form of constrained polymorphism, easily implemented in non-oop settings.
        <br>
        <br>
        Interface segregation requires just as much conscious effort, if not more, to implement in oop as non-oop.
        <br>
        <br>
        Dependency injection: ditto. Again, not a bad idea, but not inherently unique to object orientation either.
        <br>
        <br>
        Of course it is well known that any Turing-complete programming language can achieve anything possible in any other,
        and by extension any programming paradigm of such can achieve anything possible in any other (programming paradigm).
        Hence the focus here is not on what is achieveable, but whether it is provably any <i>easier</i> in oop.
-->
         reality often falls far short. The main reason is probably
        <i>meaningless</i> abstraction, but a far bigger issue arises from the one thing object orientation actually achieves: managing complexity. 
        It sounds like a wonderful thing, but all too often it <i>enables complexity</i>, and actually actively <i>encourages complexity</i>.
        <br>
        <br>
        Of course many things <i>are</i> complex, and it is the programmers job to break things down into small manageable pieces, and oo does
        a fine job of that, it is the reassembly into a comprehensible whole where things go askew. Delegation and redirection can be useful 
        and powerful tools, but they can be taken too far. Should you want to royally confuse yourself, try downloading the IUP sources and 
        figuring out how it implements something, so you can add it to <a href="xpGUI.htm">xpGUI</a>. Personally I simply prefer a single 
        albeit slightly messy printme() that handles everything over 243 scattered but trivial (or trivial but scattered) printme(), probably
        because it is all too easy to end up trying to debug or modify the wrong one, and/or having to make the exact same changes to all of
        them, but perhaps because properly documenting all 243 of them would at best be rather tedious (assuming I have not simply copy/pasted
        all the <a href="heredoc.htm">heredocs</a> along with the replicated code/stub). One thing Phix beligerently prohibits is selectively 
        overidding the builtins, so I am almost afraid to say that can make it quite difficult to write that bit of code which looks for all
        the world like it is doing something else entirely, that (imo) the unwashed oop-infected often seem so fond of.
        <br>
        <br>
        Don&rsquo;t get me wrong: there are many good things anyone can learn from studying oo. Smaller more managable pieces are almost always
        much better (just not 243 near-duplicates). I would often even accept trusting your testing without always fully considering every detail.
        Conversely, there are times when you really <i>should</i> consider every tiny little detail, in my view oo is a serious hindrance in that
        regard. There are often some benefits in adopting some of the strategies advocated for the otherwise (having once endured a situation 
        where fixing even a blatent bug was prohibited, I feel quite justified in saying this) absurd and pathetic open-closed principle, but 
        (for instance) instance specific methods can be implemented even in raw assembly as function pointers, and quite trivially at that.
        My main objection to OCP is that it enforces a timidly terrified attitude to modifying code, presumably due to inadequate testing and
        more importantly it being too difficult to track down and fix bugs, and of course since oop is just so gosh darn wonderful, there will
        simply never be any reason or attempt to improve that. Limiting potential damage to one (new) component might be reasonably sensible, 
        but decreeing that each bugfix be applied in a forever-increasing number of different places is nothing short of sheer stupidity.
        Just to be crystal clear, several highly respected sources actually advocate "regularly break OCP", but I am simply never going to have
        any respect for the "never ever violate OCP, no matter what" mob, even and perhaps especially when they happen to be paying my wages.
        The idea that OCP enables the use of buggy third party libraries without actually modifying them is a whimsical academic notion that,
        at least in my experience, in the real world and in any given calendar year manifests itself on average a round number of times, and
        to the best of my knowledge there has never been a documented instance where such a serendipitous event even had a chance to happen.
<!-- Yep, but reword/bullet-point all this stuff...
        I will concede that OCP-like powers of being able to use a buggy third-party library without actually modifying it are in principle a
        good thing, but again that is perfectly achievable using first class functions and simply does not need oo at all, though to be fair
        most "buggy third-party libraries" not written in an object orientated manner would probably not have that layer in the first place.
-->
        Unit tests are of course a great idea, as is any form of testing up to and including system-wide, but <i>not even slightly</i> oo-only.
        Refactoring is a pretty useful general skill to have, and of course converting non-oo &lt;==&gt; oo code is also a form of refactoring, 
        just as any other form of tidying up, or converting say imperative &lt;==&gt; declarative would be, in other words with no connection to 
        or dependency on oo whatsoever. Polymorphism is very useful, but entirely independent of oo (and simply done better in Phix, imo). 
        Encapsulation is an absolute must-have in any paradigm, but again in no way whatsoever exclusive to oo. Inheritance, however, is just a 
        crutch for code re-use, and in fact interferes with more explicit code re-use, and I proudly possess an absolutely unshakeable belief 
        that <a href="javascript:ExternalLink('ext833');" title='https://en.wikipedia.org/wiki/Argument-dependent_name_lookup' id="ext833" 
        style="color:#9B5565" >Koenig lookup</a> just makes maintenance much more difficult, especially when it conflicts with inheritance.
        Thankfully there is just no need for that in Phix, as evidenced by just one sq_add(), not <i>N-hundred odd</i> arg-specific variants.
<!--        and no doubt there are a few confused onlookers there, the same that would presumably ask why anyone would ever want to add an integer 
        to a float, or vice versa, or (warning: unlike Phix) why +256 doing the exact same thing as +0 might <i>even slightly</i> confuse...-->
        Of course I know all about <a href="javascript:ExternalLink('ext357');" title='https://en.wikipedia.org/wiki/Composition_over_inheritance' 
        id="ext357" style="color:#9B5565" >favor composition over inheritance</a>, but apart from implicitly dragging in code as well as data,
        there is nothing remotely exclusive to the oo paradigm regarding composite data structures. Clearly intellisense is pretty nifty too, 
        and in many ways even more useful in an oo context, only cos that <i>really</i> needs it, but not in any way tied to it either.
        <br>
        <br>
        In fact, I rather suspect almost everyone actually dislikes object orientation, what they&rsquo;re in love with is intellisense.
        <br>
        <br>
        Some bits of advice are certainly worth keeping, especially some of these gems from Kent Beck (and I am sure there are more):<br>
        <ul>
        <li>First make the change easy (warning: this may be hard), then make the easy change.</li>
        <li>If I want to make my code cheap, I should make it easy to read.</li>
        <li>Designs without duplication tend to be easy to change.</li>
        <li>Then again, he also said: Actually this book is built on a rather fragile premise: that good code matters. 
        I have seen too much ugly code make too much money to believe that quality of code is either necessary or sufficient for commercial 
        success or widespread use.</li>
        </ul>

        I was once rather taken by <a href="javascript:ExternalLink('ext383');" title='https://www.youtube.com/watch?v=8bZh5LMaSmE' id="ext383" 
        style="color:#9B5565" >All the Little Things by Sandi Metz</a> and would (still) highly recommend investing 40 mins in watching that.
        I walked away from that feeling frankly rather relieved that I had <i>finally</i> found out why object orientation is a good idea, but
        that only lasted for all of about 17 minutes, before writing something simply better. The main message is "how to make it work", the 
        not so subtle secondary message is <i>"you are not supposed to understand how it works"</i>. The really arrogant part, not of that 
        video, but the original "Gilded Rose Kata", is the blatently dismissive "no, <i>you</i> figure out how to <i>prove</i> it works".
        Given that you <i>have</i> to do the latter anyway, any and all benefits of object orientation (at least in my opinion) immediately 
        just fly straight out the window. The file demo\GildedRoseKata.exw contains three trivial refactorings that perfectly address all of 
        the concerns, without resorting to object orientation, plus for completeness one that does.
        <br>
        <br>
        Decades of fruitless searching for <i>proof</i> that oop improves anything suddenly fall neatly under "no, <i>you</i> prove it", which
        is very reminiscent of that old <a href="javascript:ExternalLink('ext373');" title='https://www.youtube.com/watch?v=6e-nyxBrMcE'
        id="ext373" style="color:#9B5565" >M&M advert</a>. Being able to modify something <i>without</i> understanding how it works also sounds 
        like a really clever idea, but (imo) must eventually make it simply impossible to ever make another properly informed descision. If I 
        can alter the behaviour of some bit of code without modifying it, what is supposed to stop me from coming back in six months and going
        "oh blimey, I forgot to do that"? If I have a base class B and some derived class D, when I add an extended class E what precisely
        will prevent me from taking (another) copy of B.doit() when I should in fact be basing my revisions on D.doit()? Or fix something
        in E and forgetting to fix the same thing in D? My local library does <i>not</i> have seven separate shelves for "An Author" since 
        seven separate staff saw nothing between "An Actor" and "A Biographer", instead they <i>are</i> allowed to use their common sense 
        and modify the main shelf itself. I could no doubt go on like this forever.
        <br>
        <br>
        Quite often I hear the phrase "naming is hard", which I have always struggled to even begin to comprehend, apart perhaps from the
        shorter/pithier side of things. However and especially when confronted by an ever-increasing outrageously overcomplicated and for
        the most part completely undocumented hierarchy of meaningless classes, typically solely created to overcome the restrictions and
        limitations inherent in an object oriented paradigm, I <i>can</i> get behind "naming this drivel is hard".
        <br>
        <br>
        Ultimately, not just the point but the entire triumph of object orientation is to allow, and in practice actively encourage you to 
        construct programs that you simply <i>cannot</i> understand, at least in any meaningful holistic sense. Another way of saying that:
        object orientation allows you to modify some small part without the slightest clue what you&rsquo;re doing. I get the need for 
        compart<i>mental</i>isation, but that is just insane. I don&rsquo;t know about you, but I don&rsquo;t care if it might cost an awful 
        lot less to train them up, I don&rsquo;t ever want a surgeon to operate on my foot (say), however flawlessly, but without <i>any</i>
        consideration at all being given to the possible consequences on the rest of me. In a complex system, even one far less complicated 
        than the human body, <i>promising</i> me there will be no consequences, when you <i>don&rsquo;t even know what they might be</i>, 
        simply doesn&rsquo;t cut it.
        <br>
        <br>
        Innovation inevitably incurs the unavoidable cost of deep understanding, putting that (unwanted?) litter of lovely little kittens 
        into a sack weighed with stones and slinging it in the nearest canal or reservoir, well that simply ain&rsquo;t me.
        <br>
        <br>
        Maybe I am just different, I fondly remember being gently teased at the age of six over my inquisitive desire to figure out how 
        things work, and (absurdly abstract abominations aside) I have never lost that.
        <br>
        <br>
        PS: The SOLID principles as applied to Phix would probably be:<br>
        <ul>
        <li><b><code>S</code></b>ingle source is somewhat simpler than seventy-six separate sources.</li>
        <li><b><code>O</code></b>pen, just keep it open, for extension, modification, or whatever.</li>
        <li><b><code>L</code></b>et&rsquo;s let you decide what is and is not a legal parameter.</li>
        <li><b><code>I</code></b>nterfaces should ideally be documented somewhere, <i>please</i>.</li>
        <li><b><code>D</code></b>ependencies, inverted or not, should "", and be easily debuggable.</li>
        </ul>
        Bugs <i>are</i> going to happen: running away terrified or putting your fingers in your ears and humming loudly is not going to help, 
        nor does saying "there is no new bug in the unmodified code, it must be somewhere else" or perhaps more relevantly in the freakishly 
        misguided object oriented mentality, <i>"there is no omission, because that bit of code has not yet been written"</i>. (<b>WHAT?</b>)
<!-- Yep, but...
        Actually, now I&rsquo;ve thought about it, there&rsquo;s probably a matching <i>&ldquo;there are no bugs here, just some bits of code 
        that might not yet have been properly overidden, and don&rsquo;t worry, you won&rsquo;t be able to tell when they have..&rdquo;</i>.
-->
        <br>
        <br>
        Rather than making you jump through hoops to avoid adding bugs, why not <i>make finding and fixing bugs easier?</i>
        <br>
        <br>
<!-- Yep, but...
        As a bonus, when you <i>do</i> fix a bug, let&rsquo;s <b>not</b> (from the stupid O in SOLID) put it someplace sometimes impossible to find,<br>
        or be practically <i>forced</i> to duplicate a huge block of code, just so that we are actually <i>allowed</i> to modify the duplicated code<br>
        (as noted above, just about acceptable when using "buggy third-party libraries", but not in your own code ffs, even when other people use it).
        <br>
        <br>
-->
        To paraphrase Kent Beck, I might say:<br>
        <ul>
        <li>First make debugging easy, then make the easily found fix.</li>
            <ul>
             <li>Warning: this may be hard, and break other things.</li>
            </ul>
        <li>Save sensibly named temporary variables, as often as you can.</li>
            <ul>
             <li>Factor out common subexpressions by hand (trust me, just do it), and give &rsquo;em a proper name.</li>
            </ul>
        <li>Except perhaps in tight inner loops:
            <ul>
             <li>Store diagnostic info in local vars, even if not needed right now.</li>
             <li>Map meaningless things to human readable strings whenever you can.</li>
             <li>Tag things properly, eg {"gImage",#NNNN}, rather than just #NNNN.</li>
             <li>Comment such out <i>only</i> when they verify-ably impact performance.</li>
            </ul>
        <li>Messy code that is easy to debug is far more valuable than neat code that isn&rsquo;t.</li>
            <ul>
             <li>Not that you shouldn&rsquo;t take some pride in your work, of course.</li>
            </ul>
        </ul>
        <br>
        <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
