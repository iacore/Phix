<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Callbacks</h1>
      <div id="mainSection">
        Callbacks are used by the application to receive notifications from the system that the user or the system itself has interacted with the user interface of the application. 
        <br>
        <br>
        On the other hand attributes are used by the application to communicate with the user interface system.
        <br>
        <br>
        Even though callbacks have different purposes from attributes, they are also associated to an element by means of an name. 
        <br>
        <br>
        The OLD method to associate a function to a callback, the application must employ the IupSetAttribute function, linking the action to a name (passed as a string). <br>
        From this point on, this name will refer to a callback. By means of function IupSetFunction, the user connects this name to the callback. For example: 
<!--eucode>
function myButton_action(Ihandle self)
...
IupSetAttribute(myButton, "ACTION", "my_button_action");
IupSetFunction("my_button_action", Icallback("myButton_action")
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">function</font><font color="#000000"> myButton_action</font><font color="#0000FF">(</font><font color="#5E005E">Ihandle</font><font color="#000000"> self</font><font color="#0000FF">)
..</font><font color="#FF0000">.
</font><font color="#5E005E">IupSetAttribute</font><font color="#0000FF">(</font><font color="#000000">myButton</font><font color="#0000FF">,</font><font color="#008000"> "ACTION"</font><font color="#0000FF">,</font><font color="#008000"> "my_button_action"</font><font color="#0000FF">);
</font><font color="#000000">IupSetFunction</font><font color="#0000FF">(</font><font color="#008000">"my_button_action"</font><font color="#0000FF">,</font><font color="#5E005E"> Icallback</font><font color="#800000">(</font><font color="#008000">"myButton_action"</font><font color="#800000">)</font>
</pre>
        <br>
        In the NEW method, the application does not needs a global name, it directly sets the callback using the attribute name using IupSetCallback. For example:
<!--eucode>
function myButton_action(Ihandle self)
...
IupSetCallback(myButton, "ACTION", Icallback("myButton_action"))
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">function</font><font color="#000000"> myButton_action</font><font color="#0000FF">(</font><font color="#5E005E">Ihandle</font><font color="#000000"> self</font><font color="#0000FF">)
..</font><font color="#FF0000">.
</font><font color="#5E005E">IupSetCallback</font><font color="#0000FF">(</font><font color="#000000">myButton</font><font color="#0000FF">,</font><font color="#008000"> "ACTION"</font><font color="#0000FF">,</font><font color="#5E005E"> Icallback</font><font color="#800000">(</font><font color="#008000">"myButton_action"</font><font color="#800000">)</font><font color="#0000FF">)</font>
</pre>
        The new method is more efficient and more secure, because there is no risk of a name conflict. Generally you should replace IupSetFunction by IupSetCallback.
        <br>
        <br>
        Although enabled in old versions, callbacks do NOT have inheritance like attributes.
        <br>
        <br>
        All callbacks receive at least the element which activated the action as a parameter (self). 
        <br>
        <br>
        <a name=IUP_DEFAULT></a>
        <a name=IUP_CLOSE></a>
        <a name=IUP_IGNORE></a>
        <a name=IUP_CONTINUE></a>
        The callbacks implemented in the application must return one of the following values:
        <ul>
        <li>IUP_DEFAULT: Proceeds normally with user interaction. In case other return values do not apply, the callback should return this value. </li>
        <li>IUP_CLOSE: Call IupExitLoop after return. Depending on the state of the application it will close all windows and exit the application. Applies only to some actions. </li>
        <li>IUP_IGNORE: Makes the native system ignore that callback action. Applies only to some actions. </li>
        <li>IUP_CONTINUE: Makes the element to ignore the callback and pass the treatment of the execution to the parent element. Applies only to some actions. </li>
        </ul>
        Only some callbacks support the last 3 return values. Check each callback documentation. When nothing is documented then only IUP_DEFAULT is supported.
        <br>
        <br>
        Note: Avoid using IUP_IGNORE (etc) unless it is specifically documented for that callback. <br>
        For example, if an IupButton ACTION callback returns IUP_IGNORE, it effectively disables the button. <br>
        Removing the callback is in fact the documented behaviour for IDLE_ACTION and doing so on an IupButton might be - but such is 
        the reality of undocumented behaviour. (I double checked that particular one, to be told that behaviour was as expected and not going to be changed.)
        <br>
        <br>
        An important detail when using callbacks is that they are only called when the user actually executes an action over an element. <br>
        A callback is not called when the programmer sets a value via IupSetAttribute. For instance: when the programmer changes a selected item on a list, no callback is called.
        <br>
        <br>
        The order of callback calling is system dependent. <br>
        For instance, the <a href="callbacks.htm#RESIZE_CB">RESIZE_CB</a> and the SHOW_CB are called in different order in Win32 and in X-Windows when the dialog is shown for the first time.
        <br>
        <br>
        As well as its normal duty of verifying parameters, the cbfunc type can be used to declare variables suitable for storing callbacks.<br>
        The C header file "iupcbs.h" lists some 50 different typedefs for callbacks (IFxxx/sIFxxx/dIFxxx). <br>
        In Phix you can always get by with "atom" for each parameter, if need be.
        <br>
        <br>
<!-- DEV (this wants to be somewhere else...)
        <h3>Main Loop</h3>
        IUP is an event-oriented interface system, so it will keep a loop “waiting” for the user to interact with the application. <br>
        For this loop to occur, the application must call the IupMainLoop function, which is generally used right before IupClose.
        <br>
        <br>
        When the application is closed by returning IUP_CLOSE in a callback, calling IupExitLoop or by hiding the last visible dialog, the function IupMainLoop will return.
        <br>
        <br>
        The IupLoopStep and the IupFlush functions force the processing of incoming events while inside an application callback.
       <br>
        &nbsp;
       <br>
-->
        The following callbacks are common to several controls/interface elements:
       <br>
       <br>
       <table>
        <col style="width: 5%"/>
        <tr>
         <td valign=top>
          <a name=BUTTON_CB></a>
          BUTTON_CB
         </td>
         <td>
            Action generated when any mouse button is pressed or released.
            <br>
            <br>
            function(Ihandle ih, integer button, integer pressed, integer x, integer y, atom pStatus)<br>
            ih: identifies the element that activated the event.<br>
            button: identifies the activated mouse button:<br>
            <br>
            IUP_BUTTON1 - left mouse button (button 1);<br>
            IUP_BUTTON2 - middle mouse button (button 2);<br>
            IUP_BUTTON3 - right mouse button (button 3).<br>
            <br>
            pressed: indicates the state of the button:<br>
            <br>
            0 - mouse button was released;<br>
            1 - mouse button was pressed.<br>
            <br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of the mouse buttons and some keyboard keys at the moment the event is generated (a char*). <br>
            <br>
            The following macros must be used for verification:
            <br>
            iup_isshift(status)<br>
            iup_iscontrol(status)<br>
            iup_isbutton1(status)<br>
            iup_isbutton2(status)<br>
            iup_isbutton3(status)<br>
            iup_isbutton4(status)<br>
            iup_isbutton5(status)<br>
            iup_isdouble(status)<br>
            iup_isalt(status)<br>
            iup_issys(status)<br>
            <br>
            They return 1 if the respective key or button is pressed, and 0 otherwise.
            <br>
            <br>
            Returns: IUP_CLOSE will be processed. On some controls if IUP_IGNORE is returned the action is ignored (this is system dependent).
            <br>
            <br>
            Notes<br>
            This callback can be used to customize a button behavior. For a standard button behavior use the ACTION callback of the IupButton.
            <br>
            <br>
            For a single click the callback is called twice, one for pressed=1 and one for pressed=0. <br>
            The ACTION callback is only invoked after both calls.<br>
            In Windows, if a dialog is shown or popup in any situation there could be unpredictable results because the native system still has processing to be done even after the callback is called.
            <br>
            <br>
            A double click is preceded by two single clicks, one for pressed=1 and one for pressed=0, and followed by a pressed=0, all three without the double click flag set. <br>
            In GTK, it is preceded by an additional two single clicks sequence. For example, for one double click all the following calls are made:
 <pre>
BUTTON_CB(but=1 (1), x=154, y=83 [  1       ])
BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])
    BUTTON_CB(but=1 (1), x=154, y=83 [  1       ])     (in GTK only)
    BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])     (in GTK only)
BUTTON_CB(but=1 (1), x=154, y=83 [  1  D    ])
BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])
 </pre>
            Affects: IupCanvas, IupButton, IupText, IupList, IupGLCanvas
         </td>
        </tr>
        <tr>
         <td valign=top>
          <a name=RESIZE_CB></a>
          RESIZE_CB
         </td>
         <td>
            Action generated when the canvas or dialog size is changed.
            <br>
            <br>
            function(Ihandle ih, integer width, integer height)
            <br>
            <br>
            ih: identifier of the element that activated the event.<br>
            width: the width of the internal element size in pixels not considering the decorations (client size)<br>
            height: the height of the internal element size in pixels not considering the decorations (client size)
            <br>
            <br>
            For the dialog, this action is also generated when the dialog is mapped, after the map and before the show.
            <br>
            <br>
            When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the canvas scrollbar is hidden/shown after changing the DX or DY attributes from inside the callback, 
            the size of the drawing area will immediately change, so the parameters with and height will be invalid. <br>
            To update the parameters consult the DRAWSIZE attribute. Also activate the drawing toolkit only after updating the DX or DY attributes.
            <br>
            <br>
            Affects: IupCanvas, IupGLCanvas, IupDialog
         </td>
        </tr>
        <tr>
         <td valign=top>
          <a name=IDLE_ACTION></a>
          IDLE_ACTION
         </td>
         <td>
            Predefined IUP action, generated when there are no events or messages to be processed. Often used to perform background operations.
            <br>
            <br>
            int function(void)<br>
            Returns: if IUP_CLOSE is returned the current loop will be closed and the callback will be removed. <br>
            If IUP_IGNORE is returned the callback is removed and normal processing continues.
            <br>
            <br>
            Notes<br>
            The Idle callback will be called whenever there are no messages left to be processed. <br>
            But this occurs more frequent than expected, for example if you move the mouse over the application the idle callback will be called
            many times because the mouse move message is processed so fast that the Idle will be called before another mouse move message is schedule to processing.
            <br>
            <br>
            So this callback changes the message loop to a more CPU consuming one. <br>
            It is important it be set NULL when not used, otherwise the application consumes CPU even if the callback is doing nothing.
            <br>
            <br>
            It can only be set using IupSetFunction(name, func).
            <br>
            <br>
            Long Time Operations<br>
            If you create a loop or an operation that takes a long time to complete inside a callback of your application then 
            the user interface message loop processing is interrupted until the callback returns, so the user can not click on 
            any control of the application. But there are ways to handle that:
            <br>
            <br>
            call IupLoopStep or IupFlush inside the application callback when it is performing long time operations. <br>
            This will allow the user to click on a cancel button for instance, because the user interface message loop will be processed.
            <br>
            <br>
            split the operation in several parts that are processed by the Idle function when no messages are left to be processed for the user interface message loop. <br>
            This will make a heavy use of the CPU, even if the callback is doing nothing. 
            <br>
            <br>
            split the operation in several parts but use a Timer to process each part. <br>
            If you just want to do something simple as a background redraw of an IupCanvas, then a better idea is to handle the "idle" state yourself. <br>
            For example, register a timer for a small time like 500ms, and reset the timer in all the mouse and keyboard callbacks of the IupCanvas. <br>
            If the timer is trigged then you are in idle state. If the IupCanvas loses its focus then stop the timer.
            <br>
            <br>
            See Also: IupSetFunction, IupTimer.
         </td>
        </tr>
        <tr>
         <td valign=top>
          also [DEV]
         </td>
         <td>
            MAP_CB, UNMAP_CB, DESTROY_CB, GETFOCUS_CB, KILLFOCUS_CB, ENTERWINDOW_CB, LEAVEWINDOW_CB, K_ANY, HELP_CB: All common callbacks are supported.
         </td>
        </tr>
       </table>
       <br>
        &nbsp;
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
