<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">gCanvas</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
            include xpGUI.e
            <br>
            <br>
            <a href="gdx.htm">gdx</a> id = gCanvas([<a href="rtn.htm">rtn</a> redraw=NULL,] 
                                                   <a href="string.htm">string</a> attributes="",
                                                   <a href="html/glossary.htm#dwordseq">dword_seq</a> args={})
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Creates an interface element that is a canvas - a working area for your application.
            <br>
            <br>
            redraw: a procedure invoked whenever the canvas needs to be redrawn, see <a href="#REDRAW">REDRAW</a> below.<br>
            For more information on the attributes and args parameters see <a href="gSetAttributes.htm">gSetAttributes</a>.<br>
            This is a <a href="g_paranormal.htm">paranormalised function</a>. <small>(see <a href="#tech" onclick="opentech()">technicalia</a>)</small>
            <br>
            <br>
            Returns the identifier of the created element.
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
          Supported.
         </td>
        </tr>
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="gGraph.htm">gGraph</a>,
          <a href="gImage.htm">gImage</a>,
          <a href="gList.htm">gList</a>,
          <a href="gTable.htm">gTable</a>,
<!--          <a href="IupBackgroundBox.htm">IupBackgroundBox</a>,-->
          <a href="gRedraw.htm">gRedraw</a>
         </td>
        </tr>
        <tr>
         <td>
          <b>Example:</b>
         </td>
         <td>
            <p align="center"><img alt="gCanvas" src="images/gCanvasACS.png" width="240" height="156"/></p>

<!--eucode>
-- a somewhat simplified version of demo\xpGUI\gCanvas.exw
include xpGUI.e

procedure redraw(gdx canvas)
    integer {w,h} = gGetAttribute(canvas,"SIZE")
    atom {cx,cy} = {w/2,h/2}
    gCanvasSetForeground(canvas,XPG_GREEN)
    gCanvasLine(canvas,0,cy,w,cy)
--  ...
end procedure

gdx canvas = gCanvas(redraw),
    dialog = gDialog(canvas,`gCanvas`,`SIZE=240x163`)
gCanvasSetBackground(canvas, XPG_PARCHMENT)
gShow(dialog)
gMainLoop()
</eucode-->
<pre>
<font color="#000080"><i>-- a somewhat simplified version of demo\xpGUI\gCanvas.exw</i></font>
<font color="#008080">include</font><font color="#000000"> xpGUI.e
</font>
<font color="#008080">procedure</font><font color="#000000"> redraw</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> canvas</font><font color="#0000FF">)</font>
<font color="#004080">    integer</font><font color="#0000FF"> {</font><font color="#000000">w</font><font color="#0000FF">,</font><font color="#000000">h</font><font color="#0000FF">} =</font><font color="#7060A8"> gGetAttribute</font><font color="#0000FF">(</font><font color="#000000">canvas</font><font color="#0000FF">,</font><font color="#008000">"SIZE"</font><font color="#0000FF">)</font>
<font color="#004080">    atom</font><font color="#0000FF"> {</font><font color="#000000">cx</font><font color="#0000FF">,</font><font color="#000000">cy</font><font color="#0000FF">} = {</font><font color="#000000">w</font><font color="#0000FF">/</font><font color="#000000">2</font><font color="#0000FF">,</font><font color="#000000">h</font><font color="#0000FF">/</font><font color="#000000">2</font><font color="#0000FF">}</font>
<font color="#7060A8">    gCanvasSetForeground</font><font color="#0000FF">(</font><font color="#000000">canvas</font><font color="#0000FF">,</font><font color="#004600">XPG_GREEN</font><font color="#0000FF">)</font>
<font color="#7060A8">    gCanvasLine</font><font color="#0000FF">(</font><font color="#000000">canvas</font><font color="#0000FF">,</font><font color="#000000">0</font><font color="#0000FF">,</font><font color="#000000">cy</font><font color="#0000FF">,</font><font color="#000000">w</font><font color="#0000FF">,</font><font color="#000000">cy</font><font color="#0000FF">)</font>
<font color="#000080"><i>--  ...</i></font>
<font color="#008080">end procedure
</font>
<font color="#7060A8">gdx</font><font color="#000000"> canvas</font><font color="#0000FF"> =</font><font color="#7060A8"> gCanvas</font><font color="#0000FF">(</font><font color="#000000">redraw</font><font color="#0000FF">),</font>
<font color="#000000">    window</font><font color="#0000FF"> =</font><font color="#7060A8"> gDialog</font><font color="#0000FF">(</font><font color="#000000">canvas</font><font color="#0000FF">,</font><font color="#008000">`gCanvas`</font><font color="#0000FF">,</font><font color="#008000">`SIZE=240x163`</font><font color="#0000FF">)</font>
<font color="#7060A8">gCanvasSetBackground</font><font color="#0000FF">(</font><font color="#000000">canvas</font><font color="#0000FF">,</font><font color="#004600"> XPG_PARCHMENT</font><font color="#0000FF">)</font>
<font color="#7060A8">gShow</font><font color="#0000FF">(</font><font color="#000000">window</font><font color="#0000FF">)</font>
<font color="#7060A8">gMainLoop</font><font color="#0000FF">()</font>
</pre>

            See demo\xpGUI\gCanvas.exw (from whence the above screenshot came), and <br>
            demo\xpGUI\GraphR.exw,<br>
            demo\xpGUI\aaline.exw ([will be] the same as demo\rosetta\XiaolinWuLine.exw)<br>
            demo\xpGUI\scroller.exw (incomplete)<br>
            <a name=XPG_colours></a>
         </td>
        </tr>
<!--
        <tr>
         <td>
          <b>Notes:</b>
         </td>
         <td>
            Note that some keys might remove the focus from the canvas. 
            To avoid this, return <a href="gSetHandler.htm#XPG_IGNORE">XPG_IGNORE</a> in the <a href="gSetHandler.htm#KEY">KEY</a> handler. 
            <br>
[DEV...]
            <br>
?           The mouse cursor position can be programmatically controlled using the global attribute <a href=gGetGlobal.htm#MOUSEPOS>MOUSEPOS</a>.
            <br>
            <br>
            Drag & Drop attributes and handlers are supported. 
            <br>
            <br>
            When the canvas is displayed for the first time, the handler call order is always:
            <br>
            <br>
<X!X--
//          <a href="gSetHandler.htm#MAP_CB">MAP_CB</a><br>
--X>
//          <a href="gSetHandler.htm#RESIZE_CB">RESIZE_CB</a><br>
            <a href="#REDRAW">REDRAW</a>
            <br>
            <br>
//          When the canvas is resized the <a href="#REDRAW">REDRAW</a> handler is always called after the <a href="gSetHandler.htm#RESIZE_CB">RESIZE_CB</a> handler.
            <br>
            <br>
//          <h4>Using with the CD library</h4>
            <br>
//          When using the CD library to draw in a IupCanvas, you can use the handlers to manage the canvas. The simplest way is to do:
            <br>
            <br>
<X!X--
//          <a href="gSetHandler.htm#MAP_CB">MAP_CB</a> - calls cdCreateCanvas  (current size is not available yet)<br>
//          <a href="gSetHandler.htm#UNMAP_CB">UNMAP_CB</a> - calls cdKillCanvas<br>
--X>
//          <a href="gSetHandler.htm#RESIZE_CB">RESIZE_CB</a> - Calling <a href="cdCanvasActivate.htm">cdCanvasActivate</a>() and 
//                      <a href="cdCanvasGetSize.htm">cdCanvasGetSize</a>() returns the same values as given by the handler parameters.
//                      Recalculate the drawing size, update the scrollbars if any.<br>
            <a href="#REDRAW">REDRAW</a> - call <a href="cdCanvasActivate.htm">cdCanvasActivate</a> then use CD primitives to draw the scene, and finally call 
                        <a href="cdCanvasClear.htm#aux">cdCanvasFlush</a>() if using a double buffer.<br>
            <a href="gSetHandler.htm#SCROLL_CB">SCROLL_CB</a> - when using scrollbars, if this handler is defined the canvas must be manually redrawn,
                        call yourself the redraw handler or call <a href="gRedraw.htm">gRedraw</a>.
                        In other words, if this handler is not defined the canvas is automatically redrawn.<br>
         </td>
        </tr>
-->
        <tr>
         <td>
          <b>Colours:</b>
         </td>
         <td>
            The following constants are defined for convenience.
            <br>
            <br>
<!--            <div id="images" class="images" align="center">-->
            <p align="center">
             <small>
<!--
              <table>
                <tr>
                  <th bgcolor="#C0C0C0">Eg</th>
                  <th bgcolor="#C0C0C0">Name</th>
                  <th bgcolor="#C0C0C0">Value/Aliases</th>
                </tr>
                <tr><td style="background-color:#000000;"></td> <td>XPG_BLACK           </td> <td>#000000 (0)           </td>
                <tr><td style="background-color:#000080;"></td> <td>XPG_DARK_BLUE       </td> <td>#000080 (128)     XPG_NAVY  </td>
                <tr><td style="background-color:#0000FF;"></td> <td>XPG_BLUE            </td> <td>#0000FF (255)         </td>
                <tr><td style="background-color:#4363d8;"></td> <td>XPG_LIGHT_BLUE      </td> <td>#4363D8 (4416472)     </td>
                <tr><td style="background-color:#008080;"></td> <td>XPG_DARK_CYAN       </td> <td>#008080 (32896)   XPG_TEAL  </td>
                <tr><td style="background-color:#00FFFF;"></td> <td>XPG_CYAN            </td> <td>#00FFFF (65535)       </td>
                <tr><td style="background-color:#008000;"></td> <td>XPG_DARK_GREEN      </td> <td>#008000 (32768)       </td>
                <tr><td style="background-color:#3cb44b;"></td> <td>XPG_GREEN           </td> <td>#3CB44B (3978315)     </td>
                <tr><td style="background-color:#00FF00;"></td> <td>XPG_LIGHT_GREEN     </td> <td>#00FF00 (65280)       </td>
                <tr><td style="background-color:#808000;"></td> <td>XPG_OLIVE           </td> <td>#808000 (8421376)     </td>
                <tr><td style="background-color:#FF8C00;"></td> <td>XPG_ORANGE          </td> <td>#FF8C00 (16747520)    </td>
                <tr><td style="background-color:#FFBF00;"></td> <td>XPG_AMBER           </td> <td>#FFBF00 (16760576)    </td>
                <tr><td style="background-color:#EBEB00;"></td> <td>XPG_DARK_YELLOW     </td> <td>#EBEB00 (15461120)    </td>
                <tr><td style="background-color:#FFFF00;"></td> <td>XPG_YELLOW          </td> <td>#FFFF00 (16776960)    </td>
                <tr><td style="background-color:#4B0082;"></td> <td>XPG_INDIGO          </td> <td>#4B0082 (4915330)     </td>
                <tr><td style="background-color:#800080;"></td> <td>XPG_DARK_PURPLE     </td> <td>#800080 (8388736)     </td>
                <tr><td style="background-color:#911eb4;"></td> <td>XPG_PURPLE          </td> <td>#911EB4 (9510580)     </td>
                <tr><td style="background-color:#f032e6;"></td> <td>XPG_MAGENTA         </td> <td>#F032E6 (15741670)    </td>
                <tr><td style="background-color:#EE82EE;"></td> <td>XPG_VIOLET          </td> <td>#EE82EE (15631086)    </td>
                <tr><td style="background-color:#800000;"></td> <td>XPG_DARK_RED        </td> <td>#800000 (8388608)     </td>
                <tr><td style="background-color:#FF0000;"></td> <td>XPG_RED             </td> <td>#FF0000 (16711680)    </td>
                <tr><td style="background-color:#808080;"></td> <td>XPG_DARK_GREY       </td> <td>#808080 (8421504) XPG_DARK_GRAY </td>
                <tr><td style="background-color:#C0C0C0;"></td> <td>XPG_GREY            </td> <td>#C0C0C0 (12632256) XPG_GRAY, XPG_SILVER  </td>
                <tr><td style="background-color:#E4E4E4;"></td> <td>XPG_LIGHT_GREY      </td> <td>#E4E4E4 (15000804) XPG_LIGHT_GRAY </td>
                <tr><td style="background-color:#FFFFE0;"></td> <td>XPG_PARCHMENT       </td> <td>#FFFFE0 (16777184)    </td>
                <tr><td style="background-color:#FAF8EF;"></td> <td>XPG_LIGHT_PARCHMENT </td> <td>#FAF8EF (16447727)    </td>
                <tr><td style="background-color:#FFFFFF;"></td> <td>XPG_WHITE           </td> <td>#FFFFFF (16777215)    </td>
              </table>
-->
              <table>
                <tr>
                  <th bgcolor="#C0C0C0" style="text-align:center">EG</th>
                  <th bgcolor="#C0C0C0">Value/Names</th>
                  <th bgcolor="#C0C0C0" style="text-align:center">EG</th>
                  <th bgcolor="#C0C0C0">Value/Names</th>
                </tr>
                <tr><td style="background-color:#000000;"></td> <td>#000000 XPG_BLACK                       </td>
                    <td style="background-color:#4B0082;"></td> <td>#4B0082 XPG_INDIGO                      </td></tr>
                <tr><td style="background-color:#000080;"></td> <td>#000080 XPG_NAVY                        </td>
                    <td style="background-color:#800080;"></td> <td>#800080 XPG_DARK_PURPLE                 </td></tr>
                <tr><td style="background-color:#0000FF;"></td> <td>#0000FF XPG_BLUE                        </td>
                    <td style="background-color:#911eb4;"></td> <td>#911EB4 XPG_PURPLE                      </td></tr>
                <tr><td style="background-color:#4363d8;"></td> <td>#4363D8 XPG_LIGHT_BLUE                  </td>
                    <td style="background-color:#f032e6;"></td> <td>#F032E6 XPG_MAGENTA                     </td></tr>
<!-- (test)
                <tr><td style="background-color:#4363d8;"></td> <td>#4363D8 ?XPG_LIGHT_BLUE                 </td>
                    <td style="background-color:#ff00ff;"></td> <td>#FF00FF ?XPG_MAGENTA                    </td></tr>
-->
                <tr><td style="background-color:#008080;"></td> <td>#008080 XPG_TEAL                        </td>
                    <td style="background-color:#EE82EE;"></td> <td>#EE82EE XPG_VIOLET                      </td></tr>
                <tr><td style="background-color:#00FFFF;"></td> <td>#00FFFF XPG_CYAN                        </td>
                    <td style="background-color:#800000;"></td> <td>#800000 XPG_DARK_RED                    </td></tr>
                <tr><td style="background-color:#008000;"></td> <td>#008000 XPG_DARK_GREEN                  </td>
                    <td style="background-color:#FF0000;"></td> <td>#FF0000 XPG_RED                         </td></tr>
                <tr><td style="background-color:#3cb44b;"></td> <td>#3CB44B XPG_GREEN                       </td>
                    <td style="background-color:#404040;"></td> <td>#404040 XPG_SLATE                       </td></tr>
                <tr><td style="background-color:#00FF00;"></td> <td>#00FF00 XPG_LIGHT_GREEN                 </td>
                    <td style="background-color:#808080;"></td> <td>#808080 XPG_DARK_GREY, XPG_DARK_GRAY    </td></tr>
                <tr><td style="background-color:#808000;"></td> <td>#808000 XPG_OLIVE                       </td>
                    <td style="background-color:#C0C0C0;"></td> <td>#C0C0C0 XPG_GREY, XPG_GRAY, XPG_SILVER  </td></tr>
                <tr><td style="background-color:#FF8C00;"></td> <td>#FF8C00 XPG_ORANGE                      </td>
                    <td style="background-color:#E4E4E4;"></td> <td>#E4E4E4 XPG_LIGHT_GREY, XPG_LIGHT_GRAY  </td></tr>
                <tr><td style="background-color:#FFBF00;"></td> <td>#FFBF00 XPG_AMBER                       </td>
                    <td style="background-color:#FFFFE0;"></td> <td>#FFFFE0 XPG_PARCHMENT                   </td></tr>
                <tr><td style="background-color:#EBEB00;"></td> <td>#EBEB00 XPG_DARK_YELLOW                 </td>
                    <td style="background-color:#FAF8EF;"></td> <td>#FAF8EF XPG_LIGHT_PARCHMENT             </td></tr>
                <tr><td style="background-color:#FFFF00;"></td> <td>#FFFF00 XPG_YELLOW                      </td>
                    <td style="background-color:#FFFFFF;"></td> <td>#FFFFFF XPG_WHITE                       </td></tr>
              </table>
             </small>
            </p>
            <br>
            &nbsp;
            <br>
            Note that for instance while yellow is a primary color, in the  
            <a href="javascript:ExternalLink('ext145');" title='https://en.wikipedia.org/wiki/Additive_color'
               id="ext145" style="color:#9B5565" >RGB/additive</a> color model (as used by xpGUI) it is made by combining red 
            and green, in other words quite unlike mixing blue and yellow paint to make green paint (since paints are/use the 
            <a href="javascript:ExternalLink('ext147');" title='https://en.wikipedia.org/wiki/Subtractive_color'
            id="ext147" style="color:#9B5565" >RYB/subtractive</a> colour model),
            and in fact mixing blue and yellow in the RGB model end ups with <i>white!</i><br>
            <a href="string.htm">string</a> res = <b>gGetColourName</b>(<a href="atom.htm">atom</a> colour) returns one of the 
            above, "#RRGGBB", or "-1".<br>
<!--
            </div>
            <div class="clear"></div>           
            <br>
            <br>
-->
            <a name=rgba></a>
         </td>
        </tr>
<!--
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
          Supported.
<X!X--
        , apart from IupDrawSetClipRect, IupDrawResetClip, IupDrawGetClipRect, IupDrawParentBackground, 
            IupDrawPolygon, IupDrawImage, IupDrawSelectRect, IupDrawFocusRect, and IupDrawGetImageInfo.
--X>
         </td>
        </tr>
-->
        <tr>
         <td>
          <b>Functions:</b>
         </td>
         <td>
<!--            A group of routines to draw on a <a href="gCanvas.htm">gCanvas</a> or an <a href="IupBackgroundBox.htm">IupBackgroundBox</a>.<br>
            They are simple functions designed to help the drawing of custom controls based on these two controls.
            <br>
            It is NOT a complete set of drawing functions, for that you should still use another toolkit like CD.
            <br>
            <br>
            IMPORTANT: all functions can be used only in <a href="gCanvas.htm">gCanvas</a> or <a href="IupBackgroundBox.htm">IupBackgroundBox</a>-->
            <a href="atom.htm">atom</a> colour = <b>rgba</b>(<a href="atom.htm">atom</a> red, green, blue, alpha=0)<br>
            &nbsp;&nbsp;Values should be 0..255 (fractions discarded). An alpha of 0 is fully opaque, 255 is fully transparent.
            <br>
            <a name=to_rgba></a>
            <br>
            <a href="integer.htm">integer</a> {red,green,blue,alpha} = <b>to_rgba</b>(<a href="atom.htm">atom</a> colour)<br>
            &nbsp;&nbsp;For example, to_rgba(XPG_YELLOW) yields {255,255,0,0}, ie red+green <small>[as it <i>is</i> in the RGB model]</small>.
            <br>
            <a name=hsv_to_rgba></a>
            <br>
            <a href="atom.htm">atom</a> colour = <b>hsv_to_rgba</b>(<a href="atom.htm">atom</a> h, s, v, a=0)<br>
            &nbsp;&nbsp;Values should be 0.0..1.0. An alpha of 0.0 is fully opaque, 1.0 is fully transparent.
            <br>
            <br>
            A gCanvas is also used to implement <a href="gGraph.htm">gGraph</a>, <a href="gList.htm">gList</a>, and <a href="gTable.htm">gTable</a>,
            and therefore the result from any of those can also be used wherever a <a href="gdx.htm#gdc">gdc</a> type is required, as well as a
            <a href="gImage.htm">gImage</a>.
            <br>
            <br>
            You can set defaults for several subsequent calls, or override on each <small>(in small font below, just to keep lines short)</small>:
            <br>
            <a name=gCanvasSetBackground></a>
            <br>
            <b>gCanvasSetBackground</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> colour)<br>
<!--DEV times ten:
            <b>gCanvasSetBackground</b>(<a href="gdx.htm#gdc">gdc</a> canvas, <a href="atom.htm">atom</a> colour)<br> -->
            &nbsp;&nbsp;The colour can be eg XPG_PARCHMENT or a similar literal constant or a result from [hsv_to]rgba().<br>
            &nbsp;&nbsp;The canvas is initially cleared to this colour, <i>prior</i> to a <a href="#REDRAW">REDRAW</a> handler, <br>
            &nbsp;&nbsp;and automatically restored after said, so you do not have to remember to,<br>
            &nbsp;&nbsp;and also used as the default fill colour. Default: XPG_WHITE.<br>
<!-- DEV test/update this... (commented out when I suddenly spotted my own "but not fills" below...)
            &nbsp;&nbsp;To manually clear an area, draw a filled shape after gCanvasSetForeground() instead.<br>
-->
            <a name=gCanvasGetBackground></a>
            &nbsp;&nbsp;<a href="atom.htm">atom</a> colour = <b>gCanvasGetBackground</b>(<a href="gdx.htm">gdx</a> canvas) is also provided.
            <br>
            <a name=gCanvasSetForeground></a>
            <br>
            <b>gCanvasSetForeground</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> colour)<br>
            &nbsp;&nbsp;Outer lines and text are drawn in this colour, but not fills. Default: <a href="#XPG_colours">XPG_BLACK</a>.<br>
            <a name=gCanvasGetForeground></a>
            &nbsp;&nbsp;<a href="atom.htm">atom</a> colour = <b>gCanvasGetForeground</b>(<a href="gdx.htm">gdx</a> canvas) is also provided.
            <br>
            <a name=gCanvasSetLineStyle></a>
            <br>
            <b>gCanvasSetLineStyle</b>(<a href="gdx.htm">gdx</a> canvas, <a href="integer.htm">integer</a> style)<br>
            &nbsp;&nbsp;Default: XPG_CONTINUOUS, valid styles are:<br>
            <img src="images/gCanvasLineStyles.png" border="2" width="262" height="62"/>
            <span style="visibility: hidden;"><small>XPG_DASHED XPG_DOTTED XPG_DASH_DOT XPG_DASH_DOT_DOT</small></span><br>
<!--
            &nbsp;&nbsp;Values other than XPG_CONTINUOUS reset the line width to 1, since WinAPI/GTK support nowt else.<br>
-->
            Note that values other than XPG_CONTINUOUS with a line width other than 1 appear as rhomboids, and perhaps for that 
            same reason native WinAPI/GTK do not support such, but while that effect may be less than ideal it is reasonably acceptable on
            slightly thicker lines, and just seems churlish to remove it completely.<br>
            <a name=gCanvasGetLineStyle></a>
            &nbsp;&nbsp;<a href="integer.htm">integer</a> style = <b>gCanvasGetLineStyle</b>(<a href="gdx.htm">gdx</a> canvas) is also provided.<br>
            &nbsp;&nbsp;Use <a href="string.htm">string</a> res = <b>gGetLineStyleName</b>(<a href="integer.htm">integer</a> style) to 
            convert a style to a human readable string.
            <br>
            <a name=gCanvasSetLineWidth></a>
            <br>
            <b>gCanvasSetLineWidth</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> width)<br>
            &nbsp;&nbsp;Values other than 1 reset the line style to XPG_CONTINUOUS, ditto. Default: 1.<br>
            <a name=gCanvasGetLineWidth></a>
            &nbsp;&nbsp;<a href="atom.htm">atom</a> width = <b>gCanvasGetLineWidth</b>(<a href="gdx.htm">gdx</a> canvas) is also provided.
            <br>
            <br>
            When id refers to a gCanvas, the following routines should only be used inside its <a href="#REDRAW">REDRAW</a> handler, or of
            course anything (only) invoked from such a routine, whereas when id refers to a <a href="gImage.htm">gImage</a>() they can be 
            invoked from anywhere and at any time. Use <a href="gRedraw.htm">gRedraw</a>() to force a repaint.
            <br>
            <a name=gCanvasLine></a>
            <br>
            <b>gCanvasLine</b>(<a href="gdx.htm#gdc">gdc</a> canvas, <a href="atom.htm">atom</a> x1, y1, x2, y2, <small>
                                                                     <a href="integer.htm">integer</a> style=-1, width=-1,
                                                                     <a href="atom.htm">atom</a> colour=-1</small>)<br>
            &nbsp;&nbsp;Draw a line from {x1,y1} to {x2,y2} (inclusive).<br>
            &nbsp;&nbsp;Non-1 style/width/colour perform implicit (but transient) gCanvasSetLineStyle/Width/Foreground().
            <br>
            <a name=gCanvasArc></a>
            <br>
            <b>gCanvasArc</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> xc, yc, w, h, angle1, angle2,
                                                                <a href="integer.htm">integer</a> flags=0, <small>style=-1, width=-1,
                                                                <a href="atom.htm">atom</a> colour=-1, fillcolour=-1</small>)<br>
            <a name=gCanvasCircle></a>
            <b>gCanvasCircle</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> xc, yc, radius, 
                                                                   <a href="integer.htm#bool">bool</a> filled=false, <small>
                                                                   <a href="integer.htm">integer</a> style=-1, width=-1,
                                                                   <a href="atom.htm">atom</a> colour=-1, fillcolour=-1</small>)<br>
            &nbsp;&nbsp;Co-ordinates are in pixels, angles in degrees, flags can be XPG_FILLED with XPG_CHORD or XPG_SECTOR.<br>
            &nbsp;&nbsp;The angles define the arc start and end, but they are <i>not</i> the angle relative to the center, except for w==h aka a circle.<br>
            &nbsp;&nbsp;The arc starts at the point (xc+(w/2)*cos(angle1), yc+(h/2)*sin(angle1)) and ditto ends/angle2 (always clockwise).<br>
            &nbsp;&nbsp;A complete ellipse can be drawn using 0 and 360 as the angles.<br>
            &nbsp;&nbsp;gCanvasCircle just invokes gCanvasArc(w=h=2*radius,0,360).<br>
            &nbsp;&nbsp;If angle2 is less than angle1 it will be increased by 360 until it is greater than angle1.<br>
            &nbsp;&nbsp;True(/false) can also be used in place of XPG_FILLED, and the latter passed to gCanvasCircle.<br>
            &nbsp;&nbsp;Non-1 style/width/[fill]colour perform implicit (but transient) gCanvasSetLineStyle/Width/Fore/Background().<br>
            &nbsp;&nbsp;There is no real difference between XPG_FILLED and XPG_CHORD|SECTOR+XPG_FILLED when Fore/Back are the same.<br>
            &nbsp;&nbsp;See the initial screenshot above.
            <br>
            <a name=gCanvasCubicBezier></a>
            <br>
            <b>gCanvasCubicBezier</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> x1, y1, xc1, yc1, xc2, yc2, x2, y2,
                                                                                                    <small>colour=-1</small>)<br>
            <a name=gCanvasQuadBezier></a>
            <b>gCanvasQuadBezier</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> x1, y1, cx, cy, x2, y2,
                                                                                                    <small>colour=-1</small>)<br>
            &nbsp;&nbsp;<small><i>NB: additional parameters not yet finalised, migration from aaline.exw to xpGUI.e still outstanding</i></small><br>
            &nbsp;&nbsp;<small><i>UPDATE: said migration revealed performance/fill issues, Line/Arc/Bezier need a bit of a rethink/redo, but <b>after</b> gImage()</i></small><br>
            &nbsp;&nbsp;Draws a curve from x1,y1 to x2,y2 using control points xc1,yc1 and xc2,yc2.<br>
            &nbsp;&nbsp;The (simpler) quadratic version just invokes the cubic one using the same control point twice.<br>
            &nbsp;&nbsp;Co-ordinates are in pixels, with fractions permitted.
<!--
Drag and drop:
The term drag and drop is often (imo) misunderstood.
If you are talking about dragging a point around on a canvas, that is just "dragging": there is not "drop" as such, except perhaps in
the simpler sense of "stop".
True drag and drop is grabbing something from one application and dropping it onto another, for instance you can drag a file from
Windows Explorer or the Linux equivalent and drop it onto (a running instance of) xpEditor, which should then behave much the same
as if you had pressed <Ctrl O>, navigated to, and selected the same file(s). It is a slightly greyer area when source and target
are in the same application, since you can fake a few things in that case, but true drag and drop is all about adhering to the 
formal inter-process communication protocols. For instance when you dragged those files out of Windows Explorer, those drag images
did not magically appear from nowhere but were carefully cnstructed by Windows Explorer, and if you were to drag something out of
your application, you would have to do the same. (catch22 ref)
-->
            <br>
            <a name=gCanvasRect></a>
            <br>
            <b>gCanvasRect</b>(<a href="gdx.htm">gdx</a> canvas, <small><a href="atom.htm">atom</a> xmin, xmax, ymin, ymax,
                                                                <a href="integer.htm#bool">bool</a> bFill=false,
                                                                <a href="integer.htm">integer</a> rc=0, <small>style=-1, width=-1,
                                                                <a href="atom.htm">atom</a> colour=-1, fillcolour=-1</small></small>)<br>
            &nbsp;&nbsp;Draws a rectangle, optionally filled and/or with rounded corners.<br>
            &nbsp;&nbsp;Non-1 style/width/[fill]colour perform implicit (but transient) gCanvasSetLineStyle/Width/Fore/Background().
            <br>
            <a name=gCanvasPixel></a>
            <br>
<!--DEV gSetPixel(gdc canvas,...)-->
            <b>gCanvasPixel</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> x, y, colour=-1)<br>
            &nbsp;&nbsp;Draws a single pixel in a specified colour or the current foreground colour if omitted or -1.<br>
            &nbsp;&nbsp;<small>(It is expected to be more common that a colour is provided on every call than using the latter defaulting.)</small><br>
            There is a planned gImageGetPixel(), but a gCanvasGetPixel() would have (/my attempts had) rather poor performance under WinAPI, 
            and just outrageously awful performance under GTK - 4 or 5 pixels per <i>second</i>, I kid thee not, and (that was) without 
            performing a GdiFlush/gdk_flush between each (and thus getting some highly suspect results anyway).
            <br>
            <a name=gCanvasText></a>
            <br>
            <b>gCanvasText</b>(<a href="gdx.htm">gdx</a> canvas, <a href="atom.htm">atom</a> x, y,
                                                                <a href="string.htm">string</a> text, <small>
                                                                <a href="integer.htm">integer</a> align=XPG_E,
                                                                <a href="object.htm">object</a> angle=0, 
                                                                <a href="atom.htm">atom</a> colour=-1, style=-1)</small><br>
            &nbsp;&nbsp;Draws text, with full UTF-8 support, optionally realigned, rotated, and/or coloured.<br>
            &nbsp;&nbsp;align: replaces <a href="cdCanvasSetTextAlignment.htm">cdCanvasSetTextAlignment</a>() of pGUI (transiently):<br>
            <img alt="gCanvasText" src="images/gCanvasText.png" width="195" height="75"/>
            <span style="visibility: hidden;"><small>XPG_N XPG_S XPG_W XPG_E XPG_NW XPG_NE XPG_SW XPG_SE</small></span><br>
            &nbsp;&nbsp;The longhand aliases XPG_NORTH, XPG_SOUTH, XPG_WEST, XPG_EAST (the default) can also be used, along<br>
            &nbsp;&nbsp;with XPG_NORTHWEST, XPG_NORTHEAST, XPG_SOUTHWEST, XPG_SOUTHEAST, and XPG_CENTRE.<br>
            &nbsp;&nbsp;&nbsp;<small>(Technically <a href="gShow.htm">XPG_CENTER</a> is the wrong constant, but treated as XPG_CENTRE here.)</small><br>
            &nbsp;&nbsp;You might also imagine the red centre of XPG_C being shifted to one of the eight surrounding orange crosses.<br>
            &nbsp;&nbsp;<a href="string.htm">string</a> res = <b>gGetAlignName</b>(<a href="integer.htm">integer</a> align) converts
                        an alignnent to a human readable string.<br>
            &nbsp;&nbsp;angle: in degrees, replaces <a href="cdCanvasSetTextOrientation.htm">cdCanvasSetTextOrientation</a>() of pGUI (transiently).<br>
<!-- (gCanvas now defaults to "Helvetic, 9", but maybe that should be gDialog() - but attribute inhertiance is not yet in place... [DEV])
            &nbsp;&nbsp;Note that on Windows a FONT must have been explicitly applied to the canvas before any rotation can occur.<br> -->
            &nbsp;&nbsp;Rotation normally occurs around the top left (XPG_NW) corner. <br>
            &nbsp;&nbsp;For a rotation of +90 only, the rotation point may be overidden by specifying an angle as eg {XPG_SE,90}.<br>
            &nbsp;&nbsp;&nbsp;&nbsp;<small>(Other angles are obviously doable, but need basic trig & more significantly a 
                                            bucketload of testing that I simply don&rsquo;t have time for.</small><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<small>&nbsp;Of course I&rsquo;d very happily adopt code with either extended restrictions such as 
                                            {+90,-90}, or a decent demo/proof that it works.</small><br>
            &nbsp;&nbsp;&nbsp;&nbsp;<small>&nbsp;For the 9 simple cases it <i>does</i> work for, as per xpGUI.e/xpg_shifta() I literally 
                                            drew 9 tiny diagrams to work out the shifts needed.)</small><br>
            &nbsp;&nbsp;colour: if other than -1 is specified, an implicit (but transient) gCanvasSetForeground() occurs.<br>
            &nbsp;&nbsp;style: may be XPG_NORMAL, XPG_BOLD, XPG_ITALIC, or XPG_BOLDITALIC. A transient gSetAttribute(canvas,"FONT") occurs.<br>
            &nbsp;&nbsp;You may also use <a href="gGetAttribute.htm#gGetTextExtent">gGetTextExtent</a>(), but any rotation is down to you.
            <br>

            <a name=PLANNED></a>
            <br>
<!-- I might well still add gCanvasMark(), but its simply not worth even stating that... -->
            Planned: gCanvasPolygon(), gImage([SVG/XPM?]), and gGet/PutImageRGB[A]().<br>
            A larger canvas (than the window that holds it) with automatic scroll bars is pretty high on my wish list.<br>
            GDI on Windows does not support anti-aliased lines, but demo\xpGUI\aaline.exw is quite possibly everything needed,
            except perhaps for filling shapes. Getting a gImage() of some kind up and running is probably more important, and 
            perhaps even incorporating some of the <a href="arwen32dib.htm">arwen32dib</a> code in a GTK/JavaScript compatible way.<br>


<!--
maybe useful: https://stackoverflow.com/questions/12490400/gtkdrawingarea-with-cairo-how-to-make-it-scrollable
                https://stackoverflow.com/questions/11132177/cairo-in-scrollable-drawing-area
                https://stackoverflow.com/questions/48725156/gtk3-and-cairo-too-slow (timer...)
            <br>
            <a name=control></a>
            <br>
            Control:
            <br>
            <br>
//          All primitives can be called only between calls to IupDrawBegin and IupDrawEnd.
//Maybe: invoked automatically for the REDRAW handler...
//          <br>
//          <br>
//          <b>IupDrawBegin</b>(Ihandle ih) - Initialize the drawing process.
//          <br>
//          <br>
//          <b>IupDrawEnd</b>(Ihandle ih) - Terminates the drawing process.
-->
<!--
MAYBE (xpGUI_from_pGUI):
//csCanvasArc/IupDrawArc => gCanvasArc (ditto Sector, Chord)
// nah, force use of gDrawPolygon
//cdCanvasBegin => gPolygonBegin (new)  ==> gDrawPolygon{}
//cdCanvasVertex => gPolygonVertex (new) ==> gDrawPolygon{}&=
//cdCanvasEnd/IupDrawPolygon => gPolygonEnd (new) ==> gDrawPolygon(,?)
//cdCanvas[Rounded]Box => gDraw[Rounded]Box (new, filled)
//cdCanvas[Rounded]Rect/IupDrawRectangle => gDraw[Rounded]Rect (new, not filled) [get rid of that trailing "angle"]
//cdCanvasFont => gDrawFont (new)
cdCanvasGetImageRGB => gCanvasGetImageRGB (new)
//cdCanvasLine/IupDrawLine => gDrawLine
cdCanvasMark[Type|Size] => gDrawMark[Type|Size] (new)
//cdCanvasText/IupDrawText => gDrawText (note: the only current use of IupDrawText() is in demo\pGUI\IupBackgroundBox.exw, so manually fix those four)
//cdCanvasGetTextSize/IupDrawGetTextSize => gDrawGetTextSize (new)
//cdCanvasSetAttribute (SIZE only) => gSetAttribute
//IupDrawGetSize => gGetAttribute("SIZE")

            <br>
            <br>
            <b>IupDrawSetClipRect</b>(Ihandle ih, int x1, int y1, int x2, int y2) - Defines a rectangular clipping 
            region<a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>.
            <br>
            <br>
            <b>IupDrawResetClip</b>(Ihandle ih) - Reset the clipping area to 
            none<a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>.
            <br>
            <br>
            integer {x1,y1,x2,y2} = <b>IupDrawGetClipRect</b>(Ihandle ih) - Returns the previous rectangular clipping region 
            set by IupDrawSetClipRect, if clipping was reset returns 0 in all values
            <a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>.
            <br>
            <a name=primitives></a>
            <br>
            Primitives:
            <br>
            <br>
            The primitives color is controlled by the attribute DRAWCOLOR<a href="notpgui.htm#IupCanvas"><span style="color:lime;"><sup>+</sup></span></a>. 
            Default: <a href="#XPG_colours">XPG_BLACK</a>.
            <br>
            <br>
            Rectangle, Arc and Polygon can be filled or stroked. <br>
            When stroked the line style can be continuous, dashed or dotted. <br>
            These are controlled by the attribute DRAWSTYLE<a href="notpgui.htm#IupCanvas"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>. <br>
            Can have values: FILL, STROKE, STROKE_DASH, STROKE_DOT, STROKE_DASH_DOT or STROKE_DASH_DOT_DOT (dash dot and dash dot dot since 3.25). Default: STROKE. <br>
            The FILL value when set before IupDrawLine has the same effect as STROKE.
            <br>
            <br>
            The line width default is 1, but it can be controlled by the DRAWLINEWIDTH attribute. (since 3.24)
            <br>
            <br>
//          <b>IupDrawParentBackground</b>(Ihandle ih) - Fills the canvas with the native parent background 
//          color<a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>.
            <br>
            <br>
//          <b>IupDrawLine</b>(Ihandle ih, integer x1, y1, x2, y2) - Draws a line including start and end points.
            <br>
            <br>
//          <b>IupDrawRectangle</b>(Ihandle ih, integer x1, y1, x2, y2) - Draws a rectangle including start and end points.
            <br>
            <br>
//          <b>IupDrawArc</b>(Ihandle ih, integer x1, y1, x2, y2, atom a1, a2) - Draws an arc inside a rectangle between the two angles in degrees. <br>
//          When filled will draw a pie shape with the vertex at the center of the rectangle. <br>
//          Angles are counter-clock wise relative to the 3 o&rsquo;clock position.
            <br>
            <br>
-->
<!--
            <b>IupDrawPolygon</b>(Ihandle ih, sequence points) - Draws a polygon. Coordinates are stored in the array in the sequence: x1, y1, x2, y2, 
            ..<a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>.
            <br>
            <br>
//          <b>IupDrawText</b>(Ihandle ih, string str, integer x, y, w=0, h=0) - Draws a text in the given position using 
//          the font defined by DRAWFONT (since 3.22), 
//          if not defined then use <a href="gSetAttribute.htm#FONT">FONT</a>. <br>
//          The coordinates are relative the top-left corner of the text. <br>
//          Strings with multiple line are accepted using '\n' as line separator. <br>
            Horizontal text alignment for multiple lines can be controlled using DRAWTEXTALIGNMENT attribute: ALEFT (default), ARIGHT and ACENTER options (since 3.22).<br>
            For single line texts if the text is larger than its box and DRAWTEXTWRAP=Yes, then the line will be automatically broken in multiple lines. <br>
            Notice that this is done internally by the system, the element natural size will still use only a single line. <br>
//          For the remaining lines to be visible the element should use EXPAND=VERTICAL or set a SIZE?/RASTERSIZE? with enough height for the wrapped lines. (since 3.25) <br>
            If the text is larger that its box and DRAWTEXTELLIPSIS=Yes, an ellipsis ("...") will be placed near the last visible part of the text and replace the invisible part. <br>
            It will be ignored when WRAP=Yes (since 3.25). w and h are optional and can be -1 or 0, the text size will be used, so WRAP nor ELLIPSIS will not produce any changes. <br>
            The text is not automatically clipped to the rectangle, if DRAWTEXTCLIP=Yes it will be clipped but depending on the driver may affect the clipping set 
            by IupDrawSetClipRect (since 3.25). <br>
//          The text can be draw in any angle using DRAWTEXTORIENTATION<a href="notpgui.htm#IupCanvas"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>,
//          in degrees and counterclockwise (since 3.25), its layout is not centered inside the 
//          given rectangle when text is oriented, to center the layout use DRAWTEXTLAYOUTCENTER=Yes. <br>
//          Text orientation, ellipsis and wrap are not supported in X11.
            <br>
            <br>
            <b>IupDrawImage</b>(Ihandle ih, string name, integer x, y, w=0, h=0) - Draws an image given its 
            name<a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>. <br>
            The coordinates are relative the top-left corner of the image. <br>
            The image name follows the same behavior as the IMAGE attribute used by many controls. <br>
            Use <a href="IupSetHandle.htm">IupSetHandle</a> or <a href="IupSetAttributeHandle.htm">IupSetAttributeHandle</a> to associate an image to a name.
            See also <a href="IupImage.htm">IupImage</a>. <br>
            The DRAWMAKEINACTIVE attribute can be used to force the image to be draw with an inactive state appearance. <br>
//          The DRAWBGCOLOR can be used to control the inactive state background color or when transparency is flatten. <br>
            w and h are optional and can be -1 or 0, then the image size will be used and no zoom will be performed (since 3.25). <br>
            Image zoom is not supported in X11 and GDK.
            <br>
            <br>
            <b>IupDrawSelectRect</b>(Ihandle ih, integer x1, y1, x2, y2) - Draws a selection 
            rectangle<a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>.
            <br>
            <br>
            <b>IupDrawFocusRect</b>(Ihandle ih, integer x1, y1, x2, y2) - Draws a focus 
            rectangle<a href="notpgui.htm#IupDrawXxxx"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>.

            <br>
            <a name=info></a>
            <br>
            Information:
            <br>
            <br>
//          integer {width,height} = <b>IupDrawGetSize</b>(Ihandle ih) - Returns the drawing area size. (erm, just use DRAWSIZE instead)
            <br>
            <br>
//          integer {width,height} = <b>IupDrawGetTextSize</b>(Ihandle ih, string str) - Returns the given text size using the font defined by DRAWFONT, if not defined then use FONT.

            <br>
            <br>
            integer {width,height,bpp} = <b>IupDrawGetImageInfo</b>(string name) - Returns the given image size and bits per pixel. bpp can be 8, 24 or 
            32.
-->
         </td>
        </tr>
        <tr>
         <td>
          <b>Attributes:</b>
         </td>
         <td>
            
         </td>
        </tr>
<!--
        <tr>
         <td>
          BACKINGSTORE
         </td>
         <td>
            [Motif Only]: Controls the canvas backing store flag. The default value is "YES".
         </td>
        </tr>
-->
<!--
//      <tr>
//       <td>
//        <a href="gSetAttribute.htm#BGCOLOR">BGCOLOR</a><a href="notpgui.htm"><span style="color:lime;"><sup>+</sup></span></a>
//       </td>
//       <td>
//          Background color. The background is painted only if the <a href="#REDRAW">REDRAW</a> handler is not defined. <br>
//          If the handler is defined the application must draw all the canvas contents. <br>
//          In GTK or Motif if you set the <a href="#ACTION">ACTION</a> handler after map then you should also set BGCOLOR to any value just after 
//          setting the handler or the first redraw will be lost. Default: "255 255 255".
//       </td>
//      </tr>
-->
<!--
        <tr>
         <td>
?         BORDER<a href="notpgui.htm#IupCanvas"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>
         </td>
         <td>
            (creation only): Shows a border around the canvas. Default: "YES".
         </td>
        </tr>
-->
<!--
//      <tr>
//       <td>
//        CAIRO_CR
//       </td>
//       <td>
//          [GTK Only] (non inheritable): Contains the "cairo_t*" parameter of the internal GTK handler. <br>
//          Valid only during the <a href="#REDRAW">REDRAW</a> handler and onyl when using GTK version 3. (since 3.7)
//       </td>
//      </tr>
        <tr>
         <td>
          CLIPRECT
         </td>
         <td>
            [Windows and GTK Only] (only during <a href="#REDRAW">REDRAW</a>): Specifies a rectangle that has its region invalidated for painting, 
            it could be used for clipping. Format: "%d %d %d %d"="x1 y1 x2 y2".
         </td>
        </tr>
        <tr>
         <td>
          <a href="gSetAttribute.htm#CURSOR">CURSOR</a>
         </td>
         <td>
            (non inheritable): Defines a cursor for the canvas. The Windows SDK recommends that cursors and icons should be implemented as resources rather than created at run time.
         </td>
        </tr>
-->
        <tr>
         <td>
?         <a href="gSetAttribute.htm#EXPAND">EXPAND</a>
         </td>
         <td>
            (non inheritable): The default value is "YES". The natural size is the size of 1 character.
         </td>
        </tr>
<!--
        <tr>
         <td>
?         DROPFILESTARGET
         </td>
         <td>
            [Windows and GTK Only] (non inheritable): Enable or disable the drop of files. 
            Default: NO, but if DROPFILES_CB is defined when the element is mapped then it will be automatically enabled.
         </td>
        </tr>
-->
<!--
//        <a name=DRAWSIZE></a>
//      <tr>
//       <td>
//?       DRAWSIZE  [DEV] This may be re-instated, if we get [automatic] scrollbars....
//       </td>
//       <td>
//          (non inheritable): The size of the drawing area in pixels. This size is also used in the <a href="gSetHandler.htm#RESIZE_CB">RESIZE_CB</a> handler.
//        <br>
//          Notice that the drawing area size is not the same as 
//          <a href="gSetAttribute.htm#RASTERSIZE">RASTERSIZE</a><a href="notpgui.htm"><span style="color:lime;"><sup>+</sup></span></a>.
//          The <a href="gSetAttribute.htm#SCROLLBAR">SCROLLBAR</a> and BORDER attributes affect the size of the drawing area.
//       </td>
//      </tr>
-->
<!--
        <tr>
         <td>
          HDC_WMPAINT
         </td>
         <td>
            [Windows Only] (non inheritable): Contains the HDC created with the BeginPaint inside the WM_PAINT message. <br>
            Valid only during the <a href="#REDRAW">REDRAW</a> handler.
         </td>
        </tr>
        <tr>
         <td>
          HWND
         </td>
         <td>
            [Windows Only] (non inheritable, read-only): Returns the Windows Window handle. Available in the Windows driver or in the GTK driver in Windows.
         </td>
        </tr>
-->
        <tr>
         <td>
?         SCROLLABLE
         </td>
         <td>
            (creation only, non inheritable): Enable or disable builtin scrollbars. Default: NO/0/false.<br>
            Fairly obviously, scrollbars are only suitable for a finite area with impassible boundaries, and would not be needed/the wrong choice anyway 
            on (say) an infinitely draggable edgeless road map, or most games and other simulations, but would be useful when zoomed in on an image, in
            much the same way as the standard mspaint and other image editors. See demo\xpGUI\scroller.exw for an example. [DEV...]
            <small><i>Not yet implemented.</i></small>
         </td>
        </tr>
        <tr>
         <td>
?         SCROLLINFO
         </td>
         <td>
            Obtain or set the scrollbar status.
            <small><i>Not yet implemented.</i></small>
         </td>
        </tr>

<!--
        <tr>
         <td>
?         <a href="gSetAttribute.htm#SCROLLBAR">SCROLLBAR</a><a href="notpgui.htm#IupCanvas"><span style="color:orange; font-size:75%;"><sup>?</sup></span></a>
         </td>
         <td>
            (creation only): Associates a horizontal and/or vertical scrollbar to the canvas. Default: "NO". 
            The <a href="gSetAttribute.htm#secondaryattributes">secondary attributes</a> are all non inheritable.
         </td>
        </tr>
-->
<!--
        <tr>
         <td>
          TOUCH
         </td>
         <td>
            [Windows 7 Only]: enable the multi-touch events processing. (Since 3.3)
         </td>
        </tr>
        <tr>
         <td>
          WHEELDROPFOCUS
         </td>
         <td>
            (non inheritable) when the wheel is used the focus control receives a SHOWDROPDOWN=No. (since 3.28)
         </td>
        </tr>
        <tr>
         <td>
          XDISPLAY
         </td>
         <td>
            [UNIX Only](non inheritable, read-only): Returns the X-Windows Display. Available in the Motif driver or in the GTK driver in UNIX.
         </td>
        </tr>
        <tr>
         <td>
          XWINDOW
         </td>
         <td>
            [UNIX Only](non inheritable, read-only): Returns the X-Windows Window (Drawable). Available in the Motif driver or in the GTK driver in UNIX.
         </td>
        </tr>
-->
        <tr>
         <td>
          also
         </td>
         <td>
            <a href="gSetAttribute.htm#ACTIVE">ACTIVE</a>, 
            <a href="gSetAttribute.htm#CANFOCUS">CANFOCUS</a>, 
            <a href="gSetAttribute.htm#FONT">FONT</a>, 
<!--        <a href="gSetAttribute.htm#NAME">NAME</a>, -->
<!--            <a href="gGetAttribute.htm#POSITION">POSITION</a>, -->>
<!--            <a href="gGetAttribute.htm#SCREENPOSITION">SCREENPOSITION</a>, -->
            <a href="gSetAttribute.htm#MINSIZE">MINSIZE</a>, 
            <a href="gSetAttribute.htm#MAXSIZE">MAXSIZE</a>,
            <a href="gSetAttribute.htm#SIZE">SIZE</a>,
            <a href="gSetAttribute.htm#TIP">TIP</a>, 
<!--            <a href="gSetAttribute.htm#RASTERSIZE">RASTERSIZE</a>,-->
<!--        <a href="gSetAttribute.htm#ZORDER">ZORDER</a>,-->
            <a href="gSetAttribute.htm#VISIBLE">VISIBLE</a>.<br>
          <a name=HANDLERS></a>
         </td>
        </tr>
        <tr>
         <td>
          <b>Handlers:</b>
         </td>
         <td>
          <br>  
          <a name=REDRAW></a>
         </td>
        </tr>
<!--
//?       <a name=BUTTON_CB></a>
//      <tr>
//       <td>
//        <a href="gSetHandler.htm#BUTTON_CB">BUTTON_CB</a>
//       </td>
//       <td>
//          Event generated when any mouse button is pressed or released.
//       </td>
//      </tr>
-->
<!--
        <tr>
         <td>
?         DROPFILES_CB
         </td>
         <td>
            [Windows and GTK Only]: Event generated when one or more files are dropped in the element.
         </td>
        </tr>
-->
<!-- (???)
          <a name=FOCUS_CB></a>
        <tr>
         <td>
?         FOCUS_CB
         </td>
         <td>
            Called when the canvas gets or looses the focus. 
            It is called after the common handlers <a href="gSetHandler.htm#GETFOCUS_CB">GETFOCUS_CB</a> and <a href="gSetHandler.htm#KILLFOCUS_CB">KILLFOCUS_CB</a>.
            <br>
            <br>
            function focus_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> focus)<br>
            ih: identifier of the element that activated the event.<br>
            focus: is non zero if the canvas is getting the focus, is zero if it is loosing the focus.
         </td>
        </tr>
-->
<!-- (now just listed as MOUSEMOVE in "also" below)
//      <tr>
//       <td>
//?       <a href="gSetHandler.htm#MOTION_CB">MOTION_CB</a>
//       </td>
//       <td>
//          Event generated when the mouse is moved.
//       </td>
//      </tr>
-->
<!--
//      <tr>
//       <td>
//?       <a href="gSetHandler.htm#KEYPRESS_CB">KEYPRESS_CB</a>
//       </td>
//       <td>
//          Event generated when a key is pressed or released. It is called after the common <a href="gSetHandler.htm#KEY">KEY</a> handler.
//          <br>
//          <br>
//          When the canvas has the focus, pressing the arrow keys may change the focus to another control in some systems. <br>
//          If your handler process the arrow keys, it is recommended you return <a href="gSetHandler.htm#XPG_IGNORE">XPG_IGNORE</a> 
//          so it will not lose its focus.
//       </td>
//      </tr>
-->
        <tr>
         <td>
          REDRAW
         </td>
         <td>
            A procedure that should be invoked when the canvas needs to be redrawn
            <br>
            <br>
            procedure redraw(<a href="gdx.htm">gdx</a> h)<br>
            h: identifier of the element (ie canvas) that activated the event.
            <br>
            <br>
            Usually specified on the initial gCanvas() call that creates the canvas, but can also be set later in the usual manner,
            being specifically here <a href="gSetHandler.htm">gSetHandler</a>(canvas,"REDRAW",redraw).
            <br>
            <br>
            Note the background colour used for initially clearing the canvas should be set before the first paint event and is 
            applied before redraw() is invoked, and automatically restored after (so you don&rsquo;t have to). Any decision to
            change that initial clear setting should likewise therefore be made and performed outside of the redraw() routine.<br>
<!--
            Note that the redraw routine should usually invoke gCanvasSetBackground() just before returning, rather than leave a random
            background colour for the next initial clear/repaint, since that occurs <i>before</i> it is re-invoked again.
-->
          <a name=DROP></a>
         </td>
        </tr>
        <tr>
         <td>
          DROP
         </td>
         <td>
            Intercept/override the drawing operations.
            <br>
            <br>
            function drop(<a href="integer.htm">integer</a> rid)<br>
            rid: an xpGUI drawing operation such as gCanvasText
            <br>
            Returns: the original or your intercept version of one of the routines listed below.<br>
            When you write an intercept, you must replicate the exact signature, usually by copying from these help docs, including
            any defaults, as say iCanvasText(), which can then invoke the real gCanvasText(), if desired.
            <br>
            <br>
            More useful on the canvas-derived controls <a href="gGraph.htm">gGraph</a>, <a href="gList.htm">gList</a>, and
            <a href="gTable.htm">gTable</a>, which have overidden the <a href="#REDRAW">REDRAW</a> handler.<br>
            Allows an application to tweak/log the drawing primitives, for an example see demo\xpGUI\gTable.exw, where at first
            I logged all such calls and copied them into demo\xpGUI\gCanvas.exw, before realising I could just tweak the two I
            actually needed. In this specific instance that was for mocking up the <a href="gSetAttribute.htm#FONT">FONT</a> 
            table in these very docs, so I could centre it (ain&rsquo;t I the fusspot).
            <br>
            <br>
            The current set of so-used drawing operations is:<br>
            <a href="#gCanvasSetForeground">gCanvasSetForeground</a>,<br>
            <a href="#gCanvasSetBackground">gCanvasSetBackground</a>, (not used by gTable)<br>
            <a href="#gCanvasRect">gCanvasRect</a>,<br>
            <a href="#gCanvasLine">gCanvasLine</a>,<br>
            <a href="#gCanvasText">gCanvasText</a>. (the only one used by gList)
            <br>
            <br>
         </td>
        </tr>

<!--
//      <tr>
//       <td>
//?       <a href="gSetHandler.htm#RESIZE_CB">RESIZE_CB</a>
//       </td>
//       <td>
//          Event generated when the canvas size is changed. 
//       </td>
//      </tr>
-->
<!--
        <tr>
         <td>
          TOUCH_CB
         </td>
         <td>
            [Windows 7 Only]: Event generated when a touch event occurred. Multiple touch events will trigger several calls. Must set TOUCH=Yes to receive this event. (Since 3.3)
            <br>
            <br>
            function touch_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> id, x, y, <a href="atom.htm">atom</a> pState)<br>
            ih: identifies the element that activated the event.<br>
            id: identifies the touch point. <br>
            x, y: position in pixels, relative to the top-left corner of the canvas.<br>
            pState: the touch point state (char*). Can be: DOWN, MOVE or UP. If the point is a "primary" point then "-PRIMARY" is appended to the string.
            <br>
            <br>
            Returns: <a href="gSetHandler.htm#IUP_CLOSE">IUP_CLOSE</a> will be processed.
         </td>
        </tr>
        <tr>
         <td>
          MULTITOUCH_CB
         </td>
         <td>
            [Windows 7 Only]: Event generated when multiple touch events occurred. Must set TOUCH=Yes to receive this event. (Since 3.3)
            <br>
            <br>
            function mulittouch_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> count, <a href="atom.htm">atom</a> pid, px, py, pstate) <br>
            ih: identifier of the element that activated the event.<br>
            count: Number of touch points in the array.<br>
            pid: Array (int*) of touch point ids.<br>
            px: Array (int*) of touch point x coordinates in pixels, relative to the top-left corner of the canvas.<br>
            py: Array (int*) of touch point y coordinates in pixels, relative to the top-left corner of the canvas.<br>
            pstate: Array (int*) of touch point states. Can be 'D' (DOWN), 'U' (UP) or 'M' (MOVE).
            <br>
            <br>
            Returns: <a href="gSetHandler.htm#IUP_CLOSE">IUP_CLOSE</a> will be processed.
         </td>
        </tr>
-->
<!-- may yet need these for a possible gCodeText() - see demo\pGUI\IupCodeText.exw - not as if that was ever anywhere near finished/useful.
        <tr>
         <td>
?         <a href="gSetHandler.htm#SCROLL_CB">SCROLL_CB</a>
         </td>
         <td>
            Called when the scrollbar is manipulated. (GTK 2.8) Also the POSX and POSY values will not be correctly updated for older GTK versions.
         </td>
        </tr>
        <tr>
         <td>
?         <a href="gSetHandler.htm#WHEEL_CB">WHEEL_CB</a>
         </td>
         <td>
            Event generated when the mouse wheel is rotated.
         </td>
        </tr>
-->
<!--
        <tr>
         <td>
          WOM_CB
         </td>
         <td>
            [Windows Only]: Event generated when an audio device receives an event.
         </td>
        </tr>
-->
        <tr>
         <td>
          also
         </td>
         <td>
<!--
//          <a href="gSetHandler.htm#MAP_CB">MAP_CB</a>,
//          <a href="gSetHandler.htm#UNMAP_CB">UNMAP_CB</a>,
//          <a href="gSetHandler.htm#DESTROY_CB">DESTROY_CB</a>, 
-->
            <a href="gSetHandler.htm#CLICK">CLICK</a>, 
<!--
?           <a href="gSetHandler.htm#GETFOCUS_CB">GETFOCUS_CB</a>, 
            <a href="gSetHandler.htm#KILLFOCUS_CB">KILLFOCUS_CB</a>, 
            <a href="gSetHandler.htm#ENTERWINDOW_CB">ENTERWINDOW_CB</a>,
            <a href="gSetHandler.htm#LEAVEWINDOW_CB">LEAVEWINDOW_CB</a>, 
-->
<!--            <a href="gSetHandler.htm#HELP_CB">HELP_CB</a> -->
            <a href="gSetHandler.htm#MOUSEMOVE">MOUSEMOVE</a>, 
            <a href="gSetHandler.htm#KEY">KEY</a>: All common handlers are supported.<br>
          <a name=tech></a>
         </td>
        </tr>
        <tr id="Technicalia" style="display:none;">
         <td>
          <a href="glossary.htm#technicalia">
           <b>Technicalia</b>
          </a>
         </td>
         <td>
            As this is a <a href="g_paranormal.htm">paranormalised function</a>, and with no expectation that you should memorise this lot,
            except maybe "raa", you can assume that all of the following are potentially perfectly valid, with the fairly obvious restrictions 
            that any parameters <i>must</i> be in strict raa-order, and no args without attributes:
            <br>
            <br>
<small>
<!--eucode>
                        gCanvas()
                        gCanvas(redraw)
                        gCanvas(attributes)
                        gCanvas(attributes, args)
                        gCanvas(redraw, attributes)
                        gCanvas(redraw, attributes, args)   -- (the full set)
</eucode-->
<pre>
<font color="#7060A8">                        gCanvas</font><font color="#0000FF">()</font>
<font color="#7060A8">                        gCanvas</font><font color="#0000FF">(</font><font color="#000000">redraw</font><font color="#0000FF">)</font>
<font color="#7060A8">                        gCanvas</font><font color="#0000FF">(</font><font color="#000000">attributes</font><font color="#0000FF">)</font>
<font color="#7060A8">                        gCanvas</font><font color="#0000FF">(</font><font color="#000000">attributes</font><font color="#0000FF">,</font><font color="#000000"> args</font><font color="#0000FF">)</font>
<font color="#7060A8">                        gCanvas</font><font color="#0000FF">(</font><font color="#000000">redraw</font><font color="#0000FF">,</font><font color="#000000"> attributes</font><font color="#0000FF">)</font>
<font color="#7060A8">                        gCanvas</font><font color="#0000FF">(</font><font color="#000000">redraw</font><font color="#0000FF">,</font><font color="#000000"> attributes</font><font color="#0000FF">,</font><font color="#000000"> args</font><font color="#0000FF">)  </font><font color="#000080"><i> -- (the full set)</i></font>
</pre>
</small>
            <br>
            Note in practice redraw is actually defined as <a href="object.htm">object</a>, and attributes as
            <a href="sequence.htm">sequence</a> rather than string, but they are all manually and thoroughly verified to 
            be of the documented types, after being repositioned via xpGUI.e/paranormalise_raa().
            <br>
            <br>
            Compatibility note: On a gCanvas (as shown) {0,0} is <a href="#gCanvasText">XPG_NW</a>, logically matching (say) the {x,y} of 
            <a href="gShow.htm">gShow</a>(), whereas on an <a href="IupCanvas.htm">IupCanvas</a>() it was/is 
            <a href="cdCanvasSetTextAlignment.htm">CD_SOUTH_WEST</a>. In other words the vertical axis is inverted - "height-y" usually works.
         </td>
        </tr>
       </table>
       <img id="Timg" src="images/sprites/tech.open.png" title="Expand/Shrink" alt="Expand/Shrink" style="display:block;clear:both;" onload="setStartT(this);" onclick="changeImageT(this);" />
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
