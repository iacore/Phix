<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">gSetHandler</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
            include xpGUI.e
            <br>
            <br>
            gSetHandler(<a href="gdx.htm">gdx</a> id, <a href="sequence.htm">sequence</a> name, <a href="rtn.htm">rtn</a> handler=NULL)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Associates one or more handlers for an event on one or more controls.
            <br>
            <br>
            id: identifier of the interface element(s), can be a single integer or a (flat) sequence of them.<br>
            name: a string identifying the handler, eg <a href="#KEY">"KEY"</a>, or an even-length sequence of string,rtn pairs.<br>
            handler: a (bare) function or procedure, or NULL. Must be NULL (/omitted) if name is pairs and not a string.
            <br>
            <br>
            A NULL rtn when name is a string, or any NULL even element of name, simply removes any association. 
            <br>
            <br>
            See the documentation of each specific interface element for a list of valid/meaningful names, and the required routine signatures.
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
            Supported.
         </td>
        </tr>
        <tr>
         <td>
          <b>Notes:</b>
         </td>
         <td>
            All elements with a parameter of type <a href="rtn.htm">rtn</a> permit/encourage an implit invocation of gSetHandler().
            <br>
            <br>
            You can also invoke this as the simple alias <b>gSetHandlers</b>(), with the implication but not enforcement that id or name 
            or both are non-unitary, or just stick with the non-s name for everything. Note however that is in stark contrast to (say)
            <a href="gSetAttribute.htm">gSetAttribute</a>() and <a href="gSetAttributes.htm">gSetAttributes</a>(), which are in fact quite 
            different, although they too can also both set one or more things on one or more elements, and likewise that is not dependent 
            on a trailing s.
            <br>
            <br>
            Handlers are used by the application to receive notifications from the system that the user or the system itself has interacted with 
            the user interface of the application. 
            <br>
            <br>
            On the other hand attributes are used by the application to communicate with the user interface system.
            <br>
            <br>
            Even though handlers have different purposes from attributes, they are also associated to an element by means of a name. <br>
            All handlers receive at least the element for which the event was triggerd as a parameter, almost always in the form of a 
            <a href="gdx.htm">gdx</a>, though it may be a tad more opaque for some, such as <a href="gTreeView.htm#BRANCHOPEN">BRANCHOPEN</a>.
            <br>
            <a name=XPG_DEFAULT></a>
            <a name=XPG_CLOSE></a>
            <a name=XPG_IGNORE></a>
            <a name=XPG_CONTINUE></a>
            <br>
            Most handlers (except those defined as procedures) must return one of the following values:
            <ul>
            <li>XPG_DEFAULT: Proceeds normally with user interaction. Should other return values do not apply, the handler should return this value. </li>
            <li>XPG_CLOSE: Close the parent window of the element and in some cases exit the application. Applies only to some events. </li>
            <li>XPG_IGNORE: Perform no further processing of this event. Applies only to some events. </li>
            <li>XPG_CONTINUE: Pass the treatment of the event to the parent element. Applies only to some events. </li>
            </ul>
            <b>NB</b>: returning XPG_CLOSE does <i>not</i> automatically invoke CLOSE_CB handlers.
            <br>
            <br>
            Only some handlers support the last 3 return values. Check each handler documentation. When nothing is documented then only XPG_DEFAULT 
            is supported (and in all probability that handler should therefore be a procedure).
            <br>
            <br>
DEV rewrite rqd from this point on:
            <br>
            <br>
            Note: Avoid using XPG_IGNORE (and XPG_CLOSE) unless it is specifically documented for that callback. <br>
            For example, it is and always was the documented behaviour for an <a href="callbacks.htm#IDLE_ACTION">IDLE_ACTION</a> callback to be removed when it 
            returns XPG_IGNORE.
            <br>
            <br>
            An important detail when using handlers is that they are only triggered when the user physically performs an action on an element. <br>
            A handler is <i>not</i> invoked when the programmer sets a value via <a href="gSetAttribute.htm">gSetAttribute</a>.<br>
            For instance: when the programmer changes a selected item on a list, no handler is called and it is up to the programmer to
            ensure any additional appropriate processing occurs, by some more direct means.
            <br>
            <br>
            The order of callback calling is system dependent. <br>
            For instance, the <a href="callbacks.htm#RESIZE_CB">RESIZE_CB</a> and the SHOW_CB are called in different order in Win32 and in X-Windows when the dialog is shown for the first time.
            <br>
            <br>
            As well as its normal duty of verifying parameters, the <a href="Icallback.htm">cbfunc</a> type can be used to declare variables suitable for storing callbacks.<br>
            The C header file "iupcbs.h" lists some 50 different typedefs for callbacks (IFxxx/sIFxxx/dIFxxx). <br>
            In Phix you can always get by with "atom" for each parameter, if need be.
            <br>
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <b>Examples:</b>
         </td>
         <td>
<!--eucode>
-- set one handler on one interface element:
gSetHandler(canvas,"REDRAW",redraw)
-- set the same handler on two elements:
gSetHandler({canvas1,canvas2},"REDRAW",redraw)
-- set two handlers on both elements:
gSetHandlers({canvas1,canvas2},{"REDRAW",redraw,"RESIZE",resize})
</eucode-->
<pre>
<font color="#000080"><i>-- set one handler on one interface element:</i></font>
<font color="#7060A8">gSetHandler</font><font color="#0000FF">(</font><font color="#000000">canvas</font><font color="#0000FF">,</font><font color="#008000">"REDRAW"</font><font color="#0000FF">,</font><font color="#000000">redraw</font><font color="#0000FF">)</font>
<font color="#000080"><i>-- set the same handler on two elements:</i></font>
<font color="#7060A8">gSetHandler</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">canvas1</font><font color="#0000FF">,</font><font color="#000000">canvas2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#008000">"REDRAW"</font><font color="#0000FF">,</font><font color="#000000">redraw</font><font color="#0000FF">)</font>
<font color="#000080"><i>-- set two handlers on both elements:</i></font>
<font color="#7060A8">gSetHandlers</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">canvas1</font><font color="#0000FF">,</font><font color="#000000">canvas2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#008000">"REDRAW"</font><font color="#0000FF">,</font><font color="#000000">redraw</font><font color="#0000FF">,</font><font color="#008000">"RESIZE"</font><font color="#0000FF">,</font><font color="#000000">resize</font><font color="#800000">}</font><font color="#0000FF">)</font>
</pre>
            <br>
          <br>
         </td>
        </tr>
<!--
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="IupGetCallback.htm">IupGetCallback</a>,
          <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>
         </td>
        </tr>
-->
        <tr>
         <td>
            <b>Common:</b>
         </td>
         <td>
          The following callbacks are common to several controls/interface elements (they just got <i>no class</i>):
         </td>
        </tr>
<!--
        <tr>
         <td>
          <a name=ACTION></a>
          "ACTION"
         </td>
         <td>
            While common to several elements, the callback parameters vary - see specific elements for details.
            <br>
            <br>
            Affects: <a href="gButton.htm">gButton</a>, <a href="IupMenuItem.htm">IupMenuItem</a>, <a href="IupList.htm">IupList</a>, 
                     <a href="gText.htm">gText</a>, <a href="gCanvas.htm">gCanvas</a>, <a href="IupToggle.htm">IupToggle</a>
            <br>
         </td>
        </tr>
-->
        <tr>
         <td>
          <a name=BUTTON_CB></a>
          BUTTON_CB
         </td>
         <td>
            Event generated when any mouse button is pressed or released.
            <br>
            <br>
            function button_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> button, pressed, x, y, <a href="atom.htm">atom</a> pStatus)<br>
            ih: identifies the element that activated the event.<br>
            button: identifies the activated mouse button:<br>
            <br>
            IUP_BUTTON1 - left mouse button (button 1);<br>
            IUP_BUTTON2 - middle mouse button (button 2);<br>
            IUP_BUTTON3 - right mouse button (button 3).<br>
            <br>
            pressed: indicates the state of the button:<br>
            <br>
            0 - mouse button was released;<br>
            1 - mouse button was pressed.<br>
            <br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of the mouse buttons and some keyboard keys at the moment the event is generated (a char*). <br>
            <br>
            Use the following routines on pStatus:
            <br>
            iup_isshift(pStatus)<br>
            iup_iscontrol(pStatus)<br>
            iup_isbutton1(pStatus)<br>
            iup_isbutton2(pStatus)<br>
            iup_isbutton3(pStatus)<br>
            iup_isbutton4(pStatus)<br>
            iup_isbutton5(pStatus)<br>
            iup_isdouble(pStatus)<br>
            iup_isalt(pStatus)<br>
            iup_issys(pStatus)<br>
            <br>
            They return 1 if the respective key or button is pressed, and 0 otherwise.
            <br>
            <br>
            Returns: <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed. <br>
            On some controls if <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the event is ignored (this is system dependent).
            <br>
            <br>
            Notes<br>
            This handler can be used to customize a button behavior. 
            For standard button behavior use the <a href="gButton.htm#CLICK">CLICK</a> handler of the <a href="gButton.htm">gButton</a>.
            <br>
            <br>
            For a single click the handler is called twice, one for pressed=1 and one for pressed=0. <br>
            The CLICK handler is only invoked after both calls.<br>
            In Windows, if a dialog is shown or popup in any situation there could be unpredictable results because the native system still has processing to be done even after the callback is called.
            <br>
            <br>
            A double click is preceded by two single clicks, one for pressed=1 and one for pressed=0, and followed by a pressed=0, all three without the double click flag set. <br>
            In GTK, it is preceded by an additional two single clicks sequence. For example, for one double click all the following calls are made:<br><br>
 <pre>
BUTTON_CB(but=1 (1), x=154, y=83 [  1       ])
BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])
    BUTTON_CB(but=1 (1), x=154, y=83 [  1       ])     (in GTK only)
    BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])     (in GTK only)
BUTTON_CB(but=1 (1), x=154, y=83 [  1  D    ])
BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])
 </pre>
            <br>
            Affects: <a href="gCanvas.htm">gCanvas</a>, <a href="gButton.htm">gButton</a>, <a href="gText.htm">gText</a>, 
                     <a href="IupList.htm">IupList</a>
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=CLOSE_CB></a>
          CLOSE_CB
         </td>
         <td>
            Called just before a dialog is closed when the user clicks the close button of the title bar or an equivalent action.<br>
            <b>NB</b>: other callbacks returning <a href="#XPG_CLOSE">XPG_CLOSE</a>, or any code invoking 
            <a href="IupExitLoop.htm">IupExitLoop</a>(), does <i>not</i> invoke any CLOSE_CB callback, instead any required final
            processing, such as saving files or invoking <a href="IupConfigDialogClosed.htm">IupConfigDialogClosed</a>(),
            must be performed manually/explicitly, that is, just before returning XPG_CLOSE or when invoking IupExitLoop.<br>
            Penning (say) my_shutdown() and invoking it from several places, including close_cb, is probably a wise move.<br>
            Note that you are not allowed to (re-)use the name <a href="close.htm">close</a>() as a handler since that is already
            reserved for the builtin.
            <br>
            <br>
            function close_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifies the element that activated the event.
            <br>
            <br>
            Returns: an <a href="#XPG_IGNORE">XPG_IGNORE</a> prevents the dialog from being closed. <br>
            Should you destroy the dialog in this handler, you must return <a href="#XPG_IGNORE">XPG_IGNORE</a>. <br>
            <a href="#XPG_CLOSE">XPG_CLOSE</a>, <a href="#XPG_CONTINUE">XPG_CONTINUE</a>, and <a href="#XPG_DEFAULT">XPG_DEFAULT</a>
            will in the specific case of this handler all be treated identically.
            <br>
            <br>
            Affects: <a href="gDialog.htm">gDialog</a>
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=DESTROY_CB></a>
          DESTROY_CB
         </td>
         <td>
            Called right before an element is destroyed.
            <br>
            <br>
            function destroy_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            If the dialog is visible then it is hidden before it is destroyed. The callback will be called right after it is hidden.
            <br>
            <br>
            The callback will be called before all other destroy procedures - for instance, if the element has children then it is called before the children are destroyed. 
            <br>
            <br>
            For language binding implementations use the callback name "LDESTROY_CB" to release memory allocated by the binding for the element. 
            Also the callback will be called before the language callback.
            <br>
            <br>
            Affects: All
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=ENTERWINDOW_CB></a>
          ENTERWINDOW_CB
         </td>
         <td>
            Event generated when the mouse enters the native element. 
            <br>
            <br>
            function enterwindow_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Notes<br>
            When the cursor is moved from one element to another, the call order in all platforms will be first the 
            <a href="callbacks.htm#LEAVEWINDOW_CB">LEAVEWINDOW_CB</a> callback of the old control followed by the 
            ENTERWINDOW_CB callback of the new control.
            <br>
            <br>
            Affects: All controls with user interaction.
            <br>
            <br>
            See Also: <a href="callbacks.htm#LEAVEWINDOW_CB">LEAVEWINDOW_CB</a>
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=GETFOCUS_CB></a>
          GETFOCUS_CB
         </td>
         <td>
            Event generated when an element is given keyboard focus. <br>
            This callback is called after the <a href="callbacks.htm#KILLFOCUS_CB">KILLFOCUS_CB</a> of the element that lost the focus. <br>
            The <a href="IupGetFocus.htm">IupGetFocus</a> function during the callback returns the element that lost the focus.
            <br>
            function getfocus_cb(<a href="Ihandle.htm">Ihandle</a> ih)
            <br>
            <br>
            ih: identifier of the element that received keyboard focus.
            <br>
            <br>
            Affects: All elements with user interaction, except menus.
            <br>
            <br>
            See Also: <a href="callbacks.htm#KILLFOCUS_CB">KILLFOCUS_CB</a>, <a href="IupGetFocus.htm">IupGetFocus</a>, <a href="IupSetFocus.htm">IupSetFocus</a> 
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=HELP_CB></a>
          HELP_CB
         </td>
         <td>
            Event generated when the user presses F1 at a control. <br>
            In Motif is also activated by the Help button in some workstations keyboard.
            <br>
            <br>
            function help_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Returns: <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed.
            <br>
            <br>
            Affects: All elements with user interaction.
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=IDLE_ACTION></a>
          IDLE_ACTION
         </td>
         <td>
            Predefined, generated when there are no events or messages to be processed. Often used to perform background operations.
            <br>
            <br>
            function idle_action()<br>
            Returns: if <a href="#XPG_CLOSE">XPG_CLOSE</a> is returned the current loop will be closed and the callback will be removed. <br>
            If <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the handler is removed and normal processing continues.
            <br>
            <br>
            Notes<br>
            The Idle callback will be called whenever there are no messages left to be processed. <br>
            This may occur more frequently than expected, for example if you move the mouse over the application the idle callback will be called
            many times because the mouse move message is processed so fast that the Idle will be called before another mouse move message occurs.<br>
            <small>[No mouse(/user) is likely to generate 100 messages/s, which on a GHz box means ten million clocks between each in which to
            perform some idle processing.]</small>
            <br>
            <br>
            So this callback changes the message loop to a more CPU consuming one. <br>
            It is important it be set NULL when not used, otherwise the application consumes CPU even if the callback is doing nothing.
            <br>
            <br>
            It can only be set using <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("IDLE_ACTION", idle_action).
            <br>
            <br>
            Long Time Operations<br>
            If you create a loop or an operation that takes a long time to complete inside a callback of your application then 
            the user interface message loop processing is interrupted until the callback returns, so the user can not click on 
            any control of the application. But there are ways to handle that:
            <ul>
            <li>call <a href="IupLoopStep.htm">IupLoopStep</a> or <a href="IupFlush.htm">IupFlush</a> inside the application callback when it is performing long time operations. <br>
            This will allow the user to click on a cancel button for instance, because the user interface message loop will be processed.</li>

            <li>split the operation in several parts that are processed by the Idle function when no messages are left to be processed for the user interface message loop. <br>
            This will make a heavy use of the CPU, even if the callback is doing nothing. </li>

            <li>split the operation in several parts but use a Timer to process each part. </li>
            </ul>
            If you just want to do something simple as a background redraw of an <a href="IupCanvas.htm">IupCanvas</a>, 
            then a better idea is to handle the "idle" state yourself. <br>
            For example, register a timer for a small time like 500ms, and reset the timer in all the mouse and keyboard callbacks of the <a href="IupCanvas.htm">IupCanvas</a>. <br>
            If the timer is trigged then you are in idle state. If the <a href="IupCanvas.htm">IupCanvas</a> loses its focus then stop the timer.
            <br>
            <br>
            <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a> Uses window.requestIdleCallback() which is marked on 
            <a href="javascript:ExternalLink('ext373','https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback');"
            id="ext373" style="color:#9B5565" >MDN</a> as experimental, but that has not changed since 2015. Note that according to 
            <a href="javascript:ExternalLink('ext382','https://caniuse.com/requestidlecallback');"
            id="ext382" style="color:#9B5565" >caniuse.com</a> for this to work in Safari you (and/or you users) must enable requestIdleCallback 
            in Experimental (Webkit) Features, and the same may be true for Chrome on macOS (not that desktop/Phix works on macOS, yet).<br>
            Also note I am not quite sure what "current loop will be closed" above means for XPG_CLOSE returns, so XPG_CLOSE and XPG_IGNORE do
            the same thing, which is in fact <i>don&rsquo;t</i> re-apply requestIdleCallback.<br>
            If at all possible you should strive to return within 50ms/break up idle processing into chucks of work shorter than that, to
            avoid (otherwise fairly harmless) JavaScript violation messages being logged to the (hidden) console. A future version may
            incorporate a means to get <code>(deadline.timeRemaining() > 0 || deadline.didTimeout)</code> in pwa/p2js, with a matching
            mechanism to get <code>true</code> on desktop/Phix, should that ever be desired/requested.
            <br>
            <br>
            See Also: <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>, <a href="IupTimer.htm">IupTimer</a>.
            <br>
         </td>
        </tr>
<!--
        <tr>
         <td>
          <a name=GLOBALCTRLFUNC_CB></a>
          GLOBALCTRLFUNC_CB
         </td>
         <td>
            Global callback for a restricted set of keys. (since 3.20)<br>
            Called only when the Ctrl+F? key combinations are pressed. <br>
            It was designed to be used for internal application debugging porpoises only. <br>
            Do not use it for release code.
            <br>
            <br>
            function ctrl_func(integer c)<br>
            c: identifier of typed key. Please refer to <a href="#KEY">KEY</a> below for a list of possible values.
            <br>
            <br>
            It can only be set using (eg) <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("GLOBALCTRLFUNC_CB", <a href="Icallback.htm">Icallback</a>("ctrl_func")).
            <br>
            <br>
            See Also: <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>.
            <br>
         </td>
        </tr>
-->
        <tr>
         <td>
          <a name=ENTRY_POINT></a>
          ENTRY_POINT
         </td>
         <td>
            (since 3.28)
            Global callback for an entry point. Used when main is not possible, such as in iOS and Android systems (which
            Phix does not currently support).
            <br>
            <br>
            It is called only once, when the main loop is processed, but after <a href="IupOpen.htm">IupOpen</a>(). <br>
            For regular systems is called right before the actual event loop is started.<br>
            It can only be set using (eg) <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("ENTRY_POINT", 
            <a href="Icallback.htm">Icallback</a>("entry_func")).
            <br>
            <br>
            See also EXIT_CB (next), <a href="IupMainLoopLevel.htm">IupMainLoopLevel</a>
            <br>
         </td>
        </tr>

        <tr>
         <td>
          <a name=EXIT_CB></a>
          EXIT_CB
         </td>
         <td>
            (since 3.28)
            Global callback for an exit. Used when main is not possible, such as in iOS and Android systems (which Phix does not
            currently support).
            <br>
            <br>
            It is called every time the last main loop is ended. <br>
            For regular systems is called right after the actual event loop is ended, every time when the main loop level returns to 0.
            <br>
            <br>
            It can only be set using (eg) <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("EXIT_CB", 
            <a href="Icallback.htm">Icallback</a>("exit_func")).
            <br>
         </td>
        </tr>

        <tr>
         <td>
          <a name=KEY></a>
          "KEY" 
         </td>
         <td>
            Event generated when a keyboard event occurs.
            <br>
            <br>
            function key(<a href="gdx.htm">gdx</a> h, <a href="integer.htm">integer</a> c,
                                                      [<a href="integer.htm#bool">bool</a> ctrl[, shift[, alt [, sys]]]])
            <br>
            <br>
            h: the element that activated the event.<br>
            c: the typed key. Some possible (special) values are listed below.<br>
            ctrl, shift, alt, sys: any key modifiers that were also pressed. When absent, the backend avoids relaying characters
            and other keystrokes that it knows the handler cannot cope with or might mis-interpret.
            <br>
            <br>
            Aside: instead of (re-)using say K_DEL from pGUI, the equivalent constant is VK_DEL (as per arwen), partly because
            I did not want to break pGUI help lookup too soon (which is neither a concern nor a reality with what little arwen
            docs there are in this file), but more importantly I certainly did not want to end up with K_C/K_D/K_E linking to 
            pGUI but K_DEL linking to (this) xpGUI help section, and probably being left in that mess pretty much forever.
            <br>
            <br>
<!--
            In previous versions of pGUI.e defining c as type integer would work, until an alt or sys key was entered, at which
            point they would fail with a run-time typecheck. Newer versions of pGUI.e now check for such a "time-bomb" signature
            and raise an error much earlier in the process, which significantly helps to avoid shipping code with that problem.
-->
            [DEV/maybe...]
            Aside: <a href="setHandler.htm">setHandler</a>() actually stores the handler under "KEY", "KEYC", "KEYCS", "KEYCSA",
            or "KEYCSAS" depending on how many parameters were specified and therefore both how many it needs to relay on, and 
            what keystrokes it should not forward at all, and it is the sole responsibility of pwa/p2js.exw for the benefit of 
            pwa/xpGUI.js to replace "KEY" in a similar fashion. The precise behaviour should it somehow set more than one of 
            those handlers is formally undefined and not supported. Fairly obviously, I should hope, you need to specify say
            "bool ctrl, shift" rather than "bool shift" as the latter would simply get the ctrl key in the shift parameter,
            and of course that remains unavoidably true even if you have no other use for the ctrl parameter.
<br>
<br>
<i>OR [DEV] </i>
<br>
<br>
            integer c, csas: if csas is zero it is a plain keystroke otherwise some other key[s] were held down, use say<br>
<!--eucode>
            bool ctrl = and_bits(csac,VK_CTRL)!=0,
                shift = and_bits(csac,VK_SHIFT)!=0,
                  alt = and_bits(csac,VK_ALT)!=0,
                  sys = and_bits(csac,VK_SYS)!=0
</eucode-->
<pre>
<font color="#004080">            bool</font><font color="#000000"> ctrl</font><font color="#0000FF"> =</font><font color="#7060A8"> and_bits</font><font color="#0000FF">(</font><font color="#000000">csac</font><font color="#0000FF">,</font><font color="#000000">VK_CTRL</font><font color="#0000FF">)!=</font><font color="#000000">0</font><font color="#0000FF">,</font>
<font color="#000000">                shift</font><font color="#0000FF"> =</font><font color="#7060A8"> and_bits</font><font color="#0000FF">(</font><font color="#000000">csac</font><font color="#0000FF">,</font><font color="#000000">VK_SHIFT</font><font color="#0000FF">)!=</font><font color="#000000">0</font><font color="#0000FF">,</font>
<font color="#000000">                  alt</font><font color="#0000FF"> =</font><font color="#7060A8"> and_bits</font><font color="#0000FF">(</font><font color="#000000">csac</font><font color="#0000FF">,</font><font color="#000000">VK_ALT</font><font color="#0000FF">)!=</font><font color="#000000">0</font><font color="#0000FF">,</font>
<font color="#000000">                  sys</font><font color="#0000FF"> =</font><font color="#7060A8"> and_bits</font><font color="#0000FF">(</font><font color="#000000">csac</font><font color="#0000FF">,</font><font color="#000000">VK_SYS</font><font color="#0000FF">)!=</font><font color="#000000">0</font>
</pre>
            Note that while caps lock is honoured, there is no forwarding of it&rsquo;s state with every keypress, and there 
            will also doubtless be cases (sic) where you have to use upper/lower or check for 'x' and 'X' to avoid confusing 
            yourself or your users or both.
            <br>
            <br>
            While pGUI/IUP defines hundreds of key constants, xpGUI limits itself to a much more reasonable subset.<br>
            You should, typically as and when the compiler complains, replace eg [V]K_a with 'a', and [V]K_cC with "ctrl and c='C'"
            or "ctrl and upper(c)='C'", etc.
            <br>
            <br>
            xpIUP defines several key constants, in particular for any that cannot be written as a normal character constant (like say 'a' can):<br>
            VK_ESC, VK_CR (or '\r'), VK_LF (or '\n'), VK_BS (or '\b'), VK_TAB (or '\t'), VK_SP (' '), VK_INS, VK_DEL, 
            VK_HOME, VK_UP, VK_PGUP, VK_LEFT, VK_MIDDLE, VK_RIGHT, VK_END, VK_DOWN, VK_PGDN, VK_PAUSE, VK_Print, VK_Menu, 
            VK_F1, VK_F2, VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10, VK_F11, VK_F12,
            VK_LSHIFT, VK_RSHIFT, VK_LCTRL, VK_RCTRL, VK_LALT, VK_RALT, VK_SCROLL, VK_NUM, and VK_CAPS.
            <br>
            <br>
<!--
            Other standard key identifiers include (aside: full lists rather than say "VK_A, VK_B, .. VK_Z" permit search/index):<br>
            VK_exclam ('!'), VK_quotedbl ('\"'), VK_numbersign ('#'), VK_dollar ('$'), VK_percent ('%'),
            VK_ampersand ('&'), VK_apostrophe '\'', VK_parentleft ('('), VK_parentright (')'), VK_asterisk ('*'), VK_plus ('+'),
            VK_comma (','), VK_minus ('-'), VK_period ('.'), VK_slash ('/'), VK_0, VK_1, VK_2, VK_3, VK_4, VK_5, VK_6, VK_7, VK_8, VK_9 ('0'..'9'), 
            VK_colon (':'), VK_semicolon (';'), VK_less ('&lt;'), VK_equal ('='), VK_greater ('&gt;'), VK_question ('?'), VK_at ('@'), VK_A, VK_B,
            VK_C, VK_D, VK_E, VK_F, VK_G, VK_H, VK_I, VK_J, VK_K, VK_L, VK_M, VK_N, VK_O, VK_P, VK_Q, VK_R, VK_S, VK_T, VK_U, VK_V, VK_W, VK_X, VK_Y, VK_Z 
            ('A'..'Z'), VK_a, VK_b, VK_c, VK_d, VK_e, VK_f, VK_g, VK_h, VK_i, VK_j, VK_k, VK_l, VK_m, VK_n, VK_o, VK_p, VK_q, VK_r, VK_s, VK_t, VK_u, VK_v, VK_w, 
            VK_x, VK_y, VK_z ('a'..'z'), VK_bracketleft ('['), VK_backslash ('\\'), VK_bracketright (']'), VK_circum ('^'), VK_underscore ('_'), 
            VK_grave ('`'), VK_braceleft ('{'), VK_bar ('|'), VK_braceright ('}'), and VK_tilde ('~'). 
            My preference and recommendation is to use the literal values instead of the constant names for 'plain' keystrokes, since 
            for example I <i>cannot</i> get '!' wrong, however I could very easily mis-spell VK_exclam as VK_exclaim, or VK_parentleft as 
            VK_parenthleft or VK_leftparenth, VK_period as VK_dot, VK_greater as VK_gt, ... sure the syntax colouring/compiler would catch it, 
            but there is little benefit in you or me sitting there going "OK, how <i>do</i> you spell it then?". 
-->
Erm... [DEV]<br>
            In contrast, the modified keystrokes as listed below are usually much easier, for instance using <code>VK_cA</code> beats 
            <code>iup_XkeyCtrl('A')</code> hands down.
            <br>
            <br>
<!--
            The following are deprecated/untested:<br>
            <span class="illegal">VK_acute</span> ('´', #B4), <span class="illegal">VK_ccedilla</span> ('ç', #E7), and 
            <span class="illegal">VK_diaeresis</span> ('¨', #A8). While those are valid for UTF-32, Windows-1252, and
            ISO 8859-1, the same cannot be said for UTF-8, and quite possibly several legacy 8-bit code pages, hence the exclusion.
            pGUI/IUP would probably understand them, but your app probably won&rsquo;t. Obviously not having those constants only
            affects what is valid source code and in no way prevents a user keying such characters into your finished application.
            <br>
            <br>
-->
            Special note: When using Edix, and therefore similar pGUI applications, you may notice that it will not let you type a pound 
            sign (&pound;) into an ansi file [not even using the old Alt-0163 trick]. Quite a shock, I know, but when you think about it, 
            also quite correct. It will of course let you type that sort of thing into a UTF-8 file. The critical thing is that a call to
            <a href="IupSetGlobal.htm">IupSetGlobal</a>("<a href="iupgattr.htm#UTF8MODE">UTF8MODE</a><a href="notpgui.htm"><span style="color:lime;"><sup>+</sup></span></a>","YES") 
            exists somewhere.
            <br>
            <br>
            For some keys, change the prefix to VK_c*, VK_m*, VK_s*, and VK_y* to add the respective modifier (Control, Alt, Shift, and Sys).<br>
            Sys in Windows is the Windows key and in Mac is the Apple key.<br>
            Modifier prefixes are always applied in the above order, for instance &lt;Ctrl Shift C&gt; is VK_csC, not VK_scC.
            <br>
            <br>
<!--
            Note that some keys have not yet made it into pGUI. Only keys that make sense and I get round to testing will (ever) be added: 
            for instance VK_sexclam (heh) makes no sense because you cannot (on my keyboard anyhow) get a '!' without the shift key being 
            down, and the same for VK_sPrint, VK_sSCROLL, and VK_sPAUSE. (Apart from a general reluctance to add rafts of untested things, I
            am also trying to keep the documentation in step with the implementation.) <br>
            The following keys (ditto re full lists) do however exist:
            <br>
            <br>
            Ctrl:<br>
            VK_cSP,
            VK_cPlus,
            VK_cMinus,
            VK_cEqual,
            VK_cA,
            VK_cB,
            VK_cC,
            VK_cD,
            VK_cE,
            VK_cF,
            VK_cG,
            VK_cH,
            VK_cI,
            VK_cJ,
            VK_cK,
            VK_cL,
            VK_cM,
            VK_cN,
            VK_cO,
            VK_cP,
            VK_cQ,
            VK_cR,
            VK_cS,
            VK_cT,
            VK_cU,
            VK_cV,
            VK_cW,
            VK_cX,
            VK_cY,
            VK_cZ,
            VK_cPGUP,
            VK_cPGDN,
            VK_cHOME,
            VK_cEND,
            VK_cF1,
            VK_cF2,
            VK_cF3,
            VK_cF4,
            VK_cF5,
            VK_cF6,
            VK_cF7,
            VK_cF8,
            VK_cF9,
            VK_cF10,
            VK_cF11,
            VK_cF12
            <br>
            <br>
            Alt:<br>
            VK_mA,
            VK_mB,
            VK_mC,
            VK_mD,
            VK_mE,
            VK_mF,
            VK_mG,
            VK_mH,
            VK_mI,
            VK_mJ,
            VK_mK,
            VK_mL,
            VK_mM,
            VK_mN,
            VK_mO,
            VK_mP,
            VK_mQ,
            VK_mR,
            VK_mS,
            VK_mT,
            VK_mU,
            VK_mV,
            VK_mW,
            VK_mX,
            VK_mY,
            VK_mZ
            <br>
            <br>
            Shift:<br>
            VK_sSP
            <br>
            <br>
            Ctrl Shift:<br>
            VK_csSP,
            VK_csA,
            VK_csB,
            VK_csC,
            VK_csD,
            VK_csE,
            VK_csF,
            VK_csG,
            VK_csH,
            VK_csI,
            VK_csJ,
            VK_csK,
            VK_csL,
            VK_csM,
            VK_csN,
            VK_csO,
            VK_csP,
            VK_csQ,
            VK_csR,
            VK_csS,
            VK_csT,
            VK_csU,
            VK_csV,
            VK_csW,
            VK_csX,
            VK_csY,
            VK_csZ,
            <br>
            <br>
            Alt Shift:<br>
            VK_msA,
            VK_msB,
            VK_msC,
            VK_msD,
            VK_msE,
            VK_msF,
            VK_msG,
            VK_msH,
            VK_msI,
            VK_msJ,
            VK_msK,
            VK_msL,
            VK_msM,
            VK_msN,
            VK_msO,
            VK_msP,
            VK_msQ,
            VK_msR,
            VK_msS,
            VK_msT,
            VK_msU,
            VK_msV,
            VK_msW,
            VK_msX,
            VK_msY,
            VK_msZ
            <br>
            <br>
            Further keys will be added as needed and when time allows for adequate testing. In the short term, it should not prove difficult
            to add any missing ones that you need to pGUI.e, where you will find several potential but untested candidates commented out,
            maybe including the one you are after.
            <br>
            <br>
            To obtain a key code for a generic combination you can also start with a base key and combine it repeated times using 
            iup_XkeyCtrl(key), iup_XkeyAlt(key), iup_XkeyShift(key), and iup_XkeySys(key).
            For instance <code>constant control_shift_c = iup_XkeyCtrl(iup_XkeyShift('C'))</code>. Note that, depending on the 
            driver/firmware for your particular keyboard, iup_XkeyShift('c') might have use when caps lock is on, (now there&rsquo;s 
            a way to confuse your users) but you are unlikely to get very far with iup_XkeyCtrl(iup_XkeyShift('c')). In general,
            pGUI/IUP cannot guarantee the behaviour of various combinations of Caps Lock, Shift, and other key modifiers with
            regard to the case<wbr>/<wbr>capitalisation of alphabetic base keys, since that is 
            system<wbr>/<wbr>driver<wbr>/<wbr>hardware dependent, instead the prudent programmer will ensure that eg 'c' and 'C' 
            are both tested for.<br>
             <a name=iup_XkeyBase></a>
            The function <a href="integer.htm">integer</a> ch = <b>iup_XkeyBase</b>(<a href="atom.htm">atom</a> c) can be used 
            to obtain the raw keystroke less any modifiers, and you can use the global attributes
            <a href="iupgattr.htm#SHIFTKEY">SHIFTKEY</a> and <a href="iupgattr.htm#CONTROLKEY">CONTROLKEY</a> instead of disecting the c
            parameter.<br>
<!-- DEV: (full search rqd, index all of these) -->
<!--        The functions iupCtrl, iupAlt, iupShift, iupSys, and iupBase are simple aliases of the above functions.<br> -->
            Also, the global attribute <a href="iupgattr.htm#MODKEYSTATE">MODKEYSTATE</a> can be used to detect the combination of two or more modifiers.
            <br>
            <br>
            Literal string versions of these names may be used to assign callbacks, eg "VK_cC", for &lt;Ctrl C&gt;, <i>with</i> the quotes, see below.
-->
            <br>
            <br>
            The above keys are also used in <a href="callbacks.htm#KEYPRESS_CB">KEYPRESS_CB</a> callbacks.
<!--
             <a name=iup_isxxx></a>
            <br>
            <br>
            The iup_isprint(key) function returns true if a key can be directly used as a printable character.<br>
<!--            The iup_isXkey(key) macro informs if a given key is an extended code.<br> -->
            The iup_isShiftXkey(key) function returns true if a given key is an extended code using the Shift modifier.<br>
            The iup_isCtrlXkey(key) function returns true for the Ctrl modifier.<br>
            The iup_isAltXkey(key) function returns true for the Alt modifier.<br>
            The iup_isSysXkey(key) function returns true for the Sys modifier.<br>
            <a href="string.htm">string</a> name = iupKeyCodeToName(key) returns a human-readable version of the key.
-->
            <br>
            <br>
            Note: GTK in Windows does not generate the Win modifier key, the VK_Print and the VK_Pause keys (up to GTK version 2.8.18).
            <br>
            <br>
            Returns: <br>
            If <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the key is ignored and not processed by the control and not propagated. <br>
            If <a href="#XPG_CONTINUE">XPG_CONTINUE</a> is returned the key is processed and the event propagated to the parent of the element receiving it. (default behavior)<br>
            If <a href="#XPG_DEFAULT">XPG_DEFAULT</a> is returned the key is processed but it is not propagated. <br>
            <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed. 
            <br>
            <br>
            Notes<br>
            Keyboard callbacks depend on the keyboard usage of the control with the focus. <br>
            So if you return <a href="#XPG_IGNORE">XPG_IGNORE</a> the control will usually not process the key. <br>
            But be aware that sometimes the control processes the key in another event so even when returning <a href="#XPG_IGNORE">XPG_IGNORE</a> 
            the key can still get processed, although it will not be propagated.
<!--??
            <br>
            <br>
            IMPORTANT: The callbacks "VK_*" of the dialog or native containers depend on the <a href="#XPG_CONTINUE">XPG_CONTINUE</a> 
            return value to work while the control is in focus.
-->
            <br>
            <br>
            If the callback does not exist it is automatically propagated to the parent of the element.
<!--
            <br>
            <br>
            VK_* callbacks<br>
            All defined keys are also callbacks of any element, called when the respective key is activated. <br>
            For example: "VK_cC" is also a callback activated when the user press Ctrl+C, when the focus is at the element or at a children with focus. <br>
            This is the way an application can create shortcut keys, also called hot keys.
-->
            <br>
            <br>
            Affects: All elements with keyboard interaction.
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=KEYPRESS_CB></a>
          KEYPRESS_CB
         </td>
         <td>
            Event generated when a key is pressed or released. <br>
            If the key is pressed and held several calls will occur. <br>
            It is called after the callback <a href="setHandler.htm#KEY">KEY</a> is processed.
            <br>
            <br>
            function keypress_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> c, <a href="integer.htm#bool">bool</a> press)
            <br>
            <br>
            ih: identifier of the element that activated the event.<br>
            c: identifier of typed key. See <a href="setHandler.htm#KEY">KEY</a> above for possible values.<br>
            press: 1(true) when the key is pressed, 0(false) when the key is released.
            <br>
            <br>
            Returns: If <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the key is ignored by the system. <br>
            <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=KILLFOCUS_CB></a>
          KILLFOCUS_CB
         </td>
         <td>
            Event generated when an element loses keyboard focus. <br>
            This callback is called before the <a href="callbacks.htm#GETFOCUS_CB">GETFOCUS_CB</a> of the element that gets the focus.
            <br>
            <br>
            function killfocus_cb(<a href="Ihandle.htm">Ihandle</a> ih)
            <br>
            <br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Affects: All elements with user interaction, except menus.
            <br>
            <br>
            In Windows, there are restrictions when using this callback. <br>
            From MSDN on WM_KILLFOCUS: <br>
            While processing this message, do not make any function calls that display or activate a window. <br>
            &nbsp;This causes the thread to yield control and can cause the application to stop responding to messages. 
            <br>
            <br>
            See Also: <a href="callbacks.htm#GETFOCUS_CB">GETFOCUS_CB</a>, <a href="IupGetFocus.htm">IupGetFocus</a>, <a href="IupSetFocus.htm">IupSetFocus</a> 
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=LEAVEWINDOW_CB></a>
          LEAVEWINDOW_CB
         </td>
         <td>
            Event generated when the mouse leaves the native element.
            <br>
            <br>
            function leavewindow_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Notes<br>
            When the cursor is moved from one element to another, the call order in all platforms will be first the LEAVEWINDOW_CB callback 
            of the old control followed by the <a href="callbacks.htm#ENTERWINDOW_CB">ENTERWINDOW_CB</a> callback of the new control.
            <br>
            <br>
            Affects: All controls with user interaction.
            <br>
            <br>
            See Also: <a href="callbacks.htm#ENTERWINDOW_CB">ENTERWINDOW_CB</a>
            <br>
         </td>
        </tr>
<!--
//      <tr>
//       <td>
//        <a name=MAP_CB></a>
//        MAP_CB
//       </td>
//       <td>
//          Called right after an element is mapped and its attributes updated in <a href="IupMap.htm">IupMap</a>().
//          <br>
//          <br>
//          When the element is a dialog, it is called after the layout is updated. 
//          For all other elements it is called before the layout is updated, so the element current size will still be 0x0 during MAP_CB (since 3.14).
//          <br>
//          <br>
//          function map_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
//          ih: identifier of the element that activated the event.
//          <br>
//          <br>
//          Affects: All elements that have a native representation.
//          <br>
//       </td>
//      </tr>
-->
        <tr>
         <td>
          <a name=MOTION_CB></a>
          MOTION_CB
         </td>
         <td>
            Event generated when the mouse moves.
            <br>
            <br>
            function motion_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> x, y, <a href="atom.htm">atom</a> pStatus)<br>
            ih: identifier of the element that activated the event.<br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of mouse buttons and certain keyboard keys at the moment the event was generated (a char*).
            <br>
            <br>
            Use the same routines for pStatus as <a href="callbacks.htm#BUTTON_CB">BUTTON_CB</a>.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>,
                     <a href="IupList.htm">IupList</a>, <a href="IupMatrix.htm">IupMatrix</a>, 
                     <a href="IupText.htm">IupText</a>, <a href="IupTree.htm">IupTree</a>
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=RESIZE_CB></a>
          RESIZE_CB
         </td>
         <td>
            Event generated when the canvas or dialog size is changed.
            <br>
            <br>
            function resize_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> width, height)
            <br>
            <br>
            ih: identifier of the element that activated the event.<br>
            width: the width of the internal element size in pixels not considering the decorations (client size)<br>
            height: the height of the internal element size in pixels not considering the decorations (client size)
            <br>
            <br>
            For a dialog, this event is also generated when the dialog is mapped, after the map and before the show.
            <br>
            <br>
            When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the canvas scrollbar is hidden/shown after changing the DX or DY attributes from inside the callback, 
            the size of the drawing area will immediately change, so the parameters with and height will be invalid. <br>
            To update the parameters consult the DRAWSIZE attribute. Also activate the drawing toolkit only after updating the DX or DY attributes.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>, <a href="IupDialog.htm">IupDialog</a>
            <br>
         </td>
        </tr>
        <tr>
         <td>
          <a name=SCROLL_CB></a>
          SCROLL_CB
         </td>
         <td>
            Called when some manipulation is made to the scrollbar. <br>
            The canvas is automatically redrawn only if this callback is NOT defined.
            <br>
            <br>
            (GTK 2.8) Also the POSX and POSY values will not be correctly updated for older GTK versions.
            <br>
            <br>
            In Ubuntu, when liboverlay-scrollbar is enabled (the new tiny auto-hide scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
            <br>
            <br>
            Callback<br>
            function scroll_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> op)<br>
            ih: identifier of the element that activated the event.<br>
            op: indicates the operation performed on the scrollbar:
            <br>
            <br>
            If the manipulation was made on the vertical scrollbar, it can have the following values:
            <br>
            <br>
            IUP_SBUP - line up<br>
            IUP_SBDN - line down<br>
            IUP_SBPGUP - page up<br>
            IUP_SBPGDN - page down<br>
            IUP_SBPOSV - vertical positioning<br>
            IUP_SBDRAGV - vertical drag 
            <br>
            <br>
            If it was on the horizontal scrollbar, the following values are valid:
            <br>
            <br>
            IUP_SBLEFT - column left<br>
            IUP_SBRIGHT - column right<br>
            IUP_SBPGLEFT - page left<br>
            IUP_SBPGRIGHT - page right<br>
            IUP_SBPOSH - horizontal positioning<br>
            IUP_SBDRAGH - horizontal drag
            <br>
            <br>
            Notes<br>
            IUP_SBDRAGH and IUP_SBDRAGV are not supported in GTK.<br>
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>, <a href="common.htm#SCROLLBAR">SCROLLBAR</a>
            <br>
         </td>
        </tr>
<!--
//      <tr>
//       <td>
//        <a name=UNMAP_CB></a>
//        UNMAP_CB
//       </td>
//       <td>
//          Called right before an element is unmapped.
//          <br>
//          <br>
//          function unmap_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
//          ih: identifier of the element that activated the event.
//          <br>
//          <br>
//          Affects: All elements that have a native representation.
//       </td>
//      </tr>
-->
        <tr>
         <td>
          <a name=WHEEL_CB></a>
          WHEEL_CB
         </td>
         <td>
            Event generated when the mouse wheel is rotated.<br>
            If this callback is not defined the wheel will automatically scroll the canvas in the vertical direction by some lines, 
            the SCROLL_CB callback if defined will be called with the IUP_SBDRAGV operation.
            <br>
            <br>
            function wheel_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="atom.htm">atom</a> delta, <a href="integer.htm">integer</a> x, y, <a href="atom.htm">atom</a> pStatus)<br>
            ih: identifier of the element that activated the event.<br>
            delta: the amount the wheel was rotated in notches (nb dodgy, see <a href="call_back.htm">call_back</a>).<br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of mouse buttons and certain keyboard keys at the moment the event was generated (a char*).
            <br>
            <br>
            Use the same routines for pStatus as <a href="callbacks.htm#BUTTON_CB">BUTTON_CB</a>.
            <br>
            <br>
            Notes: In Motif and GTK delta is always 1 or -1. In Windows is some situations delta can reach the value of two. 
            In the future with more precise wheels this increment can be changed.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>
         </td>
        </tr>
        <tr id="Technicalia" style="display:none;">
         <td>
          <a href="glossary.htm#technicalia">
           <b>Technicalia</b>
          </a>
         </td>
         <td>
            Since xpGUI uses normal first class routines as handlers instead of callbacks, IupSetCallback() has been renamed/needs to be replaced with 
            gSetHandler(), and importantly any quotes around the routine name must be removed.<br>
            There are no equivalents in xpGUI for <a href="Icallback.htm">Icallback(), cbfunc(), iup_name_from_cb(), or iup_cb_from_name()</a>, nor
            <a href="IupGetCallback.htm">IupGetCallback</a>().<br>
         </td>
        </tr>
       </table>
       <img src="images/sprites/tech.open.png" title="Expand/Shrink" alt="Expand/Shrink" style="display:block;clear:both;" onload="setStartT(this);" onclick="changeImageT(this);" />
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
