<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">gSetHandler</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
            include xpGUI.e
            <br>
            <br>
            gSetHandler(<a href="gdx.htm">gdx</a> id, <a href="sequence.htm">sequence</a> name, <a href="rtn.htm">rtn</a> handler=NULL)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Associates one or more handlers for an event on one or more controls.
            <br>
            <br>
            id: identifier of the interface element(s), can be a single integer or a (flat, NULL-free) sequence of them.<br>
            name: a string identifying the handler, eg <a href="#KEY">"KEY"</a>, or an even-length sequence of string,rtn pairs.<br>
            handler: a (bare) function or procedure, or NULL. Must be NULL (/omitted) if name is pairs and not a string.
            <br>
            <br>
            A NULL rtn when name is a string, or any NULL even element of name, simply removes any association. 
            <br>
            <br>
            Refer to each specific interface element for valid/meaningful names and their required routine signatures.
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
            Supported.
         </td>
        </tr>
        <tr>
         <td>
          <b>Notes:</b>
         </td>
         <td>
            All elements with a parameter of type <a href="rtn.htm">rtn</a> permit/encourage an implit invocation of gSetHandler().
            <br>
            <br>
            You can also invoke this as the simple alias <b>gSetHandlers</b>(), with the implication but not enforcement that id or name 
            or both are non-unitary, or just stick with the non-s name for everything. Note however that is in stark contrast to (say)
            <a href="gSetAttribute.htm">gSetAttribute</a>() and <a href="gSetAttributes.htm">gSetAttributes</a>(), which are in fact quite 
            different, although they too can both set something on one or more elements, likewise unconnected to a trailing s, though only
            the latter can set something<b><i>s</i></b> in a single call.
            <br>
            <br>
            Handlers are used by the application to receive and process notifications from the system that the user or the system itself 
            has interacted with the user interface of the application. In particular that means everything (directly and indirectly) from
            the mouse and keyboard, as well as things like timers and other alerts, such as "going idle" (ie/aka "msg queue is empty").
            <br>
            <br>
<!--
            On the other hand attributes are used by the application to communicate with the user interface system.
            <br>
            <br>
            Even though handlers have different purposes from attributes, they are also associated to elements via a name. <br>
-->
            All handlers receive at least the element for which the event was triggerd as a parameter, almost always in the form of a 
            <a href="gdx.htm">gdx</a>, though it may be a tad more opaque for some, such as <a href="gTreeView.htm#BRANCHOPEN">BRANCHOPEN</a>.
            <br>
            <a name=XPG_DEFAULT></a>
            <a name=XPG_CLOSE></a>
            <a name=XPG_IGNORE></a>
            <a name=XPG_CONTINUE></a>
            <br>
            Most handlers (except those defined as procedures) must return one of the following values:
            <ul>
            <li>XPG_DEFAULT (-1): Proceed normally with user interaction. <!--Should other return values not apply, the handler should return this value.--> </li>
            <li>XPG_IGNORE (-2): Perform no further processing of this event. <!--Applies only to some events.--> </li>
            <li>XPG_CLOSE (-3): Close the parent window and in some cases exit the application. <!--Applies only to some events.--> </li>
            <li>XPG_CONTINUE (-4): Pass the treatment of the event to the parent element. <!--Applies only to some events.--> </li>
            </ul>
            Only some handlers support the last 3 return values, check each handler documentation. <!--When nothing is documented then only XPG_DEFAULT 
            is supported (and in all probability that handler should therefore be a procedure).-->
            <br>
            <br>
            <b>NB</b>: returning XPG_CLOSE does <i>not</i> automatically invoke CLOSE_CB handlers.
            <br>
            <br>
            Note: Avoid using XPG_IGNORE (and XPG_CLOSE) unless it is specifically documented for that handler. <br>
            For example, it is and always was the documented behaviour for an <a href="gSetHandler.htm#IDLE_ACTION">IDLE_ACTION</a> handler 
            to be removed when it returns XPG_IGNORE. However, the act of IUP_IGNORE removing the callback on an IupButton in pGUI (which was 
            in fact undocumented until I myself piped up) has <i>not</i> been replicated in xpGUI, you may be relieved to hear.
            <br>
            <br>
            An important detail when using handlers is that they are only triggered when the user physically performs an action on an element. <br>
            In particular, a handler is <i>not</i> invoked when the programmer sets a value via <a href="gSetAttribute.htm">gSetAttribute</a>().<br>
            For instance: should the code change the selected item on a list, no handler is called and it is up to the programmer to
            ensure any additional appropriate processing occurs, by some more direct means.
<!--
            <br>
            <br>
DEV rewrite rqd from this point on:
            <br>
            <br>
--X>
            The order in which handlers are called is sometimes system dependent, for instance, <a href="gSetHandler.htm#RESIZE_CB">RESIZE_CB</a> 
            and SHOW_CB are called in a different order on Windows and Linux when a dialog is shown for the first time.
<X!X--
            <br>
            <br>
            As well as its normal duty of verifying parameters, the <a href="Icallback.htm">cbfunc</a> type can be used to declare variables suitable for storing callbacks.<br>
            The C header file "iupcbs.h" lists some 50 different typedefs for callbacks (IFxxx/sIFxxx/dIFxxx). <br>
            In Phix you can always get by with "atom" for each parameter, if need be.
-->
            <br>
            <a name=gGetHandler><a/>
            <br>
            <a href="rtn.htm">rtn</a> handler = <b>gGetHandler</b>(<a href="gdx.htm">gdx</a> id, 
                                                                   <a href="string.htm">string</a> name,
                                                                   <a href="integer.htm">integer</a> dflt=0) <br>
            can be used to retrieve a previously set handler, primarily intended for use inside xpGUI.e itself, and to be honest I cannot offhand
            think of any good reason user code should ever want to use it, but it costs absolutely nothing to be available anyway. There is also<br>
            <a href="rtn.htm">rtn</a> handler = <b>gGetInheritedHandler</b>(<a href="gdx.htm">gdx</a> id, 
                                                                   <a href="string.htm">string</a> name) <br>
            which is currently only used for <a href="#KEY">KEY</a> (and deliberately has no default/returns NULL if not defined).
            <!--, please refer to that source file for further details and examples if needed.-->
         </td>
        </tr>
        <tr>
         <td>
          <b>Examples:</b>
         </td>
         <td>
<!--eucode>
-- set one handler on one interface element:
gSetHandler(canvas,"REDRAW",redraw)
-- set the same handler on two elements:
gSetHandler({canvas1,canvas2},"REDRAW",redraw)
-- set two handlers on both elements:
gSetHandler({canvas1,canvas2},{"REDRAW",redraw,"CLICK",click})
</eucode-->
<pre>
<font color="#000080"><i>-- set one handler on one interface element:</i></font>
<font color="#7060A8">gSetHandler</font><font color="#0000FF">(</font><font color="#000000">canvas</font><font color="#0000FF">,</font><font color="#008000">"REDRAW"</font><font color="#0000FF">,</font><font color="#000000">redraw</font><font color="#0000FF">)</font>
<font color="#000080"><i>-- set the same handler on two elements:</i></font>
<font color="#7060A8">gSetHandler</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">canvas1</font><font color="#0000FF">,</font><font color="#000000">canvas2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#008000">"REDRAW"</font><font color="#0000FF">,</font><font color="#000000">redraw</font><font color="#0000FF">)</font>
<font color="#000080"><i>-- set two handlers on both elements:</i></font>
<font color="#7060A8">gSetHandler</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">canvas1</font><font color="#0000FF">,</font><font color="#000000">canvas2</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#008000">"REDRAW"</font><font color="#0000FF">,</font><font color="#000000">redraw</font><font color="#0000FF">,</font><font color="#008000">"CLICK"</font><font color="#0000FF">,</font><font color="#000000">click</font><font color="#800000">}</font><font color="#0000FF">)</font>
</pre>
         </td>
        </tr>
<!--
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
//        <a href="IupGetCallback.htm">IupGetCallback</a>,
//        <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>
         </td>
        </tr>
-->
        <tr>
         <td>
            <b>Common:</b>
         </td>
         <td>
          The following handlers are common to several controls/interface elements:<br>
          <!-- (they just got <i>no class</i>):-->
          <a name=CLICK></a>
         </td>
        </tr>
        <tr>
         <td>
          CLICK
         </td>
         <td>
            Event generated when any mouse button is pressed or released.
            <br>
            <br>
            function click(<a href="gdx.htm">gdx</a> id, <a href="sequence.htm">sequence</a> status[,
                                                         <a href="integer.htm">integer</a> x, y])
            <br>
            <br>
            id: identifies the interface element that activated the event.<br>
            status: a sequence of two characters and three bools that qualify the precise event that just occurred:<br>
            &nbsp;The first character is 'L', 'M',  or 'R' for Left, Middle, or Right button.<br>
            &nbsp;The second character is 'S', 'D', or 'R' for Single-click, Double-click, or Release events, see note.<br>
            &nbsp;The third element is true if the ctrl key is depressed, false otherwise.<br>
            &nbsp;The fourth element is true if the shift key is depressed, false otherwise.<br>
            &nbsp;The fifth element is true if the alt key is depressed, false otherwise.<br>
            &nbsp;You may prefer to code <code>integer {button,pressed,ctrl,shift,alt} = status</code> over using [1..5]s.<br>
            x,y: (optional) pixel co-ordinates of the mouse cursor when the click/release occurred.
            <br>
            <br>
            Note that for a double left-click, and with CSA omitted for clarity, GTK sends "LS", "LR", "LS", "LD", "LR", 
            whereas WinAPI slightly more sensibly just sends: "LS", "LR", "LD", "LR" (ie no second "LS").
            <br>
            <br>
            The <a href="gButton.htm#ACTION">ACTION</a> event is usually much more suitable for a <a href="gButton.htm">gButton</a>.<br>
            The <a href="gCheckbox.htm#VALUE_CHANGED">VALUE_CHANGED</a> event is usually much more suitable for a <a href="gCheckbox.htm">gCheckbox</a>.
            <br>
            <br>
<!-- erm, test this...
            When both action and click handlers are assigned to a <a href="gButton.htm">gButton</a>, the click handler
            is <i>not</i> invoked after the action handler (ie on left-release), but it is still invoked for button presses
            and middle/right releases.
            <br>
            <br>
-->
<!--
            The status parameter is a <a href="html/glossary.htm#dwordseq">dword-sequence</a> rather than a string to permit
             without accidentally and needlessly triggering 
            a "p2js violation: JavaScript does not support string subscript destructuring" error.
            <br>
            <br>
            IUP_BUTTON1 - left mouse button (button 1);<br>
            IUP_BUTTON2 - middle mouse button (button 2);<br>
            IUP_BUTTON3 - right mouse button (button 3).<br>
            <br>
            pressed: indicates the state of the button:<br>
            <br>
            0 - mouse button was released;<br>
            1 - mouse button was pressed.<br>
            <br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of the mouse buttons and some keyboard keys at the moment the event is generated (a char*). <br>
            <br>
            Use the following routines on pStatus:
            <br>
            iup_isshift(pStatus)<br>
            iup_iscontrol(pStatus)<br>
            iup_isbutton1(pStatus)<br>
            iup_isbutton2(pStatus)<br>
            iup_isbutton3(pStatus)<br>
            iup_isbutton4(pStatus)<br>
            iup_isbutton5(pStatus)<br>
            iup_isdouble(pStatus)<br>
            iup_isalt(pStatus)<br>
            iup_issys(pStatus)<br>
            <br>
            They return 1 if the respective key or button is pressed, and 0 otherwise.
            <br>
            <br>
            Returns: <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed. <br>
            On some controls if <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the event is ignored (this is system dependent).
            <br>
            <br>
            Notes<br>
            This handler can be used to customize a button behavior. 
            For standard button behavior use the <a href="gButton.htm#ACTION">ACTION</a> handler of the <a href="gButton.htm">gButton</a>.
            <br>
            <br>
            For a single click the handler is called twice, one for pressed=1 and one for pressed=0. <br>
            The CLICK handler is only invoked after both calls.<br>
            In Windows, if a dialog is shown or popup in any situation there could be unpredictable results because the native system still has processing to be done even after the handler is called.
            <br>
            <br>
            A double click is preceded by two single clicks, one for pressed=1 and one for pressed=0, and followed by a pressed=0, all three without the double click flag set. <br>
            In GTK, it is preceded by an additional two single clicks sequence. For example, for one double click all the following calls are made:<br><br>
// <pre>
//BUTTON_CB(but=1 (1), x=154, y=83 [    1       ])
//BUTTON_CB(but=1 (0), x=154, y=83 [    1       ])
//  BUTTON_CB(but=1 (1), x=154, y=83 [  1       ])     (in GTK only)
//  BUTTON_CB(but=1 (0), x=154, y=83 [  1       ])     (in GTK only)
//BUTTON_CB(but=1 (1), x=154, y=83 [    1  D    ])
//BUTTON_CB(but=1 (0), x=154, y=83 [    1       ])
// </pre>
            <br>
-->
            Affects: <a href="gCanvas.htm">gCanvas</a>, ...
<!--
                     <a href="gButton.htm">gButton</a>, 
                     <a href="gText.htm">gText</a>, 
                     <a href="gList.htm">gList</a> [DEV...]
-->
            <br>
          <a name=CLOSE_CB></a>
         </td>
        </tr>
        <tr>
         <td>
?         CLOSE_CB
         </td>
         <td>
            Called just before a dialog is closed when the user clicks the close button of the title bar or an equivalent action.<br>
            <b>NB</b>: other handlers returning <a href="#XPG_CLOSE">XPG_CLOSE</a><!--, or any code invoking 
            <a href="IupExitLoop.htm">IupExitLoop</a>(), does--> do <i>not</i> invoke any CLOSE_CB handler, instead any required final
            processing, such as saving files or invoking <a href="IupConfigDialogClosed.htm">IupConfigDialogClosed</a>(),
            must be performed manually/explicitly, that is, just before returning XPG_CLOSE.<!-- or when invoking IupExitLoop.--><br>
            Penning (say) my_shutdown() and invoking it from several places, including close_cb, is probably a wise move.<br>
            Note that you are not allowed to (re-)use the name <a href="close.htm">close</a>() as a handler since that is already
            reserved for the builtin.
            <br>
            <br>
            function close_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifies the element that activated the event.
            <br>
            <br>
            Returns: an <a href="#XPG_IGNORE">XPG_IGNORE</a> prevents the dialog from being closed. <br>
            Should you destroy the dialog in this handler, you must return <a href="#XPG_IGNORE">XPG_IGNORE</a>. <br>
            <a href="#XPG_CLOSE">XPG_CLOSE</a>, <a href="#XPG_CONTINUE">XPG_CONTINUE</a>, and <a href="#XPG_DEFAULT">XPG_DEFAULT</a>
            will in the specific case of this handler all be treated identically.
            <br>
            <br>
            Affects: <a href="gDialog.htm">gDialog</a>
            <br>
          <a name=IDLE_ACTION></a>
         </td>
        </tr>
        <tr>
         <td>
?         IDLE_ACTION
         </td>
         <td>
            Predefined, generated when there are no events or messages to be processed. Often used to perform background operations.
            <br>
            <br>
            function idle_action()<br>
            Returns: if <a href="#XPG_CLOSE">XPG_CLOSE</a> is returned the current loop will be closed and the handler will be removed. <br>
            If <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the handler is removed and normal processing continues.
            <br>
            <br>
            Notes<br>
            The idle handler is called whenever there are no messages left to be processed. <br>
            This may occur more frequently than expected, for example if you move the mouse over the application the idle handler will be called
            many times because the mouse move message is processed so fast that the Idle will be called before another mouse move message occurs.<br>
            <small>[No mouse(/user) is likely to generate 100 messages/s, which on a GHz box means ten million clocks between each in which to
            perform some idle processing.]</small>
            <br>
            <br>
            So this handler changes the message loop to a more CPU consuming one. <br>
            It is important it be set NULL when not used, otherwise the application consumes CPU even if the handler is doing nothing.
            <br>
            <br>
??          It can only be set using <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("IDLE_ACTION", idle_action).
            <br>
            <br>
            Long Time Operations<br>
            If you create a loop or an operation that takes a long time to complete inside a handler of your application then 
            the user interface message loop processing is interrupted until the handler returns, so the user can not click on 
            any control of the application. But there are ways to handle that:
            <ul>
<!--            <li>call <a href="IupLoopStep.htm">IupLoopStep</a> or <a href="IupFlush.htm">IupFlush</a> inside the application handler when it is performing long time operations. <br>
            This will allow the user to click on a cancel button for instance, because the user interface message loop will be processed.</li>-->

            <li>split the operation in several parts that are processed by the Idle function when no messages are left to be processed for the user interface message loop. <br>
            This will make a heavy use of the CPU, even if the handler is doing nothing. </li>

            <li>split the operation in several parts but use a Timer to process each part. </li>
            </ul>
            If you just want to do something simple as a background redraw of an <a href="IupCanvas.htm">IupCanvas</a>, 
            then a better idea is to handle the "idle" state yourself. <br>
            For example, register a timer for a small time like 500ms, and reset the timer in all the mouse and keyboard handlers of the <a href="IupCanvas.htm">IupCanvas</a>. <br>
            If the timer is trigged then you are in idle state. If the <a href="IupCanvas.htm">IupCanvas</a> loses its focus then stop the timer.
            <br>
            <br>
            <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a> Uses window.requestIdleCallback() which is marked on 
            <a href="javascript:ExternalLink('ext373');" title='https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback'
            id="ext373" style="color:#9B5565" >MDN</a> as experimental, but that has not changed since 2015. Note that according to 
            <a href="javascript:ExternalLink('ext382');" title='https://caniuse.com/requestidlecallback'
            id="ext382" style="color:#9B5565" >caniuse.com</a> for this to work in Safari you (and/or you users) must enable requestIdleCallback 
            in Experimental (Webkit) Features, and the same may be true for Chrome on macOS (not that desktop/Phix works on macOS, yet).<br>
            Also note I am not quite sure what "current loop will be closed" above means for XPG_CLOSE returns, so XPG_CLOSE and XPG_IGNORE do
            the same thing, which is in fact <i>don&rsquo;t</i> re-apply requestIdleCallback.<br>
            If at all possible you should strive to return within 50ms/break up idle processing into chucks of work shorter than that, to
            avoid (otherwise fairly harmless) JavaScript violation messages being logged to the (hidden) console. A future version may
            incorporate a means to get <code>(deadline.timeRemaining() > 0 || deadline.didTimeout)</code> in pwa/p2js, with a matching
            mechanism to get <code>true</code> on desktop/Phix, should that ever be desired/requested.
            <br>
            <br>
            See Also: <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>, <a href="gTimer.htm">gTimer</a>.
            <br>
          <a name=KEY></a>
         </td>
        </tr>
        <tr>
         <td>
          KEY 
         </td>
         <td>
            (inherited) Event generated when a keyboard event occurs.
            <br>
            <br>
            function key_handler(<a href="gdx.htm">gdx</a> id, <a href="integer.htm">integer</a> c,
                                                             [[<a href="integer.htm#bool">bool</a>] ctrl[, shift[, alt ]]])
            <br>
            <br>
            id: the interface element that had focus when the key event occurred, or maybe its parent.<br>
            c: the typed key. Some possible (special) values are listed below.<br>
            ctrl, shift, alt: (optional) any key modifiers that were also pressed.
            <br>
            <br>
            Note that, unlike pGUI, a key such as &lt;Ctrl C&gt; is passed to key_handler as 'c' or 'C' with ctrl=true, depending
            on the state of caps lock. While the latter is honoured, there is no forwarding of its state with every keypress, and
            obviously no guarantee of any correlation at all between shift and 'C' or 'c'.
<!--
            , 
            and there will also doubtless be cases (sic) where you have to use upper/lower or check for 'x' and 'X' to avoid confusing 
            yourself or your users or both.
-->
            <br>
            <br>
            While pGUI/IUP defines literally hundreds of key constants, xpGUI limits itself to a much more reasonable subset.<br>
            You should, typically as and when the compiler complains, replace eg VK_a with 'a', and any specially prefixed keys 
            such as VK_cC with (say) "ctrl and upper(c)='C'".
            <br>
            <br>
            xpGUI defines the following key constants, in particular those that cannot (intuitively) be written as a normal character 
            constant, like say 'X' can, plus, as you can see, a few/five that could be:<br>
            VK_ESC, VK_F1, VK_F2, VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10, VK_F11, VK_F12, <br>
            VK_SCROLL, VK_PAUSE, VK_NUMLOCK, VK_CAPSLOCK, <br>
            VK_BS (or '\b'), VK_TAB (or '\t'), VK_CR (or '\r'), VK_LF (or '\n'), VK_SP (' '), <br>
            VK_INS, VK_DEL, VK_HOME, VK_END, VK_PGUP, VK_PGDN, VK_UP, VK_RIGHT, VK_DOWN, VK_LEFT, <br>
            VK_LCTRL, VK_RCTRL, VK_LSHIFT, VK_RSHIFT, VK_LALT, VK_RALT, VK_APPS, and VK_POUND (&pound;, see below).
            <br>
            <br>
            Aside: instead of (re-)using say K_DEL from pGUI, the equivalent constant is VK_DEL (as per arwen), partly because
            I did not want to break pGUI help lookup too soon (which is neither a concern nor a reality with what little arwen
            docs there are in this file), but more importantly I certainly did not want to end up with K_C/K_D/K_E linking to 
            pGUI but K_DEL linking to (this) xpGUI help section, and probably getting left in that mess pretty much forever.
            <br>
            <br>
            Note that (eg) VK_F1 is (the freshly made up, unsigned) #F1 (241) rather than the potentially confusing WinAPI value of 
            'p' (ie #70 or 112, or for that matter the GTK value of #FFBE which is 65470 or -66), and likewise most other keys.
<!--
            , and xpGUI.js manually maps string
            event.key of length 1 using codePointAt(0) and lengths &gt; 1 manually/laboriously, in this case "F1" ==&gt; 0xF1), -->
            There is a relatively straightforward mapping table in xpGUI.e which should be fairly easy to tweak if ever needed,
            and some (hopefully) matching definitions/manual mapping in xpGUI.js. <small>(obvs. just search for VK_F1)</small>
<!-- DEV, nah, just do it right!
            Also, while xpGUI.e maps keystrokes from WinAPI and GTK to consistent values, there is no correlation whatsoever
            between those and the values used in xpGUI.js (no problem unless you&rsquo;re using literal constants or bit-tricks,
            and I only mention it because I&rsquo;ve seen more than my fair share of code that uses, say, 13 rather than VK_CR).
-->
            <br>
            <br>
            An error occurs if c is defined as an <a href="atom.htm">atom</a>: the original <a href="pGUI.htm">pGUI</a> went 
            to great lengths to enforce that and prevent a "time-bomb" routine signature error as I then dubbed it. Should 
            such occur you would be advised to review and update the (legacy) code as necessary, at the same time as changing 
            the c parameter to be an integer.
            <br>
            <br>
            In a similar fashion to <a href="g_paranormal.htm">paranormalised</a> functions, only without any reshuffling of the
            parameters, you can assume that all of the following are potentially perfectly valid, with the fairly obvious point 
            that the third parameter, if present, always contains the ctrl flag, and likewise the fouth contains shift and the
            fifth contains alt, in spite of whatever the parameters may actually be named, and even if you only wanted to check 
            for the alt key, you would still be required to declare the full five parameters:
            <br>
            <br>
<small>
<!--eucode>
                        key_handler(gdx id, integer c)
                        key_handler(gdx id, integer c, ctrl)
                        key_handler(gdx id, integer c, ctrl, shift)
                        key_handler(gdx id, integer c, ctrl, shift, alt)
                        key_handler(gdx id, integer c, bool ctrl)
                        key_handler(gdx id, integer c, bool ctrl, shift)
                        key_handler(gdx id, integer c, bool ctrl, shift, alt)
</eucode-->
<pre>
<font color="#000000">                        key_handler</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> c</font><font color="#0000FF">)</font>
<font color="#000000">                        key_handler</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> c</font><font color="#0000FF">,</font><font color="#000000"> ctrl</font><font color="#0000FF">)</font>
<font color="#000000">                        key_handler</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> c</font><font color="#0000FF">,</font><font color="#000000"> ctrl</font><font color="#0000FF">,</font><font color="#000000"> shift</font><font color="#0000FF">)</font>
<font color="#000000">                        key_handler</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> c</font><font color="#0000FF">,</font><font color="#000000"> ctrl</font><font color="#0000FF">,</font><font color="#000000"> shift</font><font color="#0000FF">,</font><font color="#000000"> alt</font><font color="#0000FF">)</font>
<font color="#000000">                        key_handler</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> c</font><font color="#0000FF">,</font><font color="#004080"> bool</font><font color="#000000"> ctrl</font><font color="#0000FF">)</font>
<font color="#000000">                        key_handler</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> c</font><font color="#0000FF">,</font><font color="#004080"> bool</font><font color="#000000"> ctrl</font><font color="#0000FF">,</font><font color="#000000"> shift</font><font color="#0000FF">)</font>
<font color="#000000">                        key_handler</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> c</font><font color="#0000FF">,</font><font color="#004080"> bool</font><font color="#000000"> ctrl</font><font color="#0000FF">,</font><font color="#000000"> shift</font><font color="#0000FF">,</font><font color="#000000"> alt</font><font color="#0000FF">)</font>
</pre>
</small>
            <br>
            When ctrl/shift/alt are absent, the backend avoids relaying characters and other keystrokes that it knows the 
            handler cannot cope with or might mis-interpret. In the case (sic) of shift, you&rsquo;ll still get '!' (#21) 
            all the way to '~' (#7E) but not space or below, or VK_DEL and above (including all the function keys), that 
            is when shift is down but there&rsquo;s no shift parameter on your key_handler() routine (or whatever it is 
            actually called), and you would of course still get all un-shifted keys. Should you <i>want</i> to treat say
            &lt;F1&gt;, &lt;Ctrl F1&gt;, &lt;Shift F1&gt;, &lt;Alt F1&gt;, and the other four possible combinations of
            multiple modifiers the same, you would have to declare all five parameters but then ignore the last three.
            Caps lock and Num lock do not of course alter which physical keys are relayed, just some of their values.
            <br>
            <a name=KEYDIFFS></a>
            <br>
<!--
            Also, the global attribute <a href="gGetGlobal?.htm#MODKEYSTATE">MODKEYSTATE</a> can be used to detect the combination of two or more modifiers.
            <br>
            <br>
-->
            Small differences in handling will almost certainly exist and quite likely remain forever, for instance in my testing of GTK on Windows, 
            it did not generate the VK_CAPSLOCK key, and GTK2 did not generate the VK_PAUSE key. GTK also appears unable or unwilling to permit the
            capture of Alt-Space or Alt-F4. On the other hand, Windows does some things with the Alt key (alone) and F10 that sort of put it into a
            "special mode" until you hit them a second time, all of which I don&rsquo;t completely grok. And of course a browser is going to do some
            browser-like things with some keystrokes and that may differ between browsers. Oh, and of course there is a "Windows" key one away from 
            the spacebar, but that&rsquo;s for the OS, not your app, OK? (ie/aka ymmv) However otherwise, more normal things are generally speaking 
            pretty consistent, and avoiding the odd dicey one shouldn&rsquo;t really be a problem when there are perhaps 252 other key combinations 
            that you could certainly always use, as in 4 combinations of ctrl/shift times ~63 suitable keys, at least, and nearly but not quite as
            many again that involve the alt key.
            <br>
            <br>
            Note that VK_POUND is (currently) the pseudo-UTF-8 value #C2A3 representing the UTF-32 code point #00A3, aka &pound;, and may well need 
            special treatment, perhaps by being substituted with x"C2A3". In truth I accidentally made VK_DOWN #A3, but it would be trivial to change 
            both VK_DOWN and VK_POUND to almost anything else, should doing so actually make anything any easier, just let me know.
            <br>
            <br>
            Finally, I own/use a UK keyboard, and haven&rsquo;t done <i>any</i> testing of non-latin-alphabet input, but I strongly doubt changes
            that might yet be needed in that regard would be spectacularly difficult, at least assuming there is no need for tens of thousands of
            new vk_constants, and I will of course be happy to assist as best I can (once provided with suitable details/links/photos/whatever).
            <br>
            <br>
            Returns: <br>
            If <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the key is ignored and not processed by the control and not propagated. <br>
            There are cases where <a href="#XPG_IGNORE">XPG_IGNORE</a> may start disabling generic OS/backend-specific behaviour, and cases where
            it simply doesn&rsquo;t get that chance, such as &lt;Alt F4&gt;, ymmv.<br>
<!--???         Take care not to overdo that... -->
<!--
            If <a href="#XPG_CONTINUE">XPG_CONTINUE</a> is returned the key is processed and the event propagated to the parent of the element receiving it. (default behavior)<br>
            If <a href="#XPG_DEFAULT">XPG_DEFAULT</a> is returned the key is processed but it is not propagated. <br>
-->
            <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed. <br>
?[DEV/SUG]
            A positive atom will be treated as a unicode replacement (0..#10FFFF) for whatever was keyed, a string as a UTF-8 replacement, and a 
            sequence of length 4 will be treated as that (ie either) plus three bool flags for ctrl, shift, and alt.
            <br>
            <br>
            Notes<br>
            Keyboard handlers depend on the keyboard usage of the control with the focus. <br>
            So if you return <a href="#XPG_IGNORE">XPG_IGNORE</a> the control will usually not process the key. <br>
            But be aware that sometimes the control processes the key in another event so even when returning <a href="#XPG_IGNORE">XPG_IGNORE</a> 
            the key can still get processed, although it will(/should) not be propagated, again ymmv.
            <br>
            <br>
            If the handler does not exist it is automatically propagated to the parent of the element (aka inherited).
            <br>
            <br>
            Affects: All elements with keyboard interaction.
            <br>
          <a name=MOUSEMOVE></a>
         </td>
        </tr>
        <tr>
         <td>
          MOUSEMOVE
         </td>
         <td>
            Event generated when the mouse moves.
            <br>
            <br>
            procedure mousemove(<a href="gdx.htm">gdx</a> id, <a href="integer.htm">integer</a> x, y[, 
                                                             [<a href="bool.htm">bool</a>] left,middle,right[,
                                                                                           ctrl,shift,alt]])
            <br>
            <br>
            id: identifier of the interface element that activated the event.<br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            left,middle,right: (optional) status of the mouse buttons, true for down and false for up.<br>
            ctrl,shift,alt: (optional) status of the modifier keys, true for down and false for up.
            <br>
            <br>
            In a similar fashion to <a href="g_paranormal.htm">paranormalised</a> functions, only without any reshuffling of the
            parameters, you can assume that all of the following are potentially perfectly valid (ie "in sets of 3"):
            <br>
            <br>
<small>
<!--eucode>
                mousemove(gdx id, integer x, y)
                mousemove(gdx id, integer x, y, left, middle, right)
                mousemove(gdx id, integer x, y, left, middle, right, ctrl, shift, alt)
                mousemove(gdx id, integer x, y, bool left, middle, right)
                mousemove(gdx id, integer x, y, bool left, middle, right, ctrl, shift, alt)
</eucode-->
<pre>
<font color="#000000">                mousemove</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> x</font><font color="#0000FF">,</font><font color="#000000"> y</font><font color="#0000FF">)</font>
<font color="#000000">                mousemove</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> x</font><font color="#0000FF">,</font><font color="#000000"> y</font><font color="#0000FF">,</font><font color="#000000"> left</font><font color="#0000FF">,</font><font color="#000000"> middle</font><font color="#0000FF">,</font><font color="#000000"> right</font><font color="#0000FF">)</font>
<font color="#000000">                mousemove</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> x</font><font color="#0000FF">,</font><font color="#000000"> y</font><font color="#0000FF">,</font><font color="#000000"> left</font><font color="#0000FF">,</font><font color="#000000"> middle</font><font color="#0000FF">,</font><font color="#000000"> right</font><font color="#0000FF">,</font><font color="#000000"> ctrl</font><font color="#0000FF">,</font><font color="#000000"> shift</font><font color="#0000FF">,</font><font color="#000000"> alt</font><font color="#0000FF">)</font>
<font color="#000000">                mousemove</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> x</font><font color="#0000FF">,</font><font color="#000000"> y</font><font color="#0000FF">,</font><font color="#004080"> bool</font><font color="#000000"> left</font><font color="#0000FF">,</font><font color="#000000"> middle</font><font color="#0000FF">,</font><font color="#000000"> right</font><font color="#0000FF">)</font>
<font color="#000000">                mousemove</font><font color="#0000FF">(</font><font color="#7060A8">gdx</font><font color="#000000"> id</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> x</font><font color="#0000FF">,</font><font color="#000000"> y</font><font color="#0000FF">,</font><font color="#004080"> bool</font><font color="#000000"> left</font><font color="#0000FF">,</font><font color="#000000"> middle</font><font color="#0000FF">,</font><font color="#000000"> right</font><font color="#0000FF">,</font><font color="#000000"> ctrl</font><font color="#0000FF">,</font><font color="#000000"> shift</font><font color="#0000FF">,</font><font color="#000000"> alt</font><font color="#0000FF">)</font>
</pre>
</small>
            <br>
            An error occurs if the handler does not have 3, 6, or 9 parameters, or the last 2..8 are not integer/bool.
            <br>
            <br>
            On Windows, as similarly noted in <a href="#KEYDIFFS">KEY</a> above, if you dab on the Alt key, <i>then</i> try moving the mouse,
            you may find it is effectively disabled until you tap the Alt key again. Holding the Alt key while moving however works fine.
            <br>
            <br>
<!-- (DEV maybe, but it's not "routines" any longer)
            Use the same routines for pStatus as <a href="gSetHandler.htm#CLICK">CLICK</a>.
            <br>
            <br>
-->
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, ...
<!--
            <a href="IupGLCanvas.htm">IupGLCanvas</a>,
                     <a href="IupList.htm">IupList</a>, <a href="IupMatrix.htm">IupMatrix</a>, 
                     <a href="IupText.htm">IupText</a>, <a href="IupTree.htm">IupTree</a>
-->
            <br>
          <a name=VALUE_CHANGED></a>
         </td>
        </tr>
        <tr>
         <td>
          VALUE_CHANGED
         </td>
         <td>
            Event generated when the value of a control is changed.
            <br>
            <br>
            function value_changed(<a href="gdx.htm">gdx</a> id)<br>
            ih: identifier of the element that activated the event.<br>
            Note this handler on a <a href="gCheckbox.htm#VALUE_CHANGED">gCheckbox</a>() also gets a bool bChecked parameter.
            <br>
            <br>
            Affects: 
            <a href="gDatePick.htm#VALUE_CHANGED">gDatePick</a>,
            <a href="gList.htm#VALUE_CHANGED">gList</a>,
            <a href="gText.htm#VALUE_CHANGED">gText</a>,
            <a href="gCheckbox.htm#VALUE_CHANGED">gCheckbox</a><br>
          <a name=tech></a>
         </td>
        </tr>
<!--
          <a name=ACTION></a>
        <tr>
         <td>
          "ACTION"
         </td>
         <td>
            While common to several elements, the handler parameters vary - see specific elements for details.
            <br>
            <br>
            Affects: <a href="gButton.htm">gButton</a>, <a href="IupMenuItem.htm">IupMenuItem</a>, <a href="IupList.htm">IupList</a>, 
                     <a href="gText.htm">gText</a>, <a href="gCanvas.htm">gCanvas</a>, <a href="IupToggle.htm">IupToggle</a>
            <br>
         </td>
        </tr>
-->
<!--
//        <a name=DESTROY_CB></a>
//      <tr>
//       <td>
//?       DESTROY_CB
//       </td>
//       <td>
//          Called right before an element is destroyed.
//          <br>
//          <br>
//          function destroy_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
//          ih: identifier of the element that activated the event.
//          <br>
//          <br>
//          If the dialog is visible then it is hidden before it is destroyed. The handler will be called right after it is hidden.
//          <br>
//          <br>
//          The handler will be called before all other destroy procedures - for instance, if the element has children then it is called before the children are destroyed. 
//          <br>
//          <br>
//          For language binding implementations use the handler name "LDESTROY_CB" to release memory allocated by the binding for the element. 
//          Also the handler will be called before the language handler.
//          <br>
//          <br>
//          Affects: All
//          <br>
//       </td>
//      </tr>
-->
<!--
          <a name=ENTERWINDOW_CB></a>
        <tr>
         <td>
?         ENTERWINDOW_CB
         </td>
         <td>
            Event generated when the mouse enters the native element. 
            <br>
            <br>
            function enterwindow_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Notes<br>
            When the cursor is moved from one element to another, the call order in all platforms will be first the 
            <a href="gSetHandler.htm#LEAVEWINDOW_CB">LEAVEWINDOW_CB</a> handler of the old control followed by the 
            ENTERWINDOW_CB handler of the new control.
            <br>
            <br>
            Affects: All controls with user interaction.
            <br>
            <br>
            See Also: <a href="gSetHandler.htm#LEAVEWINDOW_CB">LEAVEWINDOW_CB</a>
            <br>
         </td>
        </tr>
          <a name=GETFOCUS_CB></a>
        <tr>
         <td>
?         GETFOCUS_CB
         </td>
         <td>
            Event generated when an element is given keyboard focus. <br>
            This handler is called after the <a href="gSetHandler.htm#KILLFOCUS_CB">KILLFOCUS_CB</a> of the element that lost the focus. <br>
            The <a href="IupGetFocus.htm">IupGetFocus</a> function during the handler returns the element that lost the focus.
            <br>
            function getfocus_cb(<a href="Ihandle.htm">Ihandle</a> ih)
            <br>
            <br>
            ih: identifier of the element that received keyboard focus.
            <br>
            <br>
            Affects: All elements with user interaction, except menus.
            <br>
            <br>
            See Also: <a href="gSetHandler.htm#KILLFOCUS_CB">KILLFOCUS_CB</a>, <a href="IupGetFocus.htm">IupGetFocus</a>, <a href="IupSetFocus.htm">IupSetFocus</a> 
            <br>
         </td>
        </tr>
-->
<!--
//        <a name=HELP_CB></a>
//      <tr>
//       <td>
//?       HELP_CB
//       </td>
//       <td>
//          Event generated when the user presses F1 at a control. <br>
//          In Motif is also activated by the Help button in some workstations keyboard.
//          <br>
//          <br>
//          function help_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
//          ih: identifier of the element that activated the event.
//          <br>
//          <br>
//          Returns: <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed.
//          <br>
//          <br>
//          Affects: All elements with user interaction.
//          <br>
//       </td>
//      </tr>
-->
<!--
          <a name=GLOBALCTRLFUNC_CB></a>
        <tr>
         <td>
          GLOBALCTRLFUNC_CB
         </td>
         <td>
            Global handler for a restricted set of keys. (since 3.20)<br>
            Called only when the Ctrl+F? key combinations are pressed. <br>
            It was designed to be used for internal application debugging porpoises only. <br>
            Do not use it for release code.
            <br>
            <br>
            function ctrl_func(integer c)<br>
            c: identifier of typed key. Please refer to <a href="#KEY">KEY</a> below for a list of possible values.
            <br>
            <br>
//          It can only be set using (eg) <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("GLOBALCTRLFUNC_CB", <a href="Icallback.htm">Icallback</a>("ctrl_func")).
            <br>
            <br>
//          See Also: <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>.
            <br>
         </td>
        </tr>
-->
<!--
          <a name=ENTRY_POINT></a>
        <tr>
         <td>
          ENTRY_POINT
         </td>
         <td>
            (since 3.28)
            Global callback for an entry point. Used when main is not possible, such as in iOS and Android systems (which
            Phix does not currently support).
            <br>
            <br>
            It is called only once, when the main loop is processed, but after <a href="IupOpen.htm">IupOpen</a>(). <br>
            For regular systems is called right before the actual event loop is started.<br>
//          It can only be set using (eg) <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("ENTRY_POINT", 
            <a href="Icallback.htm">Icallback</a>("entry_func")).
            <br>
            <br>
            See also EXIT_CB (next), <a href="IupMainLoopLevel.htm">IupMainLoopLevel</a>
            <br>
         </td>
        </tr>

          <a name=EXIT_CB></a>
        <tr>
         <td>
          EXIT_CB
         </td>
         <td>
            (since 3.28)
            Global callback for an exit. Used when main is not possible, such as in iOS and Android systems (which Phix does not
            currently support).
            <br>
            <br>
            It is called every time the last main loop is ended. <br>
            For regular systems is called right after the actual event loop is ended, every time when the main loop level returns to 0.
            <br>
            <br>
//          It can only be set using (eg) <a href="IupSetGlobalFunction.htm">IupSetGlobalFunction</a>("EXIT_CB", 
            <a href="Icallback.htm">Icallback</a>("exit_func")).
            <br>
         </td>
        </tr>
-->
<!--
//        <a name=KEYPRESS_CB></a>
//      <tr>
//       <td>
//?       KEYPRESS_CB
//       </td>
//       <td>
//          Event generated when a key is pressed or released. <br>
//          If the key is pressed and held several calls will occur. <br>
//          It is called after the handler <a href="#KEY">KEY</a> is processed.
//          <br>
//          <br>
//          function keypress_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> c, <a href="integer.htm#bool">bool</a> press)
//          <br>
//          <br>
//          ih: identifier of the element that activated the event.<br>
//          c: identifier of typed key. See <a href="#KEY">KEY</a> above for possible values.<br>
//          press: 1(true) when the key is pressed, 0(false) when the key is released.
//          <br>
//          <br>
//          Returns: If <a href="#XPG_IGNORE">XPG_IGNORE</a> is returned the key is ignored by the system. <br>
//          <a href="#XPG_CLOSE">XPG_CLOSE</a> will be processed.
//          <br>
//          <br>
//          Affects: <a href="IupCanvas.htm">IupCanvas</a>
//          <br>
//       </td>
//      </tr>
-->
<!--
          <a name=KILLFOCUS_CB></a>
        <tr>
         <td>
?         KILLFOCUS_CB
         </td>
         <td>
            Event generated when an element loses keyboard focus. <br>
            This handler is called before the <a href="gSetHandler.htm#GETFOCUS_CB">GETFOCUS_CB</a> of the element that gets the focus.
            <br>
            <br>
            function killfocus_cb(<a href="Ihandle.htm">Ihandle</a> ih)
            <br>
            <br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Affects: All elements with user interaction, except menus.
            <br>
            <br>
            In Windows, there are restrictions when using this handler. <br>
            From MSDN on WM_KILLFOCUS: <br>
            While processing this message, do not make any function calls that display or activate a window. <br>
            &nbsp;This causes the thread to yield control and can cause the application to stop responding to messages. 
            <br>
            <br>
            See Also: <a href="gSetHandler.htm#GETFOCUS_CB">GETFOCUS_CB</a>, <a href="IupGetFocus.htm">IupGetFocus</a>, <a href="IupSetFocus.htm">IupSetFocus</a> 
            <br>
         </td>
        </tr>
          <a name=LEAVEWINDOW_CB></a>
        <tr>
         <td>
?         LEAVEWINDOW_CB
         </td>
         <td>
            Event generated when the mouse leaves the native element.
            <br>
            <br>
            function leavewindow_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
            ih: identifier of the element that activated the event.
            <br>
            <br>
            Notes<br>
            When the cursor is moved from one element to another, the call order in all platforms will be first the LEAVEWINDOW_CB handler 
            of the old control followed by the <a href="gSetHandler.htm#ENTERWINDOW_CB">ENTERWINDOW_CB</a> handler of the new control.
            <br>
            <br>
            Affects: All controls with user interaction.
            <br>
            <br>
            See Also: <a href="gSetHandler.htm#ENTERWINDOW_CB">ENTERWINDOW_CB</a>
            <br>
         </td>
        </tr>
-->
<!--
//        <a name=MAP_CB></a>
//      <tr>
//       <td>
//        MAP_CB
//       </td>
//       <td>
//          Called right after an element is mapped and its attributes updated in <a href="IupMap.htm">IupMap</a>().
//          <br>
//          <br>
//          When the element is a dialog, it is called after the layout is updated. 
//          For all other elements it is called before the layout is updated, so the element current size will still be 0x0 during MAP_CB (since 3.14).
//          <br>
//          <br>
//          function map_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
//          ih: identifier of the element that activated the event.
//          <br>
//          <br>
//          Affects: All elements that have a native representation.
//          <br>
//       </td>
//      </tr>
-->
<!--
          <a name=RESIZE_CB></a>
        <tr>
         <td>
?         RESIZE_CB
         </td>
         <td>
            Event generated when the canvas or dialog size is changed.
            <br>
            <br>
            function resize_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> width, height)
            <br>
            <br>
            ih: identifier of the element that activated the event.<br>
            width: the width of the internal element size in pixels not considering the decorations (client size)<br>
            height: the height of the internal element size in pixels not considering the decorations (client size)
            <br>
            <br>
            For a dialog, this event is also generated when the dialog is mapped, after the map and before the show.
            <br>
            <br>
            When XAUTOHIDE=Yes or YAUTOHIDE=Yes, if the canvas scrollbar is hidden/shown after changing the DX or DY attributes from inside the handler, 
            the size of the drawing area will immediately change, so the parameters with and height will be invalid. <br>
<X!X--          To update the parameters consult the DRAWSIZE attribute. --X>
            Also activate the drawing toolkit only after updating the DX or DY attributes.
            <br>
            <br>
            Affects: <a href="IupCanvas.htm">IupCanvas</a>, <a href="IupGLCanvas.htm">IupGLCanvas</a>, <a href="IupDialog.htm">IupDialog</a>
            <br>
         </td>
        </tr>
-->
<!--
          <a name=SCROLL_CB></a>
        <tr>
         <td>
?         SCROLL_CB
         </td>
         <td>
            Called when some manipulation is made to the scrollbar. <br>
            The canvas is automatically redrawn only if this handler is NOT defined.
            <br>
            <br>
            (GTK 2.8) Also the POSX and POSY values will not be correctly updated for older GTK versions.
            <br>
            <br>
            In Ubuntu, when liboverlay-scrollbar is enabled (the new tiny auto-hide scrollbar) only the IUP_SBPOSV and IUP_SBPOSH codes are used.
            <br>
            <br>
            function scroll_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="integer.htm">integer</a> op)<br>
            ih: identifier of the element that activated the event.<br>
            op: indicates the operation performed on the scrollbar:
            <br>
            <br>
            If the manipulation was made on the vertical scrollbar, it can have the following values:
            <br>
            <br>
            IUP_SBUP - line up<br>
            IUP_SBDN - line down<br>
            IUP_SBPGUP - page up<br>
            IUP_SBPGDN - page down<br>
            IUP_SBPOSV - vertical positioning<br>
            IUP_SBDRAGV - vertical drag 
            <br>
            <br>
            If it was on the horizontal scrollbar, the following values are valid:
            <br>
            <br>
            IUP_SBLEFT - column left<br>
            IUP_SBRIGHT - column right<br>
            IUP_SBPGLEFT - page left<br>
            IUP_SBPGRIGHT - page right<br>
            IUP_SBPOSH - horizontal positioning<br>
            IUP_SBDRAGH - horizontal drag
            <br>
            <br>
            Notes<br>
            IUP_SBDRAGH and IUP_SBDRAGV are not supported in GTK.<br>
            <br>
            <br>
            Affects: <a href="gCanvas.htm">gCanvas</a>, <a href="gSetAttribute.htm#SCROLLBAR">SCROLLBAR</a>
            <br>
         </td>
        </tr>
-->
<!--
//        <a name=UNMAP_CB></a>
//      <tr>
//       <td>
//        UNMAP_CB
//       </td>
//       <td>
//          Called right before an element is unmapped.
//          <br>
//          <br>
//          function unmap_cb(<a href="Ihandle.htm">Ihandle</a> ih)<br>
//          ih: identifier of the element that activated the event.
//          <br>
//          <br>
//          Affects: All elements that have a native representation.
//       </td>
//      </tr>
-->
<!--
          <a name=WHEEL_CB></a>
        <tr>
         <td>
?         WHEEL_CB
         </td>
         <td>
            Event generated when the mouse wheel is rotated.<br>
            If this handler is not defined the wheel will automatically scroll the canvas in the vertical direction by some lines, 
            the SCROLL_CB handler if defined will be called with the IUP_SBDRAGV operation.
            <br>
            <br>
            function wheel_cb(<a href="Ihandle.htm">Ihandle</a> ih, <a href="atom.htm">atom</a> delta, <a href="integer.htm">integer</a> x, y, <a href="atom.htm">atom</a> pStatus)<br>
            ih: identifier of the element that activated the event.<br>
            delta: the amount the wheel was rotated in notches (nb dodgy, see <a href="call_back.htm">call_back</a>).<br>
            x, y: position in the canvas where the event has occurred, in pixels.<br>
            pStatus: status of mouse buttons and certain keyboard keys at the moment the event was generated (a char*).
            <br>
            <br>
<X!X-- (DEV maybe, but it's not "routines" any longer)
            Use the same routines for pStatus as <a href="gSetHandler.htm#CLICK">CLICK</a>.
            <br>
            <br>
--X>
            Notes: In Motif and GTK delta is always 1 or -1. In Windows is some situations delta can reach the value of two. 
            In the future with more precise wheels this increment can be changed.
            <br>
            <br>
            Affects: <a href="gCanvas.htm">gCanvas</a>
         </td>
        </tr>
-->
        <tr id="Technicalia" style="display:none;">
         <td>
          <a href="glossary.htm#technicalia">
           <b>Technicalia</b>
          </a>
         </td>
         <td>
            Since xpGUI uses normal first class routines as handlers instead of callbacks, IupSetCallback() has been renamed/needs to be replaced with 
            gSetHandler(), and importantly any quotes around the routine name must be removed, though <a href="xpport.htm">xpGUI_from_pGUI</a>() does 
            all that automatically for you if you let it.<br>
            There are no equivalents in xpGUI for <a href="Icallback.htm">Icallback(), cbfunc(), iup_name_from_cb(), or iup_cb_from_name()</a>, nor
            <a href="IupGetCallback.htm">IupGetCallback</a>().<br>
         </td>
        </tr>
       </table>
       <img id="Timg" src="images/sprites/tech.open.png" title="Expand/Shrink" alt="Expand/Shrink" style="display:block;clear:both;" onload="setStartT(this);" onclick="changeImageT(this);" />
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
