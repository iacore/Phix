<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">gTimer</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
            include xpGUI.e
            <br>
            <br>
            <a href="gdx.htm">gdx</a> res = gTimer(rtn action, <a href="integer.htm">integer</a> msecs, 
                                                               <a href="integer.htm#bool">boolean</a> active=<a href="logicops.htm">true</a>)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
[DEV] not yet implemented...
<br>
<br>
            Creates a timer which periodically invokes a handler when the time is up.
            <br>
            <br>
            func: a callback address, usually specified as <a href="Icallback.htm">Icallback</a>(<i>"name"</i>).<br>
            msecs: an interval in miliseconds.<br>
            active: true or false, you can change the "RUN" attribute later.<br>
<!--
            This is <i>not</i> a paranormalised routine.
-->
            <br>
            <br>
            Each timer should be destroyed using <a href="IupDestroy.htm">IupDestroy</a>.
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
          Supported.
         </td>
        </tr>
        <tr>
         <td>
          <b>Example:</b>
         </td>
         <td>
            A generally useful example of using a timer to allow any currently active drawing processes to abandon before starting a new one can
            be found in <b>demo\rosetta\VoronoiDiagram.exw</b>. While relatively simple, it can make a huge difference to responsiveness (and in 
            that particular case, not crashing).
            <br>
            <br>
            In one case (Conway&rsquo;s game of life) setting a timer <i>before</i> the IupShow() prevented the latter from returning for quite 
            some time, and perhaps not until Escape had been keyed, so from that experience I strongly recommend not creating a timer until after
            an initial IupShow() has returned, and probably after setting any RASTERSIZE to NULL, otherwise it may misbehave - in the program
            just mentioned two things went wrong: Escape had to be keyed twice to close the window, and the canvas did not resize properly, and
            both were fixed simply by moving the IupTimer() creation down three lines.
         </td>
        </tr>
        <tr>
         <td>
          <b>Attributes:</b>
         </td>
         <td>
            
         </td>
        </tr>
        <tr>
         <td>
          TIME
         </td>
         <td>
            The time interval in milliseconds. In Windows the minimum value is 10ms.
         </td>
        </tr>
        <tr>
         <td>
          RUN
         </td>
         <td>
            Starts and stops the timer. Possible values: "YES"/true or "NO"/false.<br>
<!--
            , <a href="IupSetStrAttribute.htm#utility">IupSetInt</a>() with true/1/false/0 
            also works, as does <a href="IupSetStrAttribute.htm#utility">IupToggleInt</a>().<br>
-->
            Returns the current timer state. If you have multiple threads start the timer in the main thread.
         </td>
        </tr>
<!--
        <tr>
         <td>
          <a href="common.htm#WID">WID</a>
         </td>
         <td>
            (read-only): Returns the native serial number of the timer. Returns -1 if not running. A timer is mapped only when it is running.
         </td>
        </tr>
-->
        <tr>
         <td>
          <b>Handlers:</b>
         </td>
         <td>

         </td>
        </tr>
        <tr>
         <td>
          ACTION
         </td>
         <td>
            procedure action(<a href="gdx.htm">gdx</a> id)<br>
            id: identifier of the timer that activated the event.
            <br>
            <br>
<!--
            Returns: <a href="gSetHandler.htm#XPG_CLOSE">XPG_CLOSE</a> will be processed, but desktop/Phix only, ignored within pGUI.js.<br>
            <small><i>(My strongest advice would be to explicitly invoke IupHide() with the dialog you mean, in preference to having 
            the system guess which one, along with future readers of your code, which may very well include yourself.)</i></small>
            <br>
            <br>
-->
            Called every time the defined time interval is reached. To stop the handler from being called again simply stop the timer by
            setting RUN to "NO" or false. 
<!--
            <br>
            <br>
            Inside the callback the attribute ELAPSEDTIME returns the time elapsed since the timer was started (since 3.15).
-->
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
