<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">gTreeAddNodes</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
            include xpGUI.e
           <br>
           <br>
            gTreeAddNodes(<a href="object.htm">object</a> treenode, <a href="sequence.htm">sequence</a> tree_nodes)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Populates a tree from a nested <a href="sequence.htm">sequence</a> of branches and leaves.
          <br>
          <br>
            treenode: As provided to the <a href="gTreeView.htm#BRANCHOPEN">BRANCHOPEN</a> handler, or a <a href="gdx.htm">gdx</a> from <a href="gTerrView.htm">gTreeView</a>().<br>
            tree_nodes: a nested collection of nodes (see examples below).
            <br>
            <br>
            If a plain <a href="gdx.htm">gdx</a> is specified as the treenode, the entire treeview contents are replaced, whereas the 
            more opaque values fed through from BRANCHOPEN permit deferrred loading of sub-trees.<br>
            <small>Of course one day there <i>should</i> be a way to update any sub-tree whenever you like, but I haven&rsquo;t quite 
            designed/implemented or more importantly run into the need for that just yet. I expect it would take the form of a tree 
            traversal handler routine, not vastly different to the branchopen code, that can decide which nodes to navigate down into, 
            and when exactly to do the deed(s).</small>
            <br>
            <br>
            This routine does not return a value. It will rudely terminate in error should tree_nodes not
            conform to the required format, or if unique userids cannot be found, etc.
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
            Supported.
         </td>
        </tr>
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
            <a href="gSetHandler.htm">gSetHandler</a>,
            <a href="gTreeView.htm">gTreeView</a>
         </td>
        </tr>
        <tr>
         <td>
          <b>Notes:</b>
         </td>
         <td>
            A tree is represented by a nested collection of nodes (see example below).<br>
            A node is a <a href="string.htm">string</a> (leaf node) or a <a href="sequence.htm">sequence</a> of length 2 or 3:<br>
            <ul>
            <li>    The first element is a <a href="string.htm">string</a> description.</li>
            <li>    If length is &gt;=3 the second is an even-length set of attribute name/value pairs, can be {}.</li>
            <li>    The last &lt;= 3rd element is a <a href="sequence.htm">sequence</a> of children, or 0 to indicate a leaf node.</li>
            <li>    Elements 4 and above can contain application-specific data, ignored by this routine.</li>
            </ul>
            Each element of children is either a <a href="string.htm">string</a> to represent a leaf node or a <a href="sequence.htm">sequence</a>
            of length&gt;=2 as above. Note that if the top-level node of a (/the entire) tree is a single <a href="string.htm">string</a>, 
            it represents a single leaf node with no attributes, and no branches.
            <br>
            <br>
            The rules to remember are: <br>
            if you have attributes on a leaf node, it must have a third element of 0, and: <br>
            if a branch has no children it must still have a {} to represent that. <br>
            There cannot be any (ignored) application-specifc data on shorthand forms, ie 4 out of 6 entries in the table below.<br>
            Should you see leaf nodes such as "STATE" and "COLLAPSED", or similar attribute names/values, suspect a missing 0 or {}.
            <br>
            <br>
            The following table lists the permitted nodes. Note that the entire tree is always represented by a single node, 
            albeit an arbitrarily nested one.
            <br>
            <br>
            <table>
            <tr>
                <th>Node</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>"string"</td>
                <td>a leaf node with no attributes.</td>
            </tr>
            <tr>
                <td>{"string"}</td>
                <td>ditto.</td>
            </tr>
            <tr>
                <td>{"string",0}</td>
                <td>ditto.</td>
            </tr>
            <tr>
                <td>{"string",sequence evennvseq,0[,appdata]}</td>
                <td>a leaf node with zero or more attributes. Note the 0 is <i>not</i> optional.</td>
            </tr>
            <tr>
                <td>{"string",sequence children}</td>
                <td>a branch node with no attributes, each element of children (if any) is a node.</td>
            </tr>
            <tr>
                <td>{"string",{},sequence children}</td>
                <td>ditto.</td>
            </tr>
            <tr>
                <td>{"string",sequence evennvseq, children[,appdata]}</td>
                <td>a branch node with attribute pairs and children.</td>
            </tr>
            </table>
            <br>
            &nbsp;
            <br>
            DEV The next paragraph in particular has not yet been properly updated... (attributes on treenodes in
            xpGUI are pretty low down on my priorities list right now).
          <br>
          <br>
            Every odd element in any even-length set of attributes should be an attribute that 
            accepts an id, ie one from the <a href="IupFlatTree.htm#Nodes">Nodes</a> or 
            <a href="IupFlatTree.htm#Images">Images</a> section of the Attributes table 
            as shown in the documentation for <a href="IupFlatTree.htm">IupFlatTree</a>.
            The even elements are strings, except for "USERDATA" which requires a positive integer, 
            intended to be an index into some application-specific table.
<!--
             Note that setting custom 
            attributes proved problematical and therefore attempts to do so now trigger a fatal error. 
            If someone gets such things working, outside of IupTreeAddNodes, via IupTreeGetId 
            and friends, then I&rsquo;ll take another look.
-->
            <br>
            <br>
            In practice, a node can also be a <a href="sequence.htm">sequence</a> of length 1, which 
            represents a leaf node in the same way that a plain <a href="string.htm">string</a> does.
            The fact that a leaf node with no attributes can be represented in three different ways
            is a simple consequence of making the recursive structure easier to use, rather than a
            deliberate design decision to complicate matters. While concrete examples of the node
            structure might be a little eye-watering to look at, they should however be reasonably 
            straightforward to (recursively) construct from almost any data, and of course it makes 
            no odds should there be say {"string",{},{}} where a plain "string" would suffice.
<!--
            <br>
            <br>
            Note this routine is (now) targetted squarely at <a href="IupTreeView.htm">IupTreeView</a>,
            which is based on <a href="IupFlatTree.htm">IupFlatTree</a> on the desktop, and rewritten
            in pGUI.js for use in the browser, although it was originally written way back when only 
            <a href="IupTree.htm">IupTree</a> existed. In <i>theory</i> it should work on all four.
-->
            <br>
            <br>
            Performance note: For large trees it would normally be prudent to create all branches
            collapsed and empty, and populate them when the branch is expanded. If you have seen
            Windows Explorer take forever to load a single directory (such as the Recycle Bin),
            imagine what it would be like if it pre-loaded every directory on your entire system
            before displaying anything. Obvously you might also want to auto-expand the top-level
            node, and have that auto-populated, and perhaps repeat that down to some target.
            <br>
            <br>
            To defer load, you must specify {"STATE","COLLAPSED","USERDATA",7} where 7 is some
            unique userid for the branch, and create a "dummy" entry (to get a '+' shown), and
            lastly invoke gTreeAddNodes() inside the branchopen as per demo\xpGUI\sample.exw [DEV]
            and as reproduced below.
         </td>
        </tr>
        <tr>
         <td>
          <b>Additional routines:</b>
         </td>
         <td>
            integer treeIdx = <b>gTreeGetUserId</b>(object treenode)<br>
            <b>gTreeDeleteChildren</b>(object treenode)
            <br>
            <br>
            I trust these are self explanatory, at least after reading the branchopen() example code in 
            <a href="gTreeView.htm">gTreeView</a>.<br>
            The treenode value is backend-specific and should be considered opaque.
         </td>
        </tr>
        <tr>
         <td>
          <b>Example:</b>
         </td>
         <td>
[DEV] replace with gTreeView2.exw, when finished (including the planned timer experiments)
<br>
<br>
            Snippets taken from demo\pGUI\sample.exw:
            <br>
            <br><small>
<!--eucode>
-- This shows how to defer-load nodes on expand/demand:
-- Obviuously would probably be more dynamically set in a real app,
-- and of course elements can be more than plain-string leaf nodes,
-- with daisy-chains of unique userids to control things properly.
-- (7 is plucked out of the air, matches the 7 in tree_nodes below)
-- (also feel free to use xxx[7]!=0 instead of find(7,toload)!=0..)

sequence {toload,tolkids} = columnize({{7,{"equilateral",
                                           "isoceles",
                                           "scalenus"}},
--                                     {8,{"some",      -- (works just fine, if)
--                                         "other",     -- (8 uncommented below)
--                                         "branch"}},
                                      })

procedure branchopen(object treenode)
    integer userid = dTreeGetUserId(treenode),
            k = find(userid,toload)
    if k!=0 then -- (deferred load rqd for this node)
        -- first kill off "dummy" (which ensured a '+'):
        gTreeDeleteChildren(treenode)
        sequence children = tolkids[k]
        gTreeAddNodes(treenode, children)
        -- finally remove load from the to-do lists:
        toload[k..k] = {}
        tolkids[k..k] = {}
    end if
    return XPG_DEFAULT;
end function

        sequence tree_nodes = {"Figures",               -- (branch with 5 children)
--                             {"STATE","COLLAPSED"},   --  (works fine, btw)
                               {"Other",                -- (leaf)
--                              {"triangle",            -- (branch with 3 children)
--                               {"STATE","COLLAPSED"},
--                               {"equilateral",
--                                "isoceles",
--                                "scalenus",
--                               }},
                                {"triangle",            -- (branch with 3 children)
                                 {"STATE","COLLAPSED","USERDATA",7},
                                 {"dummy"}},            -- (ensures we get a '+')
                                {"parallelogram",       -- (branch with 2 children)
                                 {"square",
                                  {"diamond",
                                   {"COLOR","92 92 255","TITLEFONT","Courier, 8"},
                                   0}   -- (nb: this is a leaf, non-optional here)
                                 }},
                                "2D",                   -- (leaf)
--                              {"2D"},                 -- (same)
--                              {"2D",0},               -- (same)
--                              {"2D",{},0},            -- (same)
                                {"3D",{}},              -- (branch, empty)
--                              {"4D",                  -- (works just fine, if)
--                                                      -- (8 uncommented above)
--                               {"STATE","COLLAPSED","USERDATA",8},
--                               {"dummy"}}             -- (branch, deferred load)
                               }
                              }
        gSetCallback(tree, "BRANCHOPEN",  branchopen));
--DEV...
        gTreeAddNodes(tree, tree_nodes)
</eucode-->
<pre>
<font color="#000080"><i>-- This shows how to defer-load nodes on expand/demand:
-- Obviuously would probably be more dynamically set in a real app,
-- and of course elements can be more than plain-string leaf nodes,
-- with daisy-chains of unique userids to control things properly.
-- (7 is plucked out of the air, matches the 7 in tree_nodes below)
-- (also feel free to use xxx[7]!=0 instead of find(7,toload)!=0..)
</i></font>
<font color="#004080">sequence</font><font color="#0000FF"> {</font><font color="#000000">toload</font><font color="#0000FF">,</font><font color="#000000">tolkids</font><font color="#0000FF">} =</font><font color="#7060A8"> columnize</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#800080">{</font><font color="#000000">7</font><font color="#0000FF">,</font><font color="#00FF00">{</font><font color="#008000">"equilateral"</font><font color="#0000FF">,</font>
<font color="#008000">                                           "isoceles"</font><font color="#0000FF">,</font>
<font color="#008000">                                           "scalenus"</font><font color="#00FF00">}</font><font color="#800080">}</font><font color="#0000FF">,</font>
<font color="#000080"><i>--                                     {8,{"some",      -- (works just fine, if)
--                                         "other",     -- (8 uncommented below)
--                                         "branch"}},</i></font>
<font color="#800000">                                      }</font><font color="#0000FF">)
</font>
<font color="#008080">procedure</font><font color="#000000"> branchopen</font><font color="#0000FF">(</font><font color="#004080">object</font><font color="#000000"> treenode</font><font color="#0000FF">)</font>
<font color="#004080">    integer</font><font color="#000000"> userid</font><font color="#0000FF"> =</font><font color="#000000"> dTreeGetUserId</font><font color="#0000FF">(</font><font color="#000000">treenode</font><font color="#0000FF">),</font>
<font color="#000000">            k</font><font color="#0000FF"> =</font><font color="#7060A8"> find</font><font color="#0000FF">(</font><font color="#000000">userid</font><font color="#0000FF">,</font><font color="#000000">toload</font><font color="#0000FF">)</font>
<font color="#008080">    if</font><font color="#000000"> k</font><font color="#0000FF">!=</font><font color="#000000">0</font><font color="#008080"> then</font><font color="#000080"><i> -- (deferred load rqd for this node)
        -- first kill off "dummy" (which ensured a &rsquo;+&rsquo;):</i></font>
<font color="#7060A8">        gTreeDeleteChildren</font><font color="#0000FF">(</font><font color="#000000">treenode</font><font color="#0000FF">)</font>
<font color="#004080">        sequence</font><font color="#000000"> children</font><font color="#0000FF"> =</font><font color="#000000"> tolkids</font><font color="#0000FF">[</font><font color="#000000">k</font><font color="#0000FF">]</font>
<font color="#7060A8">        gTreeAddNodes</font><font color="#0000FF">(</font><font color="#000000">treenode</font><font color="#0000FF">,</font><font color="#000000"> children</font><font color="#0000FF">)</font>
<font color="#000080"><i>        -- finally remove load from the to-do lists:</i></font>
<font color="#000000">        toload</font><font color="#0000FF">[</font><font color="#000000">k</font><font color="#0000FF">..</font><font color="#000000">k</font><font color="#0000FF">] = {}</font>
<font color="#000000">        tolkids</font><font color="#0000FF">[</font><font color="#000000">k</font><font color="#0000FF">..</font><font color="#000000">k</font><font color="#0000FF">] = {}</font>
<font color="#008080">    end if
    return</font><font color="#004600"> XPG_DEFAULT</font><font color="#0000FF">;</font>
<font color="#008080">end function
</font>
<font color="#004080">        sequence</font><font color="#000000"> tree_nodes</font><font color="#0000FF"> = {</font><font color="#008000">"Figures"</font><font color="#0000FF">,              </font><font color="#000080"><i> -- (branch with 5 children)
--                             {"STATE","COLLAPSED"},   --  (works fine, btw)</i></font>
<font color="#800000">                               {</font><font color="#008000">"Other"</font><font color="#0000FF">,               </font><font color="#000080"><i> -- (leaf)
--                              {"triangle",            -- (branch with 3 children)
--                               {"STATE","COLLAPSED"},
--                               {"equilateral",
--                                "isoceles",
--                                "scalenus",
--                               }},</i></font>
<font color="#800080">                                {</font><font color="#008000">"triangle"</font><font color="#0000FF">,           </font><font color="#000080"><i> -- (branch with 3 children)</i></font>
<font color="#00FF00">                                 {</font><font color="#008000">"STATE"</font><font color="#0000FF">,</font><font color="#008000">"COLLAPSED"</font><font color="#0000FF">,</font><font color="#008000">"USERDATA"</font><font color="#0000FF">,</font><font color="#000000">7</font><font color="#00FF00">}</font><font color="#0000FF">,</font>
<font color="#00FF00">                                 {</font><font color="#008000">"dummy"</font><font color="#00FF00">}</font><font color="#800080">}</font><font color="#0000FF">,           </font><font color="#000080"><i> -- (ensures we get a &rsquo;+&rsquo;)</i></font>
<font color="#800080">                                {</font><font color="#008000">"parallelogram"</font><font color="#0000FF">,      </font><font color="#000080"><i> -- (branch with 2 children)</i></font>
<font color="#00FF00">                                 {</font><font color="#008000">"square"</font><font color="#0000FF">,</font>
<font color="#000080">                                  {</font><font color="#008000">"diamond"</font><font color="#0000FF">,</font>
<font color="#008000">                                   {"COLOR"</font><font color="#0000FF">,</font><font color="#008000">"92 92 255"</font><font color="#0000FF">,</font><font color="#008000">"TITLEFONT"</font><font color="#0000FF">,</font><font color="#008000">"Courier, 8"}</font><font color="#0000FF">,</font>
<font color="#000000">                                   0</font><font color="#000080">}  <i> -- (nb: this is a leaf, non-optional here)</i></font>
<font color="#00FF00">                                 }</font><font color="#800080">}</font><font color="#0000FF">,</font>
<font color="#008000">                                "2D"</font><font color="#0000FF">,                  </font><font color="#000080"><i> -- (leaf)
--                              {"2D"},                 -- (same)
--                              {"2D",0},               -- (same)
--                              {"2D",{},0},            -- (same)</i></font>
<font color="#800080">                                {</font><font color="#008000">"3D"</font><font color="#0000FF">,</font><font color="#00FF00">{}</font><font color="#800080">}</font><font color="#0000FF">,             </font><font color="#000080"><i> -- (branch, empty)
--                              {"4D",                  -- (works just fine, if)
--                                                      -- (8 uncommented above)
--                               {"STATE","COLLAPSED","USERDATA",8},
--                               {"dummy"}}             -- (branch, deferred load)</i></font>
<font color="#800000">                               }</font>
<font color="#0000FF">                              }</font>
<font color="#000000">        gSetCallback</font><font color="#0000FF">(</font><font color="#000000">tree</font><font color="#0000FF">,</font><font color="#008000"> "BRANCHOPEN"</font><font color="#0000FF">, </font><font color="#000000"> branchopen</font><font color="#0000FF">)</font><font color="#00FFFF">)</font><font color="#0000FF">;</font>
<font color="#000080"><i>--DEV...</i></font>
<font color="#7060A8">        gTreeAddNodes</font><font color="#0000FF">(</font><font color="#000000">tree</font><font color="#0000FF">,</font><font color="#000000"> tree_nodes</font><font color="#0000FF">)</font>
</pre>
            </small><br>
            The output does differ slightly[??], in diamond and 2D (just run demo\xpGUI\sample.exw if at all worried about that), 
            but otherwise it should be fairly similar to (an image I already had):
            <br>
            <br>
            <img src="images/iuptree2_addbranch9.png"/>
            <br>
            <br>
            Note that USERDATA is generally useful for other purposes, and would normally be allocated sequentially on that basis, hence the
            "plucked out of the air" aspect: if you need to defer-load three nodes, avoid thinking that you must use {1,2,3}.
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
