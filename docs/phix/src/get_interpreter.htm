<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">get_interpreter</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
          <a href="string.htm">string</a> s = get_interpreter(<a href="integer.htm#bool">bool</a> bQuote=<a href="logicops.htm">false</a>, 
                                                              <a href="object.htm">object</a> mb=<a href="machine_bits.htm">machine_bits</a>(), 
                                                              <a href="integer.htm">integer</a> plat=<a href="platform.htm">platform</a>(),
                                                              <a href="integer.htm#bool">bool</a> bPrefW=<a href="logicops.htm">false</a>())
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Returns the full path and filename of a Phix executable, eg `C:\Program Files (x86)\Phix\pw.exe`, 
            or "" if no suitable interpreter could be found.
            <br>
            <br>
            You can find the implementation in builtins\get_interpreter.e (an autoinclude).
<!--            
            Note this routine should (forever) be considered incomplete/unscientific/experimental.<br>
            Every situation/installation/platform is subtly different, and this routine is expected to require more than its fair share 
            of tweaks and adjustments.<br>
            It is however much better than starting from scratch every time you need something along these lines, and of course any changes 
            are best made in a renamed copy rather than the original, to avoid them being obliterated by installing a new version of phix, 
            and ideally change the entry point in your version to say get_interpreter2(), to avoid any potential confusion.<br>
            All reasonable changes will be added to the next release, on request. <br>
            If this routine does not meet your needs, I might suggest that you store and use an explicit path instead, possibly defaulted 
            from this, ie one that might work, but when needed can be overridden by the user in some configuration dialog or plaintext file.
-->
            <br>
            <br>
            Things are usually much simpler when interpreting: there is a valid interpreter readily available in command_line()[1].<br>
            However, it also has to work when compiled, and not only on Windows/Linux, 32 and 64 bit, but also when run from anywhere.
<!--
            <br>
            Obviously, using get_interpreter() can be a bad idea if you are planning to release your application as a prebuilt binary.
-->
            <br>
            <br>
            It is important not to overly-rely on this routine working in situations over which you have no physical control.
            For instance, releasing a (pre-compiled) app which does not contain an interpreter (and builtins/ etc) and will therefore 
            only work on systems where phix has previously been installed is unlikely to win you any customers, unless you give very 
            clear instructions and/or use a failing get_interpreter() to trigger some kind of automatic download and installation.
            <br>
            <br>
            bQuote: can be true (1) to add double quotes around results containing spaces.<br>
            mb: primarily for testing purposes, but there may also be cases where you specifically require a 32 or 64 bit interpreter, 
            for example you might (as I do) only have a 32-bit libcurl.dll, so you need to fire off a 32bit interpreter to download some 
            file with that, even when the main app is 64bit.<br>
            plat: likewise for testing purposes, only in this case of no practical use for anything else that I can think of.<br>
            bPrefW: causes the search to look for (eg) "pw.exe" before "p.exe" or vice versa, no real effect on Linux.
            <br>
            <br>
            Note that an integer mb is advisory: if you ask for 32bit but all it can find is 64bit, it will return that, and vice versa, 
            but at least it looks thoroughly. Should that be unacceptable, pass {32} or {64} to be more strict about the result. You can 
            also (manually) create some or all of the files <wbr>"pw64.exe",<wbr>"p64.exe",<wbr>"pw32.exe",<wbr>"p32.exe",<wbr>
            "p64", <wbr>and <wbr>"p32", <wbr>in any of the directories it looks in, to ensure it can find the one you need.<br>
            (In contrast, plat is never advisory: not that there is any need for it, or any overlap in the filenames it searches for.)<br>
            It searches the path from command_line(), cropped such that ../Phix/demo/.. -&gt; ../Phix/, and current_dir() if different,
            plus anything in %PATH% that ends with "phix" or "bin" (case insensitive).<br>
            On Windows it also searches `C:\Program Files (x86)\Phix` and `C:\Program Files\Phix`.<br>
            On Linux it also searches %HOME%/phix.
         </td>
        </tr>
        <tr>
         <td>
          <b>Example:</b>
         </td>
         <td>
<!--eucode>
?get_interpreter() -- displays eg `C:\Program Files (x86)\Phix\p.exe`
                   -- or perhaps `/home/pete/phix/p` on Linux
</eucode-->
<pre>
<font color="#0000FF">?</font><font color="#5E005E">get_interpreter</font><font color="#0000FF">()</font><font color="#000080"><i> -- displays eg `C:\Program Files (x86)\Phix\p.exe`
                   -- or perhaps `/home/pete/phix/p` on Linux</i></font>
</pre>
            <a name=aux></a>
         </td>
        </tr>
        <tr>
         <td>
          <b>Auxillary routine:</b>
         </td>
         <td>
            <b>requires</b>(<a href="object.htm">object</a> x, <a href="integer.htm#bool">bool</a> bPrefW = false)
            <br>
            <br>
            If x is a string, eg "0.8.2", it compares it (intelligently) against <a href="version.htm">version</a>() and
            displays a message and terminates execution when necessary.
            <br>
            <br>
            If x is an integer between 0 and 31, it compares it against <a href="platform.htm">platform</a>() and displays 
            a message and terminates execution when necessary. Typically you would use <i>one</i> of the builtin constants
            such as WINDOWS or LINUX, however they are not bit-fields so special literals must be used for any combinations. 
            Examine the builtins/get_interpreter.e source to be sure, but 0: always crash, 5: Windows or Linux (not js), 
            6: Windows or JavaScript (not Linux), 7: any/never crash and 8: Linux or JavaScript (not Windows) can also be 
            used, and I think that just about covers every possible permutation.
            <br>
            <br>
            Otherwise x should be 32 or 64, which is compared against <a href="machine_bits.htm">machine_bits</a>() 
            and when necessary it uses get_interpreter(true,{x},platform(),bPrefW) to construct a suitable replacement 
            commandline, which it then offers to execute, before aborting, eg:
            <br>
            <br>
<!--eucode>
requires("0.8.2")                           -- crashes on 0.8.1 and earlier
requires(WINDOWS)                           -- crashes on Linux
printf(1,"running %d-bit\n",machine_bits())
requires(96-machine_bits()) -- (toggle 32<==>64 [a rather daft thing to do!])

-- example output (forever in this rather silly little case):
--running 32-bit
--requires 64 bit: "C:\Program Files\Phix\p.exe" "C:\Program Files (x86)\Phix\test.exw"
--Press Escape to abandon, Enter to retry as above...
--running 64-bit
--requires 32 bit: "C:\Program Files (x86)\Phix\p.exe" "C:\Program Files (x86)\Phix\test.exw"
--Press Escape to abandon, Enter to retry as above...
</eucode-->
<pre>
<font color="#5E005E">requires</font><font color="#0000FF">(</font><font color="#008000">"0.8.2"</font><font color="#0000FF">)                          </font><font color="#000080"><i> -- crashes on 0.8.1 and earlier</i></font>
<font color="#5E005E">requires</font><font color="#0000FF">(</font><font color="#004600">WINDOWS</font><font color="#0000FF">)                          </font><font color="#000080"><i> -- crashes on Linux</i></font>
<font color="#5E005E">printf</font><font color="#0000FF">(</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#008000">"running %d-bit\n"</font><font color="#0000FF">,</font><font color="#7060A8">machine_bits</font><font color="#800000">()</font><font color="#0000FF">)</font>
<font color="#5E005E">requires</font><font color="#0000FF">(</font><font color="#000000">96</font><font color="#0000FF">-</font><font color="#7060A8">machine_bits</font><font color="#800000">()</font><font color="#0000FF">)</font><font color="#000080"><i> -- (toggle 32&lt;==&gt;64 [a rather daft thing to do!])

-- example output (forever in this rather silly little case):
--running 32-bit
--requires 64 bit: "C:\Program Files\Phix\p.exe" "C:\Program Files (x86)\Phix\test.exw"
--Press Escape to abandon, Enter to retry as above...
--running 64-bit
--requires 32 bit: "C:\Program Files (x86)\Phix\p.exe" "C:\Program Files (x86)\Phix\test.exw"
--Press Escape to abandon, Enter to retry as above...</i></font>
</pre>
            <br>
            Of course the more sensible requires(32) or requires(64) would only display 0 or 1 such steps.<br>
            While the prompt may be mildly annoying, and no-one in their right mind would ever code the above, 
            it is reasonably likely a main app might start off with requires(64) but then include a component 
            that says requires(32), or vice versa, and without the pause it would spawn alternately/madly and 
            in all probability completely lock up the machine. For focus reasons (specifically Edita/Edix) a
            requires() call does not terminate until after the freshly-spawned subprocess has terminated.
            <br>
            <br>
            Should a bPrefW of -1 be specified, which is ok since it is a bool rather than a boolean, it is first replaced with 
            true/false depending on whether the existing <a href="command_line.htm">command_line</a>()[1] contains a 'w'. 
            The default of false is usually appropriate given that it has already opened a console window for that prompt, even 
            when running a gui application.
            <br>
            <br>
            You can also invoke <code>requires(-machine_bits())</code> to trigger a similar "requires restart" prompt.
            <br>
            <br>
            If no suitable interpreter can be found it displays an appropriate message instead.
            <br>
            <br>
            Of course requires(32/64) may have nothing to do with the actual code, but availability of pre-built dlls, for example.<br>
            It is perfectly possible to use a 32-bit compiler on a source containing format PE64|ELF64 and a requires(64) statement, 
            and vice versa, however some 64-bit constants may (rarely) end up getting cropped to 53 bits, so it is probably best to 
            avoid that sort of thing whenever possible. Originally, before I decided to construct an alternative commandline, requires()
            was substituted in the front-end at compiler time like <a href="version.htm">version</a>(), and that code has been left
            in but commented out: it may be possible to (partially) reinstate that to at least offer a warning (an outright ban would
            however cripple the compiler&rsquo;s own self-hosting, where such cross-compilation concerns happen to be one of the less 
            important things the "four rounds" mechanism described in <a href="Installation.htm">Installation</a> happens to solve).
         </td>
        </tr>
        <tr>
         <td>
          <b>Implementation:</b>
         </td>
         <td>
            See builtins\get_interpreter.e (an autoinclude) for details of the actual implementation.
         </td>
        </tr>
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="command_line.htm">command_line</a>,
          <a href="machine_bits.htm">machine_bits</a>,
          <a href="platform.htm">platform</a>,
          <a href="version.htm">version</a>
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
