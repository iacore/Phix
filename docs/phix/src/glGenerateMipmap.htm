<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">glGenerateMipmap</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
          include pGUI.e
          <br>
          include opengl.e
          <br>
          <br>
          glGenerateMipmap(<a href="integer.htm">integer</a> target)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            generate a complete set of mipmaps for a texture object
          <br>
          <br>
            target: Specifies the texture target of the active texture unit to which the texture object is bound whose mipmaps will be generated. <br>
            Must be one of the following symbolic constants: GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP.
            <br>
            <br>
            glGenerateMipmap computes a complete set of mipmap arrays derived from the zero level array. <br>
            Array levels up to and including the 1x1 dimension texture image are replaced with the derived arrays, regardless of previous contents. <br>
            The zero level texture image is left unchanged.
            <br>
            <br>
            The internal formats of the derived mipmap arrays all match those of the zero level texture image. <br>
            The dimensions of the derived arrays are computed by halving the width and height of the zero level texture image, then in turn halving 
            the dimensions of each array level until the 1x1 dimension texture image is reached.
            <br>
            <br>
            The contents of the derived arrays are computed by repeated filtered reduction of the zero level array. <br>
            No particular filter algorithm is required, though a box filter is recommended. <br>
            glHint may be called to express a preference for speed or quality of filtering.
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
          <a href="notpgui.htm"><span class="illegal">Not supported</span></a>.
         </td>
        </tr>
        <tr>
         <td>
          <b>Notes:</b>
         </td>
         <td>
            Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, 
            as long as the server sides of the contexts share the same address space. <br>
            If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well.
            <br>
            <br>
            Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
         </td>
        </tr>
        <tr>
         <td>
          <b>Errors:</b>
         </td>
         <td>
            GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP.<br>
            GL_INVALID_OPERATION is generated if the texture bound to target is a cube map, but its six faces do not share indentical widths, heights, formats, and types.<br>
            GL_INVALID_OPERATION is generated if either the width or height of the zero level array is not a power of two.<br>
            GL_INVALID_OPERATION is generated if the zero level array is stored in a compressed internal format.
         </td>
        </tr>
<!--
Example:
Create a texture object with linear mipmaps and edge clamping.
GLuint texture_id = glCreateTexture();
glBindTexture(GL_TEXTURE_2D, texture_id);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

// texture_data is the source data of your texture, in this case
// its size is sizeof(unsigned char) * texture_width * texture_height * 4
glTexImage2Dc(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_data);
glGenerateMipmap(GL_TEXTURE_2D); // Unavailable in OpenGL 2.1, use gluBuild2DMipmaps() insteads.

glBindTexture(GL_TEXTURE_2D, 0);
-->
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="glBindTexture.htm">glBindTexture</a>,
          <a href="xor_bits.htm">xor_bits</a>,
          <a href="glHint.htm">glHint</a>,
          <a href="glTexImage2D.htm">glTexImage2Dc</a>,
          <a href="glTexParameteri.htm">glTexParameteri</a>
          <br>
DEV
See Also
//glBindTexture, glFramebufferTexture2D, //glHint, //glTexImage2D, //glTexParameter
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
