<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">glGetProgramParameter</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
          include pGUI.e
          <br>
          include opengl.e
          <br>
          <br>
          <a href="integer.htm">integer</a> res = glGetProgramParameter(<a href="integer.htm">integer</a> program, pname, dflt=0)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            return the value of a parameter from a program object
          <br>
          <br>
            program: Specifies the program object to be queried.
            pname: Specifies the object parameter. Accepted symbolic names are listed below.<br>
            dflt: (optional) the value to return when an error occurs.<br>
            The opengl.e wrapper returns a result whereas the C api requires the address of a result variable
            to be provided as the third parameter, instead of/containing a pre-poked default.
          <br>
          <br>
            On desktop/Phix, this wraps the C <span class="illegal">glGetProgramiv</span> function (but with a different third argument).<br>
            The following parameters are defined:
            <br>
            <br>
            GL_DELETE_STATUS returns GL_TRUE if program is currently flagged for deletion, and GL_FALSE otherwise.
            <br>
            <br>
            GL_LINK_STATUS returns GL_TRUE if the last link operation on program was successful, and GL_FALSE otherwise.
            <br>
            <br>
            GL_VALIDATE_STATUS returns GL_TRUE or if the last validation operation on program was successful, and GL_FALSE otherwise.
<!--
            <br>
            <br>
            GL_INFO_LOG_LENGTH returns the number of characters in the information log for program including the null termination 
            character (i.e., the size of the character buffer required to store the information log). <br>
            If program has no information log, a value of 0 is returned.
-->
            <br>
            <br>
            GL_ATTACHED_SHADERS returns the number of shader objects attached to program.
            <br>
            <br>
            GL_ACTIVE_ATTRIBUTES returns the number of active attribute variables for program.
            <br>
            <br>
            GL_ACTIVE_ATTRIBUTE_MAX_LENGTH returns the length of the longest active attribute name for program, including 
            the null termination character (i.e., the size of the character buffer required to store the longest attribute name). <br>
            If no active attributes exist, 0 is returned.
            <br>
            <br>
            GL_ACTIVE_UNIFORMS returns the number of active uniform variables for program.
            <br>
            <br>
            GL_ACTIVE_UNIFORM_MAX_LENGTH returns the length of the longest active uniform variable name for program, including 
            the null termination character (i.e., the size of the character buffer required to store the longest uniform variable name). <br>
            If no active uniform variables exist, 0 is returned.
            <br>
            <br>
            Note that <span class="illegal">GL_INFO_LOG_LENGTH</span> is not supported by WebGL and hence pwa/p2js, instead opengl.e 
            uses it internally as part of the automatic buffer management. Technically it still works on the desktop and is permitted
            by the transpiler (since it is valid inside a platform()!=JS test), but generates an explicit runtime crash in pGUI.js.
         </td>
        </tr>
        <tr>
         <td>
          <b>Notes:</b>
         </td>
         <td>
<!--
            If an error is generated, no change is made to the contents of params.
-->
            If an error is generated, the specified default is returned, but checking that glGetError() does not return GL_NO_ERROR should
            normally be used to verify an error did actually occur, unless an otherwise invalid default is provided.
         </td>
        </tr>

        <tr>
         <td>
          <b>Errors:</b>
         </td>
         <td>
            GL_INVALID_ENUM is generated if pname is not an accepted value.<br>
            GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.<br>
            GL_INVALID_OPERATION is generated if program does not refer to a program object.
         </td>
        </tr>
        <tr>
         <td>
          <b>Associated Gets:</b>
         </td>
         <td>
            glGetActiveAttrib with argument program<br>
            glGetActiveUniform with argument program<br>
            glGetAttachedShaders with argument program<br>
            <a href="glGetProgramInfoLog.htm">glGetProgramInfoLog</a> with argument program<br>
            glIsProgram
         </td>
        </tr>
<!--
Examples
Retrieve uniform data after the shader has been compiled
// The index returned from these GLint functions gets passed to glEnableVertexAttribArray during rendering.
GLint position_attrib_index = glGetAttribLocation(program, "position"); // program is what is returned by glCreateProgram.
GLint texcoord_attrib_index = glGetAttribLocation(program, "texcoord");
GLint normal_attrib_index = glGetAttribLocation(program, "normal");
GLint color_attrib_index = glGetAttribLocation(program, "color");

glBindFragDataLocation(program, 0, "output_color"); // "output_color" is an output value in your vertex shader and an input value in your fragment shader.

GLint num_uniforms;
>>glGetProgramParameter
glGetProgramiv(program, GL_ACTIVE_UNIFORMS, &num_uniforms);
GLchar uniform_name[256];
GLsizei length;
GLint size;
GLenum type;
for (int i = 0; i < num_uniforms; i++)
{
    glGetActiveUniform(program, i, sizeof(uniform_name), &length, &size, &type, uniform_name);
    // ... save this uniform data so it can be used during rendering
}
Compile a program from a vertex shader and a fragment shader.
GLuint vshader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vshader, 1, &vertex_shader_source, NULL); // vertex_shader_source is a GLchar* containing glsl shader source code
glCompileShader(vshader);

GLint vertex_compiled;
>>glGetShaderParameter
glGetShaderiv(vshader, GL_COMPILE_STATUS, &vertex_compiled);
if (vertex_compiled != GL_TRUE)
{
    GLsizei log_length = 0;
    GLchar message[1024];
    glGetShaderInfoLog(vshader, 1024, &log_length, message);
    // Write the error to a log
}

GLuint fshader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fshader, 1, &fragment_shader_source, NULL); // fragment_shader_source is a GLchar* containing glsl shader source code
glCompileShader(fshader);

GLint fragment_compiled;
>>glGetShaderParameter
glGetShaderiv(fshader, GL_COMPILE_STATUS, &fragment_compiled);
if (fragment_compiled != GL_TRUE)
{
    GLsizei log_length = 0;
    GLchar message[1024];
    glGetShaderInfoLog(fshader, 1024, &log_length, message);
    // Write the error to a log
}

GLuint program = glCreateProgram();

// This step is unnecessary if you use the location specifier in your shader
// e.g. layout (location = 0) in vec3 position;
glBindAttribLocation(program, 0, "position"); // The index passed into glBindAttribLocation is
glBindAttribLocation(program, 1, "texcoord"); // used by glEnableVertexAttribArray. "position"
glBindAttribLocation(program, 2, "normal");   // "texcoord" "normal" and "color" are the names of the
glBindAttribLocation(program, 3, "color");    // respective inputs in your fragment shader.

glAttachShader(program, vshader);
glAttachShader(program, fshader);
glLinkProgram(program);

GLint program_linked;
>>glGetProgramParameter
glGetProgramiv(program, GL_LINK_STATUS, &program_linked);
if (program_linked != GL_TRUE)
{
    GLsizei log_length = 0;
    GLchar message[1024];
    glGetProgramInfoLog(program, 1024, &log_length, message);
    // Write the error to a log
}
-->
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="glAttachShader.htm">glAttachShader</a>,
          <a href="glCreateProgram.htm">glCreateProgram</a>,
          <a href="glCreateShader.htm">W</a>,
          <a href="glGetShaderParameter.htm">glGetShaderParameter</a>,
          <a href="glLinkProgram.htm">glLinkProgram</a>,
          <a href="glGenLists.htm">Z</a>
<br>
DEV 
See Also
//glAttachShader, //glCreateProgram, glDeleteProgram, //glGetShaderParameter, //glLinkProgram, glValidateProgram
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
