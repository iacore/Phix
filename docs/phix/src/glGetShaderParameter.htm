<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">glGetShaderParameter</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
          include pGUI.e
          <br>
          include opengl.e
          <br>
          <br>
          <a href="integer.htm">integer</a> res = glGetShaderParameter(<a href="integer.htm">integer</a> shader, pname, dflt=0)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            return the value of a parameter from a shader object
          <br>
          <br>
            shader: Specifies the shader object to be queried.<br>
            pname: Specifies the object parameter. Accepted symbolic names are listed below.<br>
            dflt: (optional) the value to return when an error occurs.<br>
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
          Supported.
         </td>
        </tr>
        <tr>
         <td>
          <b>Notes:</b>
         </td>
         <td>
            The opengl.e wrapper returns a result whereas the C api requires the address of a result variable
            containing a pre-poked default to be provided as the third parameter.
          <br>
          <br>
            On desktop/Phix, this wraps the C <span class="illegal">glGetShaderiv</span> function (but with a different third argument).
            <br>
            <br>
            The following parameters are defined:
            <br>
            <br>
            GL_SHADER_TYPE returns GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.
            <br>
            <br>
            GL_DELETE_STATUS returns true if shader is currently flagged for deletion.
            <br>
            <br>
            GL_COMPILE_STATUS returns false if the last compile operation on shader was unsuccessful.
            <br>
            <br>
<!--
            GL_INFO_LOG_LENGTH For implementations that support a shader compiler, returns 
            the number of characters in the information log for shader including the null termination 
            character (i.e., the size of the character buffer required to store the information log). <br>
            If shader has no information log, a value of 0 is returned.
            <br>
            <br>
            <span class="illegal">GL_SHADER_SOURCE_LENGTH</span> For implementations that support a shader compiler, 
            returns the length of the concatenation of the source strings that make up the shader 
            source for the shader, including the null termination character. (i.e., the size of the 
            character buffer required to store the shader source). <br>
            If no source code exists, 0 is returned.
-->
            Note that <span class="illegal">GL_INFO_LOG_LENGTH</span> and <span class="illegal">GL_SHADER_SOURCE_LENGTH</span>
            are not supported by WebGL and hence pwa/p2js, instead opengl.e uses them internally as part of the automatic 
            buffer management. Technically they still work on the desktop and are permitted by the transpiler (since they 
            are valid inside a platform()!=JS test), but generate an explicit runtime crash in pGUI.js.
            <br>
            <br>
            Technically shader compiler support is optional, however opengl.e and pwa/p2js simply assume it is always available.
<!--
            Shader compiler support is optional, and thus must be queried before use by calling glGet with argument GL_SHADER_COMPILER. <br>
            glShaderSource, glCompileShader, glGetShaderPrecisionFormat, and glReleaseShaderCompiler will each generate GL_INVALID_OPERATION 
            on implementations that do not support a shader compiler, as will glGetShaderiv queries of GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, 
            and <span class="illegal">GL_SHADER_SOURCE_LENGTH</span>. <br>
            Such implementations instead offer the glShaderBinary alternative for supplying a pre-compiled shader binary.
-->
            <br>
            <br>
<!--
            If an error is generated, no change is made to the contents of params.
-->
            If an error is generated the specified default is returned, however explicitly checking glGetError()!=GL_NO_ERROR should 
            normally be used to verify that an error did actually occur, unless that is the said default is unequivocably invalid.
         </td>
        </tr>

        <tr>
         <td>
          <b>Errors:</b>
         </td>
         <td>
            GL_INVALID_ENUM is generated if pname is not an accepted value.<br>
            GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.<br>
            GL_INVALID_OPERATION is generated if pname is GL_COMPILE_STATUS, <span class="illegal">GL_INFO_LOG_LENGTH</span>, or 
            <span class="illegal">GL_SHADER_SOURCE_LENGTH</span> but a shader compiler is not supported.<br>
            GL_INVALID_OPERATION is generated if shader does not refer to a shader object.
         </td>
        </tr>
        <tr>
         <td>
          <b>Associated Gets:</b>
         </td>
         <td>
            glGet with argument GL_SHADER_COMPILER<br>
            <a href="glGetShaderInfoLog.htm">glGetShaderInfoLog</a> with argument shader<br>
            glGetShaderSource with argument shader<br>
            glIsShader
         </td>
        </tr>
<!--
Examples
Compile a program from a vertex shader and a fragment shader.
GLuint vshader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vshader, 1, &vertex_shader_source, NULL); // vertex_shader_source is a GLchar* containing glsl shader source code
glCompileShader(vshader);

GLint vertex_compiled;
>>glGetShaderParameter
glGetShaderiv(vshader, GL_COMPILE_STATUS, &vertex_compiled);
if (vertex_compiled != GL_TRUE)
{
    GLsizei log_length = 0;
    GLchar message[1024];
    glGetShaderInfoLog(vshader, 1024, &log_length, message);
    // Write the error to a log
}

GLuint fshader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fshader, 1, &fragment_shader_source, NULL); // fragment_shader_source is a GLchar* containing glsl shader source code
glCompileShader(fshader);

GLint fragment_compiled;
>>glGetShaderParameter
glGetShaderiv(fshader, GL_COMPILE_STATUS, &fragment_compiled);
if (fragment_compiled != GL_TRUE)
{
    GLsizei log_length = 0;
    GLchar message[1024];
    glGetShaderInfoLog(fshader, 1024, &log_length, message);
    // Write the error to a log
}

GLuint program = glCreateProgram();

// This step is unnecessary if you use the location specifier in your shader
// e.g. layout (location = 0) in vec3 position;
glBindAttribLocation(program, 0, "position"); // The index passed into glBindAttribLocation is
glBindAttribLocation(program, 1, "texcoord"); // used by glEnableVertexAttribArray. "position"
glBindAttribLocation(program, 2, "normal");   // "texcoord" "normal" and "color" are the names of the
glBindAttribLocation(program, 3, "color");    // respective inputs in your fragment shader.

glAttachShader(program, vshader);
glAttachShader(program, fshader);
glLinkProgram(program);

GLint program_linked;
>>glGetProgramParameter
glGetProgramiv(program, GL_LINK_STATUS, &program_linked);
if (program_linked != GL_TRUE)
{
    GLsizei log_length = 0;
    GLchar message[1024];
    glGetProgramInfoLog(program, 1024, &log_length, message);
    // Write the error to a log
}
-->
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="glCompileShader.htm">glCompileShader</a>,
          <a href="glCreateShader.htm">glCreateShader</a>,
          <a href="glDeleteShader.htm">glDeleteShader</a>,
          <a href="glGetProgramParameter.htm">glGetProgramParameter</a>,
          <a href="glShaderSource.htm">glShaderSource</a>,
          <a href="glGenLists.htm">z</a>
<br>
DEV 
See Also
//glCompileShader, //glCreateShader, //glDeleteShader, //glGetProgramParameter, //glShaderSource, glShaderBinary
         </td>
        </tr>
       </table>
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
