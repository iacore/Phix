<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">JavaScript in pwa/p2js</h1>
      <div id="mainSection">
        Obviously more complete references can be found easily enough - the whole point of this is to hook
        into the Edita/Edix F1 Help system, and that way speed up the development of pwa/p2js itself.
        <br>
        <br>
        Partly this covers the use of JavaScript in p2js.js (badly named?) and pGUI.js, it also provides
        some explanation of the code generated by pwa/p2js and placed in the &lt;script&gt; section of 
        the resulting .html file.
        <br>
        <br>
        Transpilation is largely a mechanical process of mapping between language syntax and compatible 
        features, for example "procedure p() end procedure" &lt;==&gt; "function p() { }" (with no return
        statement).
        <br>
        <br>
        Javascript is a typeless language, however I would prefer to keep the output legible so have opted 
        for eg "integer i" &lt;==&gt; "let /*integer*/ i;".
        <br>
        <br>
        Phix sequences are actually a much closer match to JavaScript Arrays than Objects, so we use []
        syntax rather than {}. Phix sequences are 1-based, whereas Javascript Arrays are (loosely) 
        0-based, so we use eg `{1,2,3}` &lt;==&gt; `["sequence",1,2,3]`.
        <br>
        <br>
        JavaScript strings are immutable (and 0-based), and JavaScript has no concept of a character, so
        we have eg `s[i]` &lt;==&gt; `s.charCodeAt(i-1)` and such monstrosities as "s[i] = 'A'" &lt;==&gt; 
        `s.splice(i-1,i,String.fromCharCode(65))`. Note that for this to work you may need to be more
        explicit with the string type, eg "initial = table[i][NAME][1]" won&rsquo;t work and instead you
        will need to code "string name = table[i][NAME]; initial = name[1]".
        <br>
        <br>
        Phix is a reference counted language with copy-on-write semantics, which poses some problems as
        JavaScript is anything but that. So sequence a = b may have to perform a deep copy, but since that
        can be expensive it should scan the AST to see if it can be avoided (obviously if it is not being
        modified, but also if it is reassigned when the function returns). I toyed with a = ...b before
        realising the spread operator only does a shallow copy, so now it uses a = $clone(b); [DEV]
        <br>
        <br>
<!--
//
// Part 1: utilities puts(), crash(), and [s]printf().
// ==================================================
//
// Aside: js allows $ in identifiers; we use that fact to effectively
//        "hide" things from p2js.exw generated code. For instance,
//        statics like $docbody and $seed, as well as local constants
//        such as $PROC and $FUNC, and also internal/private helpers 
//        such as $tce() and $_apply().
//
// Style conventions
// =================
//  Use phix_style_underscores where appropriate (ie direct mapping)
//  Use javaScriptStyleCamelCase where that seems /more/ appropriate
//  Use a very light dusting of bHungarianNotation (eg 'b' for bool)
//  Use $ident for any globals that must never, ever clash with phix
//
//  Very much a judgment call, eg $prefer_backtick suggests there is
//  something relevant in Phix.chm, whereas bAsV and zeroE are only
//  to be found in here. In practice, underscore_variables heavily
//  outnumber camelCase here, simply because the vast majority /are/
//  based on something in phix.
//
// Quickref:
// =========
//  "ABC".charAt(0) is "A" (a length-1 string)
//      equiv to "ABC".slice(0, 1);
//  "ABC".charCodeAt(0) is 65
//  String.fromCharCode(65) is "A"
//  String.fromCharCode(65,66,67) is "ABC" [?spread ... operator ?]
//
let $docbody = document.body;   // (override if required, eg like
                                //  the result panel on codepen.)

function puts(fn, text) {
    integer(fn,"fn");
//  string(text,"text");
    if (fn !== 1 && fn !== 2) { crash("fn must be 1 or 2"); }
    const am = new RegExp("&","g"),
          lt = new RegExp("[<]","g"),
          gt = new RegExp("[>]","g"),
          sp = new RegExp("[ ][ ]","g"),
          lf = new RegExp("\\n","g");
    text = text.replace(am,"&amp;")
               .replace(lt,"&lt;")
               .replace(gt,"&gt;")
               .replace(sp,"&nbsp;&nbsp;")
               .replace(lf,"<br>");
    let where = (fn === 2 ? "afterbegin" : "beforeend");
    $docbody.insertAdjacentHTML(where, text);
}

//const lf = /(\n)/g;
//puts(2,lf.toString());

function crash(msg, args = []) {
//  string(msg,"msg");
//  object(args,"args");
//  let s = "***ERROR***: " + msg + "<br>"
//  let s = "crash: " + msg + "\n"
//  document.body.insertAdjacentHTML("beforeend", s);
//  document.body.insertAdjacentHTML("afterbegin", s);
//  $docbody.insertAdjacentHTML("afterbegin", s);
//  puts(2,s);
    puts(2,msg);
    throw(new Error(msg));
}

function $tce(name, x) {
    if (name.length !== 0) {
        if (x === 'undefined') {
            crash('variable %s has not been assigned a value.',[name]);
        } else {
            crash('typecheck error, %s is %v',[name,x]);
        }
    }
    return false;
}

function integer(i, name = "") {
//
// invoke as (eg) integer(fn) to test, integer(fn,"fn") to typecheck.
//
    if (!Number.isSafeInteger(i)) {
        return $tce(name,i);
    }
    return true;
}

function atom(a, name = "") {
    if (!isFinite(a)) {
        return $tce(name,a);
    }
    return true;
}

let $prefer_backtick = false;

function sprintf(fmt, args = []) {
//function sprintf(fmt, args = ["sequence"]) {
    //
    // Should give reasonable approximation to the Phix sprintf() builtin,
    //        but is rather unlikely to ever be 100% absolutely perfect...
    //
    // Known omissions and differences:
    //      %v outputs [] rather than {}. (A simple substitution would, of
    //          course, also swap them within nested strings, etc...)
    //      "inf" and "nan" are output as "Infinity" and "NaN" (so what?!)
    //      rounding errors, eg: "%5.2f",0.005 ==> Phix: " 0.00", this: " 0.01"
    //                           "%5.2f",0.015 ==> Phix: " 0.02", this: " 0.01"
    //         (see builtins\VM\pFPU.e which is not something I can or
    //          would ever want to attempt in a cross-browser fashion.)
    //      "%g" has strange rules for picking "%e" over "%f" in Phix (===Eu),
    //          whereas this just uses a much simpler "is shorter or f=0" test.
    //      This may very well accept nonsense specifiers, producing gibberish.
    //         (I have no interest in testing anything VM/pprntfN.e rejects.)
    //      See also pwa\printf_tests.html
    //
    string(fmt,"fmt");
//DEV/temp(?): (or, maybe, i=0)
    let i = -1;
//  string(fmt,"fmt");
//  object(args,"args");
//  let i = 0;

    function stri(bAsV = false) {
        let res = argi();
        if (type of(res) !== "string") {
            if (bAsV) {
                res = JSON.stringify(res);                  // (ie/for "%v")
            } else {
                if (Array.isArray(res)) {
                    // compatibility shim: Phix/sprintf() treats eg "ABC",
                    // {'A','B','C'}, and {65[.1],66,67} exactly the same.
                    let allChar = true,
                        sres = "";
                    for (let i = 0; i < res.length; i += 1) {
                        let ch = res[i];
                            if (!Number.isInteger(ch) || ch<0 || ch>255) {
                                allChar = false;
                                break;
                            }
                            sres += String.fromCharCode(ch);
                    }
                    if (allChar) { return sres; }
                }
                crash('Invalid (string expected)');
            }
        }
        return res;
    }
    function inti(unsigned = false) {
        let res = argi();
        if (!Number.isInteger(res)) {
            res = Math.floor(res);
//          res = Math.round(res - res % 1); // (maybe..)
        }
        if (unsigned) {
            res = res >>> 0; // (casts -ve to +ve)
//          res = Math.abs(res);
        }
        return res;
    }
    function flti() {
        let res = argi();
        return res;
    }
//  function eorf(precision: number): number {  // (ie "%g") // NO!
//  function eorf(precision/*: number*/)/*: string*/ {  // (ie "%g")
    function eorf(/* integer */ precision) {    // (ie "%g")
//  function eorf(precision) {  // (ie "%g")

        let eres = flti().toExponential(precision);
        const zeroE = new RegExp("([.][0]+e|[0]+e)");
        const Ezero = new RegExp("(e\\+0$)");
        eres = eres.replace(zeroE,"e");             // eg "1.000000e14" -> "1e14"
        eres = eres.replace(Ezero,"");              // eg        "1e+0" -> "1"

        let fres = flti().toFixed(precision);
        if (fres.indexOf('.') != -1) {
            const Fzero = new RegExp("([.]?[0]+$)");    // eg "10.2300" -> "10.23"
            fres = fres.replace(Fzero,"");              // or "1023.00" -> "1023"
        }

        // note this will often disagree with the Phix/Eu output/choice
        //  (they pick %e for "(exponent>=precision or exponent<-4)")
        let res = eres.length<fres.length || parseFloat(fres) === 0 ? eres : fres;
        return res;
    }

    function allascii(x, enquote = 'q') {
        let backtick = (enquote === 'q');
        let bsi = [];
        for (let i = x.length-1; i >= 0; i -= 1) {
            let c = x[i];
            if (c === '\\' || c === '\"' || c === '\'') {
                if (backtick) {
//                  bsi &= i
                    bsi.push(i);
                } else {
//                  x[i..i] = '\\'&c    -- NB does not work on RDS Eu/OpenEuphoria
                    x = x.slice(0,i) + '\\' + x.slice(i);
                }
            } else if (c<' ' || c>'~') {
                if (c === '\t') { c='t'; }
                else if (c === '\n') { c='n'; }
                else if (c === '\r') { c='r'; }
                else if (c === '\0') { c='0'; }
                else { return 0; }
                if (backtick) {
                    for (let j = 0; j < bsi.length; j += 1) {
                        let k = bsi[j];
//                      x[k..k] = '\\'&x[k]
                        x = x.slice(0,k) + '\\' + x.slice(k);
                    }
                    backtick = false;
                }
//              x[i..i] = '\\'&c    -- NB does not work on RDS Eu/OpenEuphoria
                x = x.slice(0,i) + '\\' + x.slice(i);
            }
        }
        if (backtick && ($prefer_backtick || bsi.length !== 0)) {
            x = '`' + x + '`';
        } else {
            x = '"' + x + '"';
        }
        return x;
    }

    function callback(expr, sign, size, dot, precision, specifier) {
        //
        // Replaces a single formatting specification:
        // expr is eg "%4.2f" or "%-20s" (the whole thing)
        // sign is eg '-' or one of "+,=|", or undefined
        // size is eg "4" (leading 0 === zero-fill, "")
        // dot is eg ".2" or "." or undefined
        // precision is eg "2" or undefined
        // specifier is eg 's' or one of "tcvdboxXeEfgG%"
        //
        if (expr === '%%') { return '%'; }  // (aka specifier === '%')
        i += 1;
        precision = precision ? parseInt(precision) : dot ? 0 : 6;
        let res = "";
        switch (specifier) {
            case 's': res = stri(); break;
            case 'q': res = allascii(stri(),specifier); break;
            case 'Q': res = allascii(stri(),specifier); break;
            case 't': res = argi()?"true":"false"; break;
            case 'c': res = String.fromCharCode(argi()); break;
            case 'v': res = stri(true); break;
            case 'd': res = inti().toString(10); break;
            case 'b': res = inti().toString(2); break;
            case 'o': res = inti().toString(8); break;
            case 'x': res = inti(true).toString(16).toUpperCase(); break;
            case 'X': res = inti(true).toString(16); break; //^yep===Phix
            case 'e': res = flti().toExponential(precision); break;
            case 'E': res = flti().toExponential(precision).toUpperCase(); break;
            case 'f': res = flti().toFixed(precision); break;
            case 'g': res = eorf(precision); break;
            case 'G': res = eorf(precision).toUpperCase(); break;
            default: crash("unrecognised specifier");
        }
        if (sign === ',') {
            if ("df".indexOf(specifier) === -1) {
                crash('comma only permitted on %d and %f');
            }
            let showcommas = res.indexOf('.');
            if (showcommas === -1) { showcommas = res.length; }
            let lim = "-+".indexOf(res[0]) === -1 ? 3 : 4;
            while (showcommas>lim) {
                showcommas -= 3;
                res = res.slice(0,showcommas) + ',' + res.slice(showcommas);
            }
        }
        else if (sign === '+' && res[0] !== '-') {
            res = '+' + res;
        }
        if (size) {
            let pad = (size[0] === '0' && "-+=|".indexOf(sign) === -1 && res.indexOf('-') === -1) ? '0' : ' ';
            let padlen = parseInt(size)-res.length;
            if (padlen>0) {
                let half = Math.floor(padlen/2);
                switch (sign) {
                    case '=': res = pad.repeat(half) + res + pad.repeat(padlen-half); break;
                    case '|': res = pad.repeat(padlen-half) + res + pad.repeat(half); break;
                    case '-': res = res + pad.repeat(padlen); break;
                    default : res = pad.repeat(padlen) + res; break;
                }
            }       
        }       
        return res;
    }
    //
    // Replace each %[sign][[0]size][.[precision]]specifier (eg "%,7.2f") in turn
    //  (where sign is one of "-+=|," or undefined)
    //
//  const regex = /%([-+=|,])?(0?[0-9]+)?([.]([0-9]+)?)?([stcvdboxXeEfgG%])/g;
//puts(2,regex.toString());
//  const regex = new RegExp('/%([-+=|,])?(0?[0-9]+)?([.]([0-9]+)?)?([stcvdboxXeEfgG%])/g');
    const regex = new RegExp("%([-+=|,])?(0?[0-9]+)?([.]([0-9]+)?)?([sqQtcvdboxXeEfgG%])",'g');
    return fmt.replace(regex, callback);
}

function printf(fn, fmt, args = []) {
//  integer(fn,"fn");
//  string(fmt,"fmt");
//  object(args,"args");
    if (fn === 0 && fmt === "") {
        for (let i = 0; i < args.length; i += 2) {
            if (args[i] === 'prefer_backtick') {
                $prefer_backtick = args[i+1];
            } else {
                // sug: simply ignore 'unicode_align'?
                crash("unsupported printf option " + args[i]);
            }
        }
    } else {
        puts(fn,sprintf(fmt, args));
    }
}

// DEV/DOC: this is flattened...
//print(1,[[[[1,3]]],"this",3.1425,[5,7],11]) // (flattened...!)
function sprint(o) {
//  object(o,"o");
    let res = o.toString();
    if (Array.isArray(o)) {
        res = "{" + res + "}";
//      res = "{" + res.splice(1).toString + "}";
    }
    return res;
}

function print(fn, o) {
//  integer(fn,"fn");
//  object(o,"o");
    puts(fn,sprint(o) + "\n");
}

//DEV why not just use builtins/pfactors.e, transpiled?
function factors(num, include1 = 0) {
//  sequence(num,"num");
//  integer(include1,"include1");
    let n_factors = [],
        h_factors = [],
        i0 = include1 === 0 ? 2 : 1;
 
    for (let i = i0; i <= Math.floor(Math.sqrt(num)); i += 1) {
        if (num % i === 0) {
            n_factors.push(i);
            let ni = num/i;
            if ((ni !== i) && (ni !== num || include1 === 1)) {
//              n_factors.push(ni);
                h_factors.push(ni);
            }
        }
    }
//  n_factors.sort(function(a, b){return a - b;});  // numeric sort
    n_factors = n_factors.concat(h_factors.reverse());
    return n_factors;
}
 
//print(1,factors(45,1));  // [1,3,5,9,15,45] 
//print(1,factors(53,1));  // [1,53] 
//print(1,factors(64,1));  // [1,2,4,8,16,32,64]

//DEV why not just use builtins\psum.e, transpiled?
function sum(x) {
//  object(x,"x");
    let total = 0;
    for (let i = 0; i < x.length; i += 1) {
        let xi = x[i];
        total += xi;
    }
    return total;
}

function product(x) {
//  object(x,"x");
    let res = 1;
    for (let i = 0; i < x.length; i += 1) {
        let xi = x[i];
        res *= xi;
    }
    return res;
}

//let s = [1,2,3,4,5];
//printf(1,"sum is %d\n",sum(s));
//printf(1,"prod is %d\n",product(s));

function append(a, x) {
//  object(a,"a");
//  object(x,"x");
        if (!Array.isArray(a)) {
            a = [a];
        }
        a.push(x);
//  a.push(newElement); === a = append(a,newElement);
    return a;
}

function prepend(a, x) {
//  object(a,"a");
//  object(x,"x");
        if (!Array.isArray(a)) {
            a = [a];
        }
        a = [x].concat(a);
    return a;
}

//let s = [1,2,3,4,5];
//print(1,append(s,6));
//print(1,prepend(s,0));

function wait_key() {
    // specifically for "{} = wait_key()", do nothing
    return [];
}

// undocumented below here...
// none of these have been tested either...

function length(o) {
    if (sequence(o)) {
        return o.length-1;
    }
    crash("length of an atom is not defined");
}

function compare(a, b) {
// crikeybobs... (mind you, this is not unlike what the desktop #ilASM{} gets up to...)
    if (Array.isArray(a)) {
        b = Array.from(b);
        if (Array.isArray(b)) {
            let la = length(a),
                lb = length(b);
            for (let i = 1; i <= Math.min(la, lb); i += 1) {
                let c = compare(a[i], b[i]);
                if (c !== 0) { return c; }
            }
            if (la < lb) {
                return -1;
            } else if (la === lb) {
                return 0;
            } else {
                return 1;
            }
        }
        return -1;
    }
    if (typeof(a) === "string") {
        if (Array.isArray(b)) {
            return compare(Array.from(a), b);
        }
        if (typeof(b) === "string") {
            return a.localeCompare(b);
        }
        return 1;
    }
    if (a < b) {
        return -1;
    } else if (a === b) {
        return 0;
    } else {
        return 1;
    }
//  crash("compare not implemented!");
//  return 0;
}

function equal(a, b) {
// crikeybobs... (mind you, this is not unlike what the desktop #ilASM{} gets up to...)
    if (Array.isArray(a)) {
        if (Array.isArray(b)) {
            let la = length(a);
            if (la !== length(b)) { return false; }
            for (let i = 1; i <= la; i += 1) {
                let c = equal(a[i], b[i]);
                if (!c) { return c; }
            }
            return true;
        }
        return false;
    }
    if (typeof(a) === "string") {
        if (Array.isArray(b)) {
            return equal(Array.from(a), b);
        }
        if (typeof(b) === "string") {
            return (a === b);
        }
        return false;
    }
    return (a === b);
}


//DEV would the hll versions be fine???
//DOC: not strings: (nah, just fix it!)
//***NB*** these all need thorough testing for eg start vs. start-1, etc... [not that we build sequences proper like yet...]
function find(needle, haystack, start = 1) {
    if (!Array.isArray(haystack) || haystack[0] !== "sequence") {
        crash("second argument to find() must be a sequence");
    }
    let idx = haystack.indexOf(needle, start);
    if (idx === -1) { idx = 0; }
    return idx; // 1-based
}

function rfind(needle, haystack, start = -1) {
    if (!Array.isArray(haystack) || haystack[0] !== "sequence") {
        crash("second argument to find() must be a sequence");
    }
    // aside: haystack.length includes [0] aka +1:
    if (start < 0) { start += haystack.length; }
    let idx = haystack.lastIndexOf(needle,start);
//  if (idx === 0) { idx = -1; }    // (jic)
    if (idx === -1) { idx = 0; }
    return idx; // 1-based
}

//DOC: strings only:
function match(needle, haystack, start = 1, case_sensitive = true) {
    if (!case_sensitive) {
        needle = needle.toLowerCase();
        haystack = haystack.toLowerCase();
    }
//  let idx = haystack.indexOf(needle,start)+1;
    let idx = haystack.indexOf(needle,start);
    if (idx === -1) { idx = 0; }
    return idx; // 1-based
}

// (equivalent to phix's infix & operator [I hope!])
//$_concat()? <==> &
function $_concat(a, b) {
        if (!Array.isArray(a)) {
            a = ["sequence",a];
        }
        if (Array.isArray(b)) {
            a = a.concat(b.slice(1));
        } else {
            a = a.concat(b);
        }
    return a;
}

//DOC note that strings of length 1 are treated as chars
//      (unlike phix, in js there is no difference between "a" and 'a')
function repeat(item, count) {
    if (item.length === 1) {
        let res = item.repeat(count);
        return res;
    }
    let res = ["sequence"];
    if (Array.isArray(item)) {
        for (let i = 1; i <= count; i += 1) {
            res[i] = [...item];
        }
    } else {
        res.length = count+1;
        res.fill(item);
    }
    return res;
}

// hopefully we can rely on builtins\psqop.e (/transpile it automatcially to psqop.js)

function assert(condition, msg = "") {
    if (!condition) { crash(msg); }
}

const $PROC = 1, $FUNC = 2;

function $_apply(s, fn, pf, userdata) {
    // apply fn as $PROC or $FUNC to all elements of sequence s
    if (Number.isInteger(s)) {
        let l = userdata.length,
            n = (l>0);
        if (s === true) {
            //
            // userdata specifies multiple arguments:
            //  if userdata[i] is an atom, it is passed to every call.
            //  if userdata[i] is length(1), then userdata[i][1] "".
            //  otherwise length(userdata[i]) must match all other 
            //            non-atom/length(1) elements of it (==n).
            //  fn is then invoked n times (can be 0), and always
            //                with exactly length(userdata) args.
            //
            let args = userdata, // (sets atoms and length)
                multi = repeat(false,l);
            for (let i = 0; i < l; i += 1) {
                let ui = userdata[i];
                if (Array.isArray(ui)) {
                    let m = ui.length;
                    if (m === 1) {
                        args[i] = ui[0];
                    } else if (n !== 1 && m !== n) {
                        crash("invalid lengths");
                    } else {
                        n = m;
                        multi[i] = true;
                    }
                }
            }

            let res = (pf === $FUNC ? repeat(0,n) : []);
            for (let i = 0; i < n; i += 1) {
                for (let j = 1; j < l; j += 1) {
                    if (multi[j]) {
                        args[j] = userdata[j][i];
                    }
                }
                if (pf === $PROC) {
//DEV untested/while I try to parse this thing...
// (decided it is [probably] better to put unhandled operators into the ast...)
                    fn(...args);
//                  fn(args);
                } else {
                    res[i] = fn(...args);
//                  res[i] = fn(args);
                }
            }
            return res;
        } else if (s === false) {
            let res = (pf === $FUNC ? repeat(0,l) : []);
            for (let i = 0; i < l; i += 1) {
                let ui = userdata[i];
                if (pf === $PROC) {
                    fn(...ui);
                } else {
                    res[i] = fn(...ui);
                }
            }
            return res;
        } else {
            crash("first atom argument to crash() must be true or false");
        }
    }

    // s is a list of single args
    for (let i = 1; i <= length(s); i += 1) {
        if (pf === $PROC) {
            fn(s[i],userdata);
        } else {
            s[i] = fn(s[i],userdata);
        }
    }
    return s;
}

function apply(s, fn, userdata = []) {
    return $_apply(s, fn, $FUNC, userdata);
}

function papply(s, fn, userdata = []) {
    $_apply(s, fn, $PROC, userdata);
}

function filter(s, rs, userdata = [], rangetype = "") {
//
// Select only those elements from a sequence that pass a specified test.
//
    let idx = 0;
    let si;
    if (typeof(rs) === "string") {
        // built-in handling
        let inout = find(rs,["sequence","in","out"]);
        if (inout !== 0) {
            inout = (inout === 1); // in: true, out: false
            if (rangetype === "") {
                // set handling
                for (let i = 1; i <= length(s); i += 1) {
                    si = s[i];
                    let f = find(si,userdata);
                    if ((f !== 0) === inout) {
                        idx += 1;
                        s[idx] = si;
                    }
                }
            } else {
                // inclusive/exclusive lo/hi range handling
                let rt = find(rangetype,["sequence","[]","(]","[)","()"])-1;
                if (rt === -1) { crash("invalid rangetype"); }
                // rt is now 0..3, aka 0b00..0b11:  // exclsve, inclsive
                let xl =  (rt & 1),                 // 0 for [,  1 for (
                    xh = -(rt & 2)/2;               // 0 for ], -1 for )
                if (!sequence(userdata) ||
                    length(userdata) !== 2) {
                    crash("userdata must be a sequence of length 2 for in/out handling");
                }
                let lo = userdata[1],
                    hi = userdata[2];
                for (let i = 1; i <= length(s); i += 1) {
                    si = s[i];
                    let lc = compare(si,lo),
                        hc = compare(si,hi);
                    if (((lc >= xl) && (hc <= xh)) === inout) {
                        idx += 1;
                        s[idx] = si;
                    }
                }
            }
        } else {
            if (rangetype !== "") { crash("invalid rangetype"); }
            let ct = find(rs,["sequence","<", "<=","=", "!=",">=",">"]);
            if (ct === 0) {
                ct = find(rs,["sequence","lt","le","eq","ne","gt","ge"]);
                if (ct === 0) { //    maybe "=="    
                    if (rs !== "==") { crash("unrecognised comparison operator"); }
                    ct = 3;
                }
            }
            let ne = (ct === 4);
            ct -= (ct >= 4);
//          let ok = ["sequence",["sequence",-1],["sequence",-1,0],["sequence",0],["sequence",0,1],["sequence",1]][ct];
            let ok = ["sequence",[-1],[-1,0],[0],[0,1],[1]][ct];
            for (let i = 1; i <= length(s); i += 1) {
                si = s[i];
                let c = compare(si,userdata);
//              if ((find(c,ok) !== 0) !== ne) {
//haystack.indexOf(needle,start);
                if ((ok.indexOf(c) !== -1) !== ne) {
                    idx += 1;
                    s[idx] = si;
                }
            }
        }
        s = s.slice(0,idx+1);
        return s;
    }

    // user-defined function handling
    if (rangetype !== "") { crash("invalid rangetype"); }
    let fn = rs;
    let r = (typeof(s) === "string" ? "" : []);
    for (let i = 0; i < s.length; i += 1) {
        si = s[i];
        if (fn(si, i, userdata === [] ? s : userdata)) {
            r = append(r,si);
        }
    }
    return r;
}

let $seed = Date.now();

function rnd() {
    $seed += 1;
    let x = Math.sin($seed) * 10000;
    return x - Math.floor(x);
}

function rand(n) {
    return ((n*rnd()) >>> 0)+1;
}

function get_rand() {
    return $seed;
}

function set_rand(new_seed) {
    $seed = new_seed;
}

//seems fine:
//for (let i = 1; i <= 10; i += 1) {
//  printf(1,"%v\n",rnd());
//  printf(1,"%d:%v\n",[i,rand(i)]);
//}

//DEV auto-xlate?
function tagset(n) {
    let tags = repeat(0,n);
    for (let i = 1; i <= n; i += 1) { 
      tags[i] = i;
    }
    return tags;
}

function floor(n) {
    return Math.floor(n);
}

function reverse(src, from_to = ["sequence",1,-1]) {
    let lo = from_to[1],
        hi = from_to[2],
        len = length(src)+1;
    if (lo < 0) { lo += len; }
    if (hi < 0) { hi += len; }
    let res = [...src];
    if (len > 1 && lo < hi) {
        let mid = floor((lo+hi-1)/2);
        for (; lo <= mid; lo += 1) {
            res[hi] = src[lo];
            res[lo] = src[hi];
            hi -= 1;
        }
    }
    return res;
}

/*
From Douglas Crockford (or just transpile builtins/sort.e)
var m = ['aa', 'bb', 'a', 4, 8, 15, 16, 23, 42];
m.sort(function (a, b) {
    if (a === b) {
        return 0;
    }
});
// m is [4, 8, 15, 16, 23, 42, 'a', 'aa', 'bb']
*/  

//sin, cos, tan, arctan, log, floor, remainder, mod?, sqrt, power, PI, and/or/xor/not_bits, 
//time, date, version, requires?, clear_screen?, dict?, timedate? progress?
//everything else in builtins/pdate.e, or move them away from the #ilASM{}-using date().
"use strict";

function IupOpen() {

    function intint(val) {
        if (typeof(val) === "string") {
            // convert eg "225x75" to [225,75]
            //  (ie a js Array of length 2)
            let x = val.indexOf('x');
            if (x) {
                let y = Number(val.slice(x+1));
                    x = Number(val.slice(0,x));
                if (Number.isInteger(x) &&
                    Number.isInteger(y)) {
                    val = [x,y];
                }
            }
        }
        return val;
    }

    function class_name(ih, check) {
        if (!ih) { crash("invalid handle"); }
        let cn = ih.className;
//      let sp = cn.indexOf(' ');
////hmmm, can we be sure it stays first??
//      if (sp !== -1) { cn = cn.slice(0,cn); }
//      if (check && check !== cn) {
        if (check !== cn) {
//      return cn
    }

    function set_dialog(ih, name, val) {
//      if (ih.className !== "dialog") {
//          crash("wrong class (not IupDialog)");
//      }
        class_name(ih, "dialog");
        if (name === "TITLE") {
            const hdrs = ih.getElementsByClassName("dialog-handle");
            if (hdrs.length !== 1) {
                crash("cannot get (lone) header handle");
            }
//          hdrs[0].innerHTML = "<b>" + val + "</b>";
            hdrs[0].innerHTML = val;
        } else if (name === "MINSIZE") {
            let [w, h] = intint(val);
            if (ih.style.width < w)  { ih.style.width = w + "px"; }
            if (ih.style.height < h) { ih.style.height = h + "px"; }
            ih.minimumWidth = w;
            ih.minimumHeight = h;
        } else if (name === "RASTERSIZE") {
            let [w, h] = intint(val);
            if (w) { ih.style.width = w; }
            if (h) { ih.style.height = h; }
        } else if (name === "MARGIN" || name === "GAP") {
            let [w, h] = intint(val);
            if (h) {
                ih.style.marginTop = h;
                ih.style.marginBottom = h;
            }
            if (w) {
                ih.style.marginLeft = w;
                ih.style.marginRight = w;
            }
//DEV...?? (in general and above)
        } else if (name === "GAP") {
            let g = Number(val);
            ih.style.margin = g;
        } else {
            crash("IupStoreAttribute(IupDialog,\"" + name + "\") not yet implemented");
        }
    }

    function set_label(ih, name, val) {
        class_name(ih,"label");
        if (name === "TITLE") {
            ih.innerHTML = val;
        } else if (name === "EXPAND") {
//Value: "YES" (both directions), "HORIZONTAL", "VERTICAL", "HORIZONTALFREE", "VERTICALFREE" or "NO".
//Default: "NO". For containers the default is "YES".
//Affects: All elements, except menus. 
            if (val === "YES") {
            } else if (val === "HORIZONTAL") {
            } else if (val === "VERTICAL") {
            } else if (val === "NO") {
            } else {
                crash("IupStoreAttribute(IupLabel,\"EXPAND\", \"" + val + "\"??)");
            }
        } else if (name === "ALIGNMENT") {
//ALIGNMENT  (non inheritable) horizontal and vertical alignment. 
//              Possible values: "ALEFT", "ACENTER" and "ARIGHT", combined to "ATOP", "ACENTER" and "ABOTTOM". 
//              Default: "ALEFT:ACENTER". 
//??            Partial values are also accepted, like "ARIGHT" or ":ATOP", the other value will be used from the current alignment. 
            let k = val.indexOf(':');
            if (k !== -1) {
                let vlr = val.slice(k+1),
                    val = val.slice(0,k);
                if (vlr === "ATOP") {
                } else {
                    crash("IupStoreAttribute(IupLabel,\"ALIGNMENT\", \":" + vlr + "\"??)");
                }
                puts(1,"IupStoreAttribute(IupLabel,\"ALIGNMENT\", \":" + vlr + "\" not yet implemented)");
            }
            if (val.length) {
            }
        } else {
            crash("IupStoreAttribute(IupDialog,\"" + name + "\") not yet implemented");
        }
    }
}

    if (action !== null && typeof(action) !== "string") {
        if (typeof(action) === "function") {
            if (typeof(func) === "string") {
                attributes = func;
            }
            func = action;
            action = null;
        } else {
            if (Array.isArray(func)) {
                data = func;
            }
            attributes = action;
            func = null;
            action = null;
        }
    } else if (func === null) {
        if ((typeof(attributes) !=== "string" || attributes.length === 0) && action !== null) {
            attributes = action;
            action = null;
        }
    } else if (Array.isArray(func)) {
        attributes = action;
        data = func;
        action = null;
        func = null;
    }
    return [action,func,attributes,data];

//tests:
//  1   IupText()
//  2   IupText(action,func) [NB func is /not/ optional in this case]
//  3   IupText(func)
//  4   IupText(attributes[,data])
//  5   IupText(func,attributes[,data])
//  6   IupText(action,func,attributes[,data])
/*
function sqeq(a, b) {   // nested array match test
    if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) { crash("?9/0"); }
    for (let i = 0; i < a.length; i += 1) {
        if (Array.isArray(a[i])) {
            sqeq(a[i],b[i]);
        } else if (a[i] !== a[i]) {
            crash("?9/0");
        }
    }
}
*/

function topzindex(dlg) {
    // make dlg the topmost dialog [also done before removal]
    const dlgs = document.getElementsByClassName("dialog"),
          maxz = dlgs.length,
          thisz = dlg.style.zIndex;
    if (thisz !== maxz) {
        // eg 321 ==click2==> ([loop] 221==>) 231 [last]
        if (thisz) {
            for (let i = 0; i < dlgs.length; i += 1) {
                const di = dlgs[i], thatz = di.style.zIndex;
                if (thatz > thisz) { di.style.zIndex = thatz - 1; }
            }
        }
        dlg.style.zIndex = maxz;
    }
}

function IupDialog(child, attributes = "", data = []) {
// as close as possible to pGUI.e, see phix.chm

    function create_svg(classname, viewbox, path) {
        // (private helper function)
        const svgns = "http://www.w3.org/2000/svg",
                svg = document.createElementNS(svgns, "svg"),
                pth = document.createElementNS(svgns, "path");
        svg.setAttribute("class", classname);
        svg.setAttribute("viewBox", viewbox);
        pth.setAttribute("d", path);
        svg.appendChild(pth);
        return svg;
    }

    function header_button(htitle, path, viewbox = "0 0 30 30", classname = "minmax") {
        // (private helper function)
        const div = document.createElement("div"),
              svg = create_svg(classname, viewbox, path);
        div.title = htitle;
        div.appendChild(svg);
        return div;
    }

    //
    // First create the (dialog) window with a draggable header.
    // =========================================================
    //
    const dialog = document.createElement("div"),
          headiv = document.createElement("div"),
          header = document.createElement("div"),
          dlgbod = document.createElement("div");
//div.setAttribute('class', 'note');
//  header.innerHTML = "<b>" + htitle + "</b>";
    header.innerHTML = "<b><i>untitled</i></b>";
    headiv.appendChild(header_button("Application", "M28 0h-24c-2.2 0-4 1.8-4 4v24c0 2.2 "+
                                     "1.8 4 4 4h24c2.2 0 4-1.8 4-4v-24c0-2.2-1.8-4-4-4zM14 "+
                                     "24.828l-7.414-7.414 2.828-2.828 4.586 4.586 9.586-9.586 "+
                                     "2.828 2.828-12.414 12.414z", "-12 -8 48 48", "icon"));
// <svg class="icon icon-checkbox-checked"><use xlink:href="#icon-checkbox-checked"></use></svg>
// <symbol id="icon-checkbox-checked" viewBox="0 0 32 32">
// <path d="M28 0h-24c-2.2 0-4 1.8-4 4v24c0 2.2 1.8 4 4 4h24c2.2 0 4-1.8 4-4v-24c0-2.2-1.8-4-4-4zM14 24.828l-7.414-7.414 2.828-2.828 4.586 4.586 9.586-9.586 2.828 2.828-12.414 12.414z"></path>
// </symbol>
//.icon {
//  display: inline-block;
//  width: 1em;
//  height: 1em;
//  stroke-width: 0;
//  stroke: currentColor;
//  fill: currentColor;
//}
    headiv.appendChild(header);
    headiv.appendChild(header_button("Maximise", "M10,10 L10,20 L20,20 L20,10 Z"));
    headiv.appendChild(header_button("Close", "M10,10 L20,20 M20,10 L10,20"));
//  dlgbod.innerHTML = "<p>Move</p><p>this</p><p>div</p>";
//  dlgbod.innerHTML = "Move<br>this<br>div<br>";
    dlgbod.appendChild(child);
    dialog.className = "dialog";
    dialog.appendChild(headiv);
    dialog.appendChild(dlgbod);

    function mouseDown(event) {

        const rect = header.getBoundingClientRect(),
            shiftX = event.clientX - rect.left,
            shiftY = event.clientY - rect.top;

        function doMove(event) {
            const Lft = event.clientX - shiftX,
                  Top = event.clientY - shiftY,
                  Rht = window.innerWidth - dialog.offsetWidth + 1,
                  Btm = window.innerHeight - dialog.offsetHeight + 1;

            function clamp(num, min, max) {
                return (num <= min ? min : (num >= max ? max : num));
            }

            function above(num, low) {
                return (num <= low ? low : num);
            }

            dialog.style.top = clamp(Top, -1, above(Btm, -1)) + "px";
            dialog.style.left = clamp(Lft, -1, above(Rht, -1)) + "px";
        }

        function stopMove() {
            document.documentElement.removeEventListener("mousemove", doMove);
            document.documentElement.removeEventListener("mouseup", stopMove);
        }

        document.documentElement
        document.documentElement
    }

    const maxbtn = dialog.getElementsByClassName("Maximise")[0],
          clsbtn = dialog.getElementsByClassName("Close")[0],
          maxsvg = maxbtn.children[0];

    function maxWindow() {
        topzindex(dialog);
            dialog.wastop = dialog.style.top;
            dialog.wasleft = dialog.style.left;
            dialog.waswidth = dialog.style.width;
            dialog.washeight = dialog.style.height;
            dialog.style.top = "-1px";
            dialog.style.left = "-1px";
            dialog.style.width = window.innerWidth + "px";
            dialog.style.height = window.innerHeight + "px";
            maxbtn.title = "Restore";
    }

    header.onmousedown = mouseDown;
    maxbtn.onclick = maxWindow;
    header.ondblclick = maxWindow;
//  header.ondragstart = function ds() { return false; }
//  clsbtn.onclick = function hd() { IupHide(dialog); }
//  dialog.onmousedown = function md() { topzindex(dialog); }
    function ds() { return false; }
    function hd() { IupHide(dialog); }
    function md() { topzindex(dialog); }
    header.ondragstart = ds;
    clsbtn.onclick = hd;
    dialog.onmousedown = md;

    //
    // Next, allow re-sizing, aka dragging corners and edges.
    // ======================================================
    //
    function initSize(event) {
//      const resizer = this,  // (one of 8)
        const resizer = event.currentTarget,  // (one of 8)
              originalTop = dialog.offsetTop,
              originalLeft = dialog.offsetLeft,
              originalWidth = dialog.clientWidth,
              originalHeight = dialog.clientHeight,
              originalPageX = event.pageX,
              originalPageY = event.pageY;

        function doSize(event) {
            //
            // Note: use of "resize: both;" displays the handle *AND* effectively
            //       disables this routine on the bottom right resizer. This must
            //       handle the other seven resizers anyway, and hence instead we
            //       shun resize:both and draw our own (br) resize handle.
            //
            // Also: We deliberately allow dragging/resizing to {-1,-1}, effectively
            //       overlapping our and the browser's top 1-pixel borders, whereas
            //       limiting it to {0,0} left it looking too fat (2px). Note that
            //       the left/right/bottom borders can & do in fact end up hidden.
            //       A bug during developent allowed drag to {-2,-2}, and it looked
            //       barely any different, in other words we cannot, and would not
            //       actually want to get rid of the top border completely anyway.
            //
            let xd = event.pageX - originalPageX,
                yd = event.pageY - originalPageY,
                 w = originalWidth + resizer.xm*xd,
                 h = originalHeight + resizer.ym*yd;

            if (w >= dialog.minimumWidth) {
                if (resizer.xm === -1) {
                    // move left edge
                    xd += originalLeft;
                    if (xd < -1) {
                        w += xd + 1;
                        xd = -1;
                    }
                    dialog.style.left = xd + "px";
                } else {
                    // move right edge
                    if (originalLeft + w > window.innerWidth) {
                        w = window.innerWidth - originalLeft;
                    }
                }
                dialog.style.width = w + "px";
            }

            if (h >= dialog.minimumHeight) {
                if (resizer.ym === -1) {
                    // move top edge
                    yd += originalTop;
                    if (yd < -1) {
                        h += yd + 1;
                        yd = -1;
                    }
                    dialog.style.top = yd + "px";
                } else {
                    // move btm edge
                    if (originalTop + h > window.innerHeight) {
                        h = window.innerHeight - originalTop;
                    }
                }
                dialog.style.height = h + "px";
            }
        }

        function stopSize() {
            document.documentElement.removeEventListener("mousemove", doSize, false);
            document.documentElement.removeEventListener("mouseup", stopSize, false);
        }

        document.documentElement
        document.documentElement
        topzindex(dialog);
    }

    // add eight resizers, and all their handling, to the dialog window
    const rd = ["tl", "top", "tr", "left", "right", "bl", "bottom", "br"],
          xms = [-1,    0,    +1,    -1,      +1,    -1,      0,     +1],
          yms = [-1,   -1,    -1,     0,       0,    +1,     +1,     +1],
          rc = ["nw",  "n",  "ne",   "e",    "e",   "ne",    "n",   "nw"],
          rdiv = document.createElement("div");

//  rd.forEach((id, idx) => {
    function addSizer(id, idx) {
        const xm = xms[idx],
              ym = yms[idx],
              r = document.createElement("div");
        r.className = "resizer-" + id;  // (no longer strictly necessary)
        r.xm = xm;                      // for use in doSize()
        r.ym = ym;                      //      """
        r.style.width = xm === 0 ? "100%" : "5px";  // (edge | corner)
        r.style.height = ym === 0 ? "100%" : "5px"; //      """
        r.style.background = "transparent";
        r.style.position = "absolute";
        r.style.cursor = rc[idx] + "-resize";
        // ensure corner resizers are atop side resizers:
        r.style.zIndex = (xm === 0 || ym === 0) ? 1 : 10;
        if (ym === -1) { r.style.top = 0; } else { r.style.bottom = 0; }
        if (xm === -1) { r.style.left = 0; } else { r.style.right = 0; }
        rdiv.appendChild(r);
//    });
    }
    rd.forEach(addSizer);

    rdiv.className = "dialog-resizers"; // (not strictly necessary)

    const drag_handle = create_svg("resize","0 0 7 7","M0,6 L6,0 M4,6 L6,4");
    rdiv.appendChild(drag_handle);
    dialog.appendChild(rdiv);

    IupSetAttributes(dialog, attributes, data);

//DEV: IupShow/IupPopup??
/*
    // Then, almost last, make it top dog, and add it to the DOM.
    dialog.style.zIndex = document.getElementsByClassName("dialog").length;
//  document.body.appendChild(dialog);
    $docbody.appendChild(dialog);

    // Originally, dragging a window behaved rather differently before and
    // after resizing the window, hence this...
    const rect = dialog.getBoundingClientRect(),    // (nb: recalc in DOM)
             w = rect.width,
             h = rect.height;
    dialog.style.width = w + "px";
    dialog.style.height = h + "px";
    // It may be possible to allow some squishing, not entirely sure...
    dialog.minimumWidth = w;                        // for use in doSize()
    dialog.minimumHeight = h;                       //      """
*/
//temp:
//let s = sprintf("minsize: {%d,%d}\n",[w,h]);
//let s = sprintf("%v\n",[intint("225x75")]);   // (NB: I had to move it to test it)
//puts(2,s);
//document.body.insertAdjacentHTML("afterbegin", s);
//$docbody.insertAdjacentHTML("afterbegin", s);
//minsize: {208,202}
//minsize: {142,202}

    return dialog;
} // (create_window() ends...)

function IupShow(ih) {
    // Make it top dog, and add it to the DOM.
    ih.style.zIndex = document.getElementsByClassName("dialog").length;
    $docbody.appendChild(ih);

    // Originally, dragging a window behaved rather differently before and
    // after resizing the window, hence this...
    const rect = ih.getBoundingClientRect(),    // (nb: recalc in DOM)
             w = rect.width,
             h = rect.height;
    ih.style.width = w + "px";
    ih.style.height = h + "px";
    // It may be possible to allow some squishing, not entirely sure...
    ih.minimumWidth = w;                        // for use in doSize()
    ih.minimumHeight = h;                       //      """
}

function IupHide(ih) {
    const dialogs = document.getElementsByClassName("dialog");
    if (dialogs.length === 1) {
// See IupMainLoop:
//      if (terminator) { terminator(); }
// @grant        window.close
        window.close();  // close the whole page [DEV/erm?]
//      open(location, '_self').close();
//      window.top.close();  // close the whole page [DEV/erm?]
//      window.open('about:blank', '_self').close();
//      window.open('', '_self').close();
//      function closeWin() { 
//          window.top.close();
//      }
//      setTimeout(function(){ closeWin() }, 1000);
//      $docbody.innerHTML = "";
//      puts(1,"\n\n\n\n");
//      puts(1,"                                                 Oh dear.\n\n");
//      puts(1,"                      With all of their usual infinite lack of wisdom,\n\n");
//      puts(1,"              the spineless retards that so-called `develop` this stuff,\n\n");
//      puts(1,"          have blocked window.close() for cretinous `security reasons`.\n\n");
//      puts(1,"      Just like http:mydir and file:mydir being a stupid `CORS violation`.\n\n");
//      puts(1,"  Like it would be `far too difficult` to ever make anyone's life any easier.\n\n");
//      puts(1,"Try using an older and therefore less bug-ridden browser version, maybe.\n\n");
//      puts(1,"PS: Any resemblance of the above to a dog's turd is entirely coincidental.\n\n");
    } else {
        topzindex(ih);  // (specifically, fixup the rest)
        $docbody.removeChild(ih);
    }
//  ih.style.display = 'none';
}

//IupFlatLabel?? (mnemonics not supported...???)
function IupLabel(title=null, attributes = "", data = []) {
    const ih = document.createElement("div");
    ih.setAttribute('class', 'label');
    if (title) {
//      ih.innerHTML = title;
        ih.innerHTML = "<nobr>" + title + "</nobr>";
//DEV:
//      IupSetAtribute(ih,"TITLE",title);
    }
    IupSetAttributes(ih, attributes, data);
//  ih.className = "label";
    return ih;
}

//function IupFlatLabel(title = null, attributes = "", data = []) {
//  return IupLabel(title, attributes, data);
//}
const IupFlatLabel = IupLabel;

function IupHbox(children, attributes = "", data = []) {
    const ih = document.createElement("div");
    ih.setAttribute('class', 'hbox');
//  ih.className = "hbox";
    for (let i = 0; i < children.length; i += 1) {
        let ci = children[i];
// ?    if (ci.className === "fill") {
//          IupSetAttribute(ci,"EXPAND","HORIZONTAL");
//      }
        ih.appendChild(ci);
    }
    IupSetAttributes(ih, attributes, data);
    return ih;
}

function IupVbox(children, attributes = "", data = []) {
    const ih = document.createElement("div");
    ih.setAttribute('class', 'vbox');
//  ih.className = "vbox";
    for (let i = 0; i < children.length; i += 1) {
        let ci = children[i];
// ?    if (ci.className === "fill") {
//          IupSetAttribute(ci,"EXPAND","VERTICAL");
//      }
        ih.appendChild(ci);
    }
    IupSetAttributes(ih, attributes, data);
    return ih;
}

//DOC: [RASTER]SIZE must use wxh format, one of which will be ignored... or... must be 0.
//      Any attributes must be set before the element is inserted into the hierarchy (not normally an issue).
function IupFill(attributes = "", data = []) {
    const ih = document.createElement("div");
    ih.setAttribute('class', 'fill');
    IupSetAttributes(ih, attributes, data);
    return ih;
}

//IupButton(nullable_string title=NULL,[[nullable_string action=NULL,] cbfunc func=NULL,] string attributes="", sequence data={}) 
function IupButton(title = null, action = null, func = null, attributes = "", data = []) {
    const ih = document.createElement("button");
    ih.setAttribute('class', 'button');
    if (title) {
//      ih.innerHTML = title;
//      title = mnemonics(ih,title);
        ih.innerHTML = "<nobr>" + title + "</nobr>";
//DEV
//      IupSetAttribute(ih,"TITLE",title);
    }
    if (func) {
        if (action !== null && action !== "ACTION") { crash("?9/0"); }
//      IupSetCallback(ih, action, func)
    }
    IupSetAttributes(ih, attributes, data);
    return ih;
}

const IupFlatButton = IupButton;

function IupCloseOnEscape(/* Ihandle */ dlg) {
    function hide_dlg(event) {
//      let keyCode = window.event ? window.event.keyCode : e.which;
//      if (keyCode === 27) {
        if (event.key === 'Escape') {
            IupHide(dlg);
        }
    }
//  document.onkeydown = hide_dlg;
    dlg.onkeydown = hide_dlg;
}

function Icallback(func) {
    // dummy function, exists solely for p2js to convert Icallback("func") [phix] <==> Icallback(func); [js]
    // in other words, p2js recognises the Icallback() and simply removes/adds the quotes, whereas if it
    // instead did Icallback("func") [phix] ==> func; [js] then it would likely end up as a one-way trip.
    // (js ==> phix may help the transpiler development, but is otherwise likely to be fairly useless.)
    return func;
}

// three more, for similar reasons to Icallback():
function IupMainLoop() {
    crash("ERROR: IupMainLoop() [and any following shudown code] should be inside `if platform()!=JS then`");
}
//function IupMainLoop(fn) { terminator = fn; }

function IupClose() {}

function IupDestroy(/* Ihandlns */ dlg) {
//  Ah: IupMainLoop() is a null-op in pGUI.js so it ends up invoking following code immediately...
//  What I need to do is (maybe) something like this:
//  IupMainLoop(()==> {
//  IupDestroy()...
//  });
//  (let's just make it an error to have "end procedure" etc after IupMainLoop(), perhaps?...)
//  (maybe better, force this (in .exw files):
//  if platform()!=JAVASCRIPT then
//      IupMainLoop()
//      dlg = IupDestroy(dlg)
//      IupClose()
//  end if
//  (and if platform()=WINDOWS and someothertest then ... else                                  )
//  (                          ^illegal                   ^error, platform()=JAVASCRIPT missing )
//
//  or do we just want to let js gc deal with it?? [Eh: no good for IupNormaliser!]
//X dlg.parentNode.removeChild(dlg);
//  return null;  //DEV would be good for ih, fatal for non-if-not-JS-wrapped (main)dlg=IupDestroy(dlg)...
    return dlg;
}

// (cbfunc/Ihandles/Ihandlns/cdCanvas/imImage/cdContext?)
// IupRawStringPtr?/IupSetCallback[s]/IupGetAttribute/IupGetInt/IupS/GetGlobal/IupVersion?
// Iup[GL]Canvas/IupDraw*/IupDatePick/IupCalendar/IupImage/IupLink(example)/IupList(example)/IupMenu/
// IupProgressBar/IupGauge/IupText/IupToggle/IupTree/IupValuator/IupMatrix?/IupPlot?
// Iupappend?/IupReparent?/IupFrame/IupMultiBox/IupNormaliser?/IupRadio/IupSbox/IupSplit/IupTabs/IupUser?
// IupClipboard/IupHelp?/IupTimer
// cdCanvasClear/Arc/Begin/Vertex/PathSet/End/Box/Line  glBegin...? (gears)
// cdCreateCanvas?

/*
// for IupMenu, perhaps...
function popupMenu() {
  const menuItems = ['add', 'this'];

  const popup = document.createElement('div');
  const popupList = document.createElement('ul')
  popup.className = 'popup-menu';
  popup.appendChild(popupList)
  document.body.appendChild(popup)

  function create_item(item) {
    const li = document.createElement('li');
    li.textContent = item;
    popupList.appendChild(li);
  }
  menuItems.forEach(create_item);

  function context_listener(event) {
    popup.style.display = 'block';
    let dW = document.documentElement.clientWidth,
        dH = document.documentElement.clientHeight,
        pW = popup.offsetWidth,
        pH = popup.offsetHeight,
        pX = Math.min(event.pageX,dW-pW-3),
        pY = Math.min(event.pageY,dH-pH-3);
    popup.style.left = pX + 'px';
    popup.style.top = pY + 'px';
  }

  function click_hide(event) {
      popup.style.display = 'none';
  }
}

window.onload = popupMenu;

===
but, we probably want to attach different popups to different things anyway...:
function addContextMenu(elem) {
}

// to attach a context menu to all divs, you can do this:
var divs = document.querySelectorAll(".div");

//divs.forEach(function(d) { addContextMenu(d); });
divs.forEach(addContextMenu);
*/
-->
        <table>
         <tr>
            <th>Array</th>
            <th>Meaning</th>
         </tr>
         <tr>
            <td>
            Array.isArray(x);
            </td>
            <td>
              Self explanatory
            </td>
         </tr>
         <tr>
            <td>
            array.length;
            </td>
            <td>
              Self explanatory. Note that length(a) will be one less.
            </td>
         </tr>
         <tr>
            <td>
            array.slice(start,end);
            </td>
            <td>
              NB shallow copy. eg if a is ["sequence",1,2,3,4], a.slice(3) is [3,4], and a.slice(1,2) is [1].
            </td>
         </tr>
         <tr>
            <td>
            array.splice(start,deleteCount,item...);
            </td>
            <td>
                let a = ['a', 'b', 'c'],            r = a.splice(1, 1, 'ache', 'bug');<br>
                //  a is ['a', 'ache', 'bug', 'c']  r is ['b']
            </td>
         </tr>
         <tr>
            <td>
             $store_attr
            </td>
            <td>
              element-specific attribute handlers/setters, eg $store_attr["dialog"]["TITLE"] is set_dialog, a (private) routine
              (defined in pGUI.js) for setting the dialog title.
            </td>
         </tr>
        </table>
        <br>
        &nbsp;
        <br>
        <table>
         <tr>
            <th>Globals</th>
            <th>Meaning</th>
         </tr>
         <tr>
            <td>
             $paranormalise
            </td>
            <td>
              A hand-translated version of the (private) <a href="paranormal.htm">paranormalise</a>() routine from pGUI.js.
            </td>
         </tr>
         <tr>
            <td>
             $store_attr
            </td>
            <td>
              element-specific attribute handlers/setters, eg $store_attr["dialog"]["TITLE"] is set_dialog, a (private) routine
              (defined in pGUI.js) for setting the dialog title.
            </td>
         </tr>
        </table>
        <br>
        &nbsp;
        <br>
        <table>
         <tr>
            <th>Function</th>
            <th>Meaning</th>
         </tr>
         <tr>
            <td>
             typeof
            </td>
            <td>
              Technically a prefix operator, it is used as a function in p2js/pGUI.js. Valid results are "string",
              "number", "undefined", "boolean", and "object". Note the latter is returned for arrays...
            </td>
         </tr>
         <tr>
            <td>
             $store_attr
            </td>
            <td>
              element-specific attribute handlers/setters, eg $store_attr["dialog"]["TITLE"] is set_dialog, a (private) routine
              (defined in pGUI.js) for setting the dialog title.
            </td>
         </tr>
        </table>
        <br>
        &nbsp;
        <br>
        <table>
         <tr>
            <th>General</th>
            <th>Meaning</th>
         </tr>
         <tr>
            <td>
             this
            </td>
            <td>
              Avoided at all costs in p2js/pGUI.js. Besides, rather than say dlg.show(), we use <a href="IupShow.htm">IupShow</a>(dlg).
            </td>
         </tr>
        </table>
        <br>
        &nbsp;
        <br>
        <table>
         <tr>
            <th>Operator</th>
            <th>Meaning</th>
         </tr>
         <tr>
            <td>
             ...
            </td>
            <td>
              The spread operator. Used for eg fn(...args) much like call_func(fn,args). It might have been good for cloning arrays,
              but alas it only performs a shallow copy, see notes above.
            </td>
         </tr>
        </table>
        <br>
        &nbsp;
        <br>
        <table>
         <tr>
            <th>elem</th>
            <th>Meaning</th>
         </tr>
         <tr>
            <td>
             addEventListener(/*string*/ event_type, /*function*/ fn, /*bool*/ use_capture=false);
            </td>
            <td>
              Reasonably self explanatory.<br>
              event_type can be 'click', 'contextmenu', 'dblclick', 'DOMContentLoaded', 'keydown', 'keypress', 'keyup', 
                                'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseup', 'resize', etc.<br>
              fn: a listener function which optionally accepts a single event parameter (sometimes inlined/fat arrow).<br>
              use_capture: true (parent before child) or false (child before parent, aka bubbling) [I think]
            </td>
         </tr>
         <tr>
            <td>
             classList.add(/*string*/ token);
            </td>
            <td>
              Self explanatory
            </td>
         </tr>
         <tr>
            <td>
             classList.contains(/*string*/ token);
            </td>
            <td>
              Self explanatory
            </td>
         </tr>
         <tr>
            <td>
             classList.remove(/*string*/ token);
            </td>
            <td>
              Self explanatory
            </td>
         </tr>
         <tr>
            <td>
             classList.toggle(/*string*/ token);
            </td>
            <td>
              Self explanatory, yields true if added, false if removed
            </td>
         </tr>
        </table>
        <br>
        &nbsp;
        <br>
        <table>
         <tr>
            <th>event</th>
            <th>Meaning</th>
         </tr>
         <tr>
            <td>
            preventDefault();
            </td>
            <td>
              Self explanatory
            </td>
         </tr>
         <tr>
            <td>
            stopPropagation();
            </td>
            <td>
              Self explanatory
            </td>
         </tr>
        </table>
        <br>
        &nbsp;
        <br>
        <br>
        Blah It would probably not be difficult to create a new and improved unicode entry point based 
        on the existing code, perhaps along these lines:
<!--eucode>
</eucode-->
<pre>
</pre>
        Lorem ipsum But obviously I would rather not impose that overhead on everything, or support such.
        <br>
        <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
