<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">mpfr / gmp</h1>
      <div id="mainSection">
<!--
        Arbitrary Precision Arithmetic: mpir is a fork of gmp (gnu multiple precision), and mpfr is a floating-point extension of that.
-->
        Arbitrary Precision Arithmetic: mpfr is a floating-point extension of gmp (gnu multiple precision).
       <br>
       <br>
        It has been wrapped/is available for many programming languages, including Ada, C, C++, Fortran, Haskell, Java, Julia, Lisp, .NET, 
        Perl, PHP, Pike, Prolog, Python, R, Racket, Ruby, Rust, Scheme, and now Phix - which means there should be no shortage of examples.
       <br>
       <br>
        I have seen some performance improvements in my time, but this absolutely has to take the (chocolate covered triple-choc) biscuit.<br>
        For demo\rosetta\Ackermann, translating the Go code to calculate ack(3,1e6), which has over 300,000 digits:<br>
        Using bigatom.e (as originally submitted by cargoan) took so long that I just had to kill it....<br>
        Using bigint.e (wot I wrote meself): 5 minutes to calculate and then 32 minutes to print (gulp).<br>
        Using gmp: 0.1s for the lot! (Do I feel humiliated and then some or what?!)
       <br>
       <br>
        Included in the distribution as builtins\mpfr.e (not an autoinclude), with the required windows dlls in builtins\(32|64), but 
        you may have to install gmp/mpfr manually on Linux.
<!--
        Included in the distribution as builtins\mpfr.e (not an autoinclude), but you have to download the dlls from
        <a href="javascript:ExternalLink('ext273');" title='http://phix.x10.mx/pmwiki/pmwiki.php?n=Main.Mpfr'
           id="ext273" style="color:#9B5565">PCAN</a> or perhaps
<x!--
        <a href="javascript:ExternalLink('ext272');" title='http://www.atelierweb.com/mpir-and-mpfr'
           id="ext272" style="color:#9B5565">directly</a>
--x>
        <a href="javascript:ExternalLink('ext272');" title='https://freebasic.net/forum/viewtopic.php?t=24110'
           id="ext272" style="color:#9B5565">directly</a>
       <br>
        You should get a readable and straightforward error message when the required dlls cannot be opened.<br>
        It is entirely up to you whether to install (simple copy) them to system32/syswow64, builtins, or the application directory.<br>
        A future release of Phix may offer to download and install them (to builtins) as part of installation, however you would still 
        be responsible for shipping them along with a finished application.<br>
        Let me know if any newer pre-built dlls are uploaded to atelierweb, or elsewhere.
-->
       <br>
       <br>
        There is also a hand-crafted drop-in replacement in Phix/pwa/builtins/mpfr.js which is handled automatically for you
        by <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a>, and obviously that does not need any dlls. <br>
        Note that mpfr are effectively implemented as (limited precision) mpq and transcendental functions such as mpfr_sin(),
        mpfr_log(), mpfr_exp(), and mpfr_gamma() are <i>not</i> supported (though, perhaps suprisingly, mpfr_sqrt() and 
        mpfr_const_pi() <i>are</i> already implemented). 
        Also note that mpfr.js (effectively) assumes precision means the number of decimal places after the decimal point.
        The mechanisms for precision and rounding are quite different in the gmp dlls and mpfr.js, in other words I have
        probably recreated/interpreted them imperfectly or even quite wrongly, so you should expect a few little glitches, 
        especially in the first few releases. All I know is that right now it gets several hundred digits right on several
        dozen examples, and in fact I have no more examples left to test. A couple of debug sessions have also suggested 
        that the "discard precision" loop may be ridiculously expensive, but I have not figured out any way to separate
        the time of that from the time spent elsewhere, so it may just be more cheap iterations, and 50% or even 70% is
        perfectly fine whereas 95% or more is probably not, and 99% definately not!
       <br>
       <br>
<!--
        Version: mpfr: 3.1.5, mpir:2.7.2, two dlls, 733K (32 bit, 308K zipped), 936K (64 bit, 373K zipped)<br>
-->
        Version: mpfr: 4.1.0, gmp:5.1.2, two dlls, 3.5MB, 1.5MB zipped (same/twice that for 32 and 64-bit)<br>
        Version 3.1.0-p3 was already installed my Ubuntu box, though I also needed to install mpfr-dev, in order to compile the 
        recommended version check, which was just the one click via the ubuntu software centre, at least after typing "mpfr" 
        into the search box and picking the one that I needed. Note that eg mpfr_gamma_inc() requires 4.0.0+, I think.
       <br>
       <br>
        Be warned: mpfr/mpir/gmp are built for speed and are generally very unforgiving, hanging or 
        terminating silently without any clues as to what went wrong - good old-fashioned C for ya!<br>
        Making (for example) <span class="illegal">mpfr_clear</span>() private/internal, and wrapping the C mpfr_init() 
        functions and hence effectively making them non-optional is the least/best I could do to help, and these days 
        (quite unlike the first couple of versions) I very rarely suffer a sudden unexplained crash and almost always 
        get a proper human-readable error message.
       <br>
       <br>
        Use the mpfr_xxx() routines for your ridiculously accurate floats (with ridiculously big exponents).<br>
        Use the mpz_xxx() routines for your ridiculously big (and perfectly exact) integers.<br>
        Use the mpq_xxx() routines for rational numbers (aka fractions, ie n/m&rsquo;ths, where n and m are mpz internally).
       <br>
       <br>
        There are no hard-and-fast limits other than available memory; you should have no difficulty constructing a value
        that requires over 1GB of memory in the most compact possible form, as compared the the 4/8/10 bytes of native phix
        integers and atoms, though you might have trouble constructing a 2nd/3rd/4th that big at the same time. Printing
        numbers with more than about 500,000 digits is however neither very fast nor realistically speaking very sensible.
        See demo\rosetta\Fermat.exw for an example of how much further along you can get, provided you give up printing.
       <br>
       <br>
        Once you understand how to create and display mpfr/mpz/mpq variables, the rest is all pretty straightforward.
       <br>
       <br>
        Note that where z is an mpz/mpfr/mpq variable, on desktop/Phix atom(z) will return <a href="logicops.htm#tf">true</a> 
        (and integer(z) sometimes <a href="logicops.htm#tf">true</a>) whereas on 
        <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a> atom(z) will always return <a href="logicops.htm#tf">false</a>. 
        Otherwise the types are "strong" since they <i>are</i> properly tagged on both systems, in other words the usual 
        <a href="usingtypes.htm#can">unsafe warning</a> does <i><b>not</b></i> apply to explicit invocations of mpz(), 
        mpfr(), or mpq().
        <br>
        <br>
        Also mpz/mpfr/mpq<!--/randstate--> declare reference variables, as opposed to the copy-on-write semantics of standard 
        phix types, eg after <code>mpz a=mpz_init(3),b=a; mpz_add_ui(b,b,1)</code> both a and b are 4, whereas after 
        <code>mpz a=mpz_init(3), b=mpz_init_set(a); mpz_add_ui(b,b,1)</code> then a is 3 and b is 4. In short you need 
        an mpz_init or similar for every distinct value that needs to be held simultaneously.
       <br>
       <h3>Example:</h3>
       <div id="code-snippet-1" class="codeSnippetContainer" xmlns="">
        <div class="codeSnippetContainerCodeContainer">
         <div class="codeSnippetToolBar">
          <div class="codeSnippetToolBarText">
               <a id="copytext" href="javascript:CopyToClipboard('CodeSnippetContainerCode_18b74j93-qx54-4765-123h-8b2483c92846');">Copy</a>
          </div>
         </div>
         <div id="CodeSnippetContainerCode_18b74j93-qx54-4765-123h-8b2483c92846" class="codeSnippetContainerCode" dir="ltr">
          <div style="color:Black;">
           <small>
<!--eucode>
include mpfr.e

mpz n = mpz_init()
for e = 1 to 3 do
    mpz_ui_pow_ui(n, 10, e*30)
    mpz_sub_ui(n, n, 1)
    printf(1, "10^%d-1 = %s\n",{e*30,mpz_get_str(n,comma_fill:=true)})
end for
n = mpz_free(n)
</eucode-->
<pre>
<font color="#008080">include</font><font color="#000000"> mpfr.e
</font>
<font color="#7060A8">mpz</font><font color="#000000"> n</font><font color="#0000FF"> =</font><font color="#7060A8"> mpz_init</font><font color="#0000FF">()</font>
<font color="#008080">for</font><font color="#000000"> e</font><font color="#0000FF"> =</font><font color="#000000"> 1</font><font color="#008080"> to</font><font color="#000000"> 3</font><font color="#008080"> do</font>
<font color="#7060A8">    mpz_ui_pow_ui</font><font color="#0000FF">(</font><font color="#000000">n</font><font color="#0000FF">,</font><font color="#000000"> 10</font><font color="#0000FF">,</font><font color="#000000"> e</font><font color="#0000FF">*</font><font color="#000000">30</font><font color="#0000FF">)</font>
<font color="#7060A8">    mpz_sub_ui</font><font color="#0000FF">(</font><font color="#000000">n</font><font color="#0000FF">,</font><font color="#000000"> n</font><font color="#0000FF">,</font><font color="#000000"> 1</font><font color="#0000FF">)</font>
<font color="#7060A8">    printf</font><font color="#0000FF">(</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#008000"> "10^%d-1 = %s\n"</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">e</font><font color="#0000FF">*</font><font color="#000000">30</font><font color="#0000FF">,</font><font color="#7060A8">mpz_get_str</font><font color="#800080">(</font><font color="#000000">n</font><font color="#0000FF">,</font><font color="#000000">comma_fill</font><font color="#0000FF">:=</font><font color="#004600">true</font><font color="#800080">)</font><font color="#800000">}</font><font color="#0000FF">)</font>
<font color="#008080">end for</font>
<font color="#000000">n</font><font color="#0000FF"> =</font><font color="#7060A8"> mpz_free</font><font color="#0000FF">(</font><font color="#000000">n</font><font color="#0000FF">)</font>
</pre>
           </small>
          </div>
         </div>
        </div>
       </div>
        Output:
        <small>
 <pre>
10^30-1 = 999,999,999,999,999,999,999,999,999,999
10^60-1 = 999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999
10^90-1 = 999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999
 </pre>
        </small>
        For comparision, here is the (accurate to &tilde;15/17dp) behaviour of the standard builtin <a href="atom.htm">atom</a>:
        (
       <small>Manually re-aligned. Aside: 10^60 has seven more digits of accuracy than expected on 32 bit, no idea why, or even how.</small>)
       <br>
       <br>
       <div id="code-snippet-1" class="codeSnippetContainer" xmlns="">
        <div class="codeSnippetContainerCodeContainer">
         <div class="codeSnippetToolBar">
          <div class="codeSnippetToolBarText">
               <a id="copytext" href="javascript:CopyToClipboard('CodeSnippetContainerCode_18b74j93-atom-4765-177h-8b2483c92846');">Copy</a>
          </div>
         </div>
         <div id="CodeSnippetContainerCode_18b74j93-atom-4765-177h-8b2483c92846" class="codeSnippetContainerCode" dir="ltr">
          <div style="color:Black;">
           <small>
<!--eucode>
for e = 1 to 3 do
    printf(1, "10^%d-1 = %,d\n",{e*30,power(10,e*30)-1})
end for
</eucode-->
<pre>
<font color="#008080">for</font><font color="#000000"> e</font><font color="#0000FF"> =</font><font color="#000000"> 1</font><font color="#008080"> to</font><font color="#000000"> 3</font><font color="#008080"> do</font>
<font color="#7060A8">    printf</font><font color="#0000FF">(</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#008000"> "10^%d-1 = %,d\n"</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">e</font><font color="#0000FF">*</font><font color="#000000">30</font><font color="#0000FF">,</font><font color="#7060A8">power</font><font color="#800080">(</font><font color="#000000">10</font><font color="#0000FF">,</font><font color="#000000">e</font><font color="#0000FF">*</font><font color="#000000">30</font><font color="#800080">)</font><font color="#0000FF">-</font><font color="#000000">1</font><font color="#800000">}</font><font color="#0000FF">)</font>
<font color="#008080">end for</font>
</pre>
           </small>
          </div>
         </div>
        </div>
       </div>
        Output:
        <small>
 <pre>
-- 32-bit:
10^30-1 = 1,000,000,000,000,000,424,684,240,284,426
10^60-1 = 1,000,000,000,000,000,000,000,082,442,268,486,026,840,024,008,840,604,006,400,824
10^90-1 =   999,999,999,999,999,686,426,868,868,000,042,200,008,468,264,024,420,280,668,688,280,420,208,406,626,688,068,446,402,024
-- 64-bit:
10^30-1 =   999,999,999,999,999,998,264,846,264,264
10^60-1 =   999,999,999,999,999,996,186,866,828,000,402,842,426,462,280,408,402,286,040,882
10^90-1 = 1,000,000,000,000,000,004,244,424,008,082,284,008,804,242,048,002,866,280,462,022,042,286,202,060,886,602,048,286,628,466
 </pre>
        </small>
        Many operations are performed in-situ via procedure calls, eg mpfr_mul(x,y,z) sets x to y*z.<br>
        Source and targets may overlap, eg mpfr_mul(x,x,x) etc is perfectly fine and sets x to x*x.
       <br>
       <br>
        Since phix does not have unsigned integers, if an _ui routine has an _si variant it should be used instead. 
        It also makes sense to utilise the standard integer typechecking within the mpfr.e wrapper, hence some of the _ui 
        routines are syntax coloured illegal/red and linked to their _si counterparts, and where no such exists in C the
        _ui name is kept, but with fatal errors for args&lt;0.<br>
        In the rare case some code actually uses an unsigned value above the normal 30 bit integer limit of 1GB, it
        must be changed to use xxx_d or xxx_str.<br>
        Also take heed of the -1GB..+1GB vs 0..1GB below (obviously not technically accurate for 64-bit, but still a necessity 
        for any 32 and 64 bit compatible code).<br>
        As ever, this document is just a quick cribsheet: for specific details refer to the mpfr.e source code and/or the 
        official mpfr/mpir/gmp documentation, and/or search demo/rosetta for examples.
       <br>
       <br>
        Types mpfr, mpq, and mpz are optional, you can just use atom if preferred, though when debug_types is 
        <a href="logicops.htm#tf">true</a> (it is) these also perform some extra anti-corruption checks. They all allow NULL.
       <br>
       <br>
       <!--
dl {
    border: 3px double #ccc;
    padding: 0.5em;
  }
  dt {
    float: left;
    clear: left;
    width: 100px;
    text-align: right;
    font-weight: bold;
    color: green;
  }
  dt::after {
    content: ":";
  }
  dd {
    margin: 0 0 0 110px;
    padding: 0 0 0.5em 0;
  }
          dd .div1 {padding-left:.5em;border-left:1px solid #333;font-size:.9em;clear:both;}
          dd .div2 {color:#900;font-size:.76em;margin-top:.5em;margin-bottom:.5em;clear:both;}
--DEV did not work:
          table,td {padding:0;border-style:none;}
            <td align="right" class="nob">
          td.nob {padding:0;border-style:none;}
-->
       <h3>general</h3>
       <div id="nopad" class="nopad" align="center">
        <table cellspacing="0" cellpadding="0" border="0" style="padding: 0; border-style: none;">
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpir_open_dll></a>
            string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpir_open_dll</b>(string dll_name="", boolean mpir_only=<a href="logicops.htm#tf">false</a>)
            - optional: returns the name of a dll/so file it cannot open, or "" on success.<br>
            </dt>
            <dd class="pad">
            If only using mpz routines, you can get by with only opening/distributing the mpir dll(s), and should set the optional flag to 
            <a href="logicops.htm#tf">true</a>, and in that case mpir_open_dll() becomes non-optional. 
            Conversely, attempts to load the mpfr dll/so, without loading the mpir one first, fail at the OS level.<br>
            If dll/so are missing, and you have not used this, any and all of the following routines below will terminate with a fatal error.<br>
            The <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a> version simply always returns "" (and ignores any parameters).
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpir_get_versions></a>
           <nobr>sequence res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpir_get_versions</b>(boolean bAsNumSeq=<a href="logicops.htm#tf">false</a>)
            - yields a 3-element sequence of three versions (mpfr, mpir, and gmp), eg {"3.1.5","2.7.2","5.1.3"} or {{3,1,5},{2,7,2},{5,1,3}}.
            </dt>
            <dd class="pad">
            Note that on windows 64 bit, the mpfr.e wrapper assumes mpir is version 2.6.0 or later, with 64 bit integer arguments for _ui and _si routines, but
            does not explicitly check that, which may cause subtle problems should you obtain and use an older dll build (not from me).<br>
            If mpir_open_dll() was invoked with mpir_only=<a href="logicops.htm#tf">true</a>, the first element of the result will be "mpfr_dll==NULL".<br>
            The <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a> version (effectively) returns {"JavaScript","mpfr.js","n/a"}, ignoring bAsNumSeq,
            and is therefore acceptable for display but not version checking (obviously an "if platform()!=JS then" is advised).
            </dd>
           </dl>
          </td>
         </tr>
        </table>
       </div>
       <div style="clear:both;height:1px;"> </div>

        <a name=mpz></a>
       <h3>mpz (integer)</h3>
       <div id="nopad" class="nopad" align="center">
        <table cellspacing="0" cellpadding="0" border="0" style="padding: 0; border-style: none;">
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_init></a>
            mpz res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_init</b>(object v=0, integer bitcount=0) - Initialise. v can be integer/atom/string, but <i>not</i> mpz, for that use mpz_init_set().
            </dt>
            <dd class="pad">
<!--            Note that a string value in v may <i>not</i> use exponentiation, such as "1e200" (as per the C api, sorry).<br>-->
            As of 1.0.0 you <i>can</i> use exponentiation, such as "1e200" or even "2.5e1" (but not "2.5" or "2.55e1" aka non-integer,
            or bases>10). Unlike the nans of C&rsquo;s mpfr_init(), the defaulted v=0 of mpz_init() matches the C api behaviour.<br>
            Covers the C functions mpz_init(), <span class="illegal">mpz_init2</span>(), 
            <span class="illegal">mpz_init_set_d</span>(), <span class="illegal">mpz_init_set_si</span>(), and 
            <span class="illegal">mpz_init_set_str</span>().<br> 
            Note the (equivalent of the) latter three <i>can</i> take a bitcount in mpfr.e (albeit completely ignored in mpfr.js).<br>
            The bitcount is only the initial space, ie/eg mpz_init(1) happily stores it in one dword, a later store of 2^16000 reallocates it to 
            16000 bits (about 500 dwords). A non-zero bitcount makes it possible to avoid reallocations if a suitable size is known in advance.<br>
            You c/should use (eg) mpz_sizeinbase(x,2) in some prior test run to determine an initial bitcount (and check it actually makes the 
            thing faster).<br>
            Invoking res = mpz_free(res) when no longer needed is recommended, but occurs automatically if forgotten.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_inits></a>
           <nobr>sequence res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_inits</b>(integer n, object v=0) - initialise n variables to v. (ditto mpz_free)
            </dt>
            <dd class="pad">
            Note the method signature differs significantly from the C function of the same name.<br>
            Can also be coded as eg mpz {x,y,z} = mpz_inits(3).<br>
            v may be an integer, atom, string, (but not mpz), or a sequence of length n of said.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_init_set></a>
            mpz res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_init_set</b>(mpz src) - Initialise to some prior mpz, eg
             <small><i>(mpz x = mpz_init(...);)</i></small> mpz y = mpz_init_set(x). (ditto mpz_free)<br>
            </dt>
            <dd class="pad">
            Passing an mpz directly to mpz_init() is a similar error to using pDword when peek4u(pDword) is required, 
            and likewise there is no practical way to guard against that, you just get meaningless results. In fact
            mpz_init_set() can and does test it got an mpz, it is mpz_init() that simply cannot perform the inverse
            useful test that makes sure it has <i>not</i> been passed an mpz.
             <small>(The problem being that an actual value <i>could</i> coincide with an allocated memory address.)</small>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_free></a>
            object x =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_free</b>(object x) - Clear and deallocate any variables created using mpz_init[s|_set](), eg x = mpz_free(x)
            or {y,z} = mpz_free({y,z}).
            </dt>
            <dd class="pad">
            NB: lhs==rhs intentionally (not actually enforced but you should pretend it is). Also covers the C <span class="illegal">mpz_clears</span>() routine.<br>
            Should you forget to invoke this routine, mpfr.e will do so automatically (when the refcount drops to zero).<br>
            <span class="illegal">mpz_clear</span>() is not publicly available, use mpz_free() instead, which releases <i>both</i> mpir.dll <i>and</i> mpfr.e allocated memory.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_set></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_set</b>(mpz rop, op) -- rop := op. See also mpz_init_set.
            </dt>
            <dd class="pad">
            <b>mpz_set_si</b>(mpz rop, integer op) -- "" except op is a phix integer, -1GB..+1GB - use this instead of <span class="illegal">mpz_set_ui</span>().<br>
            <b>mpz_set_d</b>(mpz rop, atom op) -- "" except op is a phix <a href="atom.htm">atom</a>.<br>
            <b>mpz_set_q</b>(mpz rop, mpq op) -- "" except op is an mpq (truncated to make it an integer).<br>
            <b>mpz_set_str</b>(mpz rop, string s, integer base=0) -- set x from s in the specified base. See also mpz_init.<br>
            A base of 0 allows bases 2 and 16 to be auto-detected (after a leading +/-) by '0b', '0B', '0x' or '0X', otherwise base 10 is assumed.<br>
            A Phix-specific enhancement is to allow eg "1e200" (only base 10 is officially supported, though some others may work).
            General support for bases other than 2/8/10/16 (2..62 matching desktop/Phix) added to pwa/p2js in 1.0.2.<br>
            Note that desktop/Phix quietly ignores whitespace in s, whereas pwa/p2js (probably) won&rsquo;t, largely due to js/BigInt details 
            beyond my control, and/or not really being worthwhile implementing fiddly cleanup/workarounds, at least so far not yet.<br>
            <b>mpz_set_v</b>(mpz rop, object v) -- a Phix-specific shorthand for the above three (with said decimal assumption)
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_import></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_import</b>(mpz rop, integer count, order, size, endian, nails, atom_string op) -- set rop from raw binary data.
            </dt>
            <dd class="pad">
            The parameters specify the format of the data.<br>
            count: many words are read, each size bytes.<br>
            order can be 1 for most significant word first or -1 for least significant first.<br>
            Within each word endian can be 1 for most significant byte first, -1 for least, or 0 for the native endianness of the host CPU.<br>
            The most significant nails bits of each word are skipped, this can be 0 to use the full words.<br>
            There is no sign taken from the data, rop will simply be a positive integer.<br>
            An application can handle any sign itself, and apply it for instance with mpz_neg.<br>
            There are no data alignment restrictions on op, any address is allowed.<br>
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_export></a>
            <nobr>integer count =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_export</b>(atom pMem, integer order, size, endian, nails, mpz op) -- Fill pMem with word data from op.
            </dt>
            <dd class="pad">
            The parameters specify the format of the data produced.<br>
            Each word will be size bytes and order can be 1 for most significant word first or -1 for least significant first.<br>
            Within each word endian can be 1 for most significant byte first, -1 for least, or 0 for the native endianness of the host CPU.<br>
            The most significant nails bits of each word are unused and set to zero, this can be 0 to produce full words.<br>
            The number of words produced is returned, pMem must have enough space for the data (see below).<br>
            (The second parameter of the C function, size_t *countp, is handled internally by mpfr.e)<br>
            If op is non-zero then the most significant word produced will be non-zero.<br>
            If op is zero then the count returned will be zero and nothing written to rop.<br>
            The sign of op is ignored, just the absolute value is exported. An application can use mpz_sign to get the sign and handle it as desired.<br>
            There are no data alignment restrictions on rop, any address is allowed.<br>
            The required space can be determined with a calculation like the following.<br>
            Since mpz_sizeinbase always returns at least 1, count here will be at least one, though if op is zero no space at all is actually needed (or written).<br>
            numb = 8*size - nail<br>
            count = floor((mpz_sizeinbase (op, 2) + numb-1) / numb)<br>
            pMem = allocate(count * size)<br>
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_add></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_add</b>(mpz rop, op1, op2) - rop := op1 + op2
            </dt>
            <dd class="pad">
            <b>mpz_add_ui</b>(mpz rop, op1, integer op2) - "" except op2 is a phix integer, 0..1GB.<br>
            <b>mpz_add_si</b>(mpz rop, op1, integer op2) - (an <a href="#mpz_add_si">extra</a>) "" except op2 can be +/-1GB.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_addmul></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_addmul</b>(mpz rop, op1, op2) - rop := rop + op1 * op2
            </dt>
            <dd class="pad">
            <b>mpz_addmul_ui</b>(mpz rop, op1, integer op2) - "" except op2 is a phix integer, 0..1GB.<br>
            <b>mpz_addmul_si</b>(mpz rop, op1, integer op2) - (an <a href="#mpz_addmul_si">extra</a>) "", +/-1GB.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_sub></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_sub</b>(mpz rop, op1, op2) - rop := op1 - op2
            </dt>
            <dd class="pad">
            <b>mpz_sub_ui</b>(mpz rop, op1, integer op2) - "" except op2 is a phix integer, 0..1GB.<br>
            <b>mpz_ui_sub</b>(mpz rop, integer op1, mpz op2) - "" except op1/op2 types are switched.<br>
            <b>mpz_sub_si</b>(mpz rop, op1, integer op2) - (an <a href="#mpz_sub_si">extra</a>) as mpz_sub_ui() except op2 can be +/-1GB.<br>
            <b>mpz_si_sub</b>(mpz rop, integer op1, mpz op2) - (an <a href="#mpz_si_sub">extra</a>) as mpz_ui_sub() except op1 can be +/-1GB.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_submul></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_submul</b>(mpz rop, op1, op2) - rop := rop - op1 * op2
            </dt>
            <dd class="pad">
            <b>mpz_submul_ui</b>(mpz rop, op1, integer op2) - "" except op2 is a phix integer, 0..1GB.<br>
            <b>mpz_submul_si</b>(mpz rop, op1, integer op2) - (an <a href="#mpz_submul_si">extra</a>) "", +/-1GB.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_abs></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_abs</b>(mpz rop, op) - rop := <a href="abs.htm">abs</a>(op)
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_neg></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_neg</b>(mpz rop, op) - rop := -op
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_mul></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_mul</b>(mpz rop, op1, op2) - rop := op1 * op2
            </dt>
            <dd class="pad">
            <b>mpz_mul_si</b>(mpz rop, op1, integer op2) - "" except op2 is a phix integer, -1GB..+1GB - use this instead of <span class="illegal">mpz_mul_ui</span>()<br>
            <b>mpz_mul_d</b>(mpz rop, op1, atom op2) - (an <a href="#mpz_mul_d">extra</a>) as mpz_mul_si() except op2 is a phix <a href="atom.htm">atom</a><br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_mul_2exp></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_mul_2exp</b>(mpz rop, op1, integer op2) - rop := op1 * 2^op2. This operation can also be defined as a left shift by op2 bits.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_fdiv_q></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_fdiv_q</b>(mpz q, n, d) - q := <a href="floor.htm">floor</a>(n/d)<br>
            <b>mpz_fdiv_r</b>(mpz r, n, d) - r := <a href="remainder.htm">remainder</a>(n,d)<br>
            <b>mpz_fdiv_qr</b>(mpz q, r, n, d) - {q,r} := {<a href="floor.htm">floor</a>(n/d),<a href="remainder.htm">remainder</a>(n,d)}<br>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
<!-- DEV: new links done to here -->
            <a name=mpz_fdiv_q_ui></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_fdiv_q_ui</b>(mpz q, n, integer d) - {q,res} := {<a href="floor.htm">floor</a>(n/d),<a href="remainder.htm">remainder</a>(n,d)}<br>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_fdiv_q_2exp></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_fdiv_q_2exp</b>(mpz q, n, integer b) - bitwise right shift, arithmetic if n -ve.<br>
            <b>mpz_tdiv_q_2exp</b>(mpz q, n, integer b) - q := <a href="floor.htm">trunc</a>(n/2^b), rounds q towards zero<br>
            <b>mpz_tdiv_r_2exp</b>(mpz r, n, integer b) - r := <a href="remainder.htm">remainder</a>(n,2^b), r will have the same sign as n<br>
            <b>mpz_cdiv_q</b>(mpz q, n, d) - q := <a href="floor.htm">ceil</a>(n/d)<br>
            </dt>
            <dd class="pad">
            For positive n mpz_tdiv_q_2exp is a simple bitwise right shift.<br>
            For negative n mpz_tdiv_q_2exp effectively treats n as sign and magnitude. [untested...]<br>
            fdiv rounds q down towards -inf, and r will have the same sign as d. The f stands for "floor".<br>
            tdiv rounds q towards zero, and r will have the same sign as n. The t stands for "truncate".<br>
            cdiv rounds q up towards +inf, and r will have the opposite sign to d. The c stands for "ceil".<br>
            In all cases q and r will satisfy n = q(d) + r, and r will satisfy 0 &lt;= |r| &lt; |d|, where d is 2^b.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_divexact></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_divexact</b>(mpz r, n, d) - r := n/d
            </dt>
            <dd class="pad">
             <b>mpz_divexact_ui</b>(mpz r, n, integer d) - "" except d is a phix integer, 1..1GB<br>
             q = n/d, but only when it is known in advance that d divides n exactly.<br>
             The mpz_divexact[_ui] routines are much faster than the other division functions, and are the best choice
             when exact division is known to occur, for example reducing a rational to lowest terms.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_divisible_p></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_divisible_p</b>(mpz n, d) - returns non-zero if n is exactly divisible by d.
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_divisible_ui_p></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_divisible_ui_p</b>(mpz n, integer d) - "" except d is a phix integer, 0..1GB
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_divisible_2exp_p></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_divisible_2exp_p</b>(mpz n, integer b) - "" except tests if n is divisible by 2<small><sup>b</sup></small>
            </dt>
            <dd class="pad">
            n is divisible by d if there exists an integer q satisfying n = qd.<br>
            Unlike the other division functions, d = 0 is accepted and following that rule (only) 0 is considered
            divisible by 0.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_remove></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_remove</b>(mpz rop, op, f) - removes all occurrences of the factor f from op and stores the result in rop.
            </dt>
            <dd class="pad">
            Typically only invoked after mpz_divisible_p() returns non-zero. The return value is how many occurrences were removed.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_fdiv_ui></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_fdiv_ui</b>(mpz n, integer d) - returns mod(n,d) - n and d remain unaltered, d is a phix integer, 0..1GB.
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_mod></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_mod</b>(mpz r, n, d) - r := mod(n,d)
            </dt>
            <dd class="pad">
             <b>mpz_mod_ui</b>(mpz r, n, integer d) - "" except d is a phix integer, 0..1GB<br>
             <small>(In practice mpz_mod_ui() utilises the mpz_fdiv_r_ui() C entry point.)<br></small>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_pow_ui></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_pow_ui</b>(mpz rop, base, integer exponent) - rop := base^exponent, where exponent is a phix integer, 0..+1GB.<br>
            </dt>
            <dd class="pad">
            <b>mpz_ui_pow_ui</b>(mpz rop, integer base, exponent) - "", except base is also a phix integer. The case 0^0 yields 1.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_powm></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_powm</b>(mpz rop, base, exponent, modulus) - rop := mod(base^exponent,modulus)
            </dt>
            <dd class="pad">
            <b>mpz_powm_ui</b>(mpz rop, base, integer exponent, mpz modulus) - "", except exponent is a phix integer, 0..+1GB
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_root></a>
            bool bExact =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_root</b>(mpz rop, op, integer n) - rop:=<a href="floor.htm">trunc</a>(power(op,1/n)), returns (rop===op^n).
            </dt>
            <dd class="pad">
            Set rop to the truncated integer part of the nth root of op.<br>
            Return <a href="logicops.htm#tf">true</a> if the computation was exact, i.e. rop===op^n.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_nthroot></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_nthroot</b>(mpz rop, op, integer n) - rop:=<a href="floor.htm">trunc</a>(power(op,1/n)).
            </dt>
            <dd class="pad">
            Set rop to the truncated integer part of the nth root of op.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_sqrt></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_sqrt</b>(mpz rop, op) - rop := <a href="floor.htm">floor</a>(<a href="log.htm">sqrt</a>(op))
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_sqrtrem></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_sqrtrem</b>(mpz rop1, rop2, op) - {rop1,rop2} := {<a href="floor.htm">floor</a>(<a href="log.htm">sqrt</a>(op)),op-rop1^2}
            </dt>
            <dd class="pad">
            rop2 will be zero if op is a perfect square. If rop1 and rop2 are the same variable, the results are undefined.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_and></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_and</b>(mpz rop, op1, op2) - rop := and_bits(op1,op2)
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_xor></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_xor</b>(mpz rop, op1, op2) - rop := xor_bits(op1,op2)
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_popcount></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_popcount</b>(mpz op) - res := <a href="shift_bits.htm#count_bits">count_bits</a>(op)
            <dd class="pad">
            If op &gt;= 0, return the population count of op, which is the number of 1 bits in the binary
            representation. If op &lt; 0, the number of 1s is infinite, and the return value is ULONG MAX,
            the largest possible mp_bitcnt_t.
            </dd>
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_fac_ui></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_fac_ui</b>(mpz rop, integer n) - Set rop to the factorial of n.<br>
            <dd class="pad">
            Equivalent, for small n, and bar the mpz result, to <a href="factorial.htm">factorial</a>(n).
            </dd>
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_fib_ui></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_fib_ui</b>(mpz fn, integer n) - fn := fibonacci(n), where n is a phix integer, 0..+1GB
            </dt>
            <dd class="pad">
            <b>mpz_fib2_ui</b>(mpz fn, fnsub1, integer n) - as "", plus fnsub1 := fibonacci(n-1) (and must have the prev value on input).<br>
            See demo\rosetta\fibonacci.exw: note that mpz_fib_ui() is intended for isolated values only; 
            while an isolated mpz_fib_ui(4784969) takes just 0.1s, invoking mpz_fib_ui(1..4784969) would 
            take about 3&frac12; days(!!) whereas the version in that file gets the same job done in 
            about 2mins 40s, averaging &tilde;30,000/s - not bad for million-digit numbers!
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_bin_uiui></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_bin_uiui</b>(mpz rop, integer n, k) - calculate n choose k, ie n!/((n-k)!*k!)<br>
            <dd class="pad">
            Equivalent, for small n and k, and bar the mpz parameter, to <a href="factorial.htm">choose</a>(n,k)<br>
            <small>(replaces a non-standard mpz_binom() function in the previous release)</small>
            </dd>
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_invert></a>
            bool res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_invert</b>(mpz rop, op1, op2) - Set rop to the inverse of op1 modulo op2.
            </dt>
            <dd class="pad">
            Compute the inverse of op1 modulo op2 and put the result in rop. <br>
            If the inverse exists, the return value is <a href="logicops.htm#tf">true</a> and rop will satisfy 0 &lt;= rop &lt; op2. <br>
            If an inverse doesn&rsquo;t exist the return value is <a href="logicops.htm#tf">false</a> and rop is undefined.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_gcd></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_gcd</b>(mpz rop, op1, op2) - Set rop to the greatest common divisor of op1 and op2.
            </dt>
            <dd class="pad">
            The result is always positive even if one or both input operands are negative.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_gcd_ui></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_gcd_ui</b>(mpz rop, op1, integer op2) - Compute the greatest common divisor of op1 and op2.
            </dt>
            <dd class="pad">
            If rop is not NULL, store the result there.<br>
            If the result is small enough to fit in an mpir_ui, it is returned.<br>
            If the result does not fit, 0 is returned, and the result is equal to the argument op1.<br>
            Note that the result will always fit if op2 is non-zero, though when translating code you may hit problems
            with op2 being limited (in this Phix wrapper) to 0..+1GB rather than the C api of mpir_ui being 0..+4GB.<br>
            It would of course not be difficult to add a phix-specific mpz_gcd_d() with an atom parameter to ease that.<br>
            Also note this wrapper implodes if op2<0, whereas the C api would quietly cast it to an unsigned integer, and
            likewise I forsee no real difficultly performing a proper 2&rsquo;s-compliment abs(), bar perhaps minint.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_lcm></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_lcm</b>(mpz rop, op1, op2) - Set rop to the least common multiple of op1 and op2.
            </dt>
            <dd class="pad">
            <b>mpz_lcm_ui</b>(mpz rop, op1, integer op2) - "" except op2 is a phix integer, 0..1GB.<br>
             rop is always positive, irrespective of the signs of op1 and op2. rop will be zero if either op1 or op2 is zero.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_cmp></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dt>
            <b>mpz_cmp</b>(mpz op1, op2) - Compare op1 and op2. Return +1 if op1&gt;op2, 0 if op1=op2, or -1 if op1&lt;op2.
           </dt>
           <dd class="pad">
            Note the mpfr.e wrapper explicitly converts the C +ve/0/-ve result to +1/0/-1 using <a href="sign.htm">sign</a>().
           </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_cmp_si></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_cmp_si</b>(mpz op1, integer op2) - "", except op2 is a phix integer, -1GB..+1GB - use this instead of <span class="illegal">mpz_cmp_ui</span>().<br>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_sign></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_sign</b>(mpz op1) - -1: op1 -ve, 0: op1=0, +1: op1 +ve. Compatibility shim for the C macro <span class="illegal">mpz_sgn</span>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_odd></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_odd</b>(mpz op1) - returns <a href="logicops.htm#tf">true</a> if op1 is odd. 
            Compatibility shim for the C macro <span class="illegal">mpz_odd_p</span>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_even></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_even</b>(mpz op1) - returns <a href="logicops.htm#tf">true</a> if op1 is even. 
            Compatibility shim for the C macro <span class="illegal">mpz_even_p</span>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_tstbit></a>
           <nobr>integer res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_tstbit</b>(mpz op, integer bit_index) - Test bit bit_index in op and return 0 or 1 accordingly.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_scan0></a>
           integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_scan0</b>(mpz op, integer starting_bit) - Find first 0 in op >= starting_bit.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_scan1></a>
           integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_scan1</b>(mpz op, integer starting_bit) - Find first 1 in op >= starting_bit.
          </td>
         </tr>
<!-- (removed as not of much practical use, and o/c it would not exactly be very p2js compatible)
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            mpz_size(mpz op) - Return the size of op measured in number of limbs. If op is zero, the returned value will be zero.
          </td>
         </tr>
-->
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_sizeinbase></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_sizeinbase</b>(mpz op, integer base) - Return the size of op measured in number of digits in the given base.<br>
            Note there is no <span class="illegal">mpz_size</span>() function in mpfr.e ("" in limbs), since it is not very useful
            and would not be p2js compatible.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_get_str></a>
            string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_get_str</b>(mpz op, integer base=10, boolean comma_fill=<a href="logicops.htm#tf">false</a>)
             - Return op as a string in the specified base (2..62).
            </dt>
            <dd class="pad">
            Note that mpz_free_string() is taken care of automatically for you by mpfr.e. 
            See also <a href="#mpz_get_short_str">mpz_get_short_str</a>().
            </dd>
           </dl>
          </td>
         </tr>
<!--
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_probable_prime_p</b>(mpz n, randstate state, integer prob=5, div=0)
            </dt>
            <dd class="pad">
            Determine whether n is a probable prime with the chance of error being at most 1 in 2^prob.<br>
            The return value is 1 if n is probably prime, or 0 if n is definitely composite.<br>
            This function does some trial divisions to speed up the average case, then some probabilistic
            primality tests to achieve the desired level of error.<br>
            div can be used to inform the function that trial division up to div has already been performed
            on n and so n has NO divisors &lt;= div.<br>
            (The default of 0 informs the function that no trial division has been done.)<br>
            The variable state must have been initialized by calling one of the gmp_randinit functions.<br>
            This function interface is preliminary and may change in the future.<br>
            Not supported under <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js</b></span></a>, use 
            <a href="mpfr.htm#mpz_prime">mpz_prime</a>() instead.
            </dd>
           </dl>
          </td>
         </tr>
-->
        </table>
       </div>
       <div style="clear:both;height:1px;"> </div>
<!--
        <a name=mpzrand></a>
       <h3>random integers</h3>
       <div id="nopad" class="nopad" align="center">
        <table cellspacing="0" cellpadding="0" border="0" style="padding: 0; border-style: none;">
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
           <nobr>randstate state =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>gmp_randinit_mt</b>() - Initialize state for a Mersenne Twister algorithm, and invokes gmp_randseed on it (with a NULL mpz_seed).
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
           <!X-X-X procedure X-X-X>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>gmp_randseed</b>(randstate state, atom mpz_seed=NULL) - Set an initial seed value into state.
            </dt>
            <dd class="pad">
            If mpz_seed is NULL then a random 200-digit seed is generated internally (and properly disposed of after use),
            otherwise mpz_seed must be a valid/init mpz variable (and absolutely <i>not</i> a phix integer/atom/string).<br>
            Just like <a href="rand.htm">set_rand</a>(), using a fixed value gives repeatable results.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            randstate state =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>gmp_randclear</b>(randstate state) - Free all memory occupied by state.
            Should you forget to invoke this routine, mpfr.e will do so automatically.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
           <x!x-x- procedure -x-x>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_urandomm</b>(mpz rop, randstate state, mpz n) - Generate a uniform random integer in the range 0 to n-1 inclusive, and store it in rop.
          </td>
         </tr>
        </table>
       </div>
       <div style="clear:both;height:1px;"> </div>
-->

        <a name=mpzextras></a>
       <h3>extras</h3>
        The following routines are mpfr.e-specific and not part of the C api, hence there is probably not much point in googling them.<br>
        Some were largely written for simple convenience, as opposed to any improvements in performance, although I would say that 
        <a href="mpfr.htm#mpz_prime_factors">mpz_prime_factors</a>() is (I think) exceptionally efficient at what it does best, 
        unless/until you push it too far, as detailed below. Also, some routines (the integer/atom ones) are deliberately renamed 
        because they have slightly different upper limits. Note that mpz_set_v() as documented above more strictly belongs in this
        section.
       <br>
       <br>
       <div id="nopad" class="nopad" align="center">
        <table cellspacing="0" cellpadding="0" border="0" style="padding: 0; border-style: none;">
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_get_short_str></a>
            string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_get_short_str</b>(mpz op, integer ml=20, base=10, boolean comma_fill=<a href="logicops.htm#tf">false</a>, string what="digits")
            </dt>
            <dd class="pad">
            Equivalent to <a href="shorten.htm">shorten</a>(<a href="#mpz_get_str">mpz_get_str</a>(op,base,comma_fill),ml:=ml)) 
            but much faster, since it does not construct potentially hundreds of thousands of middle digits and just throw them away.
            Sadly no real impact under pwa/p2js, oh well.<br>
            Note that ml is expressed in characters, so if you specify comma_fill and a length of 4 then you&rsquo;ll 
            get (say) "12,3...,678 (nn digits)" back, the commas where they w/should rightly be on a full-length result, 
            and obviously the trailing part will probably look nicer when ml is 4k-1, ie 3,7,11,15 etc.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
<!-- SUG: mpz_add_d, mpz_sub_d, mpz_d_sub -->
            <a name=mpz_add_si></a>
            <b>mpz_add_si</b>(mpz rop, op1, integer op2) - invokes mpz_add_ui() or mpz_sub_ui() with -op2, crashes if op2 is -(maxint+1).<br>
            <a name=mpz_sub_si></a>
            <b>mpz_sub_si</b>(mpz rop, op1, integer op2) - invokes mpz_sub_ui() or mpz_add_ui() with -op2, crashes if op2 is -(maxint+1).<br>
            <a name=mpz_si_sub></a>
            <b>mpz_si_sub</b>(mpz rop, integer op1, mpz op2) - invokes mpz_sub_si(rop,op2,op1) then mpz_mul_si(rop,rop,-1).<br>
            <a name=mpz_mul_d></a>
            <b>mpz_mul_d</b>(mpz rop, op1, atom op2) - as mpz_mul_si() except op2 is a phix <a href="atom.htm">atom</a><br>
            <a name=mpz_addmul_si></a>
            <b>mpz_addmul_si</b>(mpz rop, op1, integer op2) - as mpz_addmul_ui() except op2 is +/-1GB<br>
            <a name=mpz_submul_si></a>
            <b>mpz_submul_si</b>(mpz rop, op1, integer op2) - as mpz_submul_ui() except op2 is +/-1GB<br>
            <a name=mpfr_addmul_si></a>
            <b>mpfr_addmul_si</b>(mpfr rop, op1, integer op2, rounding=default_rounding) - to match mpz_addmul_si() (note there is no mpfr_addmul_ui)<br>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_min></a>
           <nobr>mpz/int res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_min</b>(sequence s, boolean return_index=<a href="logicops.htm#tf">false</a>) - return the smallest element of s, or its index.
            </dt>
            <dd class="pad">
            s must be a flat and non-empty sequence of mpz.<br>
            This routine is similar to <a href="min.htm">minsq</a>() [as opposed to <a href="min.htm">min</a>()], but applies mpz_cmp() internally.<br>
            The result is a shared reference, modifying it directly (ie w/o an mpz_[init_]set() call) will modify the corresponding element of s.<br>
            The corresponding <b>mpz_max</b>() routine is identical, but obviously returns the largest element/index of s.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_fits_integer></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_fits_integer</b>(mpz op) - Return non-zero if the value of op fits in a (signed) phix integer, otherwise, return zero.<br>
            </dt>
            <dd class="pad">
            Note that the C routines <span class="illegal">mpz_fits_slong_p</span>() and <span class="illegal">mpz_fits_ulong_p</span>() are 
            (deliberately) not available in mpfr.e, and<br>
            this routine tests for slightly smaller limits, in fact (on 32 bit) +/-#3FFFFFFF with -#40000000 being deemed out-of-range.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_fits_atom></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_fits_atom</b>(mpz op, boolean tztrim=<a href="logicops.htm#tf">false</a>)
             - Return non-zero if the value of op fits in a (signed) phix atom, otherwise, return zero.<br>
            </dt>
            <dd class="pad">
            Note that (on 32 bit) 9,007,199,254,740,992 is deemed just-out-of-range, since that is the first value that "accidentally" fits, by ending in 
            a binary 0, that is when tztrim is <a href="logicops.htm#tf">false</a>, otherwise it returns <a href="logicops.htm#tf">true</a> for that and 
            9,007,199,254,740,994 but <a href="logicops.htm#tf">false</a> for 9,007,199,254,740,993, in other words tztrim=<a href="logicops.htm#tf">true</a> 
            makes it start returning <a href="logicops.htm#tf">true</a> for every 2<small>nd</small>, 4<small>th</small>, 8<small>th</th>, etc integer value.<br>
            Obviously that 994 is technically out of range, but would not be altered by a round trip into and back out of an atom, which
            is what that tztrim (trim trailing binary zeroes) parameter effectively implements.<br>
            While on 32-bit there is a huge difference between 31-bit integers and 53-bit atoms, on 64-bit there is only 1 bit of difference  
            between mpz_fits_integer (63 bits) and mpz_fits_atom (64 bits), at least when tztrim is <a href="logicops.htm#tf">false</a>.<br>
            While mpz_fits_integer() is somewhat of a compatibility fudge, in that under pwa/p2js it artificially recreates a boundary that does not 
            technically exist, mpz_fits_atom() is in contrast an absolutely perfect fit: you could not design a more appropriate routine for JavaScript 
            even if you tried.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_get_integer></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_get_integer</b>(mpz op) - Return op as a phix integer. Use mpz_fits_integer() to find out if
            the value will fit/be meaningful.
            </dt>
            <dd class="pad">
            Note there are (deliberately) no <span class="illegal">mpz_get_si</span>() or <span class="illegal">mpz_get_ui</span>() 
            functions in mpfr.e, use this instead and be aware that a phix integer is effectively one bit smaller than a C signed long,
            and two bits smaller than a C unsigned long.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_get_atom></a>
            atom res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_get_atom</b>(mpz op) - Return op as a phix atom. Use mpz_fits_atom() to find out if
            the value will fit/be meaningful.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_or_string></a>
            type&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpz_or_string</b> - I trust this is self explanatory, and obviously integer/atom are <i><b>not</b></i> allowed.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_prime_factors></a>
           <nobr>sequence res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_prime_factors</b>(mpz_or_string s, integer maxprime=100) - attempt to decompose the "integer" s into powers of small primes.
            </dt>
            <dd class="pad">
             returns eg 108 ==> {{2,2},{3,3}} (ie 2^2*3^3==4*27==108), or 10080 ==> {{2,5},{3,2},{5,1},{7,1}}, or 1196836 ==> {{2,2},{"299209"}}<br>
             Each element of the result is a {prime,power} pair, except for the last which may be a lone string:<br>
             The default 100th prime is 541, so at that setting this is exact/complete for all inputs &lt;= 541^2 == "292681", 
             and you can easily raise (or lower) that limit, within reason.<br>
             However, factors of even a 72-digit number is sufficiently hard that almost all internet security is based on it being a 
             <b><i>really hard</i></b> problem. <small>(72 digits is now rather ancient 256-bit security, more recently we have seen 2048-bit security 
             which is ~= factors of 575 decimal digits)</small><br>
             Hence this is designed to "give up" early/in a sensible fashion, eg:
             mpz_prime_factors(sprintf("%d",power(2*get_prime(101),2)),100) yields {{2,2},{"299209"}}.<br>
             Increasing maxprime to 101 obviously makes a big difference, ie:
             mpz_prime_factors(sprintf("%d",power(2*get_prime(101),2)),101) yields {{2,2},{547,2}}.<br>
             Increasing maxprime to say 100,000,000 is likely to make this excruciatingly slow, yet still only fully handle 20-digit numbers.<br>
             Note that while <a href="factors.htm">prime_factors</a>() accepts a -1 in maxprime there is no such facility here.<br>
             A length(res[$]) of 1 means it either failed mpz_fits_atom() or is greater than <a href="get_prime.htm">get_prime</a>(maxprime)^2, returned as a (lone) final string.<br>
             Also, while all other elements of res are almost certainly phix integer [pairs], res[$][1] may be atom (1GB..4GB), independently of res[$] being a lone string.<br>
             Finally, two special cases exist: s=0 yields {}, and s=1 yields {{2,0}}, aka 2^0.
             <!-- (Future versions may also accept a non-string s, similar to mpz_init[_set], if there is ever a genuine need for that.)-->
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_pollard_rho></a>
            sequence res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_pollard_rho</b>(mpz_or_string s, bool bAsStrings=<a href="logicops.htm#tf">false</a>)
             - find factors of s, usually significantly faster than mpz_prime_factors().
            </dt>
            <dd class="pad">
            Uses a pollard rho method for s greater than 100,000,000 else mpz_prime_factors() ie primes&lt;=10,000.<br>
            The result is a slightly flattened version of that from mpz_prime_factors(), eg {{2,2},"837568909977835437"}, or all strings if asked for, 
            in other words mpz_pollard_rho("8",true) yeilds {"2","2","2"} whereas mpz_pollard_rho("8") yields {{2,3}}.<br>
            Any factors which fail mpz_fits_atom() will certainly be returned as strings, however some smaller (but &gt; 100,000) may also slip through,
            In other words you might get "456773" instead of 456773, but I&rsquo;m sure you&rsquo;ll cope, and unlike mpz_prime_factors() there may be 
            multiple strings in the result, even when bAsStrings is <a href="logicops.htm#tf">false</a>.<br>
<!-- (what, am I bragging about having a backlog, deliberately trying to disappoint, or something else??)
            It is planned, but not a high priority, to further improve this routine using the code from
            <a href="javascript:ExternalLink('ext732');" id="ext732" 
               style="color:#9B5565">https://rosettacode.org/wiki/Factors_of_a_Mersenne_number#Phix</a>.<br>
-->
            Since this routine invokes <a href="mpfr.htm#mpz_prime">mpz_prime</a>() in the main loop anyway, there is not likely to be much benefit from 
            calling it first.<br>
            Obviously mpz_prime_factors() remains a better choice should you not be interested in factors over 10,000 and maybe 100,000.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_factors></a>
            sequence res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_factors</b>(object s, object include1=0, bool bAsAtmStr=<a href="logicops.htm#tf">true</a>, 
                                                                 bSort=<a href="logicops.htm#tf">true</a>)
            </dt>
            <dd class="pad">
            Constructs the equivalent of <a href="factors.htm">factors</a>(n,include1) from the prime powers.<br>
            s can be an integer atom (within the native precision limits), a string, a dword-sequence result from mpz_pollard_rho, or a "tagged" mpz 
            which looks like this: {"mpz",z}. Take special care to wrap an mpz like that; there is a high risk of treating the raw memory address of 
            an unwrapped mpz as an integer <small>(and pretend to work, as opposed to terminating with a more helpful error)</small>.<br>
<!--
            When I say integer, I mean an atom with no fractional part that passes
            builtins/pfactors.e/check_limits() or its equivalent, so maybe
            "small" isn&rsquo;t quite the right word, but I think you get what I mean.<br>
-->
            if bAsAtmStr is <a href="logicops.htm#tf">false</a>, the result is a sequence of mpz, otherwise (the default) result is a mixture of atoms 
            (when they fit) and strings (when they exceed the 53/64 bit precision limit of normal Phix atoms). 
            A bAsAtmStr parameter of 2 means "return all as strings".<br>
            Just as mpz_pollard_rho() can return strings for prime factors that do not fit in a phix atom, any strings in a dword_sequence s are assumed 
            to be (such) primes, and the result may be a mixture of integers and strings.<br>
            Sorting probably adds very little overhead, but you never know...<br>
            ?mpz_factors(12,bSort:=false)       ==> {1,2,4,3,6,12}<br>
            ?mpz_factors(12,bSort:=true)&nbsp;  ==> {1,2,3,4,6,12}<br>
            ?mpz_factors("12345678999999977",bAsAtmStr:=true) ==> {1,35604581,346744117,"12345678999999977"}<br>
            ?mpz_factors("12345678999999977",bAsAtmStr:=2) ==> {"1","35604581","346744117","12345678999999977"}<br>
            Note this is not expected to handle duplicate input strings correctly: should you have (somehow) managed to factor a 32-digit+ number, good 
            on you, but you have long since passed the bounds of what is realistically feasible, unless, that is, all the prime factors are reasonably 
            small integers.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_factorstring></a>
            string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_factorstring</b>(sequence s) - converts eg {{2,2},{3,3}} to "2^2*3^3", or {{2,5},{3,2},{5,1},{7,1}} to "2^5*3^2*5*7".
            </dt>
            <dd class="pad">
            s is typically from <a href="mpfr.htm#mpz_prime_factors">mpz_prime_factors</a>(), but does not have to be, 
            and s[$] may be {string} (ie unfactored/able).
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_re_compose></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_re_compose</b>(mpz rop, sequence s) - takes eg s of {{2,2},{3,3}} and sets rop to 108, ie 2^2*3^3 === 4*27 === 108.
            </dt>
            <dd class="pad">
            The same origins and contents of parameter s as noted with mpz_factorstring() above apply equally here.
            <a name=mpz_prime></a>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_prime></a>
            boolean res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_prime</b>(mpz p, integer prob=5) - Determine whether p is a probable prime with the chance of error being at most 1 in 2^prob.
            </dt>
            <dd class="pad">
<!--
            The div parameter is currently fixed at 0, unless someone can give me a good reason otherwise.<br>
            Should you ever need to, perhaps when hunting down a memory leak, mpz_prime(NULL) releases any internally generated state and returns NULL.
-->
            The return value is <a href="logicops.htm#tf">true</a> (1) if p is probably prime, or <a href="logicops.htm#tf">false</a> (0) if p is definitely composite.<br>
            Replaces <span class="illegal">mpz_probable_prime_p</span>() which has been deprecated in version 1.0.0, as have the <br>
            <span class="illegal">randstate</span> functions <span class="illegal">gmp_randinit_mt</span>(), <span class="illegal">gmp_randseed</span>(), 
            and <span class="illegal">gmp_randclear</span>().<br>
            Additionally there was a js-compatible <span class="illegal">mpz_prime_mr</span>() for a while, with desktop/Phix still using the 
            official (mpfr.dll) version by default, but the performance of the latter fell off a cliff (quite seriously) with a newer mpfr.dll 
            (mid-2022) and hence desktop/Phix now uses the same code as <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a>, which is 
<!--
            Note that desktop/Phix still uses (a now private) mpz_probable_prime_p(), whereas <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a>
            uses a transpiled version of <b>mpz_prime_mr</b>(), which is possibly slower and might yield slightly different results. The latter can
            however be invoked under that name equally on both, with parameters as above, and is -->
            deterministic to 3,317,044,064,679,887,385,961,981 whereas the gmp docs do(/did) not appear to make any such guarantee. 
            By deterministic I mean that all numbers up to that limit yield perfectly correct results, and there is no point or gain/loss 
            specifying a prob other than 1 for any p below or equal to that limit.
<!--        Replace any mpz_prime_mr() you find with mpz_prime(). -->
<!--
             To be crystal 
            clear: mpz_prime() does slow down with a larger prob, mpz_prime_mr() does not, that is when passed a p below that limit, hence mpz_prime() 
            [on desktop/Phix] could be around twice as fast as mpz_prime_mr(), but could also be much slower.
-->
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_nextprime></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_nextprime</b>(mpz rop, op) - set rop to the next prime greater than op.
            </dt>
            <dd class="pad">
            I needed this for a rosettacode task but found it horribly slow and don&rsquo;t recommend it at all.<br>
            Note that it no longer tries to use either of the (deprecated) mpz_nextprime or (its presumed successor) 
            mpz_next_prime_candidate C functions and instead just throws successive odd numbers at mpz_prime(), so it may be
            even slower, but in my tests at least, not by much.
            </dd>
           </dl>
          </td>
         </tr>

         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_rand></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_rand</b>(mpz n, range) - set n to a random number 0..range-1
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpz_rand_ui></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpz_rand_ui</b>(mpz n, integer range) - set n to a random number 0..range-1
            </dt>
            <dd class="pad">
            mpz_rand(n,r) is equivalent to mpz_set_si(n,rand(mpz_get_integer(r))-1), and <br>
            mpz_rand_ui(n,i) is actually implemented as mpz_set_si(n,i); mpz_rand(n,n).<br>
            Obviously you should just use <a href="rand.htm">rand</a>() for small numbers 
            (&lt;= machine-word) you don&rsquo;t actually need to be stored in an mpz.<br>
            Note that mpz_rand[_ui](n,n) yields 0..n-1 whereas rand(n) yields 1..n.
            Also, rand() is maybe 64 times faster than mpz_rand(), and neither should
            be considered cryptographically secure. In the case of rand() that would
            be down to a trivial algorithm, in the case of mpz_rand() that would be
            down to non-linear timings, with both possibly containing other faults.<br>
            Lastly, <span class="illegal">mpz_urandomm</span>() has been deprecated, due to
            <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a> difficulties, and 
            mpz_rand[_ui]() should now be used instead (admittedly from a gmp perspective
            that means reverting to a single shared randstate, and conversely p2js.js relies
            on Math.random, the lack of a randstate being the difficultly mentioned above).
            </dd>
           </dl>
          </td>
         </tr>
        </table>
       </div>
       <div style="clear:both;height:1px;"> </div>
       <br>
       <br>

        <a name=mpfr></a>
       <h3>mpfr (floating point)</h3>
       <style type="text/css">
          dl {margin:0;padding:0;}
          dt {margin:0;padding:0;}
          dd {margin:0;padding:0;}
          dd.pad {padding-left:8em;}
       </style>
       <div id="nopad" class="nopad" align="center">
        <table cellspacing="0" cellpadding="0" border="0" style="padding: 0; border-style: none;">
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_get_default_precision></a>
           <nobr>integer precision =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_get_default_precision</b>(boolean decimal=<a href="logicops.htm#tf">false</a>)
             - yields the default floating point precision in bits or decimal places.<br>
            <b>mpfr_set_default_precision</b>(integer precision) - set the default precision in binary bits or (if -ve) decimal places.
            </dt>
            <dd class="pad">
            Initially the precision is 53 to match IEEE-754 (approx 15dp).<br>
            It always adds four to a decimal precision to cover intermediate values, sometimes you may need a few more.<br>
            If decimal is <a href="logicops.htm#tf">true</a>, mpfr_get_default_precision() returns the minimum number of decimal digits that 
            would be required to distinguish all possible values in the actual binary representation, rather than the number of decimal places 
            that are actually held. For example if we were storing in 8 bits, we could hold -128..127 and need 3 d.p, but could not hold 128..999 
            [at least, that is, not <i>exactly</i> - remember that it is using extended IEEE-754 internally, and would never go as low as 8 bits]. 
            As above, the +4 on setting helps ensure it is sufficient to obtain the desired results/accuracy, but no such fixed safety margin 
            could ever offer any guarantee for all algorithms/intermediates needed.<br>
            <span class="illegal">mpfr_get_default_prec</span>() has been renamed mpfr_get_default_precision() in 1.0.0<br>
            <span class="illegal">mpfr_set_default_prec</span>() has been renamed mpfr_set_default_precision() in 1.0.0<br>
            Note that <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a> emulates floating points using BigInt rationals, and as such there is
            no real <i>limited</i> precision handling at all, as yet (intuitively I imagine/guess there is a point that I haven&rsquo;t figured out where
            you can just lop digits off (/2 or /10) both numerator and divisor without losing too much accuracy, or perhaps better yet hold/calculate 
            rationals with a <i>logical</i> 10(or 2)^k where k can go quite -ve or +ve and [adjust k and] just lop the numerator when it gets too big).
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_get_default_rounding_mode></a>
            <nobr>integer rounding =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_get_default_rounding_mode</b>() - yields MPFR_RNDx (0..4, initially N==0), as below.<br>
            <b>mpfr_set_default_rounding_mode</b>(integer rounding) - sets the rounding mode.
            </dt>
            <dd class="pad">
            MPFR_RND(N/Z/U/D/A) stand for Nearest, toward Zero/+inf(Up)/-inf(Down), and Away from zero.<br>
            No effort has yet been made to implement rounding modes in <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a> and they are 
            currently (almost?) completely ignored.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_init></a>
            mpfr res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_init</b>(object v=0, integer precision=default_precision, rounding=default_rounding) - Initialise. v can be integer/atom/string, but <i>not</i> mpfr.
            </dt>
            <dd class="pad">
            Covers the C functions mpfr_init, <span class="illegal">mpfr_init2</span>, <span class="illegal">mpfr_init_set_si</span>, 
            <span class="illegal">mpfr_init_set_ui</span>, <span class="illegal">mpfr_init_set_d</span>, and <span class="illegal">mpfr_init_set_str</span> 
            (note the latter three <i>can</i> take a precision in mpfr.e, and that comes <i>before</i> the rounding mode),
            however it does not cover mpfr_inits or <span class="illegal">mpfr_inits2</span>, and it must <i>not</i> be used for mpfr_init_set(mpfr), 
            ie init from another existing mpfr, see below.<br>
            Note that (as per v=0) the default is to initialise to 0, unlike the C api which creates variables set to nan (not a number).<br>
            Invoking res = mpfr_free(res) when no longer needed is recommended, but occurs automatically if forgotten,<br>
            and of course that recommendation/handling is exactly the same for the following two functions as well.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_inits></a>
           <nobr>sequence res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_inits</b>(integer n, object v=0, integer precision=default_precision, rounding=default_rounding) - initialise n variables to v.
            </dt>
            <dd class="pad">
            Note the method signature differs significantly from the C function of the same name.<br>
            Can also be coded as eg mpfr {x,y,z} = mpfr_inits(3).<br>
            v may be an integer, atom, string, (but not mpfr), or a sequence of length n of said.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_init_set></a>
            mpfr res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_init_set</b>(mpfr src, integer rounding=default_rounding) - Initialise to some prior mpfr, eg
             <small><i>(mpfr x = mpfr_init(...);)</i></small> mpfr y = mpfr_init_set(x).<br>
            </dt>
            <dd class="pad">
            Passing an mpfr directly to mpfr_init() is a similar error to using pDword when peek4u(pDword) is required, 
            and likewise there is no practical way to guard against that, you just get meaningless results. In fact
            mpfr_init_set() can and does test it got an mpfr, it is mpfr_init() that simply cannot (realistically) perform 
            the inverse useful test that ensures it has <i>not</i> accidentally been passed an mpfr.
             <small>(Since an actual value <i>could</i> coincide with an allocated memory address)</small><br>
            The functions <b>mpfr_init_set_q</b>() and <b>mpfr_init_set_z</b>() behave as mpfr_set_q and mpfr_set_z, but 
            returning res rather than being passed tgt.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_set></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_set</b>(mpfr tgt, src, integer rounding=default_rounding) - set tgt from an existing mpfr variable.
            </dt>
            <dd class="pad">
            <b>mpfr_set_si</b>(mpfr tgt, integer i, rounding=default_rounding) - set tgt from a (machine-word-sized) integer.<br>
            In mpfr.e, i is (deliberately) limited to +/-1GB, use this instead of <span class="illegal">mpfr_set_ui</span>, or
            mpfr_set_d to cope with 1..4GB.<br>
            <b>mpfr_set_d</b>(mpfr tgt, atom a, integer rounding=default_rounding) - set tgt from a normal phix <a href="atom.htm">atom</a>.<br>
            <b>mpfr_set_str</b>(mpfr tgt, string s, integer base=0, rounding=default_rounding) - set tgt from a string.<br>
            A base of 0 allows bases 2 and 16 to be auto-detected (after a leading +/-) by '0b', '0B', '0x' or '0X', otherwise base 10 is assumed.<br>
            The exponent prefix can be 'e' or 'E' for bases up to 10, or '@' in any base (see also p/P and base 0 caveat below).<br>
            Note that desktop/Phix uses the gmp function, which has accumulated hacks and tweaks from the past several decades, such as using 'p'
            and 'P' for the exponent prefix in bases 2 and 16, or "-@nAn@(This_Is_Not_17)" being a "valid" representation of NaN in base 17,
            whereas <a href="p2js.htm"><span class="pwap2js">pwa/p2js</span></a> uses a hand-crafted replacement, so some inconsistencies are <i>inevitable</i>,
            though by and large any normal/sane use should be and is of course perfectly consistent. <br>
            You should (I think) replace p/P with @ and always use a '.' for the decimal point - gmp also accepts the current locale but pwa/p2js does not (knowingly). <br>
            Non-base 10 exponents are not offically supported/adequately tested (under pwa/p2js), and likewise the above-mentioned auto-detection prevents
            proper handling of '@' (ie it looks for 'e'/'E' when base&lt;=10, and '@' only when base&gt;10). Also, some browsers may not honour bases 37..62.<br>
            A Phix-specific enhancement is to allow eg "1/10", which arose because pwa/p2js implements mpfr in an mpq-like fashion, hence "1/10" is spot-on 
            whereas "0.1" is or w/could be <a href="accuracy.htm">inaccurate</a>, and that has now (as of 1.0.2) been supported on desktop/Phix as well
            (despite the fact that said inaccuracy persists within the IEEE-754-based gmp library on the latter platform).<br>
            Fairly obviously such differences also "bleed through" to the likes of mpfr_init(), etc. I will of course happily fix any further discrepancies  
            that may arise between desktop/Phix and pwa/p2js, as long as they seem to be actually worthwhile fixing and/or are indeed even possible.<br>
            <b>mpfr_set_q</b>(mpfr tgt, mpq q, integer rounding=default_rounding) - set tgt from an mpq (rational, see below).<br>
            <b>mpfr_set_z</b>(mpfr tgt, mpz z, integer rounding=default_rounding) - set tgt from an mpz (integer, see above).
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_free></a>
            object x =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_free</b>(object x) - Clear and deallocate any variables created from mpfr_init(), eg x = mpfr_free(x) or {y,z} = mpfr_free({y,z})
            </dt>
            <dd class="pad">
            NB: lhs==rhs intentionally (not actually enforced but you should pretend it is).<br>
            Should you forget to invoke this routine, mpfr.e will do so automatically. 
            Neither <span class="illegal">mpfr_clear</span>() nor <span class="illegal">mpfr_clears</span>() are publicly available, 
            use mpfr_free() instead, which releases <i>both</i> mpfr.dll <i>and</i> mpfr.e allocated memory (and if you donb&rsquo;t
            understand the importance or significance of that, don&rsquo;t ask. No, really, just don&rsquo;t).
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_get_precision></a>
            integer precision =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_get_precision</b>(mpfr x, boolean decimal=<a href="logicops.htm#tf">false</a>) - retrieve the current precision of a specific variable.
            </dt>
            <dd class="pad">
            See mpfr_get_default_precision() above for more details about the decimal parameter.<br>
            <b>mpfr_set_precision</b>(mpfr x, integer precision) - precision is the number of bits required for the mantissa, see mpfr_set_default_precision() above.<br>
            <span class="illegal">mpfr_get_prec</span>() has been renamed mpfr_get_precision() in 1.0.0<br>
            <span class="illegal">mpfr_set_prec</span>() has been renamed mpfr_set_precision() in 1.0.0<br>
            Note that on desktop/Phix, mpfr_set_precision() sets x to NaN, whereas pwa/p2js sets it to 0, not likely to be an issue since it
            would normally be set immediately afterwards anyway. As noted above, there isn&rsquo;t much of anything in the way of precision 
            handling within pwa/p2js as yet.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_free_str></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <span class="illegal">mpfr_free_str</span>() - invoked automatically within mpfr_get_str() and hence not publically available (there is no need for it to be).
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_get_str></a>
<!--            sequence res =&nbsp;-->
            string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_get_str</b>(mpfr x, integer base=10, n=0, rounding=default_rounding, bool comma_fill=<a href="logicops.htm#tf">false</a>)
            - print x in base (2..62) to precision n(0=full).
            </dt>
            <dd class="pad">
<!--            res is {string digits, integer exponent}. Does <b>not</b> print a decimal point; mpfr_sprintf() [see next] may be a better choice.<br> -->
            Prior to version 1.0.0 this routine returned {string digits, integer exponent} and digits did <b>not</b> contain a decimal point.<br>
            Also note the parameters are quite different, C: mpfr_get_str(?, ?, b, n, x, r) ==&gt; Phix: mpfr_get_str(x, b, n, r).<br>
            For the obvious reason of a FILE* argument, use this or mpfr_sprintf instead of <span class="illegal">mpfr_out_str</span>.<br>
            Note this routine is <i>not</i> supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>, use mpfr_get_fixed() [see next] instead.<br>
            (The main reason being that I&rsquo;m not really getting the n parameter, and certainly not capabable of accurately reproducing that behaviour.)
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_get_fixed></a>
            string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_get_fixed</b>(mpfr x, integer dp=6, base=10, bool comma_fill=<a href="logicops.htm#tf">false</a>, integer maxlen=0)
             - get a string representation of x<br>
            </dt>
            <dd class="pad">
            Returns a string representation of x in base to dp digits after the "decimal" point.<br>
            A dp of 0 prints up to 16 "decimal" places, obviously if you want "zero" dp then you&rsquo;ll have to mpfr_floor(x,x) or similar first.<br>
            A negative dp is allowed, which causes it to print those as trailing zeroes, so eg 11111.111 with -3 yeilds "11000".<br>
            A non-zero maxlen (introduced in 1.0.2) makes it resort to scientific notation when necessary. Once you make that flip, there are never any commas
            in the result, however due to "bouncy length syndrome" there may be some cases where maxlen and comma_fill at the same time run interference with 
            each other, eg maxlen 8, "1,234,567" -&gt; "1.2345e6", but internally that works via "1234567?", padding a comma-less result with '?' characters 
            before patching in the dot and trailing "e6", and in some cases some of those '?' may leak through. Quite probably a future release will simply 
            replace the '?' padding with '0' and assume that will always be ok, unless of course some counter-examples are found/reported first.<br>
            As of 1.0.4 the last digit is rounded in the same fashion as <a href="floor.htm#bankers_rounding">bankers_rounding</a>().
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_sprintf></a>
            string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_sprintf</b>(string fmt, mpfr_or_mpz x) - formatted print using 'R', eg mpfr_sprintf("%.1000Rf",x) prints x to 1000 d.p.
            </dt>
            <dd class="pad">
            Code using mpfr_Xprintf() where X!="s" must be changed to use mpfr_sprintf, and any C-style length modifiers (eg h, ll) removed.<br>
            Since x is typechecked to be of type mpfr_or_mpz, only a single 'R' or 'Z' conversion specification is supported.<br>
            An 'R' can be followed by an optional rounding mode (one of NZUDA), and then it must be followed by one of abefgAEFG.<br>
            A 'Z' should be followed by one of "dxX", or possibly (untested) one of "aceEfigGo".<br>
            Currently the only other routine of similar note that has been wrapped is <a href="#mpz_get_str">mpz_get_str</a>(), which can 
            be used as an alternative for 'Z' conversion specifications.<br>
            Note this routine is <i>not</i> supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>, use 
            mpfr_get_fixed() [see above] instead.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
<!-- DEV: new links done to here -->
            <a name=mpfr_printf></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_printf</b>(integer fn, string fmt, mpfr_or_mpz x) - formatted print to file (just a trivial puts(fn,mpfr_sprintf(fmt,x)) wrapper).
            </dt>
            <dd class="pad">
            Note this differs from the C function of the same name, in having a file number as the first parameter (like C&rsquo;s 
            <span class="illegal">mpfr_fprintf</span>), plus the phix version only accepts/permits a single mpfr or mpz variable at a time.<br>
            Obviously this routine is <i>not</i> supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>, since you cannot
            perform file/io from within a browser (although you <i>might</i> be able to ask a server to do that for you).
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_floor></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_floor</b>(mpfr rop, op) - rop := <a href="floor.htm">floor</a>(op)
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_ceil></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_ceil</b>(mpfr rop, op) - rop := <a href="floor.htm">ceil</a>(op)
            </dt>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_add></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_add</b>(mpfr rop, op1, op2, integer rounding=default_rounding) - rop := op1+op2 with specified rounding
            </dt>
            <dd class="pad">
            <b>mpfr_add_si</b>(mpfr rop, op1, integer op2, rounding=default_rounding) - "" except op2 is a phix integer, -1GB..+1GB<br>
            <b>mpfr_add_d</b>(mpfr rop, op1, atom op2, rounding=default_rounding) - "" except op2 is a phix <a href="atom.htm">atom</a>.<br>
            <b>mpfr_addmul_si</b>(mpfr rop, op1, integer op2, rounding=default_rounding) - (an <a href="#mpfr_addmul_si">extra</a>) rop += op1*op2
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_sub></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_sub</b>(mpfr rop, op1, op2, integer rounding=default_rounding) - rop := op1-op2 with specified rounding
            </dt>
            <dd class="pad">
            <b>mpfr_sub_si</b>(mpfr rop, op1, integer op2, integer rounding=default_rounding) - "" except op2 is a phix integer, -1GB..+1GB<br>
            <b>mpfr_sub_d</b>(mpfr rop, op1, atom op2, integer rounding=default_rounding) - "" except op2 is a phix <a href="atom.htm">atom</a>.<br>
            <b>mpfr_si_sub</b>(mpfr rop, integer op1, mpfr op2, integer rounding=default_rounding) - "" except op1 is a phix integer, -1GB..+1GB
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_mul></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_mul</b>(mpfr rop, op1, op2, integer rounding=default_rounding) - rop := op1*op2 with specified rounding
            </dt>
            <dd class="pad">
            <b>mpfr_mul_si</b>(mpfr rop1, op1, integer op2, integer rounding=default_rounding) - "" except op2 is a phix integer, -1GB..+1GB
            <b>mpfr_mul_d</b>(mpfr rop, op1, atom op2, integer rounding=default_rounding) - "" except op2 is a phix <a href="atom.htm">atom</a>.<br>
            <b>mpfr_mul_z</b>(mpfr rop1, op1, mpz op2, integer rounding=default_rounding) - "" except op2 is an mpz
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_div></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_div</b>(mpfr rop, op1, op2, integer rounding=default_rounding) - rop := op1/op2 with specified rounding
            </dt>
            <dd class="pad">
            <b>mpfr_div_si</b>(mpfr rop, op1, integer op2, integer rounding=default_rounding) - ""  except op2 is a phix integer, -1GB..+1GB<br>
            <b>mpfr_si_div</b>(mpfr rop, integer op1, mpfr op2, integer rounding=default_rounding) - "" except op1 is ""<br>
            <b>mpfr_div_d</b>(mpfr rop, op1, atom op2, integer rounding=default_rounding) - "" except op2 is a phix <a href="atom.htm">atom</a>.<br>
            <b>mpfr_div_z</b>(mpfr rop, op1, mpz op2, integer rounding=default_rounding) - "" except rop := mpfr/mpz
            As usual, use mpfr_div_si() instead of <span class="illegal">mpfr_div_ui</span>(), or possibly mpfr_div_d().
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_fmod></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <dt>
            <b>mpfr_fmod</b>(mpfr r, x, y, integer rounding=default_rounding) - r := mod(x,y)
            </dt>
            <dd class="pad">
            Set r to the value of x - ny, rounded as specified, where n is the integer quotient of x divided by y, rounded toward zero.
            </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_sqr></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_sqr</b>(mpfr rop, op, integer rounding=default_rounding) - rop := op squared with specified rounding
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_sqrt></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_sqrt</b>(mpfr rop, op, integer rounding=default_rounding) - rop := <a href="log.htm">sqrt</a>(op) with specified rounding
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_sqrt_ui></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_sqrt_ui</b>(mpfr rop, integer op, rounding=default_rounding) - "", except rop is a phix integer 0..1GB
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_pow></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_pow</b>(mpfr rop, op1, op2, integer rounding=default_rounding) - rop := op1^op2 with specified rounding
            </dt>
            <dd class="pad">
            <b>mpfr_pow_si</b>(mpfr rop, op1, integer op2, integer rounding=default_rounding) - ""  except op2 is a phix integer, -1GB..+1GB<br>
            <b>mpfr_ui_pow</b>(mpfr rop, integer op1, mpfr op2, integer rounding=default_rounding) - "" except op1 is a phix integer, 0..+1GB<br>
            <b>mpfr_ui_pow_ui</b>(mpfr rop, integer op1, op2, rounding=default_rounding) - "" except op1 and op2 are phix integer, 0..+1GB<br>
            <b>mpfr_si_pow_si</b>(mpfr rop, integer op1, op2, rounding=default_rounding) - "" except op1 and op2 can be -1GB..+1GB<br>
            Set rop to op1 raised to op2, rounded in the specified direction.<br>
            Note that mpfr_pow_si must be used instead of <span class="illegal">mpfr_pow_ui</span> (no benefit to be had), whereas there are no 
            C mpfr_si_pow[_si] functions, that last one is a Phix-specific extra.<br>
            0^0 is 1 (as per the standard phix <a href="log.htm">power</a>() function), see mpfr.e for more specific details of +/-0/Inf/NaN handling.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_neg></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_neg</b>(mpfr rop, op, integer rounding=default_rounding) - rop := -op with specified rounding<br>
            <b>mpfr_abs</b>(mpfr rop, op, integer rounding=default_rounding) - rop := abs(op) with specified rounding<br>
            <dd class="pad">
            Just changes the sign if rop and op are the same variable, otherwise rounding can occur when the precision of rop is less than that of op.
            </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_const_pi></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_const_pi</b>(mpfr x, integer rounding=default_rounding) - x := PI
            </dt>
            <dd class="pad">
            As precise as needed/specified in some prior mpfr_set_precision(x) or the x = mpfr_init() call.<br>
            Unfortunately trying to print more than about 42,000 digits of pi crashes (in the dll) on desktop/Phix.<br>
            Note that in pwa/p2js, mpfr_const_pi() uses a very simple 
            <a href="javascript:ExternalLink('ext357');" title='https://en.wikipedia.org/wiki/Bailey-Borwein-Plouffe_formula'
               id="ext357" style="color:#9B5565" >BPP</a> based method, which yields 12,000 digits in 4.5s, without 
            any attempt at optimisation, however it should probably not be used for more than say 1000 decimal digits 
            (and in fact I have limited use on rosettacode to 1000 digits), plus it makes no attempt to cache results. 
            In contrast, the gmp routine invoked by desktop/Phix uses a state-of-the-art 
            <a href="javascript:ExternalLink('ext375');" title='https://en.wikipedia.org/wiki/Chudnovsky_algorithm'
               id="ext375" style="color:#9B5565" >Chudnovsky</a> method - should anyone want to contribute a (normal 
            hll Phix, or even JavaScript) version of that, feel free. Note however that generating a 100,000 digit string
            in a browser is going to cause it significantly more grief than a 100,000,000 digit string does desktop/Phix,
            so there are other already fairly close limits to how useful any such effort could be, somewhere between 4 and
            8 times as many digits at best I would guess.
<!--
            It is probably fair to say that desktop/Phix suffers more problems (stack overflows somehere deep in the 
            supplied dlls) than pwa/p2js, that is when generating ridiculously long strings, for instance 
            <a href="#mpz_get_str">mpz_get_str</a>() in mpfr.e resorts to chunks of 20000 digits, but there is no 
            equivalent code in any version of mpfr_get_str(), mpfr_get_fixed(), or mpfr_(s)printf(). 
            Also, I can verify digits on desktop/Phix significantly (sic) easier than on pwa/p2js.
-->
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_const_euler></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_const_euler</b>(mpfr x, integer rounding=default_rounding) - x := gamma (approx 0.57721566490153286)
            </dt>
            <dd class="pad">
            Set x to Eulers constant aka C aka gamma, not to be confused with Eulers number aka EULER, 2.7182818284590452.<br>
            As precise as needed/specified in some prior mpfr_set_precision(x) or the x = mpfr_init() call.<br>
            Similar limits to mpfr_const_pi of printing excessive digits likewise apply here.<br>
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
<!--
https://rosettacode.org/wiki/Euler%27s_constant_0.5772...
Maybe: https://fossies.org/linux/mpfr/src/const_euler.c (but unlikely to be any better than the above)
-->
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_sin></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_sin</b>(mpfr rop, op, integer rounding=default_rounding) - rop := sin(op) with specified rounding
            <dd class="pad">
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
            </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_log></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_log</b>(mpfr rop, op, integer rounding=default_rounding) - rop := log(op) with specified rounding
            <dd class="pad">
            Set rop to the natural logarithm of op, rounded in the specified direction. <br>
            Set rop to +0 if op is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards. <br>
            Set rop to -Inf if op is +/-0 (i.e., the sign of the zero has no influence on the result).<br>
            Aside: unlike log/ln and friends, there is no mpfr_ln(), since that would not be a valid gmp/mpfr name.<br>
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
            </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_exp></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_exp</b>(mpfr rop, op, integer rounding=default_rounding) - rop := exponential(op) with specified rounding
            <dd class="pad">
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
            </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
           <a name=mpfr_gamma></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_gamma</b>(mpfr rop, op, integer rounding=default_rounding) - rop := Gamma(op) with specified rounding<br>
            <b>mpfr_gamma_inc</b>(mpfr rop, op, integer rounding=default_rounding) - incomplete gama function on op and op2<br>
            <a name=mpfr_zeta></a>
            <b>mpfr_zeta</b>(mpfr rop, op, integer rounding=default_rounding) - rop := Riemann Zeta function on op, with specified rounding<br>
            <b>mpfr_zeta_ui</b>(mpfr rop, integer op, rounding=default_rounding) - same, except op is a Phix integer, 0..1GB<br>
            <dd class="pad">
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
            </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_get_d_2exp></a>
            <nobr>{atom d, integer e} =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_get_d_2exp</b>(mpfr op, integer rounding=default_rounding)
            <dd class="pad">
            Return d and e such that 0.5&lt;=<a href="abs.htm">abs</a>(d)&lt;1 and d*2<small><sup>e</sup></small> equals op <br>
            &nbsp;&nbsp;<small>(where op is rounded to double precision using the given rounding mode)</small>. <br>
            If op is zero, then a zero of the same sign is returned, and e is set to 0.<br>
            If op is NaN or an infinity, then the corresponding d is returned, and e is undefined.<br>
            Not supported under <a href="p2js.htm"><span class="illegal">pwa/p2js</span></a>.
            </dd>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_get_si></a>
            atom res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpfr_get_si</b>(mpfr op, integer rounding=default_rounding) -- res := op as a machine-word-sized signed integer.<br>
            <b>mpfr_get_d</b>(mpfr op, integer rounding=default_rounding) -- res := op as a double.<br>
            As usual, use mpfr_get_si() instead of <span class="illegal">mpfr_get_ui</span>(), or possibly mpfr_get_d().
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpfr_cmp></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpfr_cmp</b>(mpfr op1, op2) -- Compare op1 and op2. Return +1 if op1&gt;op2, 0 if op1=op2, or -1 if op1&lt;op2.
            </dt>
            <dd class="pad">
            <b>mpfr_cmp_si</b>(mpfr op1, integer op2) - ""  except op2 is a phix integer, -1GB..+1GB<br>
            As usual, mpfr_cmp_si() should always be used instead of <span class="illegal">mpfr_cmp_ui</span>(), since the latter 
            would not increase the permitted range.
            </dd>
           </dl>
          </td>
         </tr>
        </table>
       </div>
       <div style="clear:both;height:1px;"> </div>
       <br>
       <br>

        <a name=mpq></a>
       <h3>mpq (rational, aka fractions (mpz numerator/mpz denominator))</h3>
       <div id="nopad" class="nopad" align="center">
        <table cellspacing="0" cellpadding="0" border="0" style="padding-right: 0; border-style: none;">
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_init></a>
           <nobr>mpq res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_init</b>(object v=0) - Initialise a single mpq, by default set to 0/1. 
            </dt>
            <dd class="pad">
            v may be an integer or string, but <i>not</i> a non-integer atom or mpq.<br>
            Note that mpq_init_set_si() can set a non-1 denominator in a way this routine (when passed an integer) simply cannot.<br>
            Invoking res = mpq_free(res) when no longer needed is recommended, but occurs automatically if forgotten,<br>
            and obviously that recommendation/handling applies aidentically to half a dozen or so of the following routines.<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_inits></a>
           <nobr>sequence res =&nbsp;</nobr>
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_inits</b>(integer n, object v) - Returns a sequence of n mpq ({} if n=0), set to 0/1, eg mpq {y,z} = mpq_inits(2). (ditto mpq_free)
            </dt>
            <dd class="pad">
            v may be an integer or string, or a sequence of length n of said (ditto no non-integer atom(s) or mpq elements).<br>
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_init_set></a>
           mpq res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpq_init_set</b>(mpq op) - Initialise to some prior mpq.<br>
            Likewise <b>mpq_init_set_z</b>(), <b>mpq_init_set_si</b>(), and <b>mpq_init_set_str</b>() are as follows, but returning res rather than being passed tgt.
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_free></a>
            object x =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_free</b>(object x) - Clear and deallocate any variables created from mpq_init(), eg x = mpq_free(x), or {y,z} = mpq_free({y,z}).
            </dt>
            <dd class="pad">
            NB: lhs==rhs intentionally (not actually enforced but you should pretend it is). <br>
            Should you forget to invoke this routine, mpfr.e will do so automatically. Neither <span class="illegal">mpq_clear</span>() nor
            <span class="illegal">mpq_clears</span>() are publicly available, since incorrect use can lead to sudden and mysterious program termination
             <small>(admittedly that can still happen if you break the lhs==rhs rule)</small> - 
            use mpq_free() instead, which releases <i>both</i> mpir.dll <i>and</i> mpfr.e allocated memory.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_set></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_set</b>(mpq tgt, src) - Set tgt from another mpq.<br>
            <b>mpq_set_z</b>(mpq tgt, mpz n, d=NULL) - Set tgt from an mpz (d=NULL results in an implied denominator of 1).<br>
            <b>mpq_set_si</b>(mpq tgt, integer n, d=1) - Set to n/d. n is -1GB..+1GB, d cannot be zero or negative (1..+1GB).<br>
            </dt>
            <dd class="pad">
            Note that mpq_set_si() must be used instead of <span class="illegal">mpq_set_ui</span>, and the upper limit is therefore 1GB, not 4GB.<br>
            </dd>
           </dl>
           <dl>
            <dt>
            <b>mpq_set_str</b>(mpq tgt, string s, integer base=0) - Set tgt from a string such as "41" or "41/152".<br>
            </dt>
            <dd class="pad">
            If base is zero, bases 2 and 16 can be auto-detected (after a leading +/-) by '0b', '0B', '0x' or '0X', otherwise base 10 is assumed.
            That is done separately for the numerator and denominator, so for instance "0xEF/100" is 239/100, whereas "0xEF/0x100" is 239/256.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_get_str></a>
           string res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_get_str</b>(mpq op, integer base=10, boolean comma_fill=<a href="logicops.htm#tf">false</a>)
             - Return op as a string in the specified base (2..62).<br>
            </dt>
            <dd class="pad">
            The result will be of the form "num/den", or if the denominator is 1 then just "num".
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_get_num></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpq_get_num</b>(mpz numerator, mpq rational) - get the numerator of a rational.<br>
            <b>mpq_get_den</b>(mpz denominator, mpq rational) - get the denominator of a rational.<br>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_get_d></a>
           atom res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <b>mpq_get_d</b>(mpq op) - get the value as a phix atom, rounded to ~15|19 significant digits, Inf/NaN/0 if too big/small.<br>
          </td>
         </tr>

         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_canonicalize></a>
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_canonicalize</b>(mpq op) - Remove any factors common to numerator and denominator, and make the latter positive.<br>
            </dt>
            <dd class="pad">
            This is performed automatically by mpq_set_si/str and mpq_set_z with a non-null d, and by most of the following routines.
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
           <!-- procedure -->
          </td>
          <td align="left" style="padding: 0; border-style: none;">
            <a name=mpq_add></a>
            <b>mpq_add</b>(mpq rsum, addend1, addend2) - set rsum to addend1 + addend2.<br>
            <a name=mpq_add_si></a>
            <b>mpq_add_si</b>(mpq rsum, addend1, integer n, d=1) - set rsum to addend1 + n/d.<br>
            <a name=mpq_sub></a>
            <b>mpq_sub</b>(mpq rdifference, minuend, subtrahend) - set rdifference to minuend - subtrahend.<br>
            <a name=mpq_mul></a>
            <b>mpq_mul</b>(mpq rproduct, multiplier, multiplicand) - set rproduct to multiplier * multiplicand.<br>
            <a name=mpq_div></a>
            <b>mpq_div</b>(mpq rquotient, dividend, divisor) - set rquotient to dividend / divisor.<br>
            <a name=mpq_mul_2exp></a>
            <b>mpq_mul_2exp</b>(mpq rop, op, integer bits) - set rop to op * 2^bits.<br>
            <a name=mpq_div_2exp></a>
            <b>mpq_div_2exp</b>(mpq rop, op, integer bits) - set rop to op / 2^bits.<br>
            <a name=mpq_neg></a>
            <b>mpq_neg</b>(mpq rop, op) - set rop to -op.<br>
            <a name=mpq_abs></a>
            <b>mpq_abs</b>(mpq rop, op) - set rop to the absolute value of op.<br>
            <a name=mpq_inv></a>
            <b>mpq_inv</b>(mpq rop, op) - set rop to 1/op. If the new denominator is zero, this routine will divide by zero.<br>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_cmp></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_cmp</b>(mpq op1, op2) - compare op1 and op2. Return +1|0|-1 for &gt;|=|&lt; respectively.<br>
            </dt>
            <dd class="pad">
            Note the mpfr.e wrapper explicitly converts the C +ve/0/-ve result to +1/0/-1 using <a href="sign.htm">sign</a>().
            </dd>
           </dl>
          </td>
         </tr>
         <tr>
          <td align="right" style="padding: 0; border-style: none;">
            <a name=mpq_cmp_si></a>
            integer res =&nbsp;
          </td>
          <td align="left" style="padding: 0; border-style: none;">
           <dl>
            <dt>
            <b>mpq_cmp_si</b>(mpq op1, integer n, d=1) - compare op1 and n/d. Return +1|0|-1 for &gt;|=|&lt; respectively.<br>
            </dt>
            <dd class="pad">
            n and d are allowed to have common factors. mpq_cmp_si must be used instead of <span class="illegal">mpq_cmp_ui</span>, 
            d may not be zero or negative.<br>
            Note the mpfr.e wrapper explicitly converts the C +ve/0/-ve result to +1/0/-1 using <a href="sign.htm">sign</a>().
            </dd>
           </dl>
          </td>
         </tr>
        </table>
       </div>
       <div style="clear:both;height:1px;"> </div>
<!--
       <tr>
        <td align="right" style="padding: 0; border-style: none;">
        </td>
        <td align="left" style="padding: 0; border-style: none;">
         <dl>
          <dt>
          </dt>
          <dd class="pad">
          </dd>
         </dl>
        </td>
       </tr>
-->
       <br>
        More routines (many more) will be added as needed - there are several hundred (maybe even thousands) of them and, at least in my opinion, 
        it is just simply not worthwhile without something that actually uses and therefore tests them. Each one is usually quite straightforward,
        but of course this document and Edita/Edix syntax and lookup files also need to be updated. Likewise there may be a few still missing from 
        mpfr.js but so far any such have proved remarkably easy to add, with the trivial updates to js.syn and p2js_keywords.e being as fiddly if 
        not moreso than the new code itself.
       <br>
       <br>
        Note that mpz/mpfr/mpq_clear() are <i>not</i> publically available, use xxx_free() instead, which free both mpf/ir.dll and mpfr.e allocated memory.
        Since the xxx_clear() have a different calling convention to xxx_free, they are syntax coloured illegal (and linked here). In the early stages,
        several sudden mysterious crashes were traced to misuse of xxx_clear(), that now occur far less often after migrating to xxx_free()[lhs==rhs].
       <br>
        Also, in contrast, mpr_free_str() and mpz_free_string() are invoked internally for you, so when translating code you can just delete those statements.
       <br>
        Lastly note that all mpf_xxx functions have deliberately been expunged in favour of mpfr_ ones (the latter can I believe start small and grow whereas 
        the former are always allocated their maximum size) and likewise the low-level mpn_xxx functions (which require the exact number of "limbs" to be
        specified on every call and as started in the gmp docs have a deliberately "non-coherent calling interface") are not wrapped either.
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
