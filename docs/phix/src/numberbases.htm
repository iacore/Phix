<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Number Bases</h1>
      <div id="mainSection">
        Numbers (integers, including larger values that Phix quietly stores as atoms/floats, but excluding
        real numbers with fractions or (decimal) exponents) can also be entered in hexadecimal, octal, binary, 
        or in fact any number base between 2 and 16. 
       <br>
       <br>
        We humans are so used to working in base 10 we forget it is quite arbitrary, and used simply because of 
        how many fingers and thumbs we have. Apparently the Babylonians counted their wrists as well and worked 
        in base 12, and pre-1970 the UK had 12 pennies in a shilling, so 11p+2p was 1s1p. Another obvious use of
        base 12 is 11 months plus 2 months is 1 year and 1 month.
       <br> 
       <br> 
        As you probably already know, 
        a computer ultimately only has on/off switches, and therefore works in binary, or base 2. Arranging
        those switches into groups of 3 or 4 leads to octal (base 8) and hexadecimal (base 16) respectively.
        There may never be much use for say base 7, although weeks may be one possibility, however it was very 
        little extra work over just 2/8/10/16 (see ptok.e/loadBase() for the full implementation details) and 
        is available should anyone ever need it. As the above examples suggest there may well be times when 
        using base 12 actually simplifies matters, or maybe defining/solving an N-sided rubiks cube is easier 
        in base N. As yet another example, pilx86.e (part of the compiler) makes heavy use of octal and would 
        be even harder to understand if everything had to be expressed in decimal. An x86 CPU is in essence an 
        octal machine: an xrm of 250 or #FA tells me absolutely nothing(!), whereas even though it represents 
        exactly the same number as the other two, 0o372 immediately suggests regs:edi(=7),edx(=2).
        If you can see that edi(7) hiding in 250 in less than 20 seconds [tip: remainder(floor(250/8),8)], then
        clearly you are much faster at mental arithmetic than I am.
       <br>
       <br>
        If all this is very confusing, there is no need to worry about it, just be aware that some problems 
        are much easier to reason logically about using these strange numbers. Edita has builtin functions, 
        hidden under Edit/Case, to convert any current block selected number to the more common number bases.
        (You have to block select a number, or at least some text, to enable that particular sub-menu, and
         said functions will mutely do nothing if they do not recognise the entire selection as a number.)
       <br>
       <br>
        Some examples of various number bases, with our familiar decimal equivalents on the right:
<!--eucode>
        #FE             -- 254
        #fe             -- 254
        0xA000          -- 40,960
        0(16)FFFF00008  -- 68,718,428,168 (which Phix must store as an atom)
        #123456789ABCD  -- 320,255,973,501,901 ("")
        -#10            -- -16
        0o377           -- 255
        0t377           -- 255  (some people apparently prefer t for octal)
        0b111           -- 7
        0(7)10          -- 7    (for even more examples see test\t37misc.e)
</eucode-->
<pre>
<font color="#000000">        #FE            </font><font color="#000080"> -- 254
</font><font color="#000000">        #fe            </font><font color="#000080"> -- 254
</font><font color="#000000">        0xA000         </font><font color="#000080"> -- 40,960
</font><font color="#000000">        0</font><font color="#0000FF">(</font><font color="#000000">16</font><font color="#0000FF">)</font><font color="#000000">FFFF00008 </font><font color="#000080"> -- 68,718,428,168 (which Phix must store as an atom)
</font><font color="#000000">        #123456789ABCD </font><font color="#000080"> -- 320,255,973,501,901 ("")
</font><font color="#0000FF">        -</font><font color="#000000">#10           </font><font color="#000080"> -- -16
</font><font color="#000000">        0o377          </font><font color="#000080"> -- 255
</font><font color="#000000">        0t377          </font><font color="#000080"> -- 255  (some people apparently prefer t for octal)
</font><font color="#000000">        0b111          </font><font color="#000080"> -- 7
</font><font color="#000000">        0</font><font color="#0000FF">(</font><font color="#000000">7</font><font color="#0000FF">)</font><font color="#000000">10         </font><font color="#000080"> -- 7    (for even more examples see test\t37misc.e)</font>
</pre>
       <br>
        The main idea is that Phix can handle almost all number formats ("as found on'tinternet") with minimal editing. 
        Notable and deliberate exceptions are the "trailing h" of assembly and the accident waiting to happen that is 
        "leading 0 is octal (unless there is a trailing h)" of C.
       <br>
       <br>
        There is one known minor gotcha (hardly worth mentioning really) in that "a=1b=2" compiles fine whereas "a=0b=1" does not, 
        with the same problem when b is replaced with any identifier starting with any of b/t/o/x/d (including type/procedure names, 
        break, then, object, do, etc) - and obviously this can be cured completely by the trivial insertion of a single space, 
        linebreak, or semicolon.
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
