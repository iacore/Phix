<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">pGUI-IDE</h1>
      <div id="mainSection">
[DRAFT]
        <h2>Introduction</h2>

        pGUI-IDE is intended to help both beginners getting started and ease the pain of the more trivial 
        dialogs for more advanced users. It is not intended to be particularly helpful on more complex or
        dynamic layouts and dialogs. Also, many applications are just a single canvas on a single dialog,
        and you should not be too surprised or disappointed when that is exactly what this (only) shows.
        <br>
        <br>
        Often little tricks on the main dialog make it much slicker, and it is fairly unlikely that such
        a simple utility as this can keep up. It is however fair to say that pGUI-IDE is more likely to 
        shine on the secondary rarely-used screens than the main - and in fact that is intentionally so.
        One argument says that you shouldn't need as much help with the screens that you know the best.
        <br>
        <br>
        Pretty much the sole aim here is to get the containers/fillers/padding/expansion/gaps/margins
        all worked out. For everything else (especially images) you really need to see the finished
        application running to see if you got it right. More than anything else, though, you are not
        supposed to spend much time in pGUI-IDE, but rather more often just a quick in/fix/out.
        <br>
        <br>
        Initially I planned to support menus fully, but realised it is probably easier to do most of
        the necessary in plain text. Anyway, I still load them, but they are not editable in here.
        <br>
        <br>
<hr>
        As a dialog becomes ever more complicated/dynamic/configurable or even platform-specific, it
        will outgrow pGUI-IDE, which cannot be expected to keep up with every little trick programmers
        use to make their fancy application (/main screen) ever more slick. For a laugh, open google
        and find the view source option of the browser (or see https://xkcd.com/1605/ ).
<hr>
        There is an implicit assumption that you would never want to drag/drop an element to
        a sibling of an empty container. In some cases you might need to add a dummy element
        to an empty branch, collapse it, drag the sibling into place, and then remove the
        no-longer-needed dummy element.
<hr>
        Sometimes you might for instance want to add an IupCalendar to an IupFrame, only to be told you cannot,
        probably because the frame already has a child, and it can only have one. The only containers that can
        have more than one child are IupHbox, IupVbox, IupCbox, IupGridBox, IupNormaliser, IupTabs amd IupZbox,
        plus I suppose IupSlit which always takes exactly 2. All the others, including IupDialog, IupDetachBox,
        IupFrame, IupRadio, etc, can only have one child.
        <br>
        <br>
        Sometimes you can add that IupCalendar as a sibling, then add the required IupHbox, and then drag the 
        IupCalendar into place, while at other times you may be forced to cancel the operation, and add that
        IupHbox first (probably using the "parent" mode from the drop-down).
<hr>
        Note that drag and drop in the hierarchy tree is highly dependent on the EXPANDED/COLLAPSED state of
        the drop target. If the latter is expanded then the dragged item is made the first child, whereas if
        it is collapsed then it is made the next sibling. Therefore you must always ensure the destination
        node is in the correct expanded/collapsed state, before commencing the drag operation.
<hr>
        Actually, IupDestroy(IupNormaliser()) <i>should</i> be siblings of IupDialog - iff >=1(/verify that
        <i>ALL</i>) elements are indeed children of said.
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
