<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">pSQLite</h1>
      <div id="mainSection">
        A wrapper for SQLite, a self-contained, high-reliability, embedded, full-featured, public-domain, SQL database engine.<br>
        SQLite is the most used database engine in the world. Some excerpts from their 
        <a id="ext400" style="color:#9B5565" href="javascript:ExternalLink('ext400','http://www.sqlite.org');">website</a>:
        <blockquote>
            <img src="images/sqlite370_banner.gif" alt="SQLite" border="0"/>
            <br>
            Small. Fast. Reliable.  Choose any three.
            <br>
            <br>
            SQLite is an in-process library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine.<br>
            The code for SQLite is in the public domain and is thus free for use for any purpose, commercial or private.<br>
            SQLite is the most widely deployed database in the world with more applications than we can count, including several high-profile projects.
            <br>
            <br>
            SQLite is an embedded SQL database engine. 
            Unlike most other SQL databases, SQLite does not have a separate server process.<br>
            SQLite reads and writes directly to ordinary disk files. 
            A complete SQL database with multiple tables, indices, triggers, and views, is contained in a single disk file.<br>
            The database file format is cross-platform - you can freely copy a database between 32-bit and 64-bit systems or between big- and 
            little-endian architectures.<br>
            These features make SQLite a popular choice as an Application File Format. 
            Think of SQLite not as a replacement for Oracle but as a replacement for fopen()
            <br>
            <br>
            SQLite is very carefully tested prior to every release and has a reputation for being very reliable.<br>
<!--
            Most of the SQLite source code is devoted purely to testing and verification.<br>
            An automated test suite runs millions and millions of test cases involving hundreds of millions of individual SQL statements and achieves 
            100% branch test coverage.<br>
-->
            SQLite responds gracefully to memory allocation failures and disk I/O errors.<br>
            Transactions are ACID (Atomic, Consistent, Isolated, and Durable) even if interrupted by system crashes or power failures.
<!--
            All of this is verified by the automated tests using special test harnesses which simulate system failures.<br>
            Of course, even with all this testing, there are still bugs. But unlike some similar projects (especially commercial competitors) SQLite 
            is open and honest about all bugs and provides bugs lists and minute-by-minute chronologies of code changes.
-->
            <br>
            <br>
            The SQLite code base is supported by an international team of developers who work on SQLite full-time.<br>
            The developers continue to expand the capabilities of SQLite and enhance its reliability and performance while maintaining backwards 
            compatibility with the published interface spec, SQL syntax, and database file format. 
            The source code is absolutely free to anybody who wants it, but professional support is also available.
            <br>
            <br>
<!--
            The SQLite project was started on 2000-05-09.<br>
            The future is always hard to predict, but the intent of the developers is to support SQLite through the year 2050.<br>
            Design decisions are made with that objective in mind.
            <br>
            <br>
-->
            We the developers hope that you find SQLite useful and we entreat you to use it well: to make good and beautiful products that are fast, 
            reliable, and simple to use.
<!--
             <br>
            Seek forgiveness for yourself as you forgive others. And just as you have received SQLite for free, so also freely give, paying the debt forward.
-->
        </blockquote>
        Specific advantages of pSQLite.e over <a href="database.htm">database.e</a> include:<br>
        <ul>
        <li>Much higher resilience to program crashes and power failures.</li>
        <li>The resulting databases can be read and written by applications whether they are written in Phix or not.</li>
        <li>It can be much faster (see performance note below).</li>
        </ul>
        And disadvantages include:<br>
        <ul>
        <li>It uses SQL - which is ok, I guess, but I never did quite get inner/outer joins..</li>
        </ul>
        To use pSQLite, you must include pSQLite.e. The file phix\builtins\pSQLite.e is a "stub include" that simply contains include ..\demo\pSQLite\pSQLite.e
        (same on Windows and Linux) to simplify matters.<br>
        I would however recommend placing copies of (the real) pSQLite.e and any dlls you need in with the application directory, to ease distribution and maintenance.
        <br>
        <br>
        Based heavily on the work of Ray Smith, Chris Burch, and Tone Skoda, the main difference here is that Phix can pass strings directly to C functions, which 
        leads to a saving of at least one pair of calls to <a href="allocate_string.htm">allocate_string</a>() and <a href="free.htm">free</a>() in almost every routine. 
        Another difference is where it loads the dll from, and some work was done to make it a little bit more thread safe, and 64-bit compatible. I also
        implemented the <a href="sqlite3_exec.htm">sqlite3_exec</a>() optional callback routine to process rows retrieved by queries, which was missing.
        It was also helpful to repackage it as a learning exercise and as part of crafting this documentation, or perhaps more accurately, it is usually virtually 
        impossible to write any docs without finding some excuse to tweak the code.<img src="images/ksk-smile.png" alt="smile" />
        <br>
        <h3>Example:</h3>
           <div id="code-snippet-1" class="codeSnippetContainer" xmlns="">
            <div class="codeSnippetContainerCodeContainer">
             <div class="codeSnippetToolBar">
              <div class="codeSnippetToolBarText">
               <a id="copytext" href="javascript:CopyToClipboard('CodeSnippetContainerCode_18b74j93-qb37-4765-123h-8b2483c92846');">Copy</a>
              </div>
             </div>
             <div id="CodeSnippetContainerCode_18b74j93-qb37-4765-123h-8b2483c92846" class="codeSnippetContainerCode" dir="ltr">
              <div style="color:Black;">
<!--eucode>
constant LIM = 100000
include pSQLite.e

?sqlite3_libversion()

sqlite3 db = sqlite3_open("test.sqlite")

procedure db_exec(string cmd, bool fatal=true)
    integer res = sqlite3_exec(db,cmd)
    if fatal and res!=SQLITE_OK then ?9/0 end if
end procedure

db_exec("DROP TABLE test;",fatal:=false)
db_exec("CREATE TABLE test (code INTEGER PRIMARY KEY, data);")

atom t0 = time()
db_exec("BEGIN TRANSACTION;") -- (or just "BEGIN;")
for i=1 to LIM do
    db_exec(sprintf("INSERT INTO test VALUES (%d,%d);",{i,i}))
end for
db_exec("END TRANSACTION;")  -- (same as "COMMIT;")
t0 = time()-t0

sqlite3_close(db)

printf(1,"%,d records added in %3.2fs, %3.2f/s\n",{LIM,t0,LIM/t0})

-- sample output:
-- "3.23.1"
-- 100,000 records added in 0.98s, 101522.84/s
--or (an older and slower verson):
-- "3.2.1"
-- 100,000 records added in 1.24s, 80971.66/s
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">constant</font><font color="#000000"> LIM</font><font color="#0000FF"> =</font><font color="#000000"> 100000
</font><font color="#008080">include</font><font color="#000000"> pSQLite.e

</font><font color="#0000FF">?</font><font color="#5E005E">sqlite3_libversion</font><font color="#0000FF">()

</font><font color="#004080">sqlite3</font><font color="#000000"> db</font><font color="#0000FF"> =</font><font color="#5E005E"> sqlite3_open</font><font color="#0000FF">(</font><font color="#008000">"test.sqlite"</font><font color="#0000FF">)

</font><font color="#008080">procedure</font><font color="#000000"> db_exec</font><font color="#0000FF">(</font><font color="#004080">string</font><font color="#000000"> cmd</font><font color="#0000FF">,</font><font color="#004080"> bool</font><font color="#000000"> fatal</font><font color="#0000FF">=</font><font color="#004600">true</font><font color="#0000FF">)
</font><font color="#004080">    integer</font><font color="#000000"> res</font><font color="#0000FF"> =</font><font color="#5E005E"> sqlite3_exec</font><font color="#0000FF">(</font><font color="#000000">db</font><font color="#0000FF">,</font><font color="#000000">cmd</font><font color="#0000FF">)
</font><font color="#008080">    if</font><font color="#000000"> fatal</font><font color="#008080"> and</font><font color="#000000"> res</font><font color="#0000FF">!=</font><font color="#004600">SQLITE_OK</font><font color="#008080"> then</font><font color="#0000FF"> ?</font><font color="#000000">9</font><font color="#0000FF">/</font><font color="#000000">0</font><font color="#008080"> end if
end procedure

</font><font color="#000000">db_exec</font><font color="#0000FF">(</font><font color="#008000">"DROP TABLE test;"</font><font color="#0000FF">,</font><font color="#000000">fatal</font><font color="#0000FF">:=</font><font color="#004600">false</font><font color="#0000FF">)
</font><font color="#000000">db_exec</font><font color="#0000FF">(</font><font color="#008000">"CREATE TABLE test (code INTEGER PRIMARY KEY, data);"</font><font color="#0000FF">)

</font><font color="#004080">atom</font><font color="#000000"> t0</font><font color="#0000FF"> =</font><font color="#7060A8"> time</font><font color="#0000FF">()
</font><font color="#000000">db_exec</font><font color="#0000FF">(</font><font color="#008000">"BEGIN TRANSACTION;"</font><font color="#0000FF">)</font><font color="#000080"><i> -- (or just "BEGIN;")
</i></font><font color="#008080">for</font><font color="#000000"> i</font><font color="#0000FF">=</font><font color="#000000">1</font><font color="#008080"> to</font><font color="#000000"> LIM</font><font color="#008080"> do
</font><font color="#000000">    db_exec</font><font color="#0000FF">(</font><font color="#5E005E">sprintf</font><font color="#800000">(</font><font color="#008000">"INSERT INTO test VALUES (%d,%d);"</font><font color="#0000FF">,</font><font color="#800080">{</font><font color="#000000">i</font><font color="#0000FF">,</font><font color="#000000">i</font><font color="#800080">}</font><font color="#800000">)</font><font color="#0000FF">)
</font><font color="#008080">end for
</font><font color="#000000">db_exec</font><font color="#0000FF">(</font><font color="#008000">"END TRANSACTION;"</font><font color="#0000FF">) </font><font color="#000080"><i> -- (same as "COMMIT;")
</i></font><font color="#000000">t0</font><font color="#0000FF"> =</font><font color="#7060A8"> time</font><font color="#0000FF">()-</font><font color="#000000">t0

</font><font color="#5E005E">sqlite3_close</font><font color="#0000FF">(</font><font color="#000000">db</font><font color="#0000FF">)

</font><font color="#5E005E">printf</font><font color="#0000FF">(</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#008000">"%,d records added in %3.2fs, %3.2f/s\n"</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">LIM</font><font color="#0000FF">,</font><font color="#000000">t0</font><font color="#0000FF">,</font><font color="#000000">LIM</font><font color="#0000FF">/</font><font color="#000000">t0</font><font color="#800000">}</font><font color="#0000FF">)

</font><font color="#000080"><i>-- sample output:
-- "3.23.1"
-- 100,000 records added in 0.98s, 101522.84/s
--or (an older and slower verson):
-- "3.2.1"
-- 100,000 records added in 1.24s, 80971.66/s</i></font>
</pre>
              </div>
             </div>
            </div>
           </div>
        <h3>Performance:</h3>
            SQLite defaults to maximum integrity: letting it re-open/verify/wait for disk updates/close around every change can easily result
            in a program that achieves less than 10 updates per second. Thankfully, grouping (related) updates by simply surrounding them
            with "BEGIN TRANSACTION;" and "END TRANSACTION;" can easily result in a 10,000-fold performance increase, ie a truly staggering 
            100,000+ updates per second, though I suspect that peak rate might not last too long. In comparison, database.e manages about 
            5,000/s, by itself still fairly decent, even if it <i>does</i> seem rather poor head-to-head like that.
            <br>
            <br>
            Although at heart it uses much the same technology, there may be some additional overheads with using 
            <a href="sqlite3_bind.htm">sqlite3_bind_blob</a>() and 
            <a href="sqlite3_column.htm">sqlite3_column_blob</a>() on long/complex sequences/structures (specifically storage of interim 
            <a href="serialize.htm">serialization</a> values) that mean database.e is actually faster, or at least a little more on par.
            <br>
            <br>
            Obviously you can test performance by running the above snippet, but should you decide to comment out those transaction statements, 
            I strongly recommend that you also change LIM to 100 or less!
            <br>
            <br>
            One approach I have used quite successfully is a timer/countdown arrangement that performs an end transaction after 5 seconds 
            without an update, or when the program shuts down (and occasionally those rare events that genuinely need perfect integrity). 
            Obviously each update starts a new transaction when the countdown is already zero, otherwise just resets it to the full 5 seconds.
        <br>
        <br>
        None of these routines are supported by <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js</b></span></a>.
        <br>
        <br>

<!--


    
C/C++ Interface For SQLite Version 3
1.0 Overview
SQLite version 3.0 is a new version of SQLite, derived from the SQLite 2.8.13 code base, but with an incompatible file format and API.
SQLite version 3.0 was created to answer demand for the following features: 

Support for UTF-16.
User-definable text collating sequences.
The ability to store BLOBs in indexed columns.
It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format.
Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.

The API for version 3.0 is similar to the version 2.X API, but with some important changes.
Most noticeably, the "sqlite_" prefix that occurs on the beginning of all API functions and data structures are changed to "sqlite3_".
This avoids confusion between the two APIs and allows linking against both SQLite 2.X and SQLite 3.0 at the same time.

There is no agreement on what the C datatype for a UTF-16 string should be.
Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings.
Client software can cast the void* to whatever data-type is appropriate for their system.

2.0 C/C++ Interface
The API for SQLite 3.0 includes 83 separate functions in addition to several data structures and #defines.
(A complete API reference is provided in a separate document.) 
Fortunately, the interface is not nearly as complex as its size implies.
Simple programs can still make do with only 3 functions: sqlite3_open(), sqlite3_exec(), and sqlite3_close().
[PL erm, 4! - or slql_table_get()]
More control over the execution of the database engine is provided using 
<a href="sqlite3_prepare.htm">sqlite3_prepare</a>() to compile an SQLite statement into byte code and 
<a href="sqlite3_step.htm">sqlite3_step</a>() to execute that bytecode.
A family of routines with names beginning with sqlite3_column_ is used to extract information about the result set of a query.
Many interface functions come in pairs, with both a UTF-8 and UTF-16 version.
And there is a collection of routines used to implement user-defined SQL functions and user-defined text collating sequences.

2.1 Opening and closing a database
   typedef struct sqlite3 sqlite3;
   const char *sqlite3_errmsg(sqlite3*);
   int sqlite3_errcode(sqlite3*);

The sqlite3_errcode() routine returns a result code for the most recent major API call.
sqlite3_errmsg() returns an English-language text error message for the most recent error.
The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function.


2.2 Executing SQL statements

2.3 User-defined functions
User defined functions can be created using the following routine: 

   typedef struct sqlite3_value sqlite3_value;
   int sqlite3_create_function(
     sqlite3 *,
     const char *zFunctionName,
     int nArg,
     int eTextRep,
     void*,
     void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
     void (*xStep)(sqlite3_context*,int,sqlite3_value**),
     void (*xFinal)(sqlite3_context*)
   );
   int sqlite3_create_function16(
     sqlite3*,
     const void *zFunctionName,
     int nArg,
     int eTextRep,
     void*,
     void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
     void (*xStep)(sqlite3_context*,int,sqlite3_value**),
     void (*xFinal)(sqlite3_context*)
   );
   #define SQLITE3_UTF8     1
   #define SQLITE3_UTF16    2
   #define SQLITE3_UTF16BE  3
   #define SQLITE3_UTF16LE  4
   #define SQLITE3_ANY      5

The nArg parameter specifies the number of arguments to the function.
A value of 0 indicates that any number of arguments is allowed.
The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function.
The value of this parameter should be one of the parameters defined above.
SQLite version 3 allows multiple implementations of the same function using different text representations.
The database engine chooses the function that minimization the number of text conversions required.

Normal functions specify only xFunc and leave xStep and xFinal set to NULL.
Aggregate functions specify xStep and xFinal and leave xFunc set to NULL.
There is no separate sqlite3_create_aggregate() API.

The function name is specified in UTF-8.
A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.

Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X.
The following routines are used to extract useful information from these "values": 

   const void *sqlite3_value_blob(sqlite3_value*);
   int sqlite3_value_bytes(sqlite3_value*);
   int sqlite3_value_bytes16(sqlite3_value*);
   double sqlite3_value_double(sqlite3_value*);
   int sqlite3_value_int(sqlite3_value*);
   long long int sqlite3_value_int64(sqlite3_value*);
   const unsigned char *sqlite3_value_text(sqlite3_value*);
   const void *sqlite3_value_text16(sqlite3_value*);
   int sqlite3_value_type(sqlite3_value*);

Function implementations use the following APIs to acquire context and to report results: 

   void *sqlite3_aggregate_context(sqlite3_context*, int nbyte);
   void *sqlite3_user_data(sqlite3_context*);
   void sqlite3_result_blob(sqlite3_context*, const void*, int n, void(*)(void*));
   void sqlite3_result_double(sqlite3_context*, double);
   void sqlite3_result_error(sqlite3_context*, const char*, int);
   void sqlite3_result_error16(sqlite3_context*, const void*, int);
   void sqlite3_result_int(sqlite3_context*, int);
   void sqlite3_result_int64(sqlite3_context*, long long int);
   void sqlite3_result_null(sqlite3_context*);
   void sqlite3_result_text(sqlite3_context*, const char*, int n, void(*)(void*));
   void sqlite3_result_text16(sqlite3_context*, const void*, int n, void(*)(void*));
   void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
   void *sqlite3_get_auxdata(sqlite3_context*, int);
   void sqlite3_set_auxdata(sqlite3_context*, int, void*, void (*)(void*));

2.4 User-defined collating sequences
The following routines are used to implement user-defined collating sequences: 

   sqlite3_create_collation(sqlite3*, const char *zName, int eTextRep, void*,
      int(*xCompare)(void*,int,const void*,int,const void*));
   sqlite3_create_collation16(sqlite3*, const void *zName, int eTextRep, void*,
      int(*xCompare)(void*,int,const void*,int,const void*));
   sqlite3_collation_needed(sqlite3*, void*, 
      void(*)(void*,sqlite3*,int eTextRep,const char*));
   sqlite3_collation_needed16(sqlite3*, void*,
      void(*)(void*,sqlite3*,int eTextRep,const void*));

The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence.
The comparison function is only used for comparing text values.
The eTextRep parameter is one of SQLITE3_UTF8, SQLITE3_UTF16LE, SQLITE3_UTF16BE, or SQLITE3_ANY to specify which text representation the comparison function works with.
Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations.
The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.

The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence.
The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed.
The fourth parameter to the callback is the name of the collating sequence in UTF-8.
For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.

 

 

C/C++ Interface For SQLite Version 3
result-codes 
sqlite3_aggregate_context 
sqlite3_aggregate_count 
sqlite3_busy_handler 
sqlite3_busy_timeout 
sqlite3_collation_needed 
sqlite3_collation_needed16 
sqlite3_commit_hook 
sqlite3_complete 
sqlite3_complete16 
sqlite3_create_collation 
sqlite3_create_collation16 
sqlite3_create_function 
sqlite3_create_function16 
sqlite3_data_count 
sqlite3_errcode 
sqlite3_errmsg 
sqlite3_free 
sqlite3_free_table 
sqlite3_interrupt 
sqlite3_mprintf 
sqlite3_progress_handler 
sqlite3_result_blob 
sqlite3_result_double 
sqlite3_result_error 
sqlite3_result_error16 
sqlite3_result_int 
sqlite3_result_int64 
sqlite3_result_null 
sqlite3_result_text 
sqlite3_result_text16 
sqlite3_result_text16be 
sqlite3_result_text16le 
sqlite3_result_value 
sqlite3_set_authorizer 
sqlite3_total_changes 
sqlite3_trace 
sqlite3_user_data 
sqlite3_value_blob 
sqlite3_value_bytes 
sqlite3_value_bytes16 
sqlite3_value_double 
sqlite3_value_int 
sqlite3_value_int64 
sqlite3_value_text 
sqlite3_value_text16 
sqlite3_value_text16be 
sqlite3_value_text16le 
sqlite3_value_type 
sqlite3_vmprintf 
 



--------------------------------------------------------------------------------


  void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);

Aggregate functions use the following routine to allocate a structure for storing their state.
The first time this routine is called for a particular aggregate, a new structure of size nBytes is allocated, zeroed, and returned.
On subsequent calls (for the same aggregate instance) the same buffer is returned.
The implementation of the aggregate can use the returned buffer to accumulate data.

The buffer allocated is freed automatically by SQLite.



--------------------------------------------------------------------------------


  int sqlite3_aggregate_count(sqlite3_context*);

The next routine returns the number of calls to xStep for a particular aggregate function instance.
The current call to xStep counts so this routine always returns at least 1.



--------------------------------------------------------------------------------


int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);

This routine identifies a callback function that is invoked whenever an attempt is made to open a database table that is currently locked by another process or thread.
If the busy callback is NULL, then sqlite3_exec() returns <a href="sqlconst.htm#SQLITE_BUSY">SQLITE_BUSY</a> immediately if it finds a locked table.
If the busy callback is not NULL, then sqlite3_exec() invokes the callback with two arguments.
The second argument is the number of prior calls to the busy callback for the same lock.
If the busy callback returns 0, then sqlite3_exec() immediately returns <a href="sqlconst.htm#SQLITE_BUSY">SQLITE_BUSY</a>.
If the callback returns non-zero, then sqlite3_exec() tries to open the table again and the cycle repeats.

The default busy callback is NULL.

Sqlite is re-entrant, so the busy handler may start a new query.
(It is not clear why anyone would every want to do this, but it is allowed, in theory.) 
But the busy handler may not close the database.
Closing the database from a busy handler will delete data structures out from under the executing query and will probably result in a coredump.



--------------------------------------------------------------------------------


  int sqlite3_busy_timeout(sqlite3*, int ms);

This routine sets a busy handler that sleeps for a while when a table is locked.
The handler will sleep multiple times until at least "ms" milleseconds of sleeping have been done.
After "ms" milleseconds of sleeping, the handler returns 0 which causes sqlite3_exec() to return <a href="sqlconst.htm#SQLITE_BUSY">SQLITE_BUSY</a>.

Calling this routine with an argument less than or equal to zero turns off all busy handlers.



--------------------------------------------------------------------------------


int sqlite3_collation_needed(
  sqlite3*, 
  void*, 
  void(*)(void*,sqlite3*,int eTextRep,const char*)
);
int sqlite3_collation_needed16(
  sqlite3*, 
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const void*)
);

To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the database handle to be 
called whenever an undefined collation sequence is required.

If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8.
If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order.
A call to either function replaces any existing callback.

When the user-function is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16().
The second argument is the database handle.
The third argument is one of SQLITE_UTF8, SQLITE_UTF16BE or SQLITE_UTF16LE, indicating the most desirable form of the collation sequence function required.
The fourth parameter is the name of the required collation sequence.

The collation sequence is returned to SQLite by a collation-needed callback using the sqlite3_create_collation() or sqlite3_create_collation16() APIs, described above.



--------------------------------------------------------------------------------


const char *sqlite3_column_decltype(sqlite3_stmt *, int i);

The first parameter is a prepared SQL statement.
If this statement is a SELECT statement, the Nth column of the returned result set of the SELECT is a table column then the declared type of the table column is returned.
If the Nth column of the result set is not at table column, then a NULL pointer is returned.
For example, in the database schema:


 CREATE TABLE t1(c1 INTEGER);
 

And the following statement compiled:


 SELECT c1 + 1, 0 FROM t1;
 

Then this routine would return the string "INTEGER" for the second result column (i==1), and a NULL pointer for the first result column (i==0).


--------------------------------------------------------------------------------


void *sqlite3_commit_hook(sqlite3*, int(*xCallback)(void*), void *pArg);

Experimental

Register a callback function to be invoked whenever a new transaction is committed.
The pArg argument is passed through to the callback.
If the callback function returns non-zero, then the commit is converted into a rollback.

If another function was previously registered, its pArg value is returned.
Otherwise NULL is returned.

Registering a NULL function disables the callback.
Only a single commit hook callback can be registered at a time.



--------------------------------------------------------------------------------


int sqlite3_complete(const char *sql);

These functions return true if the given input string comprises one or more complete SQL statements.
The parameter must be a nul-terminated UTF-8 string.

The algorithm is simple.
If the last token other than spaces and comments is a semicolon, then return true, otherwise return false.



--------------------------------------------------------------------------------


int sqlite3_create_collation(
  sqlite3*, 
  const char *zName, 
  int pref16, 
  void*,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
int sqlite3_create_collation16(
  sqlite3*, 
  const char *zName, 
  int pref16, 
  void*,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
#define SQLITE_UTF8     1
#define SQLITE_UTF16BE  2
#define SQLITE_UTF16LE  3
#define SQLITE_UTF16    4

These two functions are used to add new collation sequences to the sqlite3 handle specified as the first argument.

The name of the new collation sequence is specified as a UTF-8 string for sqlite3_create_collation() and a UTF-16 string for sqlite3_create_collation16().
In both cases the name is passed as the second function argument.

The third argument must be one of the constants SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE, indicating that the user-supplied routine expects 
to be passed pointers to strings encoded using UTF-8, UTF-16 little-endian or UTF-16 big-endian respectively.
The SQLITE_UTF16 constant indicates that text strings are expected in UTF-16 in the native byte order of the host machine.

A pointer to the user supplied routine must be passed as the fifth argument.
If it is NULL, this is the same as deleting the collation sequence (so that SQLite cannot call it anymore).
Each time the user supplied function is invoked, it is passed a copy of the void* passed as the fourth argument to sqlite3_create_collation() or sqlite3_create_collation16() as its first parameter.

The remaining arguments to the user-supplied routine are two strings, each represented by a [length, data] pair and encoded in the encoding that was passed as 
the third argument when the collation sequence was registered.

The user routine should return negative, zero or positive if the first string is less than, equal to, or greater than the second string. i.e. (STRING1 - STRING2).



--------------------------------------------------------------------------------


int sqlite3_create_function(
  sqlite3 *,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void*,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
int sqlite3_create_function16(
  sqlite3*,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void*,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
#define SQLITE_UTF8     1
#define SQLITE_UTF16    2
#define SQLITE_UTF16BE  3
#define SQLITE_UTF16LE  4
#define SQLITE_ANY      5

These two functions are used to add user functions or aggregates implemented in C to the SQL langauge interpreted by SQLite.
The difference only between the two is that the second parameter, the name of the (scalar) function or aggregate, is encoded in UTF-8 for sqlite3_create_function() 
and UTF-16 for sqlite3_create_function16().

The first argument is the database handle that the new function or aggregate is to be added to.
If a single program uses more than one database handle internally, then user functions or aggregates must be added individually to each database handle with which they will be used.

The third parameter is the number of arguments that the function or aggregate takes.
If this parameter is negative, then the function or aggregate may take any number of arguments.

The sixth, seventh and eighth, xFunc, xStep and xFinal, are pointers to user implemented C functions that implement the user function or aggregate.
A scalar function requires an implementation of the xFunc callback only, NULL pointers should be passed as the xStep and xFinal parameters.
An aggregate function requires an implementation of xStep and xFinal, but NULL should be passed for xFunc.
To delete an existing user function or aggregate, pass NULL for all three function callback.
Specifying an inconstent set of callback values, such as an xFunc and an xFinal, or an xStep but no xFinal, SQLITE_ERROR is returned.



--------------------------------------------------------------------------------


int sqlite3_errcode(sqlite3 *db);

Return the error code for the most recent sqlite3_* API call associated with sqlite3 handle 'db'.
<a href="sqlconst.htm#SQLITE_OK">SQLITE_OK</a> is returned if the most recent API call was successful.

Calls to many sqlite3_* functions set the error code and string returned by sqlite3_errcode() and sqlite3_errmsg() (overwriting the previous values).
Note that calls to sqlite3_errcode() and sqlite3_errmsg() themselves do not affect the results of future invocations.

Assuming no other intervening sqlite3_* API calls are made, the error code returned by this function is associated with the same error as the strings returned by 
sqlite3_errmsg().



--------------------------------------------------------------------------------


const char *sqlite3_errmsg(sqlite3*);

Return a pointer to a UTF-8 encoded string describing in English the error condition for the most recent sqlite3_* API call.
The returned string is always terminated by an 0x00 byte.

The string "not an error" is returned when the most recent API call was successful.



--------------------------------------------------------------------------------


void sqlite3_free(char *z);

Use this routine to free memory obtained from sqlite3_mprintf() or sqlite3_vmprintf().



--------------------------------------------------------------------------------


 void sqlite3_interrupt(sqlite3*);

This function causes any pending database operation to abort and return at its earliest opportunity.
This routine is typically called in response to a user action such as pressing "Cancel" or Ctrl-C where the user wants a long query operation to halt immediately.




--------------------------------------------------------------------------------


char *sqlite3_mprintf(const char*,...);
char *sqlite3_vmprintf(const char*, va_list);

These routines are variants of the "sprintf()" from the standard C library.
The resulting string is written into memory obtained from malloc() so that there is never a possiblity of buffer overflow.
These routines also implement some additional formatting options that are useful for constructing SQL statements.

The strings returned by these routines should be freed by calling sqlite3_free().

All of the usual printf formatting options apply.
In addition, there is a "%q" option.
%q works like %s in that it substitutes a null-terminated string from the argument list.
But %q also doubles every '\'' character.
%q is designed for use inside a string literal.
By doubling each '\'' character it escapes that character and allows it to be inserted into the string.

For example, so some string variable contains text as follows:


  char *zText = "It's a happy day!";
 

One can use this text in an SQL statement as follows:


  sqlite3_exec_printf(db, "INSERT INTO table VALUES('%q')",
       callback1, 0, 0, zText);
  

Because the %q format string is used, the '\'' character in zText is escaped and the SQL generated is as follows:


  INSERT INTO table1 VALUES('It''s a happy day!')
 

This is correct.
Had we used %s instead of %q, the generated SQL would have looked like this:


  INSERT INTO table1 VALUES('It's a happy day!');
  

This second example is an SQL syntax error.
As a general rule you should always use %q instead of %s when inserting text into a string literal.



--------------------------------------------------------------------------------


void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);

Experimental

This routine configures a callback function - the progress callback - that is invoked periodically during long running calls to sqlite3_exec(), 
<a href="sqlite3_step.htm">sqlite3_step</a>() and sqlite3_get_table().
An example use for this API is to keep a GUI updated during a large query.

The progress callback is invoked once for every N virtual machine opcodes, where N is the second argument to this function.
The progress callback itself is identified by the third argument to this function.
The fourth argument to this function is a void pointer passed to the progress callback function each time it is invoked.

If a call to sqlite3_exec(), 
<a href="sqlite3_step.htm">sqlite3_step</a>() or sqlite3_get_table() results in less than N opcodes being executed, then the progress callback is not invoked.

To remove the progress callback altogether, pass NULL as the third argument to this function.

If the progress callback returns a result other than 0, then the current query is immediately terminated and any database changes rolled back.
If the query was part of a larger transaction, then the transaction is not rolled back and remains active.
The sqlite3_exec() call returns SQLITE_ABORT.




--------------------------------------------------------------------------------


void sqlite3_result_blob(sqlite3_context*, const void*, int n, void(*)(void*));
void sqlite3_result_double(sqlite3_context*, double);
void sqlite3_result_error(sqlite3_context*, const char*, int);
void sqlite3_result_error16(sqlite3_context*, const void*, int);
void sqlite3_result_int(sqlite3_context*, int);
void sqlite3_result_int64(sqlite3_context*, long long int);
void sqlite3_result_null(sqlite3_context*);
void sqlite3_result_text(sqlite3_context*, const char*, int n, void(*)(void*));
void sqlite3_result_text16(sqlite3_context*, const void*, int n, void(*)(void*));
void sqlite3_result_text16be(sqlite3_context*, const void*, int n, void(*)(void*));
void sqlite3_result_text16le(sqlite3_context*, const void*, int n, void(*)(void*));
void sqlite3_result_value(sqlite3_context*, sqlite3_value*);

User-defined functions invoke the following routines in order to set their return value.
The sqlite3_result_value() routine is used to return an exact copy of one of the parameters to the function.

The operation of these routines is very similar to the operation of sqlite3_bind_blob() and its cousins.
Refer to the documentation there for additional information.



--------------------------------------------------------------------------------


int sqlite3_set_authorizer(
  sqlite3*,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pUserData
);
#define SQLITE_CREATE_INDEX          1   /* Index Name      Table Name      */
#define SQLITE_CREATE_TABLE          2   /* Table Name      NULL            */
#define SQLITE_CREATE_TEMP_INDEX     3   /* Index Name      Table Name      */
#define SQLITE_CREATE_TEMP_TABLE     4   /* Table Name      NULL            */
#define SQLITE_CREATE_TEMP_TRIGGER   5   /* Trigger Name    Table Name      */
#define SQLITE_CREATE_TEMP_VIEW      6   /* View Name       NULL            */
#define SQLITE_CREATE_TRIGGER        7   /* Trigger Name    Table Name      */
#define SQLITE_CREATE_VIEW           8   /* View Name       NULL            */
#define SQLITE_DELETE                9   /* Table Name      NULL            */
#define SQLITE_DROP_INDEX           10   /* Index Name      Table Name      */
#define SQLITE_DROP_TABLE           11   /* Table Name      NULL            */
#define SQLITE_DROP_TEMP_INDEX      12   /* Index Name      Table Name      */
#define SQLITE_DROP_TEMP_TABLE      13   /* Table Name      NULL            */
#define SQLITE_DROP_TEMP_TRIGGER    14   /* Trigger Name    Table Name      */
#define SQLITE_DROP_TEMP_VIEW       15   /* View Name       NULL            */
#define SQLITE_DROP_TRIGGER         16   /* Trigger Name    Table Name      */
#define SQLITE_DROP_VIEW            17   /* View Name       NULL            */
#define SQLITE_INSERT               18   /* Table Name      NULL            */
#define SQLITE_PRAGMA               19   /* Pragma Name     1st arg or NULL */
#define SQLITE_READ                 20   /* Table Name      Column Name     */
#define SQLITE_SELECT               21   /* NULL            NULL            */
#define SQLITE_TRANSACTION          22   /* NULL            NULL            */
#define SQLITE_UPDATE               23   /* Table Name      Column Name     */
#define SQLITE_ATTACH               24   /* Filename        NULL            */
#define SQLITE_DETACH               25   /* Database Name   NULL            */

#define SQLITE_DENY   1   /* Abort the SQL statement with an error */
#define SQLITE_IGNORE 2   /* Don't allow access, but don't generate an error */

This routine registers a callback with the SQLite library.
The callback is invoked (at compile-time, not at run-time) for each attempt to access a column of a table in the database.
The callback should return <a href="sqlconst.htm#SQLITE_OK">SQLITE_OK</a> if access is allowed, 
SQLITE_DENY if the entire SQL statement should be aborted with an error and SQLITE_IGNORE if the column should be treated as a NULL value.

The second parameter to the access authorization function above will be one of the values below.
These values signify what kind of operation is to be authorized.
The 3rd and 4th parameters to the authorization function will be parameters or NULL depending on which of the following codes is used as the second parameter.
The 5th parameter is the name of the database ("main", "temp", etc.) if applicable.
The 6th parameter is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from input SQL code.

The return value of the authorization function should be one of the constants 
<a href="sqlconst.htm#SQLITE_OK">SQLITE_OK</a>, SQLITE_DENY, or SQLITE_IGNORE.

The intent of this routine is to allow applications to safely execute user-entered SQL.
An appropriate callback can deny the user-entered SQL access certain operations (ex: anything that changes the database) or to deny access to certain tables or columns within the database.




--------------------------------------------------------------------------------

>

void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);

Register a function that is called each time an SQL statement is evaluated.
The callback function is invoked on the first call to 
<a href="sqlite3_step.htm">sqlite3_step</a>() after calls to 
<a href="sqlite3_prepare.htm">sqlite3_prepare</a>() or 
<a href="sqlite3_reset.htm">sqlite3_reset</a>().
This function can be used (for example) to generate a log file of all SQL executed against a database.
This can be useful when debugging an application that uses SQLite.




--------------------------------------------------------------------------------


void *sqlite3_user_data(sqlite3_context*);

The pUserData parameter to the sqlite3_create_function() and sqlite3_create_function16() routines used to register user functions is available to the implementation of the function using this call.




--------------------------------------------------------------------------------


const void *sqlite3_value_blob(sqlite3_value*);
int sqlite3_value_bytes(sqlite3_value*);
int sqlite3_value_bytes16(sqlite3_value*);
double sqlite3_value_double(sqlite3_value*);
int sqlite3_value_int(sqlite3_value*);
long long int sqlite3_value_int64(sqlite3_value*);
const unsigned char *sqlite3_value_text(sqlite3_value*);
const void *sqlite3_value_text16(sqlite3_value*);
const void *sqlite3_value_text16be(sqlite3_value*);
const void *sqlite3_value_text16le(sqlite3_value*);
int sqlite3_value_type(sqlite3_value*);

This group of routines returns information about parameters to a user-defined function.
Function implementations use these routines to access their parameters.
These routines are the same as the sqlite3_column_... routines except that these routines take a single sqlite3_value* pointer instead of an sqlite3_stmt* and an integer column number.

See the documentation under sqlite3_column_blob for additional information.

-->
        <br>
        <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
