<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Phix vs Conventional Languages</h1>
      <div id="mainSection">
        By basing Phix on one, simple, general, recursive data structure, the sequence, 
        a tremendous amount of the complexity normally found in programming languages
        has been avoided. The arrays, structures, unions, arrays of records,
        multidimensional arrays, etc. of other languages can all be easily
        represented in Phix with sequences. So can higher-level structures such
        as lists, stacks, queues, trees etc.
       <br>
       <br>
        Furthermore, in Phix you can have sequences of mixed type; you can
        assign any object to an element of a sequence; and sequences easily grow or
        shrink in length without you having to worry about storage allocation issues.
        The exact layout of a data structure does not have to be declared in advance,
        and can change dynamically as required. It is easy to write generic code,
        where, for instance, you push or pop a mix of various kinds of data
        objects using a single stack. Making a flexible list that contains a variety
        of different kinds of data objects is trivial in Phix, but requires dozens
        of lines of ugly code in other languages.
       <br>
       <br>
        Data structure manipulations are very efficient since the Phix interpreter
        just points to large data objects rather than copying them.
       <br>
       <br>
        Programming in Phix is based entirely on creating and manipulating
        flexible, dynamic sequences of data. Sequences are
        <b>
         <i>it</i>
        </b>
        - there are no other data structures to learn. You operate 
        in a simple, safe, elastic world of
        <b>
         <i>values</i>
        </b>
        far removed from the rigid, tedious, dangerous world of bits, bytes, pointers 
        and machine crashes.
       <br>
       <br>
         Unlike other languages such as LISP and Smalltalk, Phix&rsquo;s
         "garbage collection" of unused storage is a continuous process that never
         causes random delays in execution of a program, and does not pre-allocate
         huge regions of memory.
       <br>
       <br>
        The language definitions of conventional languages such as C, C++, Ada, etc.
        are very complex. Most programmers become fluent in only a subset of the
        language. The ANSI standards for these languages read like complex legal
        documents.
       <br>
       <br>
        You are forced to write different code for different data types simply to
        copy the data, ask for its current length, concatenate it, compare it etc.
        The manuals for those languages are packed with routines such as strcpy,
        wcscpy, _tcscpy, lstrcpy, StrCpy, StringCbCpy, StringCbCpyEx,
        StringCchCpy, StringCchCpyEx, strncpy, _strncpy_l, wcsncpy, 
        _wcsncpy_l, _mbsncpy, _tcsncpy, _mbsncpy_l, strcat, lstrcat, 
        wcscat, _mbscat, strcat_s, wcscat_s, _mbscat_s, StrCat, 
        StringCbCat, StringCbCatEx, StringCbCatN, StringCbCatNEx, 
        StringCchCat, StringCchCatEx, StringCchCatN, StringCchCatNEx, 
        strncat, _strncat_l, wcsncat, wcsncat_l, _mbsncat, _mbsncat_l,
        strlen, lstrlen, StringCbLength, StringCchLength, 
        strcmp, lstrcmp, strncmp, wcsncmp, _mbsncmp, _mbsncmp_l, 
        _strnicmp, _wcsnicmp, _mbsnicmp, _strnicmp_l, _wcsnicmp_l, 
        _mbsnicmp_l, strrchr, wcsrchr, _mbsrchr, _mbsrchr_l, strspn, 
        wcsspn, _mbsspn, _mbsspn_l, memcpy, memcmp, etc. (clearly I could 
        be here all day just listing them) that each only work on one of the many 
        types of data.
       <br>
       <br>
        Much of the complexity surrounds issues of data type. How do you define
        new types? Which types of data can be mixed? How do you convert one type
        into another in a way that will keep the compiler happy? When you need to
        do something requiring flexibility at run-time, you frequently find yourself
        trying to fake out the compiler.
       <br>
       <br>
        In these languages the numeric value 4 (for example) can have a different
        meaning depending on whether it is an int, a char, a short, a double, an
        int * etc. In Phix, 4 is the atom 4, period. Phix has something
        called types as we shall see later, but it is a much simpler concept
        (used mainly for validation and debugging).
       <br>
       <br>
        Issues of dynamic storage allocation and deallocation consume a great deal
        of programmer coding time and debugging time in these other languages, and
        make the resulting programs much harder to understand. Programs that must
        run continuously often exhibit storage "leaks", since it takes a great
        deal of discipline to safely and properly free all blocks of storage
        once they are no longer needed. (The same can be said for Phix code that
        interfaces to other languages, but not for normal hll code.)
       <br>
       <br>
        In most C based languages, strings are "immutable". In Phix, you can modify 
        strings any way you like, everything is automatically taken care of for you,
        and all with no nasty surprises. Note, however, that in Phix you are expected 
        to say <code>str = modified(str)</code>, rather than <code>modify(str)</code>.
        On that note, when reading Phix code it is always absolutely clear what is
        being mofified; you are not expected to continuously assume that arguments
        to routines <i>might</i> be modified, or <i>hope and pray</i> they are not.
       <br>
       <br>
        In other languages pointer variables are extensively used. The pointer has 
        been called the "go to" of data structures. It forces programmers to think 
        of data as being bound to a fixed memory location where it can be manipulated 
        in all sorts of low-level, non-portable, tricky ways. A picture of the actual
        hardware that your program will run on is never far from your mind. Except 
        when needed to invoke routines written in other languages, and even then only
        as a normal atom value, with no special syntax, Phix does not have pointers 
        and does not need them.
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
