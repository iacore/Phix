<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">Precedence Chart</h1>
      <div id="mainSection">
         The precedence of operators in expressions is as follows:
 <pre>
        <font color="#009999"><b>highest precedence:</b></font>     function/type calls

                                subscripts/slices

                                unary-  unary+  not

                                *  /

                                +  -

                                &

                                &lt;  &gt;  &lt;=  &gt;=  =  !=

                                and  or  xor

        <font color="#009999"><b>lowest precedence:</b></font>      { , , , }
 </pre>
         Thus 2+6*3 means 2+(6*3) rather than (2+6)*3. Operators on the same line
         above have equal precedence and are evaluated left to right.
       <br>
       <br>
         The equals symbol '=' used in an
        <a href="assignment.htm">assignment statement</a> is not an operator,
         it is just part of the syntax of the language.
       <br>
       <br>
         Parenthesis is required to mix and, or, and xor in an expression. If, for example, the compiler
         finds "a or b and c" it will
        <I>
         <B>not</B>
        </I> assume "(a or b) and c" over "a or (b and c)" 
         (or vice versa) but demands you state exactly which you mean. Most programmers have at one point 
         or another coded something apparently "obvious" such as
<!--eucode>
    if a and b
    or c and d then
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">    if</font><font color="#000000"> a</font><font color="#008080"> and</font><font color="#000000"> b
</font><font color="#008080">    or</font><font color="#000000"> c</font><font color="#008080"> and</font><font color="#000000"> d</font><font color="#008080"> then</font>
</pre>
       or
<!--eucode>
    if a or b 
    and c or d then
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">    if</font><font color="#000000"> a</font><font color="#008080"> or</font><font color="#000000"> b 
</font><font color="#008080">    and</font><font color="#000000"> c</font><font color="#008080"> or</font><font color="#000000"> d</font><font color="#008080"> then</font>
</pre>
       and then been surprised when compiler gets it completely wrong, unless they actually meant (((a and b) or c) and d), or (((a or b) and c) or d), which seems unlikely.
       <br>
       <br>
       To avoid this issue, Phix simply forces the programmer to supply enough additional explicit parenthesis until everything is completely unambiguous, eg/ie
<!--eucode>
    if (a and b)
    or (c and d) then
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">    if</font><font color="#0000FF"> (</font><font color="#000000">a</font><font color="#008080"> and</font><font color="#000000"> b</font><font color="#0000FF">)
</font><font color="#008080">    or</font><font color="#0000FF"> (</font><font color="#000000">c</font><font color="#008080"> and</font><font color="#000000"> d</font><font color="#0000FF">)</font><font color="#008080"> then</font>
</pre>
       or
<!--eucode>
    if (a or b)
    and (c or d) then
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">    if</font><font color="#0000FF"> (</font><font color="#000000">a</font><font color="#008080"> or</font><font color="#000000"> b</font><font color="#0000FF">)
</font><font color="#008080">    and</font><font color="#0000FF"> (</font><font color="#000000">c</font><font color="#008080"> or</font><font color="#000000"> d</font><font color="#0000FF">)</font><font color="#008080"> then</font>
</pre>
        On a related note, <code>a*(b/c)</code> and <code>(a*b)/c</code> are mathematically equivalent, however precision limits of the physical hardware may mean they give 
        very different results, especially for partial results that approach or exceed the floating point hardware limits.
        In practice the compiler treats <code>a*b/c</code> as <code>(a*b)/c</code>, however in general that is an implementation detail that should not be overly relied on - 
        if one day some bright spark invented a safe and simple method to automatically minimise precision loss in the un-parenthesised case, I would take it.
       <br>
       <br>
        Other programming languages may have subtle differences in precedence. For instance, in Python 'or' has a lower precedence than 'and', 
        so take that into account when translating some Python code and Phix starts demanding extra parenthesis. In Python the 'not' operator has a lower 
        precedence than '+', so <code>idx + not flag + offset</code> is treated as <code>idx + not (flag + offset)</code>, quite unlike the Phix
        interpretation which is <code>idx + (not flag) + offset</code>. My recommendation is to use as much parenthesis as you can bear, and when it gets too much
        that is as good an excuse as any to break the expression down into more manageable pieces. Besides, storing partial results in appropriately named variables 
        can not only make the intent much clearer but also debugging significantly easier and faster.
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
