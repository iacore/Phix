<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">routine_id</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
          <a href="integer.htm">integer</a> rid = routine_id(<a href="string.htm">string</a> rtn_name)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Return an integer id number, in fact an index to the symbol table, for a user-defined procedure or function.
            <br>
            <br>
            The name of the procedure or function is given by the string sequence rtn_name.
            <br>
            <br>
            -1 is returned if the named routine cannot be found (see Technicalia).
         </td>
        </tr>
        <tr>
         <td>
          <b>Comments:</b>
         </td>
         <td>
            The id number can be passed to call_proc() or call_func(), to indirectly call the routine named by rtn_name.<br>
            It can also be called directly, as of 0.8.1+ routine_ids are first class, see example 1 below.
          <br>
          <br>
            The routine named by rtn_name must be visible, i.e. callable, at the place where routine_id() is used to get the id number. 
            Indirect calls to the routine can appear earlier in the program than the definition of the routine, but the id number can 
            only be obtained in code that comes <i>after</i> the definition of the routine - see example 2 below.
          <br>
          <br> 
            Once obtained, a valid <b>routine id</b> can be used at <b><i>any</i></b> place in the program to call a routine indirectly 
            via call_proc()/call_func(), or now directly.
          <br>
          <br>
            Some typical uses of routine_id() are:<br>
             1. Creating a subroutine that takes another routine as a parameter. (See Example 2 below)<br>
             2. Setting up an Object-Oriented system.<br>
             3. Defining a call_back(). (See <a href="ccall.htm">Calling C Functions</a>)
          <br>
          <br>
             Note that C routines, callable by Phix, also have (non-first-class) routine ids, but from
             <a href="define_c_proc.htm">define_c_proc</a>() and <a href="define_c_func.htm">define_c_func</a>(), not this.
         </td>
        </tr>
        <tr>
         <td>
          <b>Example 1:</b>
         </td>
         <td>
<!--eucode>
procedure foo()
    puts(1, "Hello World\n")
end procedure
constant r_foo = routine_id("foo")
call_proc(r_foo, {})    -- same as calling foo()
r_foo()                 -- "", in 0.8.1+
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">procedure</font><font color="#000000"> foo</font><font color="#0000FF">()
</font><font color="#7060A8">    puts</font><font color="#0000FF">(</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#008000"> "Hello World\n"</font><font color="#0000FF">)
</font><font color="#008080">end procedure
constant</font><font color="#000000"> r_foo</font><font color="#0000FF"> =</font><font color="#5E005E"> routine_id</font><font color="#0000FF">(</font><font color="#008000">"foo"</font><font color="#0000FF">)
</font><font color="#7060A8">call_proc</font><font color="#0000FF">(</font><font color="#000000">r_foo</font><font color="#0000FF">,</font><font color="#800000"> {}</font><font color="#0000FF">)   </font><font color="#000080"><i> -- same as calling foo()
</i></font><font color="#000000">r_foo</font><font color="#0000FF">()                </font><font color="#000080"><i> -- "", in 0.8.1+</i></font>
</pre>
         </td>
        </tr>
        <tr>
         <td>
          <b>Example 2:</b>
         </td>
         <td>
<!--eucode>
function apply_to_all(sequence s, integer f)
-- apply the specified function to all elements of a sequence
    for i=1 to length(s) do
        s[i] = call_func(f, {s[i]})
    end for
    return s
end function

function add1(atom x)
    return x + 1
end function

? apply_to_all({1, 2, 3}, routine_id("add1"))  -- displays {2,3,4}
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">function</font><font color="#000000"> apply_to_all</font><font color="#0000FF">(</font><font color="#004080">sequence</font><font color="#000000"> s</font><font color="#0000FF">,</font><font color="#004080"> integer</font><font color="#000000"> f</font><font color="#0000FF">)
</font><font color="#000080"><i>-- apply the specified function to all elements of a sequence
</i></font><font color="#008080">    for</font><font color="#000000"> i</font><font color="#0000FF">=</font><font color="#000000">1</font><font color="#008080"> to</font><font color="#7060A8"> length</font><font color="#0000FF">(</font><font color="#000000">s</font><font color="#0000FF">)</font><font color="#008080"> do
</font><font color="#000000">        s</font><font color="#0000FF">[</font><font color="#000000">i</font><font color="#0000FF">] =</font><font color="#7060A8"> call_func</font><font color="#0000FF">(</font><font color="#000000">f</font><font color="#0000FF">,</font><font color="#800000"> {</font><font color="#000000">s</font><font color="#800080">[</font><font color="#000000">i</font><font color="#800080">]</font><font color="#800000">}</font><font color="#0000FF">)
</font><font color="#008080">    end for
    return</font><font color="#000000"> s
</font><font color="#008080">end function

function</font><font color="#000000"> add1</font><font color="#0000FF">(</font><font color="#004080">atom</font><font color="#000000"> x</font><font color="#0000FF">)
</font><font color="#008080">    return</font><font color="#000000"> x</font><font color="#0000FF"> +</font><font color="#000000"> 1
</font><font color="#008080">end function

</font><font color="#0000FF">?</font><font color="#000000"> apply_to_all</font><font color="#0000FF">(</font><font color="#800000">{</font><font color="#000000">1</font><font color="#0000FF">,</font><font color="#000000"> 2</font><font color="#0000FF">,</font><font color="#000000"> 3</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#5E005E"> routine_id</font><font color="#800000">(</font><font color="#008000">"add1"</font><font color="#800000">)</font><font color="#0000FF">) </font><font color="#000080"><i> -- displays {2,3,4}</i></font>
</pre>
            <br>
            Note that add1 could be a private function in a completely different file; there is no need for it to be in scope when (actually) called.
         </td>
        </tr>
        <tr>
         <td>
          <b>Implementation:</b>
         </td>
         <td>
            See builtins\VM\prtnidN.e (an autoinclude) for details of the actual implementation.
            <br>
            <br>
            Note however that the compiler tries very hard to avoid calling/including that code, if things can be resolved at compile-time.
         </td>
        </tr>
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="call_proc.htm">call_proc</a>,
          <a href="call_func.htm">call_func</a>,
          <a href="call_back.htm">call_back</a>,
          <a href="define_c_func.htm">define_c_func</a>,
          <a href="define_c_proc.htm">define_c_proc</a>,
          <a href="ccall.htm">Calling C Functions</a>
         </td>
        </tr>
        <tr id="Technicalia" style="display:none;">
         <td>
          <a href="glossary.htm#technicalia">
           <b>Technicalia</b>
          </a>
         </td>
         <td>
          When possible the routine_id is resolved at compile-time, but (especially for constructed strings) can be left until run-time.
          There is also an inline assembler compiler directive of the same name, which <i>must</i> however be resolved at compile-time,
          and forward references are explicitly disallowed. See pilasm.e for implementation details.
          <br>
          <br>
          <div id="code-snippet-1" class="codeSnippetContainer" xmlns="">
           <div class="codeSnippetContainerCodeContainer">
            <div class="codeSnippetToolBar">
             <div class="codeSnippetToolBarText">
              <a id="copytext" href="javascript:CopyToClipboard('CodeSnippetContainerCode_12a65b96-c3ab-4175-936c-8e1295c81946');">Copy</a>
             </div>
            </div>
            <div id="CodeSnippetContainerCode_12a65b96-c3ab-4175-936c-8e1295c81946" class="codeSnippetContainerCode" dir="ltr">
             <div style="color:Black;">
<!--eucode>
    #ilASM{
            ...
            mov edx,routine_id(fopen)           -- mov edx,imm32 (sets K_ridt)
            mov ecx,$_Ltot                      -- (symtab[fopen][S_Ltot])
            call :%opFrame
            pop dword[ebp]                      -- filepath
            pop dword[ebp-4]                    -- openmode
            mov [ebp+28],:openret
            jmp $_il                            -- (symtab[fopen][S_il])
          ::openret
            ...
          }
</eucode-->
<pre>
<font color="#000000">    #</font><font color="#008080">ilASM</font><font color="#0000FF">{
            ...
</font><font color="#000000">            mov edx</font><font color="#0000FF">,</font><font color="#5E005E">routine_id</font><font color="#800000">(</font><font color="#000000">fopen</font><font color="#800000">)          </font><font color="#000080"><i> -- mov edx,imm32 (sets K_ridt)
</i></font><font color="#000000">            mov ecx</font><font color="#0000FF">,</font><font color="#000000">$_Ltot                     </font><font color="#000080"><i> -- (symtab[fopen][S_Ltot])
</i></font><font color="#7060A8">            call</font><font color="#0000FF"> :</font><font color="#000000">%opFrame
            pop dword</font><font color="#800000">[</font><font color="#000000">ebp</font><font color="#800000">]                     </font><font color="#000080"><i> -- filepath
</i></font><font color="#000000">            pop dword</font><font color="#800000">[</font><font color="#000000">ebp</font><font color="#0000FF">-</font><font color="#000000">4</font><font color="#800000">]                   </font><font color="#000080"><i> -- openmode
</i></font><font color="#000000">            mov</font><font color="#800000"> [</font><font color="#000000">ebp</font><font color="#0000FF">+</font><font color="#000000">28</font><font color="#800000">]</font><font color="#0000FF">,:</font><font color="#000000">openret
            jmp $_il                           </font><font color="#000080"><i> -- (symtab[fopen][S_il])
</i></font><font color="#0000FF">          ::</font><font color="#000000">openret
</font><font color="#0000FF">            ...
          }</font>
</pre>
             </div>
            </div>
           </div>
          </div>
            Note that there are no quotes around the routine name when invoked in this manner within #ilASM. As shown, $_Ltot and $_il can be used to obtain the equivalent
            fixed constant literal values from the symtab entry corresponding to the most recent routine_id directive. It is currently coded to issue an error if you forget
            to use all three, routine_id first. The statement "mov edx,routine_id(fopen)" is compiled to and executes as (say) "mov edx,118", and also sets the K_ridt (known 
            routine_id target) flag on symtab[fopen], therefore forcing full parameter typechecking.
            <br>
            <br>
            The above example is taken from builtins\VM\pfileioN.e (wherein you can find 32 and 64-bit versions with proper reference counting) and implements a hll open() 
            statement. Of course the latter is much easier, and this method should only be used when some other reason makes it necessary, in this specific case that would
            be a combination of getting these things into the optable (so that pfileioN.e does not have to be recompiled every time when interpreting) and the subsequent 
            implications for thread-safety (in top-level code).
            <br>
            <br>
            In Phix, a return value of 0 for failure would probably make more sense, however for compatibility with Euphoria, on which 0 <i>is</i> a valid routine_id,
            it returns -1. Previous versions of Phix could also return -2 if there were multiple globals of that name, and -3 if the namespace did not exist, and some
            (Phix-only) routines check the result for &lt;=0, or even &lt;=T_const1(==26) as nothing in the symbol table &lt;=26 can be a valid routine_id target.
<!--
            <br>
            <br>
            The SetHandler() routine in win32lib.ew performs special handling of -1 [clear] and -2 [prefix] in the (list of) routine_ids: that handling is unchanged
            but there may be some subtle differences as routine_id() now generates 0 - my hope is that it exposes a few bugs that might have previously slipped under 
            the radar, rather than causing problems it should not.

old/partially attempted before deciding against:
            <br>
            <br>
            If the name cannot be found, 0 is returned. For compatibility with Euphoria, which returns -1, and older versions of Phix, which returned -1/-2/-3, the 
            result should be tested for &lt;=0 (should you see anything testing for "=-1", please change it to "&lt;=0" and, if appropriate, let me know).
-->
            <br>
            <br>
            As of 0.8.1, routine_ids are first class, ie [also] callable directly. Eg:
<!--eucode>
            procedure show(string s) ?s end procedure
            constant r_show = routine_id("show")
            -- show("40")   (normal non-routine_id call [still valid!])
            call_proc(r_show,{"41"})                -- old style [""!]
            r_show("42")                            -- ***new***

            function f(integer i) return i end function
            constant r_f = routine_id("f")
            --?f(40)        (normal non-routine_id call [still valid!])
            ?call_func(r_f,{41})                    -- old style [""!]
            ?r_f(42)                                -- ***new***
</eucode-->
<pre>
<font color="#000000"></font><font color="#008080">            procedure</font><font color="#000000"> show</font><font color="#0000FF">(</font><font color="#004080">string</font><font color="#000000"> s</font><font color="#0000FF">) ?</font><font color="#000000">s</font><font color="#008080"> end procedure
            constant</font><font color="#000000"> r_show</font><font color="#0000FF"> =</font><font color="#5E005E"> routine_id</font><font color="#0000FF">(</font><font color="#008000">"show"</font><font color="#0000FF">)
</font><font color="#000080"><i>            -- show("40")   (normal non-routine_id call [still valid!])
</i></font><font color="#7060A8">            call_proc</font><font color="#0000FF">(</font><font color="#000000">r_show</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#008000">"41"</font><font color="#800000">}</font><font color="#0000FF">)               </font><font color="#000080"><i> -- old style [""!]
</i></font><font color="#000000">            r_show</font><font color="#0000FF">(</font><font color="#008000">"42"</font><font color="#0000FF">)                           </font><font color="#000080"><i> -- ***new***

</i></font><font color="#008080">            function</font><font color="#000000"> f</font><font color="#0000FF">(</font><font color="#004080">integer</font><font color="#000000"> i</font><font color="#0000FF">)</font><font color="#008080"> return</font><font color="#000000"> i</font><font color="#008080"> end function
            constant</font><font color="#000000"> r_f</font><font color="#0000FF"> =</font><font color="#5E005E"> routine_id</font><font color="#0000FF">(</font><font color="#008000">"f"</font><font color="#0000FF">)
</font><font color="#000080"><i>            --?f(40)        (normal non-routine_id call [still valid!])
</i></font><font color="#0000FF">            ?</font><font color="#7060A8">call_func</font><font color="#0000FF">(</font><font color="#000000">r_f</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#000000">41</font><font color="#800000">}</font><font color="#0000FF">)                   </font><font color="#000080"><i> -- old style [""!]
</i></font><font color="#0000FF">            ?</font><font color="#000000">r_f</font><font color="#0000FF">(</font><font color="#000000">42</font><font color="#0000FF">)                               </font><font color="#000080"><i> -- ***new***</i></font>
</pre>
            <br>
            Any integer followed by '(' is treated as a call_func() or a call_proc(), depending on the context, and obviously as above the normal/old styles remain perfectly 
            valid and fully supported. However I decided against supporting this sort of thing (at least not before someone comes up with a compelling reason to):
<!--eucode>
            --?r_f(r_f)(43)
            --r_f(r_show)(44)
            --sequence rids = {r_show}
            --rids[1](45)
</eucode-->
<pre>
<font color="#000000"></font><font color="#000080"><i>            --?r_f(r_f)(43)
            --r_f(r_show)(44)
            --sequence rids = {r_show}
            --rids[1](45)</i></font>
</pre>
            <br>
            Instead you have to code integer rid=r_f(r_f) then ?rid(43), etc. (Some wag might say that makes them second class, but it is not like you could ever do anything 
            like that with "show" anyway.) Note that i(5) where i is not a routine_id will fail just as badly and in exactly the same way as call_func/proc(i,{5}) always did.<br>
            Likewise the additional compile-time validation of argument types that occurs on a show() call is not performed/deferred until run-time on r_show(), in exactly 
            the same way as it always was for explicit/old-style call_func/proc() calls. <br>
            These changes (first class routine_ids) were made to complement the syntax enhancements for the new struct/class handling, specifically class methods.
            <br>
            <br>
            There is inevitably<sup><small>1</small></sup> perhaps three or four times as much overhead on a call_func/proc(), and equivalently on r_show()-style, as there is 
            on a direct call, however that should be of no concern unless you are invoking it millions of times, in which case I would suggest you consider three versions of 
            a tight inner loop rather than just the one inner loop that can call any of three different routines.<br>
            <sup><small>1</small></sup> The arguments are boxed into a single sequence, additional validation occurs on rid and the length of said sequence, then each element
            of the sequence is individually extracted and put into place (same deal for r_show()-style), whereas of course a direct call has no rid to validate, the number 
            and type of arguments is validated (and fairly often only) at compile-time, and each argument is put directly into place.
         </td>
        </tr>
       </table>
       <img src="images/sprites/tech.open.png" title="Expand/Shrink" style="display:block;clear:both;" onload="setStartT(this);" onclick="changeImageT(this);" />
       <br>
       <br>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
