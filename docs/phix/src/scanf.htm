<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">scanf</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td valign=top>
          <b>Syntax:</b>
         </td>
         <td>
          <font face = "Arial, Helvetica">
            sequence res = scanf(string s, string fmt)
          </font>
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Description:</b>
         </td>
         <td>
            Attempt to find sequence params for which <a href="sprintf.htm">sprintf</a>(fmt,params) could have produced s.
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>Comments:</b>
         </td>
         <td>
            May return more than one set, for example
<!--eucode>
    res = scanf("one two three","%s %s") - res is {{"one","two three"},{"one two","three"}}
</eucode-->
<pre>
<font color="#000000">    res</font><font color="#0000FF"> =</font><font color="#800080"> scanf</font><font color="#0000FF">(</font><font color="#008000">"one two three"</font><font color="#0000FF">,</font><font color="#008000">"%s %s"</font><font color="#0000FF">) -</font><font color="#000000"> res is</font><font color="#0000FF"> {</font><font color="#800000">{</font><font color="#008000">"one"</font><font color="#0000FF">,</font><font color="#008000">"two three"</font><font color="#800000">}</font><font color="#0000FF">,</font><font color="#800000">{</font><font color="#008000">"one two"</font><font color="#0000FF">,</font><font color="#008000">"three"</font><font color="#800000">}</font><font color="#0000FF">}</font>
</pre>
            <br>
            Note that scanf relies heavily on literal separators, especially spaces. It is illegal to specify back-to-back
            strings, integers, or atoms with format strings such as "%s%s", "%d%d", "%s%d", etc. The one exception is that
            a string can immediately follow a number, an example of which is "4th" and "%d%s". Theoretically it might be
            possible to write a scanf that yields {{1,23},{12,3}} from scanf("123","%d%d") but I for one cannot think of
            a single practical use, and a scanf(x,"%s%s") that returns {{"",x},..{x,""}} is also of dubious value.
            Likewise the ability to get {"hello",12} from "hello12", which is hard, as opposed to from "hello 12", which 
            is trivial, is deemed completely unnecessary.
            <br>
            <br>
            Any width/precision/justify/zerofill etc details are for the most part quietly ignored: you may get exactly 
            the same result from %d/%d/%d as %02d/%02d/%04d, but obviously the latter might make the intent clearer, 
            re-use something that actually needs those qualifiers, or just be brain on autopilot: any error/punishment 
            here would hinder rather than help. If scanf is about to return several possibilities, it tests the results 
            of sprintf and trims the result set down to those with an exact character-by-character match, as long as 
            that does not trim the result set down to zero, and, as in the example above, it may trim nothing.
            <br>
            <br>
            Internally scanf only cares for d/f/s formats; (x/o/b)/(e/g)/(c) are treated as respective aliases, up to but 
            not including the afore-mentioned final printf trimming stage that is. For more details regarding format strings 
            refer to <a href="printf.htm">printf</a>. All characters not part of a %-group are treated as literal. There is 
            no way to suggest, let alone force, that say scanf("#FF","%d") should fail but scanf("255","%d") should succeed, 
            and anything like scanf("#FF","#%x") simply does not work (sorry), but scanf("#FF","%x") is perfectly fine.
            <br>
            <br>
            Failure is indicated by {}. Otherwise each element of the results has as many elements as there were format
            specifications in the format string, in the same order as specfied. A perfect unique and unambiguous result is 
            indicated by length(res)=1.
            <br>
            <br>
            <i>(programming note: %s is all the wildcard-matching we can handle; ? and * are just literals.)</a>
         </td>
        </tr>
        <tr>
         <td valign=top>
          <b>See Also:</b>
         </td>
         <td>
          <a href="printf.htm">printf,</a>
          <a href="sprintf.htm">sprintf</a>
         </td>
        </tr>
       </table>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
