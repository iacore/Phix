<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">PRAGMA Statements</h1>
      <div id="mainSection">
       <p>The PRAGMA statement is an SQL extension specific to SQLite and used to 
        modify the operation of the SQLite library or to query the SQLite library for 
        internal (non-table) data. The PRAGMA statement is issued using the same
        interface as other SQLite commands (e.g. 
        <a href="sqlite3_lang_select.htm">SELECT</a>, 
        <a href="sqlite3_lang_insert.htm">INSERT</a>) but is
        different in the following important respects:
       </p>
       <ul>
        <li>Specific pragma statements may be removed and others added in future
            releases of SQLite. There is no guarantee of backwards compatibility.</li>
        <li>No error messages are generated if an unknown pragma is issued.
            Unknown pragmas are simply ignored. This means if there is a typo in 
            a pragma statement the library does not inform the user of the fact.</li>
        <li>Some pragmas take effect during the SQL compilation stage, not the
            execution stage. This means if using the C-language 
            <a href="sqlite3_prepare.htm">sqlite3_prepare()</a>, 
            <a href="sqlite3_step.htm">sqlite3_step()</a>, 
            <a href="sqlite3_finalize.htm">sqlite3_finalize()</a> API (or similar in a wrapper 
            interface), the pragma may run during the 
            <a href="sqlite3_prepare.htm">sqlite3_prepare()</a> call, not during the 
            <a href="sqlite3_step.htm">sqlite3_step()</a> call as normal SQL statements do.
            Or the pragma might run during 
            <a href="sqlite3_step.htm">sqlite3_step</a>() just like normal
            SQL statements.  Whether or not the pragma runs during 
            <a href="sqlite3_prepare.htm">sqlite3_prepare</a>() or 
            <a href="sqlite3_step.htm">sqlite3_step</a>() depends on the pragma and on the specific release
            of SQLite.</li>
        <li>The pragma command is specific to SQLite and is
            not compatible with any other SQL database engine.</li>
       </ul>
       <p>The C-language API for SQLite provides the 
        [a href="c3ref/c_fcntl_begin_atomic_write.htm?#sqlitefcntlpragma"]SQLITE_FCNTL_PRAGMA[/a] [not wrapped]
        [a href="c3ref/file_control.htm?"]file control[/a] [not wrapped] which gives 
        [a href="vfs.htm?"]VFS[/a] [not wrapped] implementations the
        opportunity to add new PRAGMA statements or to override the meaning of
        built-in PRAGMA statements.
       </p>
       <hr /><a name="syntax"></a>
       <h2>PRAGMA command syntax</h2>
       <p><b><a href="sqlite3_lang_syntaxdiagrams.htm#pragma-stmt">pragma-stmt:</a></b>
        <button id='x1477' onclick='hideorshow("x1477","x1478")'>hide</button>
       </p>
       <div id='x1478' class='imgcontainer'>
        <img alt="syntax diagram pragma-stmt" src="images/syntax/pragma-stmt.gif" />
        <p><b><a href="sqlite3_lang_syntaxdiagrams.htm#pragma-value">pragma-value:</a></b>
         <button id='x1479' onclick='hideorshow("x1479","x1480")'>hide</button>
        </p>
        <div id='x1480' class='imgcontainer'>
         <img alt="syntax diagram pragma-value" src="images/syntax/pragma-value.gif" />
         <p><b><a href="sqlite3_lang_syntaxdiagrams.htm#signed-number">signed-number:</a></b>
          <button id='x1481' onclick='hideorshow("x1481","x1482")'>show</button>
         </p>
         <div id='x1482' style='display:none;' class='imgcontainer'>
          <img alt="syntax diagram signed-number" src="images/syntax/signed-number.gif" />
         </div>
        </div>
       </div>
       <p>
        A pragma can take either zero or one argument.  The argument is may be either
        in parentheses or it may be separated from the pragma name by an equal sign.
        The two syntaxes yield identical results.
        In many pragmas, the argument is a boolean.  The boolean can be one of:
       </p>
       <center>
        <b>1 yes true on
        <br>0 no false off</b>
       </center>
       <p>Keyword arguments can optionally appear in quotes.  
        (Example:
        <tt>'yes' &#91;FALSE&#93;</tt>.) Some pragmas
        takes a string literal as their argument.  When pragma takes a keyword
        argument, it will usually also take a numeric equivalent as well.
        For example, "0" and "no" mean the same thing, as does "1" and "yes".
        When querying the value of a setting, many pragmas return the number
        rather than the keyword.
       </p>
       <p>A pragma may have an optional
        <span class='yyterm'>schema-name</span>
        before the pragma name.
        The <span class='yyterm'>schema-name</span> is the name of an 
        <a href="sqlite3_lang_attach.htm">ATTACH</a>-ed database 
        or "main" or "temp" for the main and the TEMP databases.  If the optional
        schema name is omitted, "main" is assumed.  In some pragmas, the schema
        name is meaningless and is simply ignored.  In the documentation below,
        pragmas for which the schema name is meaningful are shown with a
        <i>schema.</i> prefix.
       </p>
       <hr /><a name="pragfunc"></a>
       <h2>PRAGMA functions</h2>
       <p>
        PRAGMAs that return results and that have no side-effects can be accessed from ordinary 
        <a href="sqlite3_lang_select.htm">SELECT</a> statements as table-valued functions.
        For each participating PRAGMA, the corresponding table-valued function
        has the same name as the PRAGMA with a 7-character "pragma_" prefix.
        The PRAGMA argument and schema, if any, are passed as arguments to
        the table-valued function.
       </p>
       <p>
        For example, information about the columns in an index can be read using the 
        <a href="sqlite3_lang_pragma.htm#pragma_index_info">index_info pragma</a> as follows:
       </p>
       <blockquote><pre>
        PRAGMA index_info('idx52');
        </pre>
       </blockquote>
       <p>Or, the same content can be read using:</p>
       <blockquote><pre>
        SELECT * FROM pragma_index_info('idx52');
        </pre>
       </blockquote>
       <p>The advantage of the table-valued function format is that the query
        can return just a subset of the PRAGMA columns, can include a WHERE clause,
        can use aggregate functions, and the table-valued function can be just
        one of several data sources in a join.
        For example, to get a list of all indexed columns in a schema, one
        could query:
       </p>
       <blockquote><pre>
        SELECT DISTINCT m.name || '.' || ii.name AS 'indexed-columns'
          FROM sqlite_master AS m,
               pragma_index_list(m.name) AS il,
               pragma_index_info(il.name) AS ii
         WHERE m.type='table'
         ORDER BY 1;
        </pre>
       </blockquote>
       <p>
        Additional notes:
       </p>
       <ul>
        <li>
        <p>
        Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined using the 
        SQLITE_FCNTL_PRAGMA file control.
        </p></li>
        <li>
        <p>
        Table-valued functions exist only for PRAGMAs that return results and
        that have no side-effects.
        </p></li>
        <li>
        <p>
        This feature could be used to implement
        <a href="javascript:ExternalLink('ext287','https://en.wikipedia.org/wiki/Information_schema');"
           id="ext287" style="color:#9B5565" >information schema</a>
        by first creating a separate schema using
         <blockquote><pre>
        <a href="sqlite3_lang_attach.htm">ATTACH</a> ':memory:' AS 'information_schema';
        </pre>
         </blockquote>
        Then creating
        <a href="sqlite3_lang_createview.htm">VIEWs</a> in that schema that implement the official information schema
        tables using table-valued PRAGMA functions.
        </p></li>
        <li>
        <p>
        This feature is experimental and is subject to change.  Further documentation
        will become available if and when the table-valued functions for PRAGMAs
        feature becomes officially supported.
        </p></li>
        <li>
        <p>
        The table-valued functions for PRAGMA feature was added
        in SQLite version 3.16.0 (2017-01-02).  Prior versions of SQLite
        cannot use this feature.
        </p></li>
       </ul>


    <a name="pragma_application_id"></a>
       <h _id=pragma_application_id style="display:none"> PRAGMA application_id</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>application_id;
        <br>PRAGMA </b><i>schema.</i><b>application_id = </b><i>integer </i><b>;</b>
       </p>
       <p>
        The application_id PRAGMA is used to query or set the 32-bit
        unsigned big-endian "Application ID" integer located at offset 68 into the 
        database header. Applications that use SQLite as their
        application file-format should set the Application ID integer to
        a unique integer so that utilities such as 
        file(1) can determine the specific
        file type rather than just reporting "SQLite3 Database".  A list of
        assigned application IDs can be seen by consulting the
        magic.txt file in the SQLite source repository.
       </p>
       <p>See also the <a href="sqlite3_lang_pragma.htm#pragma_user_version">user_version pragma</a>.</p>

    <a name="pragma_auto_vacuum"></a>
       <h _id=pragma_auto_vacuum style="display:none"> PRAGMA auto_vacuum</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>auto_vacuum;
        <br>
              PRAGMA </b><i>schema.</i><b>auto_vacuum = </b>
               <i>0 | NONE | 1 | FULL | 2 | INCREMENTAL</i><b>;</b>
       </p>
       <p>Query or set the auto-vacuum status in the database.</p>
       <p>The default setting for auto-vacuum is 0 or "none",
        unless the SQLITE_DEFAULT_AUTOVACUUM compile-time option is used.
        The "none" setting means that auto-vacuum is disabled.
        When auto-vacuum is disabled and data is deleted data from a database,
        the database file remains the same size.  Unused database file 
        pages are added to a freelist and reused for subsequent inserts.    So
        no database file space is lost.  However, the database file does not
        shrink.  In this mode the <a href="sqlite3_lang_vacuum.htm">VACUUM</a>
        command can be used to rebuild the entire database file and
        thus reclaim unused disk space.
       </p>
       <p>When the auto-vacuum mode is 1  or "full", the freelist pages are
        moved to the end of the database file and the database file is truncated
        to remove the freelist pages at every transaction commit.
        Note, however, that auto-vacuum only truncates the freelist pages
        from the file.  Auto-vacuum does not defragment the database nor
        repack individual database pages the way that the
        <a href="sqlite3_lang_vacuum.htm">VACUUM</a> command does.  In fact, because
        it moves pages around within the file, auto-vacuum can actually
        make fragmentation worse.
       </p>
       <p>Auto-vacuuming is only possible if the database stores some
        additional information that allows each database page to be
        traced backwards to its referrer.  Therefore, auto-vacuuming must
        be turned on before any tables are created.  It is not possible
        to enable or disable auto-vacuum after a table has been created.
       </p>
       <p>When the value of auto-vacuum is 2 or "incremental" then the additional
        information needed to do auto-vacuuming is stored in the database file
        but auto-vacuuming does not occur automatically at each commit as it
        does with auto_vacuum=full.  In incremental mode, the separate
        <a href="sqlite3_lang_pragma.htm#pragma_incremental_vacuum">incremental_vacuum</a> pragma must
        be invoked to cause the auto-vacuum to occur.
       </p>
       <p>The database connection can be changed between full and incremental
        autovacuum mode at any time.  However, changing from
        "none" to "full" or "incremental" can only occur when the database 
        is new (no tables
        have yet been created) or by running the <a href="sqlite3_lang_vacuum.htm">VACUUM</a> command.  To
        change auto-vacuum modes, first use the auto_vacuum pragma to set
        the new desired mode, then invoke the <a href="sqlite3_lang_vacuum.htm">VACUUM</a> command to 
        reorganize the entire database file.  To change from "full" or
        "incremental" back to "none" always requires running <a href="sqlite3_lang_vacuum.htm">VACUUM</a> even
        on an empty database.
       </p>
       <p>When the auto_vacuum pragma is invoked with no arguments, it
        returns the current auto_vacuum mode.
       </p>

    <a name="pragma_automatic_index"></a>
       <h _id=pragma_automatic_index style="display:none"> PRAGMA automatic_index</h>
       <hr>
       <p><b>PRAGMA automatic_index;
        <br>PRAGMA automatic_index = </b><i>boolean</i><b>;</b>
       </p>
       <p>Query, set, or clear the automatic indexing capability.</p>
       <p>Automatic indexing is enabled by default as of 
        version 3.7.17 (2013-05-20), but this might change in future releases of SQLite.

    <a name="pragma_busy_timeout"></a>
        <h _id=pragma_busy_timeout style="display:none"> PRAGMA busy_timeout</h>
        <hr>
       </p>
       <p><b>PRAGMA busy_timeout;
        <br>PRAGMA busy_timeout = </b><i>milliseconds</i><b>;</b>
       </p>
       <p>Query or change the setting of the
        [a href="c3ref/busy_timeout.htm?"]busy timeout[/a] [not implemented].
        This pragma is an alternative to the [a href="c3ref/busy_timeout.htm?"]sqlite3_busy_timeout()[/a] [not implemented] C-language
        interface which is made available as a pragma for use with language
        bindings that do not provide direct access to [a href="c3ref/busy_timeout.htm?"]sqlite3_busy_timeout()[/a] [not implemented].
       </p>
       <p>Each database connection can only have a single
        [a href="c3ref/busy_handler.htm?"]busy handler[/a] [not implemented].  This PRAGMA sets the busy handler
        for the process, possibly overwriting any previously set busy handler.

    <a name="pragma_cache_size"></a>
        <h _id=pragma_cache_size style="display:none"> PRAGMA cache_size</h>
        <hr>
       </p>
       <p><b>PRAGMA </b><i>schema.</i><b>cache_size;
        <br>PRAGMA </b><i>schema.</i><b>cache_size = </b><i>pages</i><b>;
        <br>PRAGMA </b><i>schema.</i><b>cache_size = -</b><i>kibibytes</i><b>;</b>
       </p>
       <p>Query or change the suggested maximum number of database disk pages
        that SQLite will hold in memory at once per open database file.  Whether
        or not this suggestion is honored is at the discretion of the
        Application Defined Page Cache.
        The default page cache that is built into SQLite honors the request,
        however alternative application-defined page cache implementations
        may choose to interpret the suggested cache size in different ways
        or to ignore it all together.
        The default suggested cache size is -2000, which means the cache size
        is limited to 2048000 bytes of memory.
        The default suggested cache size can be altered using the
        SQLITE_DEFAULT_CACHE_SIZE compile-time options.
        The TEMP database has a default suggested cache size of 0 pages.
       </p>
       <p>If the argument N is positive then the suggested cache size is set 
        to N. If the argument N is negative, then the
        number of cache pages is adjusted to use approximately abs(N*1024) bytes
        of memory.
        <i>Backwards compatibility note:</i>
        The behavior of cache_size with a negative N
        was different in prior to version 3.7.10 (2012-01-16).  In
        version 3.7.9 and earlier, the number of pages in the cache was set
        to the absolute value of N.
       </p>
       <p>When you change the cache size using the cache_size pragma, the
        change only endures for the current session.  The cache size reverts
        to the default value when the database is closed and reopened.
       </p>


    <a name="pragma_cache_spill"></a>
       <h _id=pragma_cache_spill style="display:none"> PRAGMA cache_spill</h>
       <hr>
       <p><b>PRAGMA cache_spill;
        <br>PRAGMA cache_spill=</b><i>boolean</i><b>;
        <br>PRAGMA </b><i>schema.</i><b>cache_spill=<i>N</i>;</b>
       </p>
       <p>The cache_spill pragma enables or disables the ability of the pager
        to spill dirty cache pages to the database file in the middle of a 
        transaction.  Cache_spill is enabled by default and most applications
        should leave it that way as cache spilling is usually advantageous.
        However, a cache spill has the side-effect of acquiring an
        EXCLUSIVE lock on the database file.  Hence, some applications that
        have large long-running transactions may want to disable cache spilling
        in order to prevent the application from acquiring an exclusive lock
        on the database until the moment that the transaction <a href="sqlite3_lang_transaction.htm">COMMIT</a>s.
       </p>
       <p>The PRAGMA cache_spill=<i>N</i> form of this pragma sets a minimum
        cache size threshold required for spilling to occur. The number of pages
        in cache must exceed both the cache_spill threshold and the maximum cache
        size set by the <a href="sqlite3_lang_pragma.htm#pragma_cache_size">PRAGMA cache_size</a> statement in order for spilling to
        occur.
       </p>
       <p>The "PRAGMA cache_spill=<i>boolean</i>" form of this pragma applies
        across all databases attached to the database connection.  But the
        "PRAGMA cache_spill=<i>N</i>" form of this statement only applies to
        the "main" schema or whatever other schema is specified as part of the
        statement.
       </p>
    <a name="pragma_case_sensitive_like"></a>
       <h _id=pragma_case_sensitive_like style="display:none"> PRAGMA case_sensitive_like</h>
       <hr>
       <p><b>PRAGMA case_sensitive_like = </b><i>boolean</i><b>;</b></p>
       <p>The default behavior of the <a href="sqlite3_lang_expr.htm#like">LIKE</a> operator is to ignore case
        for ASCII characters. Hence, by default <b>'a' LIKE 'A'</b> is
        true.  The case_sensitive_like pragma installs a new application-defined
        LIKE function that is either case sensitive or insensitive depending
        on the value of the case_sensitive_like pragma.
        When case_sensitive_like is disabled, the default LIKE behavior is
        expressed.  When case_sensitive_like is enabled, case becomes
        significant.  So, for example,
        <b>'a' LIKE 'A'</b> is false but <b>'a' LIKE 'a'</b> is still true.
       </p>
       <p>This pragma uses sqlite3_create_function() [not wrapped] to overload the
        LIKE and GLOB functions, which may override previous implementations
        of LIKE and GLOB registered by the application.  This pragma
        only changes the behavior of the SQL <a href="sqlite3_lang_expr.htm#like">LIKE</a> operator.  It does not
        change the behavior of the [a href="c3ref/strlike.htm?"]sqlite3_strlike()[/a] [not implemented] C-language interface,
        which is always case insensitive.
       </p>
    <a name="pragma_cell_size_check"></a>
       <h _id=pragma_cell_size_check style="display:none"> PRAGMA cell_size_check</h>
       <hr>
       <p><b>PRAGMA cell_size_check
        <br>PRAGMA cell_size_check = </b><i>boolean</i><b>;</b>
       </p>
       <p>The cell_size_check pragma enables or disables additional sanity
        checking on database b-tree pages as they are initially read from disk.
        With cell size checking enabled, database corruption is detected earlier
        and is less likely to "spread".  However, there is a small performance
        hit for doing the extra checks and so cell size checking is turned off
        by default.
    <a name="pragma_checkpoint_fullfsync"></a>
        <h _id=pragma_checkpoint_fullfsync style="display:none"> PRAGMA checkpoint_fullfsync</h>
        <hr>
       </p>
       <p><b>PRAGMA checkpoint_fullfsync
        <br>PRAGMA checkpoint_fullfsync = </b><i>boolean</i><b>;</b>
       </p>
       <p>Query or change the fullfsync flag for checkpoint operations.
        If this flag is set, then the F_FULLFSYNC syncing method is used
        during checkpoint operations on systems that support F_FULLFSYNC. 
        The default value of the checkpoint_fullfsync flag
        is off.  Only Mac OS-X supports F_FULLFSYNC.
       </p>
       <p>If the <a href="sqlite3_lang_pragma.htm#pragma_fullfsync">fullfsync</a> flag is set, then the F_FULLFSYNC syncing
        method is used for all sync operations and the checkpoint_fullfsync
        setting is irrelevant.
       </p>
    <a name="pragma_collation_list"></a>
       <h _id=pragma_collation_list style="display:none"> PRAGMA collation_list</h>
       <hr>
       <p><b>PRAGMA collation_list;</b></p>
       <p>Return a list of the collating sequences defined for the current
        database connection.
       </p>
    <a name="pragma_compile_options"></a>
       <h _id=pragma_compile_options style="display:none"> PRAGMA compile_options</h>
       <hr>
       <p><b>PRAGMA compile_options;</b></p>
       <p>This pragma returns the names of compile-time options used when
        building SQLite, one option per row.  The "SQLITE_" prefix is omitted
        from the returned option names.  See also the
        [a href="c3ref/compileoption_get.htm?"]sqlite3_compileoption_get()[/a] [not implemented] C/C++ interface and the
        <a href="sqlite3_lang_corefunc.htm#sqlite_compileoption_get">sqlite_compileoption_get()</a> SQL functions.
       </p>

    <a name="pragma_count_changes"></a>
       <h _id=pragma_count_changes style="display:none"> PRAGMA count_changes</h>
       <hr>
       <p><b>PRAGMA count_changes;
        <br>PRAGMA count_changes = </b><i>boolean</i><b>;</b>
       </p>
       <p>Query or change the count-changes flag. Normally, when the
        count-changes flag is not set, <a href="sqlite3_lang_insert.htm">INSERT</a>, 
        <a href="sqlite3_lang_update.htm">UPDATE</a> and 
        <a href="sqlite3_lang_delete.htm">DELETE</a> statements
        return no data. When count-changes is set, each of these commands 
        returns a single row of data consisting of one integer value - the
        number of rows inserted, modified or deleted by the command. The 
        returned change count does not include any insertions, modifications
        or deletions performed by triggers, or any changes made automatically
        by <a href="sqlite3_lang_foreignkeys.htm#fk_actions">foreign key actions</a>.
       </p>
       <p>Another way to get the row change counts is to use the
        <a href="sqlite3_changes.htm">sqlite3_changes</a>() or 
        <a href="sqlite3_changes.htm">sqlite3_total_changes</a>() interfaces.
        There is a subtle different, though.  When an INSERT, UPDATE, or
        DELETE is run against a view using an 
        <a href="sqlite3_lang_createtrigger.htm#instead_of_trigger">INSTEAD OF trigger</a>,
        the count_changes pragma reports the number of rows in the view
        that fired the trigger, whereas 
        <a href="sqlite3_changes.htm">sqlite3_changes</a>() and
        <a href="sqlite3_changes.htm">sqlite3_total_changes</a>() do not.
       </p>
       <p style='background-color: #ffd0d0;'>
        <b>This pragma is deprecated</b> and exists
        for backwards compatibility only.  New applications
        should avoid using this pragma.  Older applications should discontinue
        use of this pragma at the earliest opportunity.  This pragma may be omitted
        from the build when SQLite is compiled using SQLITE_OMIT_DEPRECATED.
       </p>
      
    <a name="pragma_data_store_directory"></a>
       <h _id=pragma_data_store_directory style="display:none"> PRAGMA data_store_directory</h>
       <hr>
       <p><b>PRAGMA data_store_directory;
        <br>PRAGMA data_store_directory = '</b><i>directory-name</i><b>';</b>
       </p>
       <p>Query or change the value of the sqlite3_data_directory global
        variable, which windows operating-system interface backends use to
        determine where to store database files specified using a relative
        pathname.
       </p>
       <p>Changing the data_store_directory setting is
        <u>not</u> threadsafe.
        Never change the data_store_directory setting if another thread
        within the application is running any SQLite interface at the same time.
        Doing so results in undefined behavior.  Changing the data_store_directory
        setting writes to the sqlite3_data_directory global
        variable and that global variable is not protected by a mutex.
       </p>
       <p>This facility is provided for WinRT which does not have an OS
        mechanism for reading or changing the current working directory.
        The use of this pragma in any other context is discouraged and may
        be disallowed in future releases.
       </p>
       <p style='background-color: #ffd0d0;'>
        <b>This pragma is deprecated</b> and exists
        for backwards compatibility only.  New applications
        should avoid using this pragma.  Older applications should discontinue
        use of this pragma at the earliest opportunity.  This pragma may be omitted
        from the build when SQLite is compiled using SQLITE_OMIT_DEPRECATED.
       </p>
      
    <a name="pragma_data_version"></a>
       <h _id=pragma_data_version style="display:none"> PRAGMA data_version</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>data_version;</b></p>
       <p>The "PRAGMA data_version" command provides an indication that the
        database file has been modified.
        Interactive programs that hold database content in memory or that
        display database content on-screen can use the PRAGMA data_version
        command to determine if they need to flush and reload their memory
        or update the screen display.
       </p>
       <p>The integer values returned by two
        invocations of "PRAGMA data_version" from the same connection
        will be different if changes were committed to the database 
        by any other connection in the interim.
        The "PRAGMA data_version" value is unchanged for commits made
        on the same database connection.
        The behavior of "PRAGMA data_version" is the same for all database
        connections, including database connections in separate processes
        and shared cache database connections.
       </p>
       <p>The "PRAGMA data_version" value is a local property of each
        database connection and so values returned by two concurrent invocations
        of "PRAGMA data_version" on separate database connections are 
        often different even though the underlying database is identical.
        It is only meaningful to compare the "PRAGMA data_version" values
        returned by the same database connection at two different points in
        time.
       </p>
    <a name="pragma_database_list"></a>
       <h _id=pragma_database_list style="display:none"> PRAGMA database_list</h>
       <hr>
       <p><b>PRAGMA database_list;</b></p>
       <p>This pragma works like a query to return one row for each database
        attached to the current database connection.
        The second column is the "main" for the main database file, "temp"
        for the database file used to store TEMP objects, or the name of the
        ATTACHed database for other database files.
        The third column is the name of the database file itself, or an empty
        string if the database is not associated with a file.
       </p>
    <a name="pragma_default_cache_size"></a>
       <h _id=pragma_default_cache_size style="display:none"> PRAGMA default_cache_size</h>
       <hr>
        <b>PRAGMA </b><i>schema.</i><b>default_cache_size;
       <br>PRAGMA </b><i>schema.</i><b>default_cache_size
                = </b><i>Number-of-pages</i><b>;</b>
       <p>This pragma queries or sets the suggested maximum number of pages
        of disk cache that will be allocated per open database file.
        The difference between this pragma and <a href="sqlite3_lang_pragma.htm#pragma_cache_size">cache_size</a> is that the
        value set here persists across database connections.
        The value of the default cache size is stored in the 4-byte
        big-endian integer located at offset 48 in the header of the
        database file.
       </p>
       <p style='background-color: #ffd0d0;'>
        <b>This pragma is deprecated</b> and exists
        for backwards compatibility only.  New applications
        should avoid using this pragma.  Older applications should discontinue
        use of this pragma at the earliest opportunity.  This pragma may be omitted
        from the build when SQLite is compiled using SQLITE_OMIT_DEPRECATED.
       </p>
      
    <a name="pragma_defer_foreign_keys"></a>
       <h _id=pragma_defer_foreign_keys style="display:none"> PRAGMA defer_foreign_keys</h>
       <hr>
       <p><b>PRAGMA defer_foreign_keys
        <br>PRAGMA defer_foreign_keys = </b><i>boolean</i><b>;</b>
       </p>
       <p>When the defer_foreign_keys <a href="sqlite3_lang_pragma.htm#syntax">PRAGMA</a> is on,
        enforcement of all <a href="sqlite3_lang_foreignkeys.htm">foreign key constraints</a> is delayed until the
        outermost transaction is committed.  The defer_foreign_keys pragma
        defaults to OFF so that foreign key constraints are only deferred if
        they are created as "DEFERRABLE INITIALLY DEFERRED".  The 
        defer_foreign_keys pragma is automatically switched off at each
        COMMIT or ROLLBACK.  Hence, the defer_foreign_keys pragma must be
        separately enabled for each transaction.  This pragma is
        only meaningful if foreign key constraints are enabled, of course.
       </p>
       <p>The [a href="c3ref/db_status.htm?"]sqlite3_db_status[/a](db,SQLITE_DBSTATUS_DEFERRED_FKS,...) [not wrapped]
        C-language interface can be used during a transaction to determine 
        if there are deferred and unresolved foreign key constraints.
       </p>
    <a name="pragma_empty_result_callbacks"></a>
       <h _id=pragma_empty_result_callbacks style="display:none"> PRAGMA empty_result_callbacks</h>
       <hr>
       <p><b>PRAGMA empty_result_callbacks;
        <br>PRAGMA empty_result_callbacks = </b><i>boolean</i><b>;</b>
       </p>
       <p>Query or change the empty-result-callbacks flag.</p>
       <p>The empty-result-callbacks flag affects the <a href="sqlite3_exec.htm">sqlite3_exec()</a> API only.
        Normally, when the empty-result-callbacks flag is cleared, the
        callback function supplied to the <a href="sqlite3_exec.htm">sqlite3_exec()</a> is not invoked
        for commands that return zero rows of data.  When empty-result-callbacks
        is set in this situation, the callback function is invoked exactly once,
        with the third parameter set to 0 (NULL). This is to enable programs  
        that use the <a href="sqlite3_exec.htm">sqlite3_exec()</a> API to retrieve column-names even when
        a query returns no data.
       </p>
       <p style='background-color: #ffd0d0;'>
        <b>This pragma is deprecated</b> and exists
        for backwards compatibility only.  New applications
        should avoid using this pragma.  Older applications should discontinue
        use of this pragma at the earliest opportunity.  This pragma may be omitted
        from the build when SQLite is compiled using SQLITE_OMIT_DEPRECATED.
       </p>
      
    <a name="pragma_encoding"></a>
       <h _id=pragma_encoding style="display:none"> PRAGMA encoding</h>
       <hr>
       <p><b>PRAGMA encoding;
        <br>PRAGMA encoding = "UTF-8";
        <br>PRAGMA encoding = "UTF-16";
        <br>PRAGMA encoding = "UTF-16le";
        <br>PRAGMA encoding = "UTF-16be";</b>
       </p>
       <p>In first form, if the main database has already been
        created, then this pragma returns the text encoding used by the
        main database, one of "UTF-8", "UTF-16le" (little-endian UTF-16
        encoding) or "UTF-16be" (big-endian UTF-16 encoding).  If the main
        database has not already been created, then the value returned is the
        text encoding that will be used to create the main database, if 
        it is created by this session.
       </p>
       <p>The second through fifth forms of this pragma
        set the encoding that the main database will be created with if
        it is created by this session. The string "UTF-16" is interpreted
        as "UTF-16 encoding using native machine byte-ordering".  It is not
        possible to change the text encoding of a database after it has been
        created and any attempt to do so will be silently ignored.
       </p>
       <p>Once an encoding has been set for a database, it cannot be changed.</p>
       <p>Databases created by the <a href="sqlite3_lang_attach.htm">ATTACH</a> command always use the same encoding
        as the main database.  An attempt to <a href="sqlite3_lang_attach.htm">ATTACH</a> a database with a different
        text encoding from the "main" database will fail.
       </p>
    <a name="pragma_foreign_key_check"></a>
       <h _id=pragma_foreign_key_check style="display:none"> PRAGMA foreign_key_check</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>foreign_key_check;
        <br>PRAGMA </b><i>schema.</i><b>foreign_key_check(</b><i>table-name</i><b>);</b>
       </p>
       <p>The foreign_key_check pragma checks the database, or the table
        called <i>table-name</i>, for 
        <a href="sqlite3_lang_foreignkeys.htm">foreign key constraints</a> that are violated and returns one row of
        output for each violation.  There are four columns in each result row.
        The first column is the name of the table that contains the REFERENCES
        clause.  The second column is the <a href="sqlite3_lang_createtable.htm#rowid">rowid</a> of the row that
        contains the invalid REFERENCES clause, or NULL if the child table is a
        <a href="sqlite3_lang_withoutrowid.htm">WITHOUT ROWID</a> table.  The third column is the name
        of the table that is referred to. The fourth column is the index of
        the specific foreign key constraint that failed.  The fourth column
        in the output of the foreign_key_check pragma is the same integer as
        the first column in the output of the <a href="sqlite3_lang_pragma.htm#pragma_foreign_key_list">foreign_key_list pragma</a>.
        When a <i>table-name</i> is specified, the only foreign key constraints
        checked are those created by REFERENCES clauses in the
        CREATE TABLE statement for <i>table-name</i>.
       </p>
    <a name="pragma_foreign_key_list"></a>
       <h _id=pragma_foreign_key_list style="display:none"> PRAGMA foreign_key_list</h>
       <hr>
       <p><b>PRAGMA foreign_key_list(</b><i>table-name</i><b>);</b></p>
       <p>This pragma returns one row for each <a href="sqlite3_lang_foreignkeys.htm">foreign key constraint</a>
        created by a REFERENCES clause in the CREATE TABLE statement of
        table <i>table-name</i>.
       </p>
    <a name="pragma_foreign_keys"></a>
       <h _id=pragma_foreign_keys style="display:none"> PRAGMA foreign_keys</h>
       <hr>
       <p><b>PRAGMA foreign_keys;
        <br>PRAGMA foreign_keys = </b><i>boolean</i><b>;</b>
       </p>
       <p>Query, set, or clear the enforcement of <a href="sqlite3_lang_foreignkeys.htm">foreign key constraints</a>.</p>
       <p>This pragma is a no-op within a transaction; foreign key constraint
           enforcement may only be enabled or disabled when there is no pending
           <a href="sqlite3_lang_transaction.htm">BEGIN</a> or <a href="sqlite3_lang_savepoint.htm">SAVEPOINT</a>.
       </p>
       <p>Changing the foreign_keys setting affects the execution of
           all statements prepared
           using the database connection, including those prepared before the
           setting was changed. Any existing statements prepared using the legacy 
           <a href="sqlite3_prepare.htm">sqlite3_prepare()</a> interface may fail with an 
           <a href="sqlconst.htm#SQLITE_SCHEMA">SQLITE_SCHEMA</a> error
           after the foreign_keys setting is changed.
       </p>
       <p>As of SQLite version 3.6.19, the default setting for foreign
           key enforcement is OFF.  However, that might change in a future
           release of SQLite.  The default setting for foreign key enforcement
           can be specified at compile-time using the SQLITE_DEFAULT_FOREIGN_KEYS
           preprocessor macro.  To minimize future problems, applications should
           set the foreign key enforcement flag as required by the application
           and not depend on the default setting.
       </p>
    <a name="pragma_freelist_count"></a>
       <h _id=pragma_freelist_count style="display:none"> PRAGMA freelist_count</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>freelist_count;</b></p>
       <p>Return the number of unused pages in the database file.</p>
    <a name="pragma_full_column_names"></a>
       <h _id=pragma_full_column_names style="display:none"> PRAGMA full_column_names</h>
       <hr>
       <p><b>PRAGMA full_column_names;
        <br>PRAGMA full_column_names = </b><i>boolean</i><b>;</b>
       </p>
       <p>Query or change the full_column_names flag. This flag together 
        with the <a href="sqlite3_lang_pragma.htm#pragma_short_column_names">short_column_names</a> flag determine
        the way SQLite assigns names to result columns of <a href="sqlite3_lang_select.htm">SELECT</a> statements.
        Result columns are named by applying the following rules in order:
       </p>
       <ol>
        <li>
        <p>If there is an AS clause on the result, then the name of
            the column is the right-hand side of the AS clause.
        </p></li>
        <li>
        <p>If the result is a general expression, not a just the name of
            a source table column,
            then the name of the result is a copy of the expression text.
        </p></li>
        <li>
        <p>If the <a href="sqlite3_lang_pragma.htm#pragma_short_column_names">short_column_names</a> pragma is ON, then the name of the
            result is the name of the source table column without the 
            source table name prefix:  COLUMN.
        </p></li>
        <li>
        <p>If both pragmas <a href="sqlite3_lang_pragma.htm#pragma_short_column_names">short_column_names</a> and 
            <a href="sqlite3_lang_pragma.htm#pragma_full_column_names">full_column_names</a>
            are OFF then case (2) applies.
        </p></li>
        <li>
        <p>The name of the result column is a combination of the source table
            and source column name:  TABLE.COLUMN
        </p></li>
       </ol>
       <p style='background-color: #ffd0d0;'>
        <b>This pragma is deprecated</b> and exists
        for backwards compatibility only.  New applications
        should avoid using this pragma.  Older applications should discontinue
        use of this pragma at the earliest opportunity.  This pragma may be omitted
        from the build when SQLite is compiled using SQLITE_OMIT_DEPRECATED.
       </p>
      
    <a name="pragma_fullfsync"></a>
       <h _id=pragma_fullfsync style="display:none"> PRAGMA fullfsync</h>
       <hr>
       <p><b>PRAGMA fullfsync
        <br>PRAGMA fullfsync = </b><i>boolean</i><b>;</b>
       </p>
       <p>Query or change the fullfsync flag. This flag
        determines whether or not the F_FULLFSYNC syncing method is used
        on systems that support it.  The default value of the fullfsync flag
        is off.  Only Mac OS X supports F_FULLFSYNC.
       </p>
       <p>See also <a href="sqlite3_lang_pragma.htm#pragma_checkpoint_fullfsync">checkpoint_fullfsync</a>.</p>

    <a name="pragma_function_list"></a>
       <h _id=pragma_function_list style="display:none"> PRAGMA function_list</h>
       <hr>
       <p><b>PRAGMA function_list;</b></p>
       <p>This pragma returns a list of SQL functions
        known to the database connection.
       </p>
       <p style='background-color: #f0e0ff;'>
        This pragma is only available if SQLite is built using the
        -DSQLITE_INTROSPECTION_PRAGMAS compile-time option.
       </p>
      
    <a name="pragma_ignore_check_constraints"></a>
       <h _id=pragma_ignore_check_constraints style="display:none"> PRAGMA ignore_check_constraints</h>
       <hr>
       <p><b>PRAGMA ignore_check_constraints  = </b><i>boolean</i><b>;</b></p>
       <p>This pragma enables or disables the enforcement of CHECK constraints.
        The default setting is off, meaning that CHECK constraints are
        enforced by default.
       </p>

    <a name="pragma_incremental_vacuum"></a>
       <h _id=pragma_incremental_vacuum style="display:none"> PRAGMA incremental_vacuum</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>incremental_vacuum</b><i>(N)</i><b>;
        <br>
          PRAGMA </b><i>schema.</i><b>incremental_vacuum;</b>
       </p>
       <p>The incremental_vacuum pragma causes up to <i>N</i> pages to
        be removed from the freelist.  The database file is truncated by
        the same amount.  The incremental_vacuum pragma has no effect if
        the database is not in
        <a href="#pragma_auto_vacuum">auto_vacuum=incremental</a> mode
        or if there are no pages on the freelist.  If there are fewer than
        <i>N</i> pages on the freelist, or if <i>N</i> is less than 1, or
        if the "(<i>N</i>)" argument is omitted, then the entire
        freelist is cleared.
       </p>

    <a name="pragma_index_info"></a>
       <h _id=pragma_index_info style="display:none"> PRAGMA index_info</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>index_info(</b><i>index-name</i><b>);</b></p>
       <p>This pragma returns one row for each key column in the named index.
        A key column is a column that is actually named in the <a href="sqlite3_lang_createindex.htm">CREATE INDEX</a>
        index statement or <a href="sqlite3_lang_createtable.htm#uniqueconst">UNIQUE constraint</a> or 
        <a href="sqlite3_lang_createtable.htm#primkeyconst">PRIMARY KEY constraint</a> that
        created the index.  Index entries also usually contain auxiliary
        columns that point back to the table row being indexed.  The auxiliary
        index-columns are not shown by the index_info pragma, but they are
        listed by the <a href="sqlite3_lang_pragma.htm#pragma_index_xinfo">index_xinfo pragma</a>.
       </p>
       <p>Output columns from the index_info pragma are as follows:</p>
       <ol>
        <li>The rank of the column within the index.  (0 means left-most.)</li>
        <li>The rank of the column within the table being indexed.</li>
        <li>The name of the column being indexed.</li>
       </ol>

    <a name="pragma_index_list"></a>
       <h _id=pragma_index_list style="display:none"> PRAGMA index_list</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>index_list(</b><i>table-name</i><b>);</b></p>
       <p>This pragma returns one row for each index associated with the
        given table.
       </p>
       <p>Output columns from the index_list pragma are as follows:
        <ol>
        <li>A sequence number assigned to each index for internal tracking purposes.</li>
        <li>The name of the index.</li>
        <li>"1" if the index is UNIQUE and "0" if not.</li>
        <li>"c" if the index was created by a <a href="sqlite3_lang_createindex.htm">CREATE INDEX</a> statement,
              "u" if the index was created by a <a href="sqlite3_lang_createtable.htm#uniqueconst">UNIQUE constraint</a>, or
              "pk" if the index was created by a <a href="sqlite3_lang_createtable.htm#primkeyconst">PRIMARY KEY constraint</a>.</li>
        <li>"1" if the index is a <a href="sqlite3_lang_partialindex.htm">partial index</a> and "0" if not.</li>
        </ol>
       </p>

    <a name="pragma_index_xinfo"></a>
       <h _id=pragma_index_xinfo style="display:none"> PRAGMA index_xinfo</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>index_xinfo(</b><i>index-name</i><b>);</b></p>
       <p>This pragma returns information about every column in an index.
        Unlike this <a href="sqlite3_lang_pragma.htm#pragma_index_info">index_info pragma</a>, this pragma returns information about
        every column in the index, not just the key columns.
        (A key column is a column that is actually named in the <a href="sqlite3_lang_createindex.htm">CREATE INDEX</a>
        index statement or <a href="sqlite3_lang_createtable.htm#uniqueconst">UNIQUE constraint</a> or 
        <a href="sqlite3_lang_createtable.htm#primkeyconst">PRIMARY KEY constraint</a> that
        created the index.  Auxiliary columns are additional columns needed to
        locate the table entry that corresponds to each index entry.)
       </p>
       <p>Output columns from the index_xinfo pragma are as follows:
        <ol>
        <li>The rank of the column within the index. (0 means left-most.
             Key columns come before auxiliary columns.)</li>
        <li>The rank of the column within the table being indexed, or -1 if
             the index-column is the <a href="sqlite3_lang_createtable.htm#rowid">rowid</a> of the table being indexed.</li>
        <li>The name of the column being indexed, or NULL if the index-column
             is the <a href="sqlite3_lang_createtable.htm#rowid">rowid</a> of the table being indexed.</li>
        <li>1 if the index-column is sorted in reverse (DESC) order by the
             index and 0 otherwise.</li>
        <li>The name for the <a href="sqlite3_lang_datatype3.htm#collation">collating sequence</a>
             used to compare values in the index-column.</li>
        <li>1 if the index-column is a key column and 0 if the index-column
             is an auxiliary column.</li>
        </ol>
       </p>

    <a name="pragma_integrity_check"></a>
       <h _id=pragma_integrity_check style="display:none"> PRAGMA integrity_check</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>integrity_check;
        <br>PRAGMA </b><i>schema.</i><b>integrity_check(</b><i>N</i><b>)</b>
       </p>
       <p>This pragma does an integrity check of the entire database.  The
        integrity_check pragma
        looks for out-of-order records, missing pages, malformed records, missing
        index entries, and UNIQUE, CHECK, and NOT NULL constraint errors.
        If the integrity_check pragma finds problems, strings are returned
        (as multiple rows with a single column per row) which describe
        the problems.  Pragma integrity_check will return at most <i>N</i>
        errors before the analysis quits, with N defaulting
        to 100.  If pragma integrity_check finds no errors, a
        single row with the value 'ok' is returned.
       </p>
       <p>PRAGMA integrity_check does not find
        <a href="sqlite3_lang_foreignkeys.htm">FOREIGN KEY</a> errors.  
        Use the <a href="sqlite3_lang_pragma.htm#pragma_foreign_key_check">PRAGMA foreign_key_check</a> command for to find errors in
        FOREIGN KEY constraints.
       </p>
       <p>See also the <a href="sqlite3_lang_pragma.htm#pragma_quick_check">PRAGMA quick_check</a> command which does most of the
        checking of PRAGMA integrity_check but runs much faster.
       </p>

    <a name="pragma_journal_mode"></a>
       <h _id=pragma_journal_mode style="display:none"> PRAGMA journal_mode</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>journal_mode;
        <br>PRAGMA </b><i>schema.</i><b>journal_mode
                  = <i>DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF</i></b>
       </p>
       <p>This pragma queries or sets the journal mode for databases
        associated with the current database connection.
       </p>
       <p>The first form of this pragma queries the current journaling
        mode for <i>database</i>.  When <i>database</i> is omitted, the
        "main" database is queried.
       </p>
       <p>The second form changes the journaling mode for <i>database</i>
        or for all attached databases if <i>database</i> is omitted.
        The new journal mode is returned.  If the journal mode
        could not be changed, the original journal mode is returned.</p>

        <p>The DELETE journaling mode is the normal behavior.  In the DELETE
        mode, the rollback journal is deleted at the conclusion of each
        transaction.  Indeed, the delete operation is the action that causes
        the transaction to commit.
        (Search online for the document titled "Atomic Commit In SQLite" for additional detail.)
       </p>
       <p>The TRUNCATE journaling mode commits transactions by truncating
        the rollback journal to zero-length instead of deleting it.  On many
        systems, truncating a file is much faster than deleting the file since
        the containing directory does not need to be changed.
       </p>
       <p>The PERSIST journaling mode prevents the rollback journal from
        being deleted at the end of each transaction.  Instead, the header
        of the journal is overwritten with zeros.  This will prevent other
        database connections from rolling the journal back.  The PERSIST
        journaling mode is useful as an optimization on platforms where
        deleting or truncating a file is much more expensive than overwriting
        the first block of a file with zeros.  See also:
        <a href="sqlite3_lang_pragma.htm#pragma_journal_size_limit">PRAGMA journal_size_limit</a> and 
        SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT compile time option.
       </p>
       <p>The MEMORY journaling mode stores the rollback journal in 
        volatile RAM.  This saves disk I/O but at the expense of database
        safety and integrity.  If the application using SQLite crashes in
        the middle of a transaction when the MEMORY journaling mode is set,
        then the database file will very likely go corrupt.
       </p>
       <p>The WAL journaling mode uses a write-ahead log instead of a
        rollback journal to implement transactions.  The WAL journaling mode
        is persistent; after being set it stays in effect
        across multiple database connections and after closing and
        reopening the database.  A database in WAL journaling mode
        can only be accessed by SQLite version 3.7.0 (2010-07-21)
        or later.
       </p>
       <p>The OFF journaling mode disables the rollback journal completely.
        No rollback journal is ever created and hence there is never a rollback
        journal to delete.  The OFF journaling mode disables the atomic
        commit and rollback capabilities of SQLite. The 
        <a href="sqlite3_lang_transaction.htm">ROLLBACK</a> command no longer works; 
        it behaves in an undefined way.  Applications must avoid using the 
        <a href="sqlite3_lang_transaction.htm">ROLLBACK</a> command when the journal mode is OFF.
        If the application crashes
        in the middle of a transaction when the OFF journaling mode is
        set, then the database file will very likely go corrupt.
       </p>
       <p>Note that the journal_mode for an in-memory database
        is either MEMORY or OFF and can not be changed to a different value.
        An attempt to change the journal_mode of an in-memory database to
        any setting other than MEMORY or OFF is ignored.  Note also that
        the journal_mode cannot be changed while a transaction is active.
       </p>
    <a name="pragma_journal_size_limit"></a>
       <h _id=pragma_journal_size_limit style="display:none"> PRAGMA journal_size_limit</h>
       <hr>
       <p><b>
        PRAGMA </b><i>schema.</i><b>journal_size_limit
        <br>
        PRAGMA </b><i>schema.</i><b>journal_size_limit = </b><i>N</i> <b>;</b>
       </p>
       <p>If a database connection is operating in
      <a href="sqlite3_lang_pragma.htm#pragma_locking_mode">exclusive locking mode</a> or in
      <a href="sqlite3_lang_pragma.htm#pragma_journal_mode">persistent journal mode</a> 
      (PRAGMA journal_mode=persist) then after committing a transaction the 
      rollback journal file may remain in
      the file-system. This increases performance for subsequent transactions
      since overwriting an existing file is faster than append to a file,
      but it also consumes file-system space. After a large transaction (e.g. a 
      <a href="sqlite3_lang_vacuum.htm">VACUUM</a>),
      the rollback journal file may consume a very large amount of space.
       </p>
       <p>Similarly, in WAL (Write-Ahead Logging) mode, the write-ahead log file is not truncated
      following a checkpoint.  Instead, SQLite reuses the existing file
      for subsequent WAL entries since overwriting is faster than appending.
       </p>
       <p>The journal_size_limit pragma may be used to limit the size of 
      rollback-journal and WAL files left
      in the file-system after transactions or checkpoints.
      Each time a transaction is committed or a WAL file resets, SQLite 
      compares the size of the rollback journal file or WAL file left in 
      the file-system to the size limit
      set by this pragma and if the journal or WAL file is larger 
      it is truncated to the limit.
       </p>
       <p>The second form of the pragma listed above is used to set a new limit
      in bytes for the specified database.  A negative number implies no limit.
      To always truncate rollback journals and WAL files to their minimum size, 
      set the journal_size_limit to zero.
      Both the first and second forms of the pragma listed above return a single
      result row containing a single integer column - the value of the journal
      size limit in bytes. The default journal size limit is -1 (no limit).  The
      SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT preprocessor macro can be used to change
      the default journal size limit at compile-time.
       </p>
       <p>This pragma only operates on the single database specified prior
      to the pragma name (or on the "main" database if no database is specified.)
      There is no way to change the journal size limit on all attached databases
      using a single PRAGMA statement.  The size limit must be set separately for
      each attached database.
       </p>
    <a name="pragma_legacy_file_format"></a>
       <h _id=pragma_legacy_file_format style="display:none"> PRAGMA legacy_file_format</h>
       <hr>
       <p><b>PRAGMA legacy_file_format;
        <br>PRAGMA legacy_file_format = <i>boolean</i></b>
       </p>
       <p>This pragma sets or queries the value of the legacy_file_format
        flag.  When this flag is on, new SQLite databases are created in
        a file format that is readable and writable by all versions of
        SQLite going back to 3.0.0.  When the flag is off, new databases
        are created using the latest file format which might not be
        readable or writable by versions of SQLite prior to 3.3.0.
       </p>
       <p>When the legacy_file_format pragma is issued with no argument,
        it returns the setting of the flag.  This pragma does
        <u>not</u> tell
        which file format the current database is using; it tells what format
        will be used by any newly created databases.
       </p>
       <p>The legacy_file_format pragma is initialized to OFF when an existing
        database in the newer file format is first opened.
       </p>
       <p>The default file format is set by the
        SQLITE_DEFAULT_FILE_FORMAT compile-time option.
       </p>

    <a name="pragma_locking_mode"></a>
       <h _id=pragma_locking_mode style="display:none"> PRAGMA locking_mode</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>locking_mode;
        <br>PRAGMA </b><i>schema.</i><b>locking_mode
                    = <i>NORMAL | EXCLUSIVE</i></b>
       </p>
       <p>This pragma sets or queries the database connection locking-mode. 
        The locking-mode is either NORMAL or EXCLUSIVE.
       </p>
       <p>In NORMAL locking-mode (the default unless overridden at compile-time
        using SQLITE_DEFAULT_LOCKING_MODE), a database connection
        unlocks the database file at the conclusion of each read or
        write transaction. When the locking-mode is set to EXCLUSIVE, the
        database connection never releases file-locks. The first time the
        database is read in EXCLUSIVE mode, a shared lock is obtained and 
        held. The first time the database is written, an exclusive lock is
        obtained and held.
       </p>
       <p>Database locks obtained by a connection in EXCLUSIVE mode may be
        released either by closing the database connection, or by setting the
        locking-mode back to NORMAL using this pragma and then accessing the
        database file (for read or write). Simply setting the locking-mode to
        NORMAL is not enough - locks are not released until the next time
        the database file is accessed.
       </p>
       <p>There are three reasons to set the locking-mode to EXCLUSIVE.
        <ol>
        <li>The application wants to prevent other processes from
            accessing the database file.</li>
        <li>The number of system calls for filesystem operations is reduced,
            possibly resulting in a small performance increase.</li>
        <li>WAL (Write-Ahead Logging) databases can be accessed in EXCLUSIVE mode without the
            use of shared memory. </li>
        </ol>
       </p>
       <p>When the locking_mode pragma specifies a particular database,
        for example:
       </p>
       <blockquote>
    PRAGMA <b>main.</b>locking_mode=EXCLUSIVE;
       </blockquote>
       <p>Then the locking mode applies only to the named database.  If no
        database name qualifier precedes the "locking_mode" keyword then
        the locking mode is applied to all databases, including any new
        databases added by subsequent <a href="sqlite3_lang_attach.htm">ATTACH</a> commands.
       </p>
       <p>The "temp" database (in which TEMP tables and indices are stored)
       and in-memory databases
       always uses exclusive locking mode.  The locking mode of temp and
       in-memory databases cannot
       be changed.  All other databases use the normal locking mode by default
       and are affected by this pragma.
       </p>
       <p>If the locking mode is EXCLUSIVE when first entering
       WAL journal mode, then the locking mode cannot be changed to
       NORMAL until after exiting WAL journal mode. 
       If the locking mode is NORMAL when first entering WAL
       journal mode, then the locking mode can be changed between NORMAL and
       EXCLUSIVE and back again at any time and without needing to exit
       WAL journal mode.
       </p>

    <a name="pragma_max_page_count"></a>
       <h _id=pragma_max_page_count style="display:none"> PRAGMA max_page_count</h>
       <hr>
       <p><b>PRAGMA </b><i>schema.</i><b>max_page_count;
        <br>PRAGMA </b><i>schema.</i><b>max_page_count = </b><i>N</i><b>;</b>
       </p>
       <p>Query or set the maximum number of pages in the database file.
        Both forms of the pragma return the maximum page count.  The second
        form attempts to modify the maximum page count.  The maximum page
        count cannot be reduced below the current database size.
       </p>

    <a name="pragma_mmap_size"></a>
       <h _id=pragma_mmap_size style="display:none"> PRAGMA mmap_size</h>
       <hr>
       <p>
        <br><b>PRAGMA </b><i>schema.</i><b>mmap_size;
        <br>PRAGMA </b><i>schema.</i><b>mmap_size=</b><i>N</i>
       </p>
       <p>Query or change the maximum number of bytes that are set
           aside for memory-mapped I/O on a single database.  The first form
           (without an argument) queries the current limit.  The second
           form (with a numeric argument) sets the limit for the specified
           database, or for all databases if the optional database name is
           omitted.  In the second form, if the database name is omitted, the
           limit that is set becomes the default limit for all databases that
           are added to the database connection by subsequent <a href="sqlite3_lang_attach.htm">ATTACH</a>
           statements.
       </p>
       <p>The argument N is the maximum number of bytes of the database file
           that will be accessed using memory-mapped I/O.  If N is zero then
           memory mapped I/O is disabled.  If N is negative, then the limit
           reverts to the default value determined by the most recent
           [a href="c3ref/config.htm?"]sqlite3_config[/a](SQLITE_CONFIG_MMAP_SIZE) [not wrapped], or to the compile
           time default determined by SQLITE_DEFAULT_MMAP_SIZE if not
           start-time limit has been set.
       </p>
       <p>The <a href="sqlite3_lang_pragma.htm#pragma_mmap_size">PRAGMA mmap_size</a> statement will never increase the amount
           of address space used for memory-mapped I/O above the
           hard limit set by the SQLITE_MAX_MMAP_SIZE compile-time option,
           nor the hard limit set start-time by the second argument to
           sqlite3_config(SQLITE_CONFIG_MMAP_SIZE)
       </p>
       <p>The size of the memory-mapped I/O region cannot be changed while
           the memory-mapped I/O region is in active use, to avoid unmapping
           memory out from under running SQL statements.  For this reason,
           the mmap_size pragma may be a no-op if the prior mmap_size is non-zero
           and there are other SQL statements running concurrently on the same
           database connection.
       </p>
    <a name="pragma_module_list"></a>
       <h _id=pragma_module_list style="display:none"> PRAGMA module_list</h>
       <hr>
       <p><b>PRAGMA module_list;</b>
        <p>This pragma returns a list of 
        [a href="vtab.htm?"]virtual table[/a] [not implemented] modules registered with the database connection.
        </p>
        <p style='background-color: #f0e0ff;'>
        This pragma is only available if SQLite is built using the
        -DSQLITE_INTROSPECTION_PRAGMAS compile-time option.
        </p>
      
    <a name="pragma_optimize"></a>
        <h _id=pragma_optimize style="display:none"> PRAGMA optimize</h>
        <hr>
        <p><b>PRAGMA optimize;
         <br>PRAGMA optimize(</b><i>MASK</i><b>);
         <br>PRAGMA </b><i>schema</i><b>.optimize;
         <br>PRAGMA </b><i>schema</i><b>.optimize(</b><i>MASK</i><b>);</b>
        </p>
        <p>Attempt to optimize the database.  All schemas are optimized in the 
      first two forms, and only the specified schema is optimized in the latter
      two.
        </p>
        <p>To achieve the best long-term query performance without the need to
      do a detailed engineering analysis of the application schema and SQL,
      it is recommended that applications run "PRAGMA optimize" (with no arguments)
      just before closing each database connection.  Long-running applications
      might also benefit from setting a timer to run "PRAGMA optimize" every
      few hours.
        </p>
        <p>This pragma is usually a no-op or nearly so and is very fast.
      However if SQLite feels
      that performing database optimizations (such as running <a href="sqlite3_lang_analyze.htm">ANALYZE</a>
      or creating new indexes) will improve the performance of future queries, then
      some database I/O may be done.  Applications that want to limit the amount
      of work performed can set a timer that will invoke
      [a href="c3ref/interrupt.htm?"]sqlite3_interrupt()[/a] [not implemented] if the pragma goes on for too long.
        </p>
        <p>The details of optimizations performed by this pragma are expected
      to change and improve over time.  Applications should anticipate that
      this pragma will perform new optimizations in future releases.
        </p>
        <p>The optional MASK argument is a bitmask of optimizations to perform:
         <ol>
      <li value='1'>
          <p>
             Debugging mode.  Do not actually perform any optimizations
             but instead return one line of text for each optimization
             that would have been done.  Off by default.
          </p></li>
      <li value='2'>
          <p>
             Run <a href="sqlite3_lang_analyze.htm">ANALYZE</a> on tables that might benefit.  On by default.
             See below for additional information.
          </p></li>
      <li value='4'>
          <p>
             <em>(Not yet implemented)</em>
             Record usage and performance 
             information from the current session in the
             database file so that it will be available to "optimize"
             pragmas run by future database connections.
          </p></li>
      <li value='8'>
          <p>
             <em>(Not yet implemented)</em>
             Create indexes that might have been helpful to recent queries.
          </p></li>
         </ol>
        </p>
        <p>The default MASK is and always shall be 0xfffe.  The 0xfffe mask means
      perform all of the optimizations listed above except Debug Mode.  If new
      optimizations are added in the future that should be off by default, those
      new optimizations will be given a mask of 0x10000 or larger.
        </p>
        <p>To see all optimizations that would have been done without actually
      doing them, run "PRAGMA optimize(-1)".  To use only the ANALYZE
      optimization, run "PRAGMA optimize(0x02)".
        </p>
        <p><b>Determination Of When To Run Analyze</b></p>
        <p> In the current implementation, a table is analyzed if and only if 
          all of the following are true:
         <ul><li><p>MASK bit 0x02 is set.</p></li>
             <li><p>The query planner used sqlite_stat1-style statistics for one or
                    more indexes of the table at some point during the lifetime of
                    the current connection.</p></li>
             <li><p>One or more indexes of the table are currently unanalyzed <em>or</em>
                    the number of rows in the table has increased by 25 times or more
                    since the last time ANALYZE was run.</p></li>
         </ul>
        </p>
        <p> The rules for when tables are analyzed are likely to change in
          future releases.
        </p>

    <a name="pragma_page_count"></a>
        <h _id=pragma_page_count style="display:none"> PRAGMA page_count</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>page_count;</b></p>
        <p>Return the total number of pages in the database file.</p>
    <a name="pragma_page_size"></a>
        <h _id=pragma_page_size style="display:none"> PRAGMA page_size</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>page_size;
         <br>PRAGMA </b><i>schema.</i><b>page_size = </b><i>bytes</i><b>;</b>
        </p>
        <p>Query or set the page size of the database. The page
        size must be a power of two between 512 and 65536 inclusive.
        </p>
        <p>When a new database is created, SQLite assigns a page size to
        the database based on platform and filesystem.  For many years,
        the default page size was almost always 1024 bytes, but beginning
        with SQLite version 3.12.0 (2016-03-29), 
        the default page size increased to 4096.
        The default page size is recommended for most applications.
        </p>
        <p>Specifying a new page size does not change the page size
        immediately.  Instead, the new page size is remembered and is used
        to set the page size when the database is first created, if it does
        not already exist when the page_size pragma is issued, or at the
        next <a href="sqlite3_lang_vacuum.htm">VACUUM</a> command that is run on the same database connection
        while not in WAL mode.
        </p>
        <p>The SQLITE_DEFAULT_PAGE_SIZE compile-time option can be used
        to change the default page size assigned to new databases.
        </p>

    <a name="pragma_parser_trace"></a>
        <h _id=pragma_parser_trace style="display:none"> PRAGMA parser_trace</h>
        <hr>
        <p><b>PRAGMA parser_trace = </b><i>boolean</i><b>; </b></p>
        <p>If SQLite has been compiled with the SQLITE_DEBUG compile-time
        option, then the parser_trace pragma can be used to turn on tracing
        for the SQL parser used internally by SQLite.
        This feature is used for debugging SQLite itself.
        </p>
        <p style='background-color: #f0e0ff;'>
        This pragma is intended for use when debugging SQLite itself.  It
        is only available when the SQLITE_DEBUG compile-time option
        is used.
        </p>
      
    <a name="pragma_pragma_list"></a>
        <h _id=pragma_pragma_list style="display:none"> PRAGMA pragma_list</h>
        <hr>
        <p><b>PRAGMA pragma_list;</b></p>
        <p>This pragma returns a list of PRAGMA commands
        known to the database connection.
        </p>
        <p style='background-color: #f0e0ff;'>
        This pragma is only available if SQLite is built using the
        -DSQLITE_INTROSPECTION_PRAGMAS compile-time option.
        </p>
      
    <a name="pragma_query_only"></a>
        <h _id=pragma_query_only style="display:none"> PRAGMA query_only</h>
        <hr>
        <p><b>PRAGMA query_only;
         <br>PRAGMA query_only = </b><i>boolean</i><b>;</b>
        </p>
        <p>The query_only pragma prevents all changes to database files when
        enabled.
        </p>

    <a name="pragma_quick_check"></a>
        <h _id=pragma_quick_check style="display:none"> PRAGMA quick_check</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>quick_check;
         <br>PRAGMA </b><i>schema.</i><b>quick_check(</b><i>N</i><b>)</b>
        </p>
        <p>The pragma is like <a href="sqlite3_lang_pragma.htm#pragma_integrity_check">integrity_check</a> except that it does not verify
        UNIQUE constraints and does not verify
        that index content matches table content.  By skipping UNIQUE
        and index consistency checks, quick_check is able to run much faster than
        integrity_check.  Otherwise the two pragmas are the same.
        </p>

    <a name="pragma_read_uncommitted"></a>
        <h _id=pragma_read_uncommitted style="display:none"> PRAGMA read_uncommitted</h>
        <hr>
        <p><b>PRAGMA read_uncommitted;
         <br>PRAGMA read_uncommitted = </b><i>boolean</i><b>;</b>
        </p>
        <p>Query, set, or clear READ UNCOMMITTED isolation. The default isolation
        level for SQLite is SERIALIZABLE.  Any process or thread can select
        READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except
        between connections that share a common page and schema cache.
        Cache sharing is enabled using the [a href="c3ref/enable_shared_cache.htm?"]sqlite3_enable_shared_cache()[/a] [not implemented] API.
        Cache sharing is disabled by default.
        </p>

    <a name="pragma_recursive_triggers"></a>
        <h _id=pragma_recursive_triggers style="display:none"> PRAGMA recursive_triggers</h>
        <hr>
        <p><b>PRAGMA recursive_triggers;
         <br>PRAGMA recursive_triggers = </b><i>boolean</i><b>;</b>
        </p>
        <p>Query, set, or clear the recursive trigger capability.</p>
        <p>Changing the recursive_triggers setting affects the execution of
           all statements prepared
           using the database connection, including those prepared before the
           setting was changed. Any existing statements prepared using the legacy 
           <a href="sqlite3_prepare.htm">sqlite3_prepare()</a> interface may fail with an 
           <a href="sqlconst.htm#SQLITE_SCHEMA">SQLITE_SCHEMA</a> error
           after the recursive_triggers setting is changed.
        </p>
        <p>Prior to SQLite version 3.6.18 (2009-09-11), 
        recursive triggers were not supported.
        The behavior of SQLite was always as if this pragma was
        set to OFF.  Support for recursive triggers was added in version 3.6.18
        but was initially turned OFF by default, for compatibility.  Recursive
        triggers may be turned on by default in future versions of SQLite.
        </p>
        <p>The depth of recursion for triggers has a hard upper limit set by
        the SQLITE_MAX_TRIGGER_DEPTH compile-time option and a run-time
        limit set by sqlite3_limit(db,SQLITE_LIMIT_TRIGGER_DEPTH,...) [not wrapped].
        </p>

    <a name="pragma_reverse_unordered_selects"></a>
        <h _id=pragma_reverse_unordered_selects style="display:none"> PRAGMA reverse_unordered_selects</h>
        <hr>
        <p><b>PRAGMA reverse_unordered_selects;
         <br>PRAGMA reverse_unordered_selects = </b><i>boolean</i><b>;</b>
        </p>
        <p>When enabled, this PRAGMA causes many <a href="sqlite3_lang_select.htm">SELECT</a> statements without
        an ORDER BY clause to emit their results in the reverse order from what
        they normally would.  This can help debug applications that are
        making invalid assumptions about the result order.  
        The reverse_unordered_selects pragma works for most SELECT statements,
        however the query planner may sometimes choose an algorithm that is
        not easily reversed, in which case the output will appear in the same
        order regardless of the reverse_unordered_selects setting.
        </p>
        <p>SQLite makes no
        guarantees about the order of results if a SELECT omits the ORDER BY
        clause.  Even so, the order of results does not change from one
        run to the next, and so many applications mistakenly come to depend
        on the arbitrary output order whatever that order happens to be.  However, 
        sometimes new versions of SQLite will contain optimizer enhancements
        that will cause the output order of queries without ORDER BY clauses
        to shift.  When that happens, applications that depend on a certain
        output order might malfunction.  By running the application multiple
        times with this pragma both disabled and enabled, cases where the
        application makes faulty assumptions about output order can be
        identified and fixed early, reducing problems
        that might be caused by linking against a different version of SQLite.
        </p>

    <a name="pragma_schema_version"></a>
        <h _id=pragma_schema_version style="display:none"> PRAGMA schema_version</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>schema_version;
         <br>PRAGMA </b><i>schema.</i><b>schema_version = </b><i>integer </i>;
        </p>
        <p>   The schema_version pragma will to get or set
           the value of the schema-version integer at offset 40 in the
           database header.
        </p>
        <p>    SQLite automatically increments the schema-version whenever the
           schema changes. As each SQL statement runs, the schema version is
           checked to ensure that the schema has not changed since the SQL
           statement was <a href="sqlite3_prepare.htm">prepared</a>.
           Subverting this mechanism by using "PRAGMA schema_version"
           may cause SQL statement to run using an obsolete schema,
           which can lead to incorrect answers and/or database corruption.
        </p>
        <p>
         <span style='background-color: #ffff60;'>
        <b>Warning:</b>
        Misuse of this pragma can result in database corruption.
         </span>
        </p>
        <p> For the purposes of this pragma, the <a href="sqlite3_lang_vacuum.htm">VACUUM</a> command is considered
            a schema change, since <a href="sqlite3_lang_vacuum.htm">VACUUM</a> will usual alter the "rootpage"
            values for entries in the sqlite_master table.
        </p>
        <p> See also the <a href="sqlite3_lang_pragma.htm#pragma_application_id">application_id pragma</a> and 
            <a href="sqlite3_lang_pragma.htm#pragma_user_version">user_version pragma</a>.</p>

    <a name="pragma_secure_delete"></a>
        <h _id=pragma_secure_delete style="display:none"> PRAGMA secure_delete</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>secure_delete;
         <br>PRAGMA </b><i>schema.</i><b>secure_delete = </b><i>boolean</i>|<b>FAST</b>
        </p>
        <p>Query or change the secure-delete setting. When secure_delete is
        on, SQLite overwrites deleted content with zeros.  The default
        setting for secure_delete is determined by the SQLITE_SECURE_DELETE
        compile-time option and is normally off.  The off setting for
        secure_delete improves performance by reducing the number of CPU cycles
        and the amount of disk I/O.  Applications that wish to avoid leaving
        forensic traces after content is deleted or updated should enable the
        secure_delete pragma prior to performing the delete or update, or else
        run <a href="sqlite3_lang_vacuum.htm">VACUUM</a> after the delete or update.
        </p>
        <p>The "fast" setting for secure_delete (added circa 2017-08-01)
        is an intermediate setting in between "on" and "off".
        When secure_delete is set to "fast",
        SQLite will overwrite deleted content with zeros only if doing so
        does not increase the amount of I/O.  In other words, the "fast"
        setting uses more CPU cycles but does not use more I/O.
        This has the effect of purging all old content from b-tree pages,
        but leaving forensic traces on freelist pages.
        </p>
        <p>
        When there are <a href="sqlite3_lang_attach.htm">attached databases</a> and no database
        is specified in the pragma, all databases have their secure-delete
        setting altered.
        The secure-delete setting for newly attached databases is the setting
        of the main database at the time the ATTACH command is evaluated.
        </p>
        <p>
        When multiple database connections share the same cache, changing
        the secure-delete flag on one database connection changes it for them
        all.
        </p>

    <a name="pragma_short_column_names"></a>
        <h _id=pragma_short_column_names style="display:none"> PRAGMA short_column_names</h>
        <hr>
        <p><b>PRAGMA short_column_names;
         <br>PRAGMA short_column_names = </b><i>boolean</i><b>;</b>
        </p>
        <p>Query or change the short-column-names flag. This flag affects
        the way SQLite names columns of data returned by <a href="sqlite3_lang_select.htm">SELECT</a> statements.
        See the <a href="sqlite3_lang_pragma.htm#pragma_full_column_names">full_column_names</a> pragma for full details.
        </p>
        <p style='background-color: #ffd0d0;'>
        <b>This pragma is deprecated</b> and exists
        for backwards compatibility only.  New applications
        should avoid using this pragma.  Older applications should discontinue
        use of this pragma at the earliest opportunity.  This pragma may be omitted
        from the build when SQLite is compiled using SQLITE_OMIT_DEPRECATED.
        </p>
      
    <a name="pragma_shrink_memory"></a>
        <h _id=pragma_shrink_memory style="display:none"> PRAGMA shrink_memory</h>
        <hr>
        <p><b>PRAGMA shrink_memory</b></p>
        <p>This pragma causes the database connection on which it is invoked
        to free up as much memory as it can, by calling
        [a href="c3ref/db_release_memory.htm?"]sqlite3_db_release_memory()[/a] [not otherwise wrapped].
        </p>
    <a name="pragma_soft_heap_limit"></a>
        <h _id=pragma_soft_heap_limit style="display:none"> PRAGMA soft_heap_limit</h>
        <hr>
        <p><b>PRAGMA soft_heap_limit
         <br>
              PRAGMA soft_heap_limit=</b><i>N</i>
        </p>
        <p>This pragma invokes the [a href="c3ref/soft_heap_limit64.htm?"]sqlite3_soft_heap_limit64()[/a] [not otherwise wrapped] interface with
        the argument N, if N is specified and is a non-negative integer.
        The soft_heap_limit pragma always returns the same integer
        that would be returned by the [a href="c3ref/soft_heap_limit64.htm?"]sqlite3_soft_heap_limit64[/a](-1) C-language
        function [not implemented].
        </p>

    <a name="pragma_stats"></a>
        <h _id=pragma_stats style="display:none"> PRAGMA stats</h>
        <hr>
        <p><b>PRAGMA stats;</b> </p>
        <p>This pragma returns auxiliary information about tables and
        indices.  The returned information is used during testing to help
        verify that the query planner is operating correctly.  The format
        and meaning of this pragma will likely change from one release
        to the next. Because of its volatility, the behavior and output
        format of this pragma are deliberately undocumented.
        </p>
        <p style='background-color: #f0e0ff;'>
        The intended use of this pragma is only for testing and validation of
        SQLite.  This pragma is subject to change without notice and is not
        recommended for use by application programs.
        </p>
      
    <a name="pragma_synchronous"></a>
        <h _id=pragma_synchronous style="display:none"> PRAGMA synchronous</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>synchronous;
         <br>PRAGMA </b><i>schema.</i><b>synchronous = </b>
              <i>0 | OFF | 1 | NORMAL | 2 | FULL | 3 | EXTRA</i><b>;</b>
        </p>
        <p>Query or change the setting of the "synchronous" flag.
        The first (query) form will return the synchronous setting as an 
        integer.  The second form changes the synchronous setting.
        The meanings of the various synchronous settings are as follows:
         <dl>
          <dt><b>EXTRA</b> (3)</dt>
          <dd>
        EXTRA synchronous is like FULL with the addition that the directory
        containing a rollback journal is synced after that journal is unlinked
        to commit a transaction in DELETE mode.  EXTRA provides additional
        durability if the commit is followed closely by a power loss.
          </dd>
          <dt><b>FULL</b> (2)</dt>
          <dd>
        When synchronous is FULL (2), the SQLite database engine will
        use the xSync method of the VFS to ensure that all content is safely
        written to the disk surface prior to continuing.
        This ensures that an operating system crash or power failure will
        not corrupt the database.
        FULL synchronous is very safe, but it is also slower.  FULL is the
        most commonly used synchronous setting when not in WAL mode.
          </dd>
          <dt><b>NORMAL</b> (1)</dt>
          <dd>
        When synchronous is NORMAL (1), the SQLite database
        engine will still sync at the most critical moments, but less often
        than in FULL mode.  There is a very small (though non-zero) chance that
        a power failure at just the wrong time could corrupt the database in
        NORMAL mode.  But in practice, you are more likely to suffer
        a catastrophic disk failure or some other unrecoverable hardware
        fault.  Many applications choose NORMAL when in WAL mode.
          </dd>
          <dt><b>OFF</b> (0)</dt>
          <dd>
        With synchronous OFF (0), SQLite continues without syncing
        as soon as it has handed data off to the operating system.
        If the application running SQLite crashes, the data will be safe, but
        the database might become corrupted if the operating system
        crashes or the computer loses power before that data has been written
        to the disk surface.  On the other hand, commits can be orders of
        magnitude faster with synchronous OFF.
          </dd>
         </dl>
        </p>
        <p>In WAL mode when synchronous is NORMAL (1), the WAL file is
        synchronized before each checkpoint and the database file is
        synchronized after each completed checkpoint and the WAL file
        header is synchronized when a WAL file begins to be reused after
        a checkpoint, but no sync operations occur during most transactions.
        With synchronous=FULL in WAL mode, an additional
        sync operation of the WAL file happens after each transaction commit.
        The extra WAL sync following each transaction help ensure that 
        transactions are durable across a power loss.  Transactions are
        consistent with or without the extra syncs provided by
        synchronous=FULL.
        If durability is not a concern, then synchronous=NORMAL is normally
        all one needs in WAL mode.
        </p>
        <p>The TEMP schema always has synchronous=OFF since the content of
        of TEMP is ephemeral and is not expected to survive a power outage.
        Attempts to change the synchronous setting for TEMP are
        silently ignored.
        </p>
        <p>See also the <a href="sqlite3_lang_pragma.htm#pragma_fullfsync">fullfsync</a> and 
            <a href="sqlite3_lang_pragma.htm#pragma_checkpoint_fullfsync">checkpoint_fullfsync</a> pragmas.</p>

    <a name="pragma_table_info"></a>
        <h _id=pragma_table_info style="display:none"> PRAGMA table_info</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>table_info(</b><i>table-name</i><b>);</b></p>
        <p>This pragma returns one row for each column in the named table.
        Columns in the result set include the column name,
        data type, whether or not the column can be NULL, and the default
        value for the column.  The "pk" column in the result set is zero
        for columns that are not part of the primary key, and is the index of
        the column in the primary key for columns that are part of the primary
        key.
        </p>
        <p>The table named in the table_info pragma can also be a view.</p>

    <a name="pragma_temp_store"></a>
        <h _id=pragma_temp_store style="display:none"> PRAGMA temp_store</h>
        <hr>
        <p><b>PRAGMA temp_store;
         <br>PRAGMA temp_store = </b>
                <i>0 | DEFAULT | 1 | FILE | 2 | MEMORY</i><b>;</b>
        </p>
        <p>Query or change the setting of the "<b>temp_store</b>" parameter.
        When temp_store is DEFAULT (0), the compile-time C preprocessor macro
        SQLITE_TEMP_STORE is used to determine where temporary tables and indices
        are stored.  When
        temp_store is MEMORY (2) temporary tables and indices are kept in
        as if they were pure in-memory databases memory.
        When temp_store is FILE (1) temporary tables and indices are stored in a file.  
        The <a href="sqlite3_lang_pragma.htm#pragma_temp_store_directory">temp_store_directory</a> 
        pragma can be used to specify the directory containing temporary files when
        <b>FILE</b> is specified.  When the temp_store setting is changed,
        all existing temporary tables, indices, triggers, and views are
        immediately deleted.
        </p>
        <p>It is possible for the library compile-time C preprocessor symbol
        SQLITE_TEMP_STORE to override this pragma setting.
        The following table summarizes
        the interaction of the SQLITE_TEMP_STORE preprocessor macro and the
        temp_store pragma:
        </p>
         <table cellpadding="2" border="1">
          <tr>
           <th valign="bottom">SQLITE_TEMP_STORE</th>
           <th valign="bottom">PRAGMA
            <br>temp_store
           </th>
           <th>Storage used for
            <br>TEMP tables and indices
           </th>
          </tr>
          <tr>
           <td align="center">0</td>
           <td align="center"><em>any</em></td>
           <td align="center">file</td>
          </tr>
          <tr>
           <td align="center">1</td>
           <td align="center">0</td>
           <td align="center">file</td>
          </tr>
          <tr>
           <td align="center">1</td>
           <td align="center">1</td>
           <td align="center">file</td>
          </tr>
          <tr>
           <td align="center">1</td>
           <td align="center">2</td>
           <td align="center">memory</td>
          </tr>
          <tr>
           <td align="center">2</td>
           <td align="center">0</td>
           <td align="center">memory</td>
          </tr>
          <tr>
           <td align="center">2</td>
           <td align="center">1</td>
           <td align="center">file</td>
          </tr>
          <tr>
           <td align="center">2</td>
           <td align="center">2</td>
           <td align="center">memory</td>
          </tr>
          <tr>
           <td align="center">3</td>
           <td align="center"><em>any</em></td>
           <td align="center">memory</td>
          </tr>
         </table>
        <p></p>

    <a name="pragma_temp_store_directory"></a>
        <h _id=pragma_temp_store_directory style="display:none"> PRAGMA temp_store_directory</h>
        <hr>
        <p><b>PRAGMA temp_store_directory;
         <br>PRAGMA temp_store_directory = '</b><i>directory-name</i><b>';</b>
        </p>
        <p>Query or change the value of the sqlite3_temp_directory global
        variable, which many operating-system interface backends use to
        determine where to store temporary tables and indices.
        </p>
        <p>When the temp_store_directory setting is changed, all existing temporary
        tables, indices, triggers, and viewers in the database connection that
        issued the pragma are immediately deleted.  In
        practice, temp_store_directory should be set immediately after the first
        database connection for a process is opened.  If the temp_store_directory
        is changed for one database connection while other database connections
        are open in the same process, then the behavior is undefined and
        probably undesirable.
        </p>
        <p>Changing the temp_store_directory setting is
         <u>not</u> threadsafe.
        Never change the temp_store_directory setting if another thread
        within the application is running any SQLite interface at the same time.
        Doing so results in undefined behavior.  Changing the temp_store_directory
        setting writes to the sqlite3_temp_directory global
        variable and that global variable is not protected by a mutex.
        </p>
        <p>The value <i>directory-name</i> should be enclosed in single quotes.
        To revert the directory to the default, set the <i>directory-name</i> to
        an empty string, e.g., <i>PRAGMA temp_store_directory = ''</i>.  An
        error is raised if <i>directory-name</i> is not found or is not
        writable.
        </p>
        <p>The default directory for temporary files depends on the OS.  Some
        OS interfaces may choose to ignore this variable and place temporary
        files in some other directory different from the directory specified
        here.  In that sense, this pragma is only advisory.
        </p>
        <p style='background-color: #ffd0d0;'>
        <b>This pragma is deprecated</b> and exists
        for backwards compatibility only.  New applications
        should avoid using this pragma.  Older applications should discontinue
        use of this pragma at the earliest opportunity.  This pragma may be omitted
        from the build when SQLite is compiled using SQLITE_OMIT_DEPRECATED.
        </p>
      
    <a name="pragma_threads"></a>
        <h _id=pragma_threads style="display:none"> PRAGMA threads</h>
        <hr>
        <p><b>PRAGMA threads;
         <br>PRAGMA threads = </b><i>N</i><b>;</b>
        </p>
        <p>Query or change the value of the 
        sqlite3_limit(db,SQLITE_LIMIT_WORKER_THREADS,...) [not wrapped] limit for
        the current database connection.  This limit sets an upper bound
        on the number of auxiliary threads that a <a href="sqlite3_prepare.htm">prepared statement</a> is
        allowed to launch to assist with a query.  The default limit is 0
        unless it is changed using the SQLITE_DEFAULT_WORKER_THREADS
        compile-time option.  When the limit is zero, that means no
        auxiliary threads will be launched.
        </p>
        <p>This pragma is a thin wrapper around the
        sqlite3_limit(db,SQLITE_LIMIT_WORKER_THREADS,...) interface [not wrapped].
        </p>

    <a name="pragma_user_version"></a>
        <h _id=pragma_user_version style="display:none"> PRAGMA user_version</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>user_version;
         <br>PRAGMA </b><i>schema.</i><b>user_version = </b><i>integer </i><b>;</b>
        </p>
        <p>    The user_version pragma will to get or set
           the value of the user-version integer at offset 60 in the
           database header. The user-version is an integer that is
           available to applications to use however they want.  SQLite
           makes no use of the user-version itself.
        </p>
        <p>See also the <a href="sqlite3_lang_pragma.htm#pragma_application_id">application_id pragma</a> 
            and <a href="sqlite3_lang_pragma.htm#pragma_schema_version">schema_version pragma</a>.</p>

    <a name="pragma_vdbe_addoptrace"></a>
        <h _id=pragma_vdbe_addoptrace style="display:none"> PRAGMA vdbe_addoptrace</h>
        <hr>
        <p><b>PRAGMA vdbe_addoptrace = </b><i>boolean</i><b>;</b></p>
        <p>If SQLite has been compiled with the SQLITE_DEBUG compile-time
        option, then the vdbe_addoptrace pragma can be used to cause a complete
        VDBE opcodes to be displayed as they are created during code generation.
        This feature is used for debugging SQLite itself.
        </p>
        <p style='background-color: #f0e0ff;'>
        This pragma is intended for use when debugging SQLite itself.  It
        is only available when the SQLITE_DEBUG compile-time option
        is used.
        </p>
      
    <a name="pragma_vdbe_debug"></a>
        <h _id=pragma_vdbe_debug style="display:none"> PRAGMA vdbe_debug</h>
        <hr>
        <p><b>PRAGMA vdbe_debug = </b><i>boolean</i><b>;</b></p>
        <p>If SQLite has been compiled with the SQLITE_DEBUG compile-time
        option, then the vdbe_debug pragma is a shorthand for three other
        debug-only pragmas: vdbe_addoptrace, vdbe_listing, and vdbe_trace.
        This feature is used for debugging SQLite itself.
        </p>
        <p style='background-color: #f0e0ff;'>
        This pragma is intended for use when debugging SQLite itself.  It
        is only available when the SQLITE_DEBUG compile-time option
        is used.
        </p>
      
    <a name="pragma_vdbe_listing"></a>
        <h _id=pragma_vdbe_listing style="display:none"> PRAGMA vdbe_listing</h>
        <hr>
        <p><b>PRAGMA vdbe_listing = </b><i>boolean</i><b>;</b></p>
        <p>If SQLite has been compiled with the SQLITE_DEBUG compile-time
        option, then the vdbe_listing pragma can be used to cause a complete
        listing of the virtual machine opcodes to appear on standard output
        as each statement is evaluated.
        With listing is on, the entire content of a program is printed
        just prior to beginning execution.  The statement
        executes normally after the listing is printed.
        This feature is used for debugging SQLite itself.
        </p>
        <p style='background-color: #f0e0ff;'>
        This pragma is intended for use when debugging SQLite itself.  It
        is only available when the SQLITE_DEBUG compile-time option
        is used.
        </p>
      
    <a name="pragma_vdbe_trace"></a>
        <h _id=pragma_vdbe_trace style="display:none"> PRAGMA vdbe_trace</h>
        <hr>
        <p><b>PRAGMA vdbe_trace = </b><i>boolean</i><b>;</b></p>
        <p>If SQLite has been compiled with the SQLITE_DEBUG compile-time
        option, then the vdbe_trace pragma can be used to cause virtual machine
        opcodes to be printed on standard output as they are evaluated.
        This feature is used for debugging SQLite.
        </p>
        <p style='background-color: #f0e0ff;'>
        This pragma is intended for use when debugging SQLite itself.  It
        is only available when the SQLITE_DEBUG compile-time option
        is used.
        </p>
      
    <a name="pragma_wal_autocheckpoint"></a>
        <h _id=pragma_wal_autocheckpoint style="display:none"> PRAGMA wal_autocheckpoint</h>
        <hr>
        <p><b>PRAGMA wal_autocheckpoint;
         <br>
              PRAGMA wal_autocheckpoint=</b><i>N</i><b>;</b>
        </p>
        <p>This pragma queries or sets the write-ahead log
        auto-checkpoint interval.
        When the write-ahead log is enabled (via the
        <a href="sqlite3_lang_pragma.htm#pragma_journal_mode">journal_mode pragma</a>) 
        a checkpoint will be run automatically whenever
        the write-ahead log equals or exceeds <i>N</i> pages in length.
        Setting the auto-checkpoint size to zero or a negative value
        turns auto-checkpointing off.
        </p>
        <p>This pragma is a wrapper around the
        [a href="c3ref/wal_autocheckpoint.htm?"]sqlite3_wal_autocheckpoint()[/a] [not implemented] C interface.
        All automatic checkpoints are [a href="c3ref/wal_checkpoint_v2.htm?"]PASSIVE[/a] [not implemented].
        </p>
        <p>Autocheckpointing is enabled by default with an interval
        of 1000 or the SQLITE_DEFAULT_WAL_AUTOCHECKPOINT compile-time option.
        </p>

    <a name="pragma_wal_checkpoint"></a>
        <h _id=pragma_wal_checkpoint style="display:none"> PRAGMA wal_checkpoint</h>
        <hr>
        <p><b>PRAGMA </b><i>schema.</i><b>wal_checkpoint;</b>
         <br>
           <b>PRAGMA </b><i>schema.</i><b>wal_checkpoint(PASSIVE);</b>
         <br>
           <b>PRAGMA </b><i>schema.</i><b>wal_checkpoint(FULL);</b>
         <br>
           <b>PRAGMA </b><i>schema.</i><b>wal_checkpoint(RESTART);</b>
         <br>
           <b>PRAGMA </b><i>schema.</i><b>wal_checkpoint(TRUNCATE);</b>
        </p>
        <p>If the write-ahead log is enabled (via the 
        <a href="sqlite3_lang_pragma.htm#pragma_journal_mode">journal_mode pragma</a>),
        this pragma causes a checkpoint operation to run on database
        <i>database</i>, or on all attached databases if <i>database</i>
        is omitted.  If write-ahead log mode is disabled, this pragma is a
        harmless no-op.
        </p>
        <p>Invoking this
        pragma without an argument is equivalent to calling the
        [a href="c3ref/wal_checkpoint.htm?"]sqlite3_wal_checkpoint()[/a] [not implemented] C interface.
        </p>
        Invoking this pragma with an argument is equivalent to calling the
        [a href="c3ref/wal_checkpoint_v2.htm?"]sqlite3_wal_checkpoint_v2()[/a] [not implemented] C interface with a 
        [a href="c3ref/c_checkpoint_full.htm?"]3rd parameter[/a] [not implemented]
        corresponding to the argument:
        <dl>
         <dt>PASSIVE</dt>
         <dd>
          Checkpoint as many frames as possible without waiting for any database 
          readers or writers to finish. Sync the db file if all frames in the log
          are checkpointed. This mode is the same as calling the
          [a href="c3ref/wal_checkpoint.htm?"]sqlite3_wal_checkpoint()[/a] [not implemented] C interface. The
          [a href="c3ref/busy_handler.htm?"]busy-handler callback[/a] [not implemented] is never invoked in
          this mode.
         </dd>
         <dt>FULL</dt>
         <dd>
          This mode blocks 
          (invokes the [a href="c3ref/busy_handler.htm?"]busy-handler callback[/a] [not implemented])
          until there is no
          database writer and all readers are reading from the most recent database
          snapshot. It then checkpoints all frames in the log file and syncs the
          database file. FULL blocks concurrent writers while it is
          running, but readers can proceed.
         </dd>
         <dt>RESTART</dt>
         <dd>
          This mode works the same way as FULL with the addition that after 
          checkpointing the log file it blocks (calls the 
          [a href="c3ref/busy_handler.htm?"]busy-handler callback[/a] [not implemented])
          until all readers are finished with the log file. This ensures 
          that the next client to write to the database file restarts the log file 
          from the beginning. RESTART blocks concurrent writers while it is
          running, but allowed readers to proceed.
         </dd>
         <dt>TRUNCATE</dt>
         <dd>
          This mode works the same way as RESTART with the 
          addition that the WAL file is truncated to zero bytes upon successful
          completion.
         </dd>
        </dl>
       </p>
       <p>The wal_checkpoint pragma returns a single row with three
        integer columns.  The first column is usually 0 but will be
        1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing,
        for example because another thread or process was actively
        using the database.  In other words, the first column is 0 if the
        equivalent call to [a href="c3ref/wal_checkpoint_v2.htm?"]sqlite3_wal_checkpoint_v2()[/a] [not implemented] would have returned
        <a href="sqlconst.htm#SQLITE_OK">SQLITE_OK</a> or 1 if the equivalent call would have returned 
        <a href="sqlconst.htm#SQLITE_BUSY">SQLITE_BUSY</a>.
        The second column is the number of modified pages that have been
        written to the write-ahead log file.
        The third column is the number of pages in the write-ahead log file
        that have been successfully moved back into the database file at
        the conclusion of the checkpoint.
       The second and third column are -1 if there is no
        write-ahead log, for example if this pragma is invoked on a database
        connection that is not in WAL mode.
       </p>

    <a name="pragma_writable_schema"></a>
       <h _id=pragma_writable_schema style="display:none"> PRAGMA writable_schema</h>
       <hr>
       <p><b>PRAGMA writable_schema  = </b><i>boolean</i><b>;</b></p>
       <p>When this pragma is on, the SQLITE_MASTER tables in which database
        can be changed using ordinary <a href="sqlite3_lang_update.htm">UPDATE</a>, 
        <a href="sqlite3_lang_insert.htm">INSERT</a>, and 
        <a href="sqlite3_lang_delete.htm">DELETE</a>
        statements.
        <span style='background-color: #ffff60;'><b>Warning:</b>
        misuse of this pragma can easily result in corrupt database file.
        </span>
       </p>
       <hr>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
