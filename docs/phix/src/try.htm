A new construct is to be added to the language: 
try 
   <block> 
catch e 
   <block> 
end try 


 In addition there will also be a new builtin, throw(atom code). 

The catch statement traps any exception within the try block or any routines it invokes that 
is not first caught by another nested try/catch statement. 
Any exceptions that must be re-thrown must be done so manually.
Unlike other languages there is only one (non-optional) catch clause. 
There are no confusing <i>classes</i> of exceptions, and no implicit
filtering, and hence no unexpected leaks to the outside world.

The exception variable is declared immediately after the catch keyword and is a sequence.
It can be given with any valid identifier as a name, though "e" is usually sufficient.

The sequence e always contains at least an exception code and address, but could also hold 
a routine number/name, and source code line number. The content beyond the first two elements 
may differ between interpreted and compiled applications, and the catch code block should be 
written to cope accordingly. 

Obviously the application will terminate immediately (just like 9/0) should throw() be invoked 
when there is no active handler (try/catch construct) in the current call stack.

I concede. Once I thought of it, catch e ... throw(e) is a fairly compelling argument. 

 Here is a first stab at defining what an exception innards might look like (with something of a Phix bias) 

catch e 

The following constants (automatically defined in psym.e/syminit) can be used to examine the contents of an exception:
1   E_CODE (atom) hardware and operating system exceptions usually have bit #800000000 set, user exceptions can be any atom value, even 0. 
2   E_ADDR (atom) a machine address indicating where the exception ocurred.
3   E_RTN (integer, optional) equivalent to routine_id(), an index to the symbol table identifying the routine.
4   E_LINE (integer, optional) the source code line matching E_ADDR in E_RTN.
5   E_NAME (string|integer, optional) the human-readable name of E_RTN.
6   E_USER (object, optional) user defined/application specific content in e[6..$].

Only the first two elements are guaranteed to be present. Further user-defined elements may also be present. 
There is no upper limit to the length of an exception or the amount of detailed information it can contain, 
however the first five elements have predefined meanings. 

throw(object e, object e6={}) 

 if e6!={} then e must be atom and throw(e,e6) is equivalent to throw({e,-1,-1,-1,-1,e6}), modified as below.
 if e is an atom, throw(e) is equivalent to throw({e,-1,-1,-1,-1}), modifed as below.
 if e is a string, throw(e) is equivalent to throw({0,-1,-1,-1,-1,e}), "" (probably Phix only, and same as throw(0,"string")).
 Otherwise e must be a sequence containing at least the first two elements, E_CODE and E_ADDR, type safe as above and any user-defined data in e[6..$]. 
    if e[E_ADDR] is -1 it is replaced with the return address from the throw() call. 
    if e[E_RTN] is -1 it is replaced with a routine number from the current call stack. 
    if e[E_LINE] is -1 and e[E_ADDR] was -1, then the (new) value of e[ADDR]-1 is mapped to a line number in e[E_RTN] and stored in e[E_LINE]. 
    if e[E_NAME] is -1 and e[E_RTN] was -1, the name is retrieved from the symbol table.
[DEV], however (in Phix) that may be a meaningless ttree index when interpreting and a proper string only when compiled. [DEV] (see what happens during implementation)

Performance/benchmarking note: when interpreting, the first exception may take a few seconds to populate the (entire) symbol table with 
actual identifier names instead of ttree indexes. Deliberately throwing and catching an exception before timing begins may therefore give 
a much more sensible/honest/useful result for per-exception handling overhead.

Note that for hardware and operating system exceptions, e[E_ADDR] may correspond to a machine instruction emitted for the source code line, 
or the first byte of the next line, or somewhere deep in the heart of say kernel32.dll, or part of the internal workings of c_func, and 
therefore (in early versions at least) e[E_LINE] may be quite wrong. Such cases will need to be fixed on an ad hoc basis, either by 
subtracting 1 from e[E_ADDR] for selected e[E_CODE], emitting a judicious nop instruction, or hunting about in the call stack for the first 
thing that makes sense. If all such efforts are in vain, the runtime reserves the right to give up and return a two-element sequence. 
In short, you should not become over-reliant on the optional values e[E_LINE] and e[E_NAME], and do not panic/crash if absent or -1. 
You can however populate a throw() statement with made-up values. If you supply a made-up E_RTN you are also expected to supply a made-up
E_NAME, and likewise with E_ADDR/E_LINE. Note the latter may drift over time, just like a puts(1,"This is line 6170\n") might.

Gosling:
A try statement with a finally block is executed by first executing the try block. Then there is a choice:
    If execution of the try block completes normally, then the finally block is executed, and then there is a choice:
        If the finally block completes normally, then the try statement completes normally.
        If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S.
    If execution of the try block completes abruptly because of a throw of a value V, then there is a choice:
        If the run-time type of V is assignment compatible with a catchable exception class of any catch clause of the try statement, then the first (leftmost) such catch clause is selected. 
        The value V is assigned to the parameter of the selected catch clause, and the Block of that catch clause is executed. Then there is a choice:
            If the catch block completes normally, then the finally block is executed. Then there is a choice:
                If the finally block completes normally, then the try statement completes normally.
                If the finally block completes abruptly for any reason, then the try statement completes abruptly for the same reason.
            If the catch block completes abruptly for reason R, then the finally block is executed. Then there is a choice:
                If the finally block completes normally, then the try statement completes abruptly for reason R.
                If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and reason R is discarded).
        If the run-time type of V is not assignment compatible with a catchable exception class of any catch clause of the try statement, then the finally block is executed. Then there is a choice:
            If the finally block completes normally, then the try statement completes abruptly because of a throw of the value V.
            If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and the throw of value V is discarded and forgotten).
    If execution of the try block completes abruptly for any other reason R, then the finally block is executed, and then there is a choice:
        If the finally block completes normally, then the try statement completes abruptly for reason R.
        If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and reason R is discarded).
