<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">try - TEMP/TEST</h1>
      <div id="mainSection">
A new construct is to be added to the language: 
<pre>
try 
   <block> 
catch e 
   <block> 
end try 
</pre>

In addition there will also be a new builtin, throw(see below). 

The catch statement traps any exception within the try block or any routines it invokes that 
is not first caught by another nested try/catch statement. <br>
Any exceptions that must be re-thrown must be done so manually.<br>
Unlike other languages there is only one (non-optional) catch clause. <br>
There are no confusing <i>classes</i> of exceptions, and no implicit
filtering, and hence no unexpected leaks to the outside world.
<br>
<br>
SUG: try[flag] - if the token immediately following the try keyword is '[', there follows a
flag (compile-time-constant) that dictates whether the try is active. Actually scratch that,
try..catch e "if flag then ?9/0 end if" fulfils the same need much simpler. (recommend that)
The need, fyi, is that live software must be robust whereas developers should be notified of
failures asap - and there should definitely be warnings for "catch <do nothing> end try" - 
at the very least you should quietly log the event, in >=9/10 cases.
<br>
<br>
The exception variable is declared immediately after the catch keyword and is a sequence.<br>
It can be given with any valid identifier as a name, though "e" is usually sufficient.
<br>
<br>
The sequence e always contains at least an exception code and address, but could also hold 
a routine number/name, and source code line number. The content beyond the first two elements 
may differ between interpreted and compiled applications, and the catch code block should be 
written to cope accordingly. 
<br>
<br>
Obviously the application will terminate immediately (just like 9/0) should throw() be invoked 
when there is no active handler (try/catch construct) in the current call stack.
<br>
<br>
I concede. Once I thought of it, catch e ... throw(e) is a fairly compelling argument. 
<br>
<br>
 Here is a first stab at defining what an exception innards might look like (with something of a Phix bias) 
<br>
<br>
catch e 
<br>
<br>
The following constants (automatically defined in psym.e/syminit) can be used to examine the contents of an exception:<br>
1   E_CODE (atom) hardware and operating system exceptions usually have bit #800000000 set, user exceptions can be any atom value, even 0. <br>
2   E_ADDR (atom) a machine address indicating where the exception ocurred.<br>
3   E_RTN (integer, optional) equivalent to routine_id(), an index to the symbol table identifying the routine.<br>
4   E_LINE (integer, optional) the source code line matching E_ADDR in E_RTN.<br>
5   E_NAME (string|integer, optional) the human-readable name of E_RTN.<br>
6   E_USER (object, optional) user defined/application specific content in e[6..$].
<br>
<br>
Only the first two elements are guaranteed to be present. Further user-defined elements may also be present. 
There is no upper limit to the length of an exception or the amount of detailed information it can contain, 
however the first five elements have predefined meanings. 
<br>
<br>
throw(object e, object e6={}) 

<pre>
 if e6!={} then e must be atom and throw(e,e6) is equivalent to throw({e,-1,-1,-1,-1,e6}), modified as below.
 if e is an atom, throw(e) is equivalent to throw({e,-1,-1,-1,-1}), modifed as below.
 if e is a string, throw(e) is equivalent to throw({0,-1,-1,-1,-1,e}), "" (probably Phix only, and same as throw(0,"string")).
 Otherwise e must be a sequence containing at least the first two elements, E_CODE and E_ADDR, type safe as above and any user-defined data in e[6..$]. 
    if e[E_ADDR] is -1 it is replaced with the return address from the throw() call. 
    if e[E_RTN] is -1 it is replaced with a routine number from the current call stack. 
    if e[E_LINE] is -1 and e[E_ADDR] was -1, then the (new) value of e[ADDR]-1 is mapped to a line number in e[E_RTN] and stored in e[E_LINE]. 
    if e[E_NAME] is -1 and e[E_RTN] was -1, the name is retrieved from the symbol table.
</pre>
[DEV], however (in Phix) E_NAME may be a meaningless ttree index when interpreting and a proper string only when compiled. <br>
[DEV] (see what happens during implementation)
<br>
<br>
Performance/benchmarking note: when interpreting, the first exception may take a few seconds to populate the (entire) symbol table with 
actual identifier names instead of ttree indexes. Deliberately throwing and catching an exception before timing begins may therefore give 
a much more sensible/honest/useful result for per-exception handling overhead.
<br>
<br>
Note that for hardware and operating system exceptions, e[E_ADDR] may correspond to a machine instruction emitted for the source code line, 
or the first byte of the next line, or somewhere deep in the heart of say kernel32.dll, or part of the internal workings of c_func, and 
therefore (in early versions at least) e[E_LINE] may be quite wrong. Such cases will need to be fixed on an ad hoc basis, either by 
subtracting 1 from e[E_ADDR] for selected e[E_CODE], emitting a judicious nop instruction, or hunting about in the call stack for the first 
thing that makes sense. If all such efforts are in vain, the runtime reserves the right to give up and return a two-element sequence. 
In short, you should not become over-reliant on the optional values e[E_LINE] and e[E_NAME], and do not panic/crash if absent or -1. 
You can however populate a throw() statement with made-up values. If you supply a made-up E_RTN you are also expected to supply a made-up
E_NAME, and likewise with E_ADDR/E_LINE. Note the latter may drift over time, just like a puts(1,"This is line 6170\n") might.
<br>
<br>
Gosling:
<small>
<pre>
A try statement with a finally block is executed by first executing the try block. Then there is a choice:
    If execution of the try block completes normally, then the finally block is executed, and then there is a choice:
        If the finally block completes normally, then the try statement completes normally.
        If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S.
    If execution of the try block completes abruptly because of a throw of a value V, then there is a choice:
        If the run-time type of V is assignment compatible with a catchable exception class of any catch clause of the try statement, then the first (leftmost) such catch clause is selected. 
        The value V is assigned to the parameter of the selected catch clause, and the Block of that catch clause is executed. Then there is a choice:
            If the catch block completes normally, then the finally block is executed. Then there is a choice:
                If the finally block completes normally, then the try statement completes normally.
                If the finally block completes abruptly for any reason, then the try statement completes abruptly for the same reason.
            If the catch block completes abruptly for reason R, then the finally block is executed. Then there is a choice:
                If the finally block completes normally, then the try statement completes abruptly for reason R.
                If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and reason R is discarded).
        If the run-time type of V is not assignment compatible with a catchable exception class of any catch clause of the try statement, then the finally block is executed. Then there is a choice:
            If the finally block completes normally, then the try statement completes abruptly because of a throw of the value V.
            If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and the throw of value V is discarded and forgotten).
    If execution of the try block completes abruptly for any other reason R, then the finally block is executed, and then there is a choice:
        If the finally block completes normally, then the try statement completes abruptly for reason R.
        If the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and reason R is discarded).
</pre>
</small>
        Of course, each individual phrase/clause/statement is perfectly reasonable, however as a whole it is utterly incomprehensible, quite
        literally almost impossible to remember, and hence extremely difficult to code correctly against.
        <br>
        <br>
        By adopting a simpler scheme with no finally clause and a single catch clause this becomes:
<small>
<pre>
The catch clause is only entered if an exception occurs during the execution of the try block.
(There is no special exception handling within the catch block other than any such already in place before and after the try statement.)
</pre>
</small>
        <br>
        <br>
        This is one way to mimic a finally block:
<pre>
bool rethrow = False
sequence esave
try 
   <block> 
catch e 
   ...
   if <condition> then  -- (optional)
      rethrow = True
      esave = e
   end if
   ...
end try 
the <finally> block (containing another try block if necessary)
if rethrow then
   throw(esave)
end if
</pre>
        Note that when another try block exists, whether esave is overwritten is entirely dependent on any condition (if any) explicitly 
        coded within the secondary catch block, and indeed whether exceptions in the finally block are rethrown or quietly ignored is also 
        completely your decision (provided that secondary/nested try block exists).
        <br>
        <br>
        Technicalia:<br>
        A new field is required in every frame on the call stack to contain the address of the exception handler. Obviously NULL means
        there is no handler, but also the special value 1 means there is one somewhere lower down the stack (so we need to issue fake
        opRetf until we reach it). opFrame will be responsible for setting that 0/1 on all new frames. I expect most of the support 
        code will live in builtins\VM\pStack.e, plus FEH.e will also contain a quick test on the new field to decide whether to invoke 
        ehandler or fehDiag.
        <br>
        <br>
        Every try statement will create a new unnamed local temporary to faciliate the save/restore of the exception handler field, as
        needed to cope with nested exception handlers.
        <br>
        <br>
<pre>
        opTry -> atom tmpNN := [ebp+NN];
                 [ebp+NN] := addr(:catchNN);
        opCatch -> :catchNN
                      [ebp+NN] := tmpNN;
                      e := eax;
        opEndTry -> [ebp+NN] := tmpNN;
</pre>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
