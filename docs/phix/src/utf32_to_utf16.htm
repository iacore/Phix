<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">utf32_to_utf16</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
            <a href="html/glossary.htm#dwordseq">dword_sequence</a> utf16 = <span class="illegal">utf32_to_utf16</span>(<a href="sequence.htm">sequence</a> utf32)
            <br>
            <i>-- or --</i>
            <br>
            <a href="html/glossary.htm#dwordseq">dword_sequence</a> utf16 = <span class="illegal">utf8_to_utf16</span>(<a href="string.htm">string</a> utf8)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Convert a UTF-32 sequence to UTF-16.
            <br>
            <br>
            Returns a <a href="html/glossary.htm#dwordseq">dword_sequence</a>.
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
          <b>Not supported</b>, mainly since I cannot think of any good reason to support utf16 in a browser &#1F600;.<br>
            It would probably be fairly easy, apart from the fact that p2js.js (now) uses codePointAt() in preference to charCodeAt().<br>
            The routine is coloured illegal in Edita/Edix to remind you that an if platform()!=JS guard is needed, but it is still valid.
         </td>
        </tr>
        <tr>
         <td>
          <b>Comments:</b>
         </td>
         <td>
            The input should not contain any elements outside the range 0..#10FFFF, or values in the range 
            #D800..#DFFF (since that range is reserved, across the board, for UTF-16 surrogate pairs). Any 
            such values are replaced with the element value #FFFD. Obviously the output can be chock-full
            of (matching) surrogate pairs.
            <br>
            <br>
            Unlike <a href="utf32_to_utf8.htm">utf32_to_utf8</a>() there is no optional fail_flag, and when 
            necessary you must manually check for any #FFFD in the return, rather than a return of -1.
            <br>
            <br>
            Note, however, the input can legally contain #FFFD, which are returned unaltered, so technically 
            it is more #FFFD in the output than were in the input that constitutes an error.
            <br>
            <a name="utf8_to_utf16"></a>
            <br>
            The function <span class="illegal">utf8_to_utf16</span>() is a simple wrapper that returns 
            <span class="illegal">utf32_to_utf16</span>(<a href="utf8_to_utf32.htm">utf8_to_utf32</a>()).
         </td>
        </tr>
        <tr>
         <td>
          <b>See Also:</b>
         </td>
         <td>
          <a href="utfconv.htm">utfconv</a>,
          <a href="utf32_to_utf8.htm">utf32_to_utf8</a>,
          <a href="utf8_to_utf32.htm">utf8_to_utf32</a>,
          <a href="utf16_to_utf32.htm">utf16_to_utf32</a>
         </td>
        </tr>
       </table>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
