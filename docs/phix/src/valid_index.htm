<head>
 <body>
  <toc>
   <these>
    <get>
     <stripped>
      <h1 class="title">valid_index</h1>
      <div id="mainSection">
       <table>
        <col style="width: 5%"/>
        <tr>
         <td>
          <b>Definition:</b>
         </td>
         <td>
         <a href="integer.htm#bool">bool</a> res = valid_index(<a href="sequence.htm">sequence</a> s, <a href="object.htm">object</a> idx)
         </td>
        </tr>
        <tr>
         <td>
          <b>Description:</b>
         </td>
         <td>
            Simple check whether idx can legally be used to subscript s. Should this routine return <a href="logicops.htm#tf">false</a>, 
            attempts to do so would raise an exception (probably<small><sup>2</sup></small>).
            <br>
            <br>
            s: the <a href="sequence.htm">sequence</a> for which the index is to be checked.<br>
            idx: the proposed subscript.
            <br>
            <br>
            Negative subscripts are supported, idx is checked to be an <a href="integer.htm">integer</a> in the range 1 to length(s) or 
            it&rsquo;s negative counterpart (which subscripts right/last to left/first). Note that while Euphoria allows fractional
            subscripts (truncating them), Phix does not<sup><small>1</small></sup>, forcing you to either truncate or round them as 
            appropriate first, since it would rather not guess and (at least sometimes, and possibly more often given Phix permits 
            -ve idx whereas Eu does not) inevitably be wrong.
            <br>
            <br>
            <small>
            <small><sup>1</sup></small> Currently rather weakly/sporadically enforced in 1.x<small><sup>2</sup></small>, will be 
            more strictly prohibited in 2.x - one thing earmarked for improvement is subscript performance, and if not permitting 
            fractional indices helps in any way (speed / less ARM assembly / less testing), I&rsquo;m taking it.<br>
            Genrerally speaking, subscripts in Phix are fine and pretty fast, and not something you should try and avoid, it&rsquo;s 
            just that some other languages do them better, in particular those that only permit homogenous arrays (and as it happens
            only integer subscripts). In fact, subscripting in Phix already seriously outperforms that in say JavaScript and Python. 
            The two planned improvements are: <br>
            a) spot when a sequence is or can be flagged as homogenous, and <br>
            b) better register allocation, and should I want to put a subscript in a CPU register, 
            for any gain it&rsquo;d jolly well better be an integer.
            <br>
            <br>
            <small><sup>2</sup></small> For an example, s[i/3] (when i is 4) tends to blow up, whereas s[1.333] doesn&rsquo;t - which 
            can hardly be described as consistent behaviour, and is clearly something 2.x should address. Obviously a calculated 
            subscript of 1.333 strongly suggests a logic error in the code.<br>
            </small>
         </td>
        </tr>
        <tr>
         <td>
          <a href="p2js.htm"><span class="pwap2js"><b>pwa/p2js:</b></span></a>
         </td>
         <td>
          Supported.
         </td>
        </tr>
        <tr>
         <td>
          <b>Implementation:</b>
         </td>
         <td>
            See builtins\pseqc.e (an autoinclude) for details of the actual implementation (which is pretty trivial, but sometimes quite handy).
         </td>
        </tr>
       </table>
      </div>
     </stripped>
    </get>
   </these>
  </toc>
 </body>
</head>
