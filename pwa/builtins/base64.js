// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\base64.e (an autoinclude)
// =================
//
//   Base 64 Encoding and Decoding
//
//   Author: Pete Lomax, July 3rd 2002
//
//   Base64 is used to encode binary data into ASCII strings, allowing transmission
//   of binary data over media designed to transmit text data only. See the RFC 2045 
//   standard and http://en.wikipedia.org/wiki/Base64 and for more information.
//
//#
//# Pad character is '=' (61)
//#
//# encoded lines should be no more than 76 characters long.
//#
//# Base 64 has been chosen (in RFC 2045) since
//#
//#    256^3 = 16777216 = 64^4
//# 
//# hence every 3 input characters can be represented by 4 encoded,
//# and vice versa.
//# If length(s) mod 3 = 0 no padding.
//# If length(s) mod 3 = 1 code with two bytes and pad with two 
//# If length(s) mod 3 = 2 code with three bytes and pad with one
//#
//# For each set of three input characters:
//#    (from writing out the bits longhand)
//#
//# out[1]=                    src[1]/4
//# out[2]=src[1] rem 4 * 16 + src[2]/16
//# out[3]=src[2] rem 16 * 4 + src[3]/64
//# out[4]=src[3] rem 64 * 1 
//#
//#
//# When decoding the last four characters,
//# if byte(3) = pad then length = 1 
//# else if byte(4) = pad then length = 2 
//# else length = 3
//#
//# For each set of four input characters:
//#    (from writing out the bits longhand)
//#
//# out[1]=src[1]        * 4  + src[2]/16
//# out[2]=src[2] rem 16 * 16 + src[3]/4     
//# out[3]=src[3] rem  4 * 64 + src[4]
//#
let /*bool*/ $base64_init = false;
let /*sequence*/ $aleph;
let /*sequence*/ $ccha; // inverted decode table
function $init_base64() {
    $aleph = ["sequence",0X41,0X42,0X43,0X44,0X45,0X46,0X47,0X48,0X49,0X4A,0X4B,0X4C,0X4D,0X4E,0X4F,0X50,0X51,0X52,0X53,0X54,0X55,0X56,0X57,0X58,0X59,0X5A,0X61,0X62,0X63,0X64,0X65,0X66,0X67,0X68,0X69,0X6A,0X6B,0X6C,0X6D,0X6E,0X6F,0X70,0X71,0X72,0X73,0X74,0X75,0X76,0X77,0X78,0X79,0X7A,0X30,0X31,0X32,0X33,0X34,0X35,0X36,0X37,0X38,0X39,0X2B,0X2F];
    //#
    //# invert $aleph to a decode table
    //#
    $ccha = repeat(0,256);
    for (let i=1, i$lim=length($aleph); i<=i$lim; i+=1) {
        $ccha = $repe($ccha,$subse($aleph,i),i-1);
    }
    $base64_init = true;
}

/*global*/ function encode_base64(/*sequence*/ src, /*integer*/ wrap_column=0) {
//
// encodes to base64.
//
// The src parameter should be a string or sequence of bytes, ie no float/string/sequence elements
// The result should be broken into lines of no more than 76 characters before transmission.
//
    let /*sequence*/ ediv = ["sequence",4, 16, 64, 0], 
                     erem = ["sequence",0, 4, 16, 64], 
                     emul = ["sequence",0, 16, 4, 1], 
                     nc4 = ["sequence",2, 3, 4, 1],  //# 1234123412341234...
                     next = ["sequence",1, 1, 1, 0]; //# increment by 3 every 4 iterations
    if (!$base64_init) { $init_base64(); }
    //#
    //# start with a full-length sequence of pads;
    //# then decrement oidx to leave rqd pads in place
    //#
    let /*integer*/ len = length(src), 
                    oidx = floor((len+2)/3)*4;
    let /*string*/ result = repeat(0X3D,oidx);
    if (!equal(remainder(len,3),0)) {
        oidx = (oidx+remainder(len,3))-3;
    }
    let /*integer*/ case4 = 1, 
                    sdx = 1, 
                    prev, tmp;
    for (let i=1, i$lim=oidx; i<=i$lim; i+=1) {
        //#
        //# out[1]=                    src[1]/4
        //# out[2]=src[1] rem 4 * 16 + src[2]/16
        //# out[3]=src[2] rem 16 * 4 + src[3]/64
        //# out[4]=src[3] rem 64 * 1 
        //#
        //# ediv = {4,16,64, 0}
        //# erem = {0, 4,16,64}
        //# emul = {0,16, 4, 1}
        //#
        tmp = 0;
        if (compare($subse(ediv,case4),0)>0 && sdx<=len) {
            let /*integer*/ ch = $subse(src,sdx);
            if (ch<0 || ch>0xFF) { crash("9/0"); } // bytes only!
            tmp = floor(ch/$subse(ediv,case4));
        }
        if (compare($subse(erem,case4),0)>0) {
            tmp += remainder(prev,$subse(erem,case4))*$subse(emul,case4);
        }
        result = $repe(result,i,$subse($aleph,tmp+1)); //# and encode it
        if (sdx<=len) {
            prev = $subse(src,sdx);
        }
        sdx += $subse(next,case4);
        case4 = $subse(nc4,case4);
    }
    if (wrap_column>0) {
        len = length(result);
        let /*integer*/ start = 1;
        if (len>wrap_column) {
            let /*sequence*/ chunks = ["sequence"];
            while (1) {
                if (len<=wrap_column) {
                    chunks = append(chunks,$subss(result,start,-1));
                    break;
                }
                tmp = start;
                start += wrap_column;
                chunks = append(chunks,$subss(result,tmp,start-1));
                len -= wrap_column;
            }
            result = join(chunks,"\r\n");
        }
    }
    return result;
}

/*global*/ function decode_base64(/*sequence*/ src) {
//
// decodes from base64.
//
// The src parameter should be a string or sequence of characters with a length 
//  which is a multiple of 4 between 4 and 76 (inclusive).
//
// The result is a string, but it may contain binary rather than text.
//
// Note: As per RFC2045, lines should not exceed 76 characters.
//  Joining received encoded lines and passing the lot to decode() in one go
//  should be expected to be a little slower than passing individual lines 
//  and joining the results from decode() - simply because the decoded form 
//  is 3/4 or 75% of the size of the encoded form. However there may be cases
//  such as splitting an already joined line, that tip things the other way.
//
    let /*sequence*/ drem = ["sequence",64, 16, 4], 
                     dmul = ["sequence",4, 16, 64], 
                     ddiv = ["sequence",16, 4, 1], 
                     nc3 = ["sequence",3, 1, 2],  //# 321321321321...
                     ldrop = ["sequence",2, 1, 1]; //# to drop len by 4 every 3 output
    if (!$base64_init) { $init_base64(); }
    src = substitute_all(src,["sequence","\r\n","\r","\n"],["sequence","","",""]);
    let /*integer*/ len = length(src);
    if (!equal(remainder(len,4),0)) { crash("9/0"); }
    let /*integer*/ oidx = (len/4)*3, 
                    case3 = 3, tmp;
    while (equal($subse(src,len),0X3D)) { //# should only happen 0 1 or 2 times
        oidx -= 1;
        case3 = $subse(nc3,case3);
        len -= 1;
    }
    let /*string*/ result = repeat(0X3F,oidx);
    for (let i=oidx; i>=1; i-=1) {
        //#
        //# out[1]=src[1]        * 4  + src[2]/16
        //# out[2]=src[2] rem 16 * 16 + src[3]/4     
        //# out[3]=src[3] rem  4 * 64 + src[4]
        //#
        //# drem = {64,16, 4}
        //# dmul = { 4,16,64}
        //# ddiv = {16, 4, 1}
        //#
        tmp = remainder($subse($ccha,$subse(src,len-1)),$subse(drem,case3))*$subse(dmul,case3);
        tmp += floor($subse($ccha,$subse(src,len))/$subse(ddiv,case3));
        result = $repe(result,i,tmp);
        len -= $subse(ldrop,case3);
        case3 = $subse(nc3,case3);
    }
    return result;
}
/*
just some quick tests:
sequence s, e, d
s = sq_sub(sq_rand(repeat(256,10000)),1)    -- NB: 0..255 only
e = encode_base64(s,76)
d = decode_base64(e)
if d!=s then ?9/0 end if
e = encode_base64(tagset(54))
?e
?length(e)

for i=1 to 57 do
    s = tagset(i)
    e = encode_base64(s)
    d = decode_base64(e)
    if d!=s then ?9/0 end if
end for
*/
