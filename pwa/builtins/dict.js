// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\dict.e
// ===============
//
//  The Phix implementation of dictionaries aka associative arrays.
//
// See demo\rosetta\AVL_tree.exw for a slightly longer but perhaps more readable version.
//  (I stripped the comments here because no way am I maintaining them in parallel...)
// Unlike the above, this allows multiple dictionaries ([tid] has appeared everwhere).
//
//without debug -- showing a massive "trees" in ex.err files is not normally helpful!
const $KEY = 0,
      $DATA = 1,
      $LEFT = 2,
      $HEIGHT = 3, // (NB +/-1 gives $RIGHT/$LEFT)
      $RIGHT = 4
let /*sequence*/ $trees, 
                 $treenames, 
                 $roots, 
                 $sizes, 
                 $defaults, 
                 $freelists;
let /*integer*/ $free_trees = 0, 
                $init_dict = 0;
function $dict_init() {
    $trees = ["sequence",["sequence"]];
//  $trees = repeat(repeat(0,0),0)
    $treenames = ["sequence","1"];
    $roots = ["sequence",0];
    $sizes = ["sequence",0];
    $defaults = ["sequence",NULL];
    $freelists = ["sequence",0];
    $init_dict = 1;
}
//DEV/SUG: (requires forward type [erm, may already be working, just not yet tried in psym/init]) ...needs MARKTYPES...
/*global*/ function $dictionary(/*integer*/ tid) {
    return (tid===1) || ((($init_dict && tid>=1) && compare(tid,length($roots))<=0) && sequence($subse($trees,tid)));
//  return tid=1 or ($init_dict and tid>=1 and tid<=length($roots))
}

/*global*/ function is_dict(/*object*/ tid) {
    return (equal(tid,1)) || (((($init_dict && integer(tid)) && compare(tid,1)>=0) && compare(tid,length($roots))<=0) && sequence($subse($trees,tid)));
//  return tid=1 or ($init_dict and integer(tid) and tid>=1 and tid<=length($roots))
}
function $check_tid(/*integer*/ tid) {
//28/10/20: (even though p2js.js may yet choose a completely different approach for dictionaries...)
    if (!is_dict(tid)) { crash("invalid $dictionary id (%d)",["sequence",tid],3); }
//  if not is_dict(tid) then
//      #ilASM{ mov ecx,2           -- no of frames to pop to obtain an era (>=2)
//              mov al,56           -- e56idi (invalid $dictionary id)
//              jmp :!fatalN        -- fatalN(level,errcode,ep1,ep2)
//            }
//  end if
    if (!$init_dict) { $dict_init(); }
}
function $newNode(/*object*/ key, /*object*/ data, /*integer*/ tid) {
    let /*integer*/ node = $subse($freelists,tid);
    if (node===0) {
//p2js: (NOT QUITE SURE HERE...)
 /*
        node = length($trees[tid])+1
--      $trees[tid] &= {key,data,NULL,1,NULL}
        -- much faster:
        $trees[tid] = append($trees[tid],key)
        $trees[tid] = append($trees[tid],data)
        $trees[tid] = append($trees[tid],NULL)
        $trees[tid] = append($trees[tid],1)
        $trees[tid] = append($trees[tid],NULL)
*/ 
        // no measurable gain:
        let /*sequence*/ treet = $subse($trees,tid);
        if (equal(length(treet),0)) {
            treet = ["sequence",key,data,NULL,1,NULL];
            node = 1;
        } else {
            $trees = $repe($trees,tid,0);
            treet = append(treet,key);
            node = length(treet);
            treet = append(treet,data);
            treet = append(treet,NULL);
            treet = append(treet,1);
            treet = append(treet,NULL);
        }
        $trees = $repe($trees,tid,treet);
//      node = length(treet)
    } else {
        $freelists = $repe($freelists,tid,$subse($subse($trees,tid),node));
        $trees = $repss($trees,node+$KEY,node+$RIGHT,["sequence",key,data,NULL,1,NULL],["sequence",tid]);
    }
    $sizes = $repe($sizes,tid,$subse($sizes,tid)+(1));
    return node;
}
function $height(/*integer*/ node, /*integer*/ branch, /*integer*/ tid) {
    node = $subse($subse($trees,tid),node+branch);
    return ((node===NULL) ? 0 : $subse($subse($trees,tid),node+$HEIGHT));
}
function $setHeight(/*integer*/ node, /*integer*/ tid) {
    $trees = $repe($trees,node+$HEIGHT,max($height(node,$LEFT,tid),$height(node,$RIGHT,tid))+1,["sequence",tid]);
}
function $rotate(/*integer*/ node, /*integer*/ direction, /*integer*/ tid) {
    let /*integer*/ idirection = ($LEFT+$RIGHT)-direction, 
                    pivot = $subse($subse($trees,tid),node+idirection), 
                    temp2 = $subse($subse($trees,tid),pivot+direction);
    $trees = $repe($trees,pivot+direction,node,["sequence",tid]);
    $trees = $repe($trees,node+idirection,temp2,["sequence",tid]);
    $setHeight(node,tid);
    $setHeight(pivot,tid);
    return pivot;
}
function $getBalance(/*integer*/ N, /*integer*/ tid) {
    return ((N===NULL) ? 0 : $height(N,$LEFT,tid)-$height(N,$RIGHT,tid));
}
function $insertNode(/*integer*/ node, /*object*/ key, /*object*/ data, /*integer*/ tid) {
    if (node===NULL) {
        return $newNode(key,data,tid);
    }
    let /*integer*/ c = compare(key,$subse($subse($trees,tid),node+$KEY));
    if (c===0) {
        $trees = $repe($trees,node+$DATA,data,["sequence",tid]);
    } else {
        let /*integer*/ direction = $HEIGHT+c; // $LEFT or $RIGHT
//15/7/22 while apparently not actually needed[?], we may as well copy the AVL bugfix:
//      $trees[tid][node+direction] = $insertNode($trees[tid][node+direction], key, data, tid)
        let /*atom*/ tnd = $insertNode($subse($subse($trees,tid),node+direction),key,data,tid);
        $trees = $repe($trees,node+direction,tnd,["sequence",tid]);
        $setHeight(node,tid);
        let /*integer*/ balance = trunc($getBalance(node,tid)/2); // +/-1 (or 0)
        if (balance) {
            direction = $HEIGHT-balance; // $LEFT or $RIGHT
            let /*integer*/ child = $subse($subse($trees,tid),node+direction);
            c = compare(key,$subse($subse($trees,tid),child+$KEY));
            if (c===balance) {
                $trees = $repe($trees,node+direction,$rotate(child,direction,tid),["sequence",tid]);
            }
            if (c!==0) {
                node = $rotate(node,($LEFT+$RIGHT)-direction,tid);
            }
        }
    }
    return node;
}

/*global*/ function setd(/*object*/ key, /*object*/ data, /*integer*/ tid=1) {
    $check_tid(tid);
    $roots = $repe($roots,tid,$insertNode($subse($roots,tid),key,data,tid));
}
let putd = setd;
//4/11/22 now properly aliased in psym.e, in a way that p2js understands
//global procedure putd(object key, object data, integer tid=1)
//--21/10/21...
//--    setd(key, data, tid=1)
//  setd(key, data, tid)
//end procedure

// (old name) now handled via psym.e/syminit()/Alias():
//global procedure putd(object key, object data, integer tid=1)
//  $roots[tid] = $insertNode($roots[tid], key, data, tid)
//end procedure

/*global*/ function setd_default(/*object*/ o, /*integer*/ tid) {
    $check_tid(tid);
    $defaults = $repe($defaults,tid,o);
}
function $getNode(/*integer*/ node, /*object*/ key, dflt, /*integer*/ tid) {
    while (node!==NULL) {
        let /*integer*/ c = compare(key,$subse($subse($trees,tid),node+$KEY));
        if (c===0) { return $subse($subse($trees,tid),node+$DATA); }
        let /*integer*/ direction = $HEIGHT+c; // $LEFT or $RIGHT
        node = $subse($subse($trees,tid),node+direction);
    }
    return dflt;
}

/*global*/ function getd(/*object*/ key, /*integer*/ tid=1) {
    $check_tid(tid);
    return $getNode($subse($roots,tid),key,$subse($defaults,tid),tid);
}

/*global*/ function getdd(/*object*/ key, dflt, /*integer*/ tid=1) {
    $check_tid(tid);
    return $getNode($subse($roots,tid),key,dflt,tid);
}
function $getKey(/*integer*/ node, /*object*/ key, /*integer*/ tid) {
    while (node!==NULL) {
        let /*integer*/ c = compare(key,$subse($subse($trees,tid),node+$KEY));
        if (c===0) { return node; }
        let /*integer*/ direction = $HEIGHT+c; // $LEFT or $RIGHT
        node = $subse($subse($trees,tid),node+direction);
    }
    return NULL;
}

/*global*/ function getd_index(/*object*/ key, /*integer*/ tid=1) {
    $check_tid(tid);
    return $getKey($subse($roots,tid),key,tid);
}

/*global*/ function getd_by_index(/*integer*/ node, /*integer*/ tid=1) {
    $check_tid(tid);
    if (node===0) { return 0; }
    return $subse($subse($trees,tid),node+$DATA);
}
function $minValueNode(/*integer*/ node, tid, direction) {
    while (1) {
        let /*integer*/ next = $subse($subse($trees,tid),node+direction);
        if (next===NULL) { break; }
        node = next;
    }
    return node;
}
function $deleteNode(/*integer*/ root, /*object*/ key, /*integer*/ tid) {
    if (root===NULL) { return root; }
    let /*integer*/ c = compare(key,$subse($subse($trees,tid),root+$KEY)), 
                    left = $subse($subse($trees,tid),root+$LEFT), 
                    right = $subse($subse($trees,tid),root+$RIGHT);
    if (c===-1) {
        $trees = $repe($trees,root+$LEFT,$deleteNode(left,key,tid),["sequence",tid]);
    } else if (equal(c,+1)) {
        $trees = $repe($trees,root+$RIGHT,$deleteNode(right,key,tid),["sequence",tid]);
    } else if ((left===NULL) || (right===NULL)) {
        let /*integer*/ temp = ((left) ? left : right);
        if (temp===NULL) {  // No child case
            [,temp,root] = ["sequence",root,NULL];
        } else {
                            // One child case
            $trees = $repss($trees,root+$KEY,root+$RIGHT,$subss($subse($trees,tid),temp+$KEY,temp+$RIGHT),["sequence",tid]);
        }
        $trees = $repe($trees,temp+$KEY,$subse($freelists,tid),["sequence",tid]);
//4/2/21: (no gain, but left in)
        $trees = $repe($trees,temp+$DATA,NULL,["sequence",tid]);
        $freelists = $repe($freelists,tid,temp);
        $sizes = $repe($sizes,tid,$subse($sizes,tid)-(1));
    } else {
                            // Two child case
        let /*integer*/ temp = $minValueNode(right,tid,$LEFT);
        key = $subse($subse($trees,tid),temp+$KEY);
        $trees = $repe($trees,root+$KEY,key,["sequence",tid]);
//bugfix 29/1/21:
        $trees = $repe($trees,root+$DATA,$subse($subse($trees,tid),temp+$DATA),["sequence",tid]);
        $trees = $repe($trees,root+$RIGHT,$deleteNode(right,key,tid),["sequence",tid]);
    }
    if (root===NULL) { return root; }
    $setHeight(root,tid);
    let /*integer*/ balance = trunc($getBalance(root,tid)/2);
    if (balance) {
        let /*integer*/ direction = $HEIGHT-balance;
        c = compare($getBalance($subse($subse($trees,tid),root+direction),tid),0);
        if (c===-balance) {
            $trees = $repe($trees,root+direction,$rotate($subse($subse($trees,tid),root+direction),direction,tid),["sequence",tid]);
        }
        root = $rotate(root,($LEFT+$RIGHT)-direction,tid);
    }
    return root;
}

/*global*/ function deld(/*object*/ key, /*integer*/ tid=1) {
    $check_tid(tid);
    $roots = $repe($roots,tid,$deleteNode($subse($roots,tid),key,tid));
}
function $traverse(/*integer*/ node, /*integer*/ rid, /*object*/ user_data, /*integer*/ tid, /*bool*/ rev) {
    let /*object*/ tt = $subse($trees,tid), 
                   key = $subse(tt,node+$KEY), 
                   data = $subse(tt,node+$DATA);
    let /*integer*/ left = $subse(tt,node+$LEFT), 
                    right = $subse(tt,node+$RIGHT);
    tt = 0;
    if (rev) {
        [,left,right] = ["sequence",right,left];
    }
    if (left!==NULL) {
        if (equal($traverse(left,rid,user_data,tid,rev),0)) { return 0; }
    }
    if (equal(call_func(rid,["sequence",key,data,user_data]),0)) { return 0; }
    if (right!==NULL) {
        if (equal($traverse(right,rid,user_data,tid,rev),0)) { return 0; }
    }
    return 1;
}

/*global*/ function traverse_dict(/*integer*/ rid, /*object*/ user_data=0, /*integer*/ tid=1, /*bool*/ rev=false) {
    $check_tid(tid);
    if (!equal($subse($roots,tid),0)) {
        /*[,] =*/ $traverse($subse($roots,tid),rid,user_data,tid,rev);
    }
}
function $traverse_key(/*integer*/ node, /*integer*/ rid, /*object*/ pkey, /*object*/ user_data, /*integer*/ tid, /*bool*/ rev) {
    let /*object*/ tt = $subse($trees,tid), 
                   key = $subse(tt,node+$KEY), 
                   data = $subse(tt,node+$DATA);
    let /*integer*/ left = $subse(tt,node+$LEFT), 
                    right = $subse(tt,node+$RIGHT), 
                    c = compare(key,pkey);
    tt = 0;
    if (rev) {
        [,left,right] = ["sequence",right,left];
        c = -c;
    }
    if ((left!==NULL) && c>0) {
        if (equal($traverse_key(left,rid,pkey,user_data,tid,rev),0)) { return 0; }
    }
    if (c>=0) {
        if (equal(call_func(rid,["sequence",key,data,pkey,user_data]),0)) { return 0; }
    }
    if (right!==NULL) {
        if (equal($traverse_key(right,rid,pkey,user_data,tid,rev),0)) { return 0; }
    }
    return 1;
}

/*global*/ function traverse_dict_partial_key(/*integer*/ rid, /*object*/ pkey, /*object*/ user_data=0, /*integer*/ tid=1, /*bool*/ rev=false) {
    $check_tid(tid);
    if (!equal($subse($roots,tid),0)) {
        /*[,] =*/ $traverse_key($subse($roots,tid),rid,pkey,user_data,tid,rev);
    }
}
//object gpk    -- NB not thread safe!

//function gpk_visitor(object key, object /*data*/, object /*pkey*/, object /*user_data=-2*/)
//  gpk = key
//  return 0    -- stop!
//end function
//constant r_gpkv = routine_id("gpk_visitor")
function $traverser(/*sequence*/ res, /*integer*/ node, /*bool*/ partial, /*object*/ pkey, /*integer*/ tid, /*bool*/ rev, bKeys=true) {
    if (node!==NULL) {
        let /*object*/ tt = $subse($trees,tid), 
                       key = $subse(tt,node+$KEY), 
                       data = $subse(tt,node+$DATA);
        let /*integer*/ left = $subse(tt,node+$LEFT), 
                        right = $subse(tt,node+$RIGHT);
        tt = 0;
        let /*integer*/ c = ((partial) ? compare(key,pkey) : 0);
        if (rev) {
            [,left,right] = ["sequence",right,left];
        }
        if (left!==NULL) {
            res = $traverser(res,left,partial,pkey,tid,rev,bKeys);
        }
        if (c>=0 && (!partial || (equal(length(res),0)))) {
            res = append(res,((bKeys) ? key : data));
        }
        if ((right!==NULL) && (!partial || (equal(length(res),0)))) {
            res = $traverser(res,right,partial,pkey,tid,rev,bKeys);
        }
    }
    return res;
}

/*global*/ function getd_partial_key(/*object*/ pkey, /*integer*/ tid=1, /*bool*/ rev=false) {
    $check_tid(tid);
//if 0 then
//  gpk = $defaults[tid]
//  if $roots[tid]!=0 then
//      {} = $traverse_key($roots[tid], r_gpkv, pkey, NULL, tid, rev, bKeys)
//  end if
//  return gpk
//end if
    let /*object*/ res = $traverser(["sequence"],$subse($roots,tid),true,pkey,tid,rev);
    if (length(res)) {
        res = $subse(res,1);
    } else {
        res = $subse($defaults,tid);
    }
    return res;
}

/*global*/ function getd_all_keys(/*integer*/ tid=1, /*bool*/ bKeys=true) {
    $check_tid(tid);
//p2js:
//  return $traverser({}, $roots[tid], false, NULL, tid, false)
    let /*sequence*/ res = ["sequence"];
    res = $traverser(res,$subse($roots,tid),false,NULL,tid,false,bKeys);
    return res;
}

/*global*/ function dict_size(/*integer*/ tid=1) {
    $check_tid(tid);
    return $subse($sizes,tid);
}
function $peekpop(/*integer*/ tid, /*bool*/ rev, bDelete) {
    let /*integer*/ node = $minValueNode($subse($roots,tid),tid,((rev) ? $RIGHT : $LEFT));
    if (node===0) { return $subse($defaults,tid); }
    let /*object*/ key = $subse($subse($trees,tid),node+$KEY), 
                   data = $subse($subse($trees,tid),node+$DATA);
    if (bDelete) {
        $roots = $repe($roots,tid,$deleteNode($subse($roots,tid),key,tid));
    }
    return ["sequence",key,data];
}

/*global*/ function peep_dict(/*integer*/ tid=1, /*bool*/ rev=false) {
    return $peekpop(tid,rev,false);
}

/*global*/ function pop_dict(/*integer*/ tid=1, /*bool*/ rev=false) {
    return $peekpop(tid,rev,true);
}

/*global*/ function dict_name(/*integer*/ tid=1) {
    $check_tid(tid);
    return $subse($treenames,tid);
}

/*global*/ function named_dict(/*string*/ name) {
    for (let tid=1, tid$lim=length($treenames); tid<=tid$lim; tid+=1) {
        if (equal($subse($treenames,tid),name)) { return tid; }
    }
    return NULL;
}
//--DEV temp: (didn't help...)
//function f(object o) return o end function
//if "abc"="def" then object x=f(1) x=f(1.5); x=f(""); x=f({1,1.5,"",{x}}) end if

/*global*/ function new_dict(/*object*/ kd_pairs=["sequence"], /*integer*/ pool_only=0) {
//if "abc"="def" then object x=f(1) x=f(1.5); x=f(""); x=f({1,1.5,"",{x}}) end if
//kd_pairs = f(kd_pairs)
//pool_only = f(pool_only)
    if (!$init_dict) { $dict_init(); }
    let /*integer*/ tid = $free_trees;
    if (tid!==0) {
        $free_trees = $subse($trees,$free_trees);
        $trees = $repe($trees,tid,["sequence"]);
        $treenames = $repe($treenames,tid,"");
        $roots = $repe($roots,tid,NULL);
        $sizes = $repe($sizes,tid,0);
        $defaults = $repe($defaults,tid,NULL);
        $freelists = $repe($freelists,tid,0);
    } else if (pool_only===0) {
        $trees = append($trees,["sequence"]);
//      $trees = append($trees,repeat(0,0))
        $treenames = append($treenames,"");
        $roots = $conCat($roots, NULL);
        $sizes = $conCat($sizes, 0);
        $defaults = $conCat($defaults, 0);
        $freelists = $conCat($freelists, 0);
        tid = length($trees);
    } else if (pool_only>1) {
        if (length(kd_pairs)) { crash("9/0"); }
        if (!equal(kd_pairs,["sequence"])) { crash("9/0"); }
        for (let i=1, i$lim=pool_only; i<=i$lim; i+=1) {
//25/8/16 (spotted in passing!)
//          $trees = append($trees,{})
            $trees = append($trees,$free_trees);
            $treenames = append($treenames,"");
            $free_trees = length($trees);
            $roots = $conCat($roots, NULL);
            $sizes = $conCat($sizes, 0);
            $defaults = $conCat($defaults, 0);
            $freelists = $conCat($freelists, 0);
        }
    }
    if (string(kd_pairs)) {
        $treenames = $repe($treenames,tid,kd_pairs);
    } else if (sequence(kd_pairs)) {
        for (let i=1, i$lim=length(kd_pairs); i<=i$lim; i+=1) {
            if (!equal(length($subse(kd_pairs,i)),2)) { crash("9/0"); }
            let /*object*/ [,key,data] = $subse(kd_pairs,i);
            setd(key,data,tid);
        }
    } else {
        let /*integer*/ copy_tid = kd_pairs;
        $check_tid(copy_tid);
//      $trees[tid] = $trees[copy_tid]
        $trees = $repe($trees,tid,deep_copy($subse($trees,copy_tid)));
        $freelists = $repe($freelists,tid,$subse($freelists,copy_tid));
        // programming note: the above is not really a copy, but 
        //                   of course the cow-semantics of phix
        //                   leaves one tree/freelist pair as-is
        //                   when the other pair is modified.
        $roots = $repe($roots,tid,$subse($roots,copy_tid));
        $sizes = $repe($sizes,tid,$subse($sizes,copy_tid));
    }
    return tid;
}

/*global*/ function destroy_dict(/*integer*/ tid, /*bool*/ justclear=false) {
//global procedure destroy_dict($dictionary tid, bool justclear=false)
//
// Note: It is (and should be) perfectly legal to destroy_dict(1) at the very start.
//       In contrast, destroy_dict(5) is fatal when 5 is not a valid $dictionary, or
//       (equivalently) was the recent subject of a destroy_dict() call.
//
    $check_tid(tid);
    if ((tid===1) || justclear) {
        // just empty the default, but leave it still available
        // (this also means that new_dict() can never return 1)
        $trees = $repe($trees,tid,["sequence"]);
//      $trees[tid] = repeat(0,0)
        $roots = $repe($roots,tid,NULL);
        $sizes = $repe($sizes,tid,0);
        $defaults = $repe($defaults,tid,NULL);
//      $freelists[tid] = 0
        if (!equal($subse($freelists,tid),0)) { crash("9/0"); }
    } else {
        $trees = $repe($trees,tid,$free_trees);
        $roots = $repe($roots,tid,NULL);
        $sizes = $repe($sizes,tid,0);
        $defaults = $repe($defaults,tid,NULL);
        $free_trees = tid;
        $freelists = $repe($freelists,tid,0);
    }
}

/*global*/ function $destroy_dictf(/*integer*/ tid) {
    destroy_dict(tid);
    return NULL;
}
