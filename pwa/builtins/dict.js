"use strict";
// auto-generated by pwa/p2js.
//
// builtins\dict.e
// ===============
//
//  The Phix implementation of dictionaries aka associative arrays.
//
// See demo\rosetta\AVL_tree.exw for a slightly longer but perhaps more readable version.
//  (I stripped the comments here because no way am I maintaining them in parallel...)
// Unlike the above, this allows multiple dictionaries ([tid] has appeared everwhere).
//
//without debug -- showing a massive "trees" in ex.err files is not normally helpful!
const KEY = 0,
      DATA = 1,
      LEFT = 2,
      HEIGHT = 3, // (NB +/-1 gives RIGHT/LEFT)
      RIGHT = 4
let /*sequence*/ trees, 
                 treenames, 
                 roots, 
                 sizes, 
                 defaults, 
                 freelists;
let /*integer*/ free_trees = 0, 
                initd = 0;
function dinit() {
    trees = ["sequence",["sequence"]];
    treenames = ["sequence","1"];
    roots = ["sequence",0];
    sizes = ["sequence",0];
    defaults = ["sequence",null];
    freelists = ["sequence",0];
    initd = 1;
}
//DEV/SUG: (requires forward type [erm, may already be working, just not yet tried in psym/init]) ...needs MARKTYPES...
/*global*/ /*type dictionary(/!*integer*!/ tid) {
    return (tid===1) || (initd && compare(tid,1)>=0 && compare(tid,length(roots))<=0 && sequence($subse(trees,tid)));
}*/
/*global*/ function is_dict(/*object*/ tid) {
    return (tid===1) || (initd && integer(tid) && compare(tid,1)>=0 && compare(tid,length(roots))<=0 && sequence($subse(trees,tid)));
}
function check(/*integer*/ tid) {
//28/10/20: (even though p2js.js may yet choose a completely different approach for dictionaries...)
    if (!is_dict(tid)) { crash("invalid dictionary id (%d)",["sequence",tid],3); }
//  if not is_dict(tid) then
//      #ilASM{ mov ecx,2           -- no of frames to pop to obtain an era (>=2)
//              mov al,56           -- e56idi (invalid dictionary id)
//              jmp :!fatalN        -- fatalN(level,errcode,ep1,ep2)
//            }
//  end if
    if (!initd) { dinit(); }
}
function newNode(/*object*/ key, /*object*/ data, /*integer*/ tid) {
    let /*integer*/ node = $subse(freelists,tid);
    if (node===0) {
        node = length($subse(trees,tid))+1;
//      trees[tid] &= {key,data,NULL,1,NULL}
        // much faster:
        trees = $repe(trees,tid,append($subse(trees,tid),key));
        trees = $repe(trees,tid,append($subse(trees,tid),data));
        trees = $repe(trees,tid,append($subse(trees,tid),null));
        trees = $repe(trees,tid,append($subse(trees,tid),1));
        trees = $repe(trees,tid,append($subse(trees,tid),null));
        // no measurable gain:
//      sequence treet = trees[tid]
//      trees[tid] = 0
//      treet = append(treet,key)
//      treet = append(treet,data)
//      treet = append(treet,NULL)
//      treet = append(treet,1)
//      treet = append(treet,NULL)
//      trees[tid] = treet
//      node = length(treet)
    } else {
        freelists = $repe(freelists,tid,$subse($subse(trees,tid),node));
        trees = $repss(trees,node+KEY,node+RIGHT,["sequence",key, data, null, 1, null],["sequence",tid]);
    }
    sizes = $repe(sizes,tid,$subse(sizes,tid)+1);
    return node;
}
function height(/*integer*/ node, /*integer*/ branch, /*integer*/ tid) {
    node = $subse($subse(trees,tid),node+branch);
    return ((node===null) ? 0 : $subse($subse(trees,tid),node+HEIGHT));
}
function setHeight(/*integer*/ node, /*integer*/ tid) {
    trees = $repe(trees,node+HEIGHT,max(height(node,LEFT,tid),height(node,RIGHT,tid))+1,["sequence",tid]);
}
function rotate(/*integer*/ node, /*integer*/ direction, /*integer*/ tid) {
    let /*integer*/ idirection = LEFT+RIGHT-direction;
    let /*integer*/ pivot = $subse($subse(trees,tid),node+idirection);
    let /*integer*/ temp2 = $subse($subse(trees,tid),pivot+direction);
    trees = $repe(trees,pivot+direction,node,["sequence",tid]);
    trees = $repe(trees,node+idirection,temp2,["sequence",tid]);
    setHeight(node,tid);
    setHeight(pivot,tid);
    return pivot;
}
function getBalance(/*integer*/ N, /*integer*/ tid) {
    return ((N==null) ? 0 : height(N,LEFT,tid)-height(N,RIGHT,tid));
}
function insertNode(/*integer*/ node, /*object*/ key, /*object*/ data, /*integer*/ tid) {
    if (node==null) {
        return newNode(key,data,tid);
    }
    let /*integer*/ c = compare(key,$subse($subse(trees,tid),node+KEY));
    if (c===0) {
        trees = $repe(trees,node+DATA,data,["sequence",tid]);
    } else {
        let /*integer*/ direction = HEIGHT+c; // LEFT or RIGHT
        trees = $repe(trees,node+direction,insertNode($subse($subse(trees,tid),node+direction),key,data,tid),["sequence",tid]);
        setHeight(node,tid);
        let /*integer*/ balance = trunc(getBalance(node,tid)/2); // +/-1 (or 0)
        if (balance) {
            direction = HEIGHT-balance; // LEFT or RIGHT
            let /*integer*/ child = $subse($subse(trees,tid),node+direction);
            c = compare(key,$subse($subse(trees,tid),child+KEY));
            if (c===balance) {
                trees = $repe(trees,node+direction,rotate(child,direction,tid),["sequence",tid]);
            }
            if (c!==0) {
                node = rotate(node,LEFT+RIGHT-direction,tid);
            }
        }
    }
    return node;
}
/*global*/ function setd(/*object*/ key, /*object*/ data, /*integer*/ tid=1) { // (aka putd)
    check(tid);
    roots = $repe(roots,tid,insertNode($subse(roots,tid),key,data,tid));
}
// (old name) now handled via psym.e/syminit()/Alias():
//global procedure putd(object key, object data, integer tid=1)
//  roots[tid] = insertNode(roots[tid], key, data, tid)
//end procedure
/*global*/ function setd_default(/*object*/ o, /*integer*/ tid) {
    check(tid);
    defaults = $repe(defaults,tid,o);
}
function getNode(/*integer*/ node, /*object*/ key, dflt, /*integer*/ tid) {
    while (node!==null) {
        let /*integer*/ c = compare(key,$subse($subse(trees,tid),node+KEY));
        if (c===0) { return $subse($subse(trees,tid),node+DATA); }
        let /*integer*/ direction = HEIGHT+c; // LEFT or RIGHT
        node = $subse($subse(trees,tid),node+direction);
    }
    return dflt;
}
/*global*/ function getd(/*object*/ key, /*integer*/ tid=1) {
    check(tid);
    return getNode($subse(roots,tid),key,$subse(defaults,tid),tid);
}
/*global*/ function getdd(/*object*/ key, dflt, /*integer*/ tid=1) {
    check(tid);
    return getNode($subse(roots,tid),key,dflt,tid);
}
function getKey(/*integer*/ node, /*object*/ key, /*integer*/ tid) {
    while (node!==null) {
        let /*integer*/ c = compare(key,$subse($subse(trees,tid),node+KEY));
        if (c===0) { return node; }
        let /*integer*/ direction = HEIGHT+c; // LEFT or RIGHT
        node = $subse($subse(trees,tid),node+direction);
    }
    return null;
}
/*global*/ function getd_index(/*object*/ key, /*integer*/ tid=1) {
    check(tid);
    return getKey($subse(roots,tid),key,tid);
}
/*global*/ function getd_by_index(/*integer*/ node, /*integer*/ tid=1) {
    check(tid);
    if (node===0) { return 0; }
    return $subse($subse(trees,tid),node+DATA);
}
function minValueNode(/*integer*/ node, tid, direction) {
    while (1) {
        let /*integer*/ next = $subse($subse(trees,tid),node+direction);
        if (next===null) { break; }
        node = next;
    }
    return node;
}
function deleteNode(/*integer*/ root, /*object*/ key, /*integer*/ tid) {
    let /*integer*/ c, left, right;
    if (root===null) { return root; }
    c = compare(key,$subse($subse(trees,tid),root+KEY));
    left = $subse($subse(trees,tid),root+LEFT);
    right = $subse($subse(trees,tid),root+RIGHT);
    if (c===-1) {
        trees = $repe(trees,root+LEFT,deleteNode(left,key,tid),["sequence",tid]);
    } else if (c===+1) {
        trees = $repe(trees,root+RIGHT,deleteNode(right,key,tid),["sequence",tid]);
    } else if ((left==null) || (right==null)) {
        let /*integer*/ temp = ((left) ? left : right);
        if (temp==null) {   // No child case
            [,temp, root] = ["sequence",root, null];
        } else {
                            // One child case
            trees = $repss(trees,root+KEY,root+RIGHT,$subss($subse(trees,tid),temp+KEY,temp+RIGHT),["sequence",tid]);
        }
        trees = $repe(trees,temp+KEY,$subse(freelists,tid),["sequence",tid]);
//4/2/21: (no gain, but left in)
        trees = $repe(trees,temp+DATA,null,["sequence",tid]);
        freelists = $repe(freelists,tid,temp);
        sizes = $repe(sizes,tid,$subse(sizes,tid)-1);
    } else {
                            // Two child case
        let /*integer*/ temp = minValueNode(right,tid,LEFT);
        key = $subse($subse(trees,tid),temp+KEY);
        trees = $repe(trees,root+KEY,key,["sequence",tid]);
//bugfix 29/1/21:
        trees = $repe(trees,root+DATA,$subse($subse(trees,tid),temp+DATA),["sequence",tid]);
        trees = $repe(trees,root+RIGHT,deleteNode(right,key,tid),["sequence",tid]);
    }
    if (root===null) { return root; }
    setHeight(root,tid);
    let /*integer*/ balance = trunc(getBalance(root,tid)/2);
    if (balance) {
        let /*integer*/ direction = HEIGHT-balance;
        c = compare(getBalance($subse($subse(trees,tid),root+direction),tid),0);
        if (c===-balance) {
            trees = $repe(trees,root+direction,rotate($subse($subse(trees,tid),root+direction),direction,tid),["sequence",tid]);
        }
        root = rotate(root,LEFT+RIGHT-direction,tid);
    }
    return root;
}
/*global*/ function deld(/*object*/ key, /*integer*/ tid=1) {
    check(tid);
    roots = $repe(roots,tid,deleteNode($subse(roots,tid),key,tid));
}
function traverse(/*integer*/ node, /*integer*/ rid, /*object*/ user_data, /*integer*/ tid, /*bool*/ rev) {
    let /*sequence*/ tt = $subse(trees,tid);
    let /*object*/ key = $subse(tt,node+KEY), 
                   data = $subse(tt,node+DATA);
    let /*integer*/ left = $subse(tt,node+LEFT), 
                    right = $subse(tt,node+RIGHT);
    if (rev) {
        [,left, right] = ["sequence",right, left];
    }
    if (left!==null) {
        if (traverse(left,rid,user_data,tid,rev)===0) { return 0; }
    }
    if (call_func(rid,["sequence",key, data, user_data])===0) { return 0; }
    if (right!==null) {
        if (traverse(right,rid,user_data,tid,rev)===0) { return 0; }
    }
    return 1;
}
/*global*/ function traverse_dict(/*integer*/ rid, /*object*/ user_data=0, /*integer*/ tid=1, /*bool*/ rev=false) {
    check(tid);
    if ($subse(roots,tid)!==0) {
        [] = traverse($subse(roots,tid),rid,user_data,tid,rev);
    }
}
function traverse_key(/*integer*/ node, /*integer*/ rid, /*object*/ pkey, /*object*/ user_data, /*integer*/ tid, /*bool*/ rev) {
    let /*sequence*/ tt = $subse(trees,tid);
    let /*object*/ key = $subse(tt,node+KEY), 
                   data = $subse(tt,node+DATA);
    let /*integer*/ left = $subse(tt,node+LEFT), 
                    right = $subse(tt,node+RIGHT);
    let /*integer*/ c = compare(key,pkey);
    if (rev) {
        [,left, right] = ["sequence",right, left];
        c = -c;
    }
    if ((left!==null) && compare(c,0)>0) {
        if (traverse_key(left,rid,pkey,user_data,tid,rev)===0) { return 0; }
    }
    if (compare(c,0)>=0) {
        if (call_func(rid,["sequence",key, data, pkey, user_data])===0) { return 0; }
    }
    if (right!==null) {
        if (traverse_key(right,rid,pkey,user_data,tid,rev)===0) { return 0; }
    }
    return 1;
}
/*global*/ function traverse_dict_partial_key(/*integer*/ rid, /*object*/ pkey, /*object*/ user_data=0, /*integer*/ tid=1, /*bool*/ rev=false) {
    check(tid);
    if ($subse(roots,tid)!==0) {
        [] = traverse_key($subse(roots,tid),rid,pkey,user_data,tid,rev);
    }
}
//object gpk    -- NB not thread safe!
//function gpk_visitor(object key, object /*data*/, object /*pkey*/, object /*user_data=-2*/)
//  gpk = key
//  return 0    -- stop!
//end function
//constant r_gpkv = routine_id("gpk_visitor")
function traverser(/*sequence*/ res, /*integer*/ node, /*bool*/ partial, /*object*/ pkey, /*integer*/ tid, /*bool*/ rev) {
    let /*sequence*/ tt = $subse(trees,tid);
    if (node!==null) {
        let /*object*/ key = $subse(tt,node+KEY), 
                       data = $subse(tt,node+DATA);
        let /*integer*/ left = $subse(tt,node+LEFT), 
                        right = $subse(tt,node+RIGHT);
        let /*integer*/ c = ((partial) ? compare(key,pkey) : 0);
        if (rev) {
            [,left, right] = ["sequence",right, left];
        }
        if (left!==null) {
            res = traverser(res,left,partial,pkey,tid,rev);
        }
        if (compare(c,0)>=0 && (!partial || (length(res)===0))) {
            res = append(res,key);
        }
        if ((right!==null) && (!partial || (length(res)===0))) {
            res = traverser(res,right,partial,pkey,tid,rev);
        }
    }
    return res;
}
/*global*/ function getd_partial_key(/*object*/ pkey, /*integer*/ tid=1, /*bool*/ rev=false) {
    check(tid);
//if 0 then
//  gpk = defaults[tid]
//  if roots[tid]!=0 then
//      {} = traverse_key(roots[tid], r_gpkv, pkey, NULL, tid, rev)
//  end if
//  return gpk
//end if
    let /*object*/ res = traverser(["sequence"],$subse(roots,tid),true,pkey,tid,rev);
    if (length(res)) {
        res = $subse(res,1);
    } else {
        res = $subse(defaults,tid);
    }
    return res;
}
/*global*/ function getd_all_keys(/*integer*/ tid=1) {
    check(tid);
    return traverser(["sequence"],$subse(roots,tid),false,null,tid,false);
}
/*global*/ function dict_size(/*integer*/ tid=1) {
    check(tid);
    return $subse(sizes,tid);
}
function peekpop(/*integer*/ tid, /*bool*/ rev, bDelete) {
    let /*integer*/ node = minValueNode($subse(roots,tid),tid,((rev) ? RIGHT : LEFT));
    if (node===0) { return $subse(defaults,tid); }
    let /*object*/ key = $subse($subse(trees,tid),node+KEY), 
                   data = $subse($subse(trees,tid),node+DATA);
    if (bDelete) {
        roots = $repe(roots,tid,deleteNode($subse(roots,tid),key,tid));
    }
    return ["sequence",key, data];
}
/*global*/ function peep_dict(/*integer*/ tid=1, /*bool*/ rev=false) {
    return peekpop(tid,rev,false);
}
/*global*/ function pop_dict(/*integer*/ tid=1, /*bool*/ rev=false) {
    return peekpop(tid,rev,true);
}
/*global*/ function dict_name(/*integer*/ tid=1) {
    check(tid);
    return $subse(treenames,tid);
}
/*global*/ function named_dict(/*string*/ name) {
    for (let tid=1, tid$lim=length(treenames); tid<=tid$lim; tid+=1) {
        if ($subse(treenames,tid)===name) { return tid; }
    }
    return null;
}
//--DEV temp: (didn't help...)
//function f(object o) return o end function
//if "abc"="def" then object x=f(1) x=f(1.5); x=f(""); x=f({1,1.5,"",{x}}) end if
/*global*/ function new_dict(/*object*/ kd_pairs=["sequence"], /*integer*/ pool_only=0) {
//if "abc"="def" then object x=f(1) x=f(1.5); x=f(""); x=f({1,1.5,"",{x}}) end if
//kd_pairs = f(kd_pairs)
//pool_only = f(pool_only)
    if (!initd) { dinit(); }
    let /*integer*/ tid = free_trees;
    if (tid!==0) {
        free_trees = $subse(trees,free_trees);
        trees = $repe(trees,tid,["sequence"]);
        treenames = $repe(treenames,tid,"");
        roots = $repe(roots,tid,null);
        sizes = $repe(sizes,tid,0);
        defaults = $repe(defaults,tid,null);
        freelists = $repe(freelists,tid,0);
    } else if (pool_only===0) {
        trees = append(trees,["sequence"]);
        treenames = append(treenames,"");
        roots = $conCat(roots, null);
        sizes = $conCat(sizes, 0);
        defaults = $conCat(defaults, 0);
        freelists = $conCat(freelists, 0);
        tid = length(trees);
    } else if (compare(pool_only,1)>0) {
        if (length(kd_pairs)) { crash("9/0"); }
        if (!equal(kd_pairs,["sequence"])) { crash("9/0"); }
        for (let i=1, i$lim=pool_only; i<=i$lim; i+=1) {
//25/8/16 (spotted in passing!)
//          trees = append(trees,{})
            trees = append(trees,free_trees);
            treenames = append(treenames,"");
            free_trees = length(trees);
            roots = $conCat(roots, null);
            sizes = $conCat(sizes, 0);
            defaults = $conCat(defaults, 0);
            freelists = $conCat(freelists, 0);
        }
    }
    if (string(kd_pairs)) {
        treenames = $repe(treenames,tid,kd_pairs);
    } else if (sequence(kd_pairs)) {
        for (let i=1, i$lim=length(kd_pairs); i<=i$lim; i+=1) {
            if (length($subse(kd_pairs,i))!==2) { crash("9/0"); }
            let /*object*/ [,key, data] = $subse(kd_pairs,i);
            setd(key,data,tid);
        }
    } else {
        let /*integer*/ copy_tid = kd_pairs;
        check(copy_tid);
        trees = $repe(trees,tid,$subse(trees,copy_tid));
        freelists = $repe(freelists,tid,$subse(freelists,copy_tid));
        // programming note: the above is not really a copy, but 
        //                   of course the cow-semantics of phix
        //                   leaves one tree/freelist pair as-is
        //                   when the other pair is modified.
        roots = $repe(roots,tid,$subse(roots,copy_tid));
        sizes = $repe(sizes,tid,$subse(sizes,copy_tid));
    }
    return tid;
}
/*global*/ function destroy_dict(/*integer*/ tid, /*bool*/ justclear=false) {
//global procedure destroy_dict(dictionary tid, bool justclear=false)
//
// Note: It is (and should be) perfectly legal to destroy_dict(1) at the very start.
//       In contrast, destroy_dict(5) is fatal when 5 is not a valid dictionary, or
//       (equivalently) was the recent subject of a destroy_dict() call.
//
    check(tid);
    if ((tid===1) || justclear) {
        // just empty the default, but leave it still available
        // (this also means that new_dict() can never return 1)
        trees = $repe(trees,tid,["sequence"]);
        roots = $repe(roots,tid,null);
        sizes = $repe(sizes,tid,0);
        defaults = $repe(defaults,tid,null);
//      freelists[tid] = 0
        if ($subse(freelists,tid)!==0) { crash("9/0"); }
    } else {
        trees = $repe(trees,tid,free_trees);
        roots = $repe(roots,tid,null);
        sizes = $repe(sizes,tid,0);
        defaults = $repe(defaults,tid,null);
        free_trees = tid;
        freelists = $repe(freelists,tid,0);
    }
}

