// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\file_utils.e (an autoinclude)
// =====================
//
// (p2js compatible routines, hand-selected simple string/number manipulatuion only)
//

//DEV needs testing on Linux (get_proper_path)
/*global*/ function get_file_name(/*string*/ path) {
//  if not finit then initf() end if
    path = get_proper_path(path);
    path = $subss(path,rfind(SLASH,path)+1,-1);
    return path;
}

/*global*/ function get_file_extension(/*string*/ filename) {
// treats eg "libglfw.so.3.1" as "libglfw.so" (both yeilding "so"),
//  however "file.1" ==> "1", and "test.part.4.r01" -> "r01".
//  (ie the first example sets extension to "1" then "3" then "so",
//   and carries on looking all the way down to the first 'l'.)
// forwardslash and backslash are handled for all platforms.
// result is lower case (ie "TEST.EXW" and "test.exw" -> "exw")
    let /*string*/ extension = "";
    let /*integer*/ len = length(filename);
    for (let i=len; i>=1; i-=1) {
        let /*integer*/ ch = $subse(filename,i);
        if (ch===0X2E) {
            extension = lower($subss(filename,i+1,len));
            if (length(extension)) {
                let /*bool*/ allnum = true;
                for (let j=length(extension); j>=1; j-=1) {
                    ch = $subse(extension,j);
                    if (ch<0X30 || ch>0X39) {
                        allnum = false;
                        break;
                    }
                }
                if (!allnum) { break; }
            }
            len = i-1;
        } else if (find(ch,`\\/:`)) {
            break;
        }
    }
    return extension;
}
let fileext = get_file_extension;
/*
if get_file_extension("libglfw.so.3.1")!="so" then ?9/0 end if
if get_file_extension("libglfw.so")!="so" then ?9/0 end if
if get_file_extension("file.1")!="1" then ?9/0 end if
if get_file_extension("file.r01")!="r01" then ?9/0 end if
if get_file_extension("file.part.4.r01")!="r01" then ?9/0 end if
if get_file_extension("TEST.EXW")!="exw" then ?9/0 end if
if get_file_extension("test.exw")!="exw" then ?9/0 end if
*/

/*global*/ function get_file_base(/*string*/ path) {
    path = get_file_name(path);
    path = $subss(path,1,find(0X2E,path)-1);
    return path;
}
let filebase = get_file_base;

/*global*/ function get_file_path(/*string*/ path, /*bool*/ dropslash=true) {
//  if not finit then initf() end if
    path = get_proper_path(path);
    return $subss(path,1,rfind(SLASH,path)-dropslash);
}
let pathname = get_file_path;

/*global*/ function get_file_path_and_name(/*string*/ filepath, /*bool*/ dropslash=true) {
//  if not finit then initf() end if
    filepath = get_proper_path(filepath);
    let /*integer*/ k = rfind(SLASH,filepath);
    let /*string*/ path = $subss(filepath,1,k-dropslash), 
                   name = $subss(filepath,k+1,-1);
    return ["sequence",path,name];
}

/*global*/ function get_file_name_and_path(/*string*/ filepath, /*bool*/ dropslash=true) {
    let /*string*/ [,path,name] = get_file_path_and_name(filepath,dropslash);
    return ["sequence",name,path];
}
//11/2/22 (removed silly "stickness")
/*global*/ function file_size_k(/*atom*/ size, /*integer*/ width=1) {
//
// Trivial routine to convert a size in bytes to a human-readable string, such as "2GB".
//X The width setting is also "sticky", ie whatever is set becomes the new default.
//
    let /*integer*/ sw = max(width,1), 
                    s2 = ((sw>=3) ? sw-2 : sw), 
                    fdx = 0;
    let /*string*/ fmt = sprintf("%%%d.0f%%s",sw),  // eg "%11.0f%s" (the %s gets ""...)
                   sfmt = sprintf("%%%d.0f%%s",s2),  // eg "%9.0f%s" (this %s gets eg "KB")
                   dpsfmt = sprintf("%%%d.2f%%s",s2),  // eg "%9.2f%s" (        ""          )
                   res, suffix = "";
    while (fdx<=3) {
        let /*atom*/ rsize = round(size/1024,100); // (to 2 d.p.)
        if (rsize<1) { break; }
        size = rsize;
        fdx += 1;
        suffix = $conCat($subse("KMGT",fdx), 0X42);
        fmt = sfmt;
    }
    if (!equal(size,trunc(size))) { fmt = dpsfmt; }
    res = sprintf(fmt,["sequence",size,suffix]);
    return res;
}
