// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\gcd.e
// ==============
//
//  Implements gcd(), lcm() [aka hcf(), aliased in psym.e], and phi().
//

/*global*/ function gcd(/*object*/ u, /*atom*/ v=0) {
//
// returns the greatest common divisor of two numbers or a sequence of numbers.
// result is always a positive integer (that might still need storing in an atom), except for gcd(0,0) which is 0
// atom parameters allow greater precision, but any fractional parts are immediately and deliberately discarded.
// if the first parameter is a sequence then the second paramneter is completely ignored.
// if the sequence contains only one element, then (floored and unsigned) it is the result, ie gcd({N}) is N.
//
    let /*atom*/ t;
    if (sequence(u)) {
        v = $subse(u,1);                // (for the typecheck)
        t = floor(abs(v));
        for (let i=2, i$lim=length(u); i<=i$lim; i+=1) {
            v = $subse(u,i);            // (for the typecheck)
            t = gcd(t,v);
        }
        return t;
    }
    u = floor(abs(u));
    v = floor(abs(v));
    while (v) {
        t = u;
        u = v;
        v = remainder(t,v);
    }
    return u;
}
let hcf = gcd;

/*global*/ function lcm(/*object*/ m, /*atom*/ n=0) {
//
// returns the least common multiple of two numbers or a sequence of numbers
//
    let /*atom*/ g;
    if (sequence(m)) {
//DEV...
//      sequence s = m
        let /*object*/ s = m;
        if (!atom($subse(m,1))) { crash("9/0"); }
        m = floor($subse(m,1));
        for (let i=2, i$lim=length(s); i<=i$lim; i+=1) {
            n = floor($subse(s,i));
//DEV
//          m = m/gcd(m,n)*n
            g = gcd(m,n);
            m = (m/g)*n;
        }
        s = ["sequence"];
    } else {
        m = floor(m);
        n = floor(n);
//DEV
//      m = m/gcd(m,n)*n
        g = gcd(m,n);
        m = (m/g)*n;
    }
    return m;
}
//
//moved from:
// builtins\phi.e (an autoinclude)
// ==============
//
//  Implements Euler's $totient function
//  double-memoised, which makes this ~16x faster.
//
                 // max()
let /*integer*/ $pinit = 0; // 0 = uninitialised, else kept as length($fact)
let /*sequence*/ $fact,  // smallest prime factor of n (1 if n is prime)
                 $totient; // cached phi(n) values

/*global*/ function phi(/*integer*/ n) {
    if (n<=1) { return 1; }
    if (n>$pinit) {
        if ($pinit===0) {
            $fact = ["sequence",1];
            $totient = ["sequence",1];
        }
        let /*integer*/ l = length($fact), adnl = max(n-l,8192-odd(l));
        $fact = $conCat($fact, repeat(1,adnl), false);
        $totient = $conCat($totient, repeat(0,adnl), false);
        let /*integer*/ nl = length($fact);
        for (let i=2, i$lim=nl; i<=i$lim; i+=1) {
            if (equal($subse($fact,i),1)) {
                let /*integer*/ kmin = (floor(max(l,i)/i)+1)*i;
//              assert(kmin>l)
                for (let k=kmin, k$lim=nl; k<=k$lim; k+=i) {
                    if (equal($subse($fact,k),1)) {
                        $fact = $repe($fact,k,i); }
                }
            }
        }
///!*   -- even though it gets rid of recursion, this made no improvement 
        // on the 1..1e6 time compared to res=0 below, so I backed it out,
        // since doing so ought to make make some "1 in 10" cases faster.
        for (let i=l+1, i$lim=nl; i<=i$lim; i+=1) {
            let /*integer*/ f = $subse($fact,i), r;
            if (f===1) {
                r = i-1;
            } else {
                let /*integer*/ p = 1, fp = 1, j = i/f;
                while (equal(remainder(j,f),0)) {
                    p += 1;
                    fp *= f;
                    j /= f;
                }
                r = ($subse($totient,j)*(f-1))*fp;
            }
            $totient = $repe($totient,i,r);
        }
//*!/
        $pinit = nl;
    }
    let /*integer*/ res = $subse($totient,n);
/*
    if res=0 then
        integer f = $fact[n]
        if f=1 then
            res = n-1
        else
            integer p = 1, fp = 1, m = n/f;
            while remainder(m,f)=0 do
                p += 1
                fp *= f
                m /= f
            end while
            res = phi(m)*(f-1)*fp
        end if
        $totient[n] = res
    end if
*/
    return res;
}
// Just in case it helps, here's an earlier non-cached version:
//  function $totient(integer n)
//      integer n0 = n, tot = n, i = 2
//      while i*i<=n do
//          if mod(n,i)=0 then
//              while true do
//                  n /= i
//                  if mod(n,i)!=0 then exit end if
//              end while
//              tot -= tot/i
//          end if
//          i += iff(i=2?1:2)
//      end while
//      if n>1 then
//          tot -= tot/n
//      end if
//      return tot
//  end function
