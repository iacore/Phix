// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// gcd.e
//

/*global*/ function gcd(/*object*/ u, /*atom*/ v=0) {
//
// returns the greatest common divisor of two numbers or a sequence of numbers.
// result is always a positive integer (that might still need storing in an atom), except for gcd(0,0) which is 0
// atom parameters allow greater precision, but any fractional parts are immediately and deliberately discarded.
// if the first parameter is a sequence then the second paramneter is completely ignored.
// if the sequence contains only one element, then (floored and unsigned) it is the result, ie gcd({N}) is N.
//
    let /*atom*/ t;
    if (sequence(u)) {
        v = $subse(u,1);                // (for the typecheck)
        t = floor(abs(v));
        for (let i=2, i$lim=length(u); i<=i$lim; i+=1) {
            v = $subse(u,i);            // (for the typecheck)
            t = gcd(t,v);
        }
        return t;
    }
    u = floor(abs(u));
    v = floor(abs(v));
    while (v) {
        t = u;
        u = v;
        v = remainder(t,v);
    }
    return u;
}
let hcf = gcd;

/*global*/ function lcm(/*object*/ m, /*atom*/ n=0) {
//
// returns the least common multiple of two numbers or a sequence of numbers
//
    let /*atom*/ g;
    if (sequence(m)) {
//DEV...
//      sequence s = m
        let /*object*/ s = m;
        if (!atom($subse(m,1))) { crash("9/0"); }
        m = floor($subse(m,1));
        for (let i=2, i$lim=length(s); i<=i$lim; i+=1) {
            n = floor($subse(s,i));
//DEV
//          m = m/gcd(m,n)*n
            g = gcd(m,n);
            m = (m/g)*n;
        }
        s = ["sequence"];
    } else {
        m = floor(m);
        n = floor(n);
//DEV
//      m = m/gcd(m,n)*n
        g = gcd(m,n);
        m = (m/g)*n;
    }
    return m;
}
