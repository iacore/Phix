"use strict";
// auto-generated by pwa/p2js.
//
// builtins\match.e
// ================
//
//  hll implementation of match()  (replaces builtins/VM/pMatch.e)
//
/*global*/ function match(/*object*/ needle, /*sequence*/ haystack, /*integer*/ start=1, /*bool*/ case_sensitive=true) {
//
// Try to match needle against some slice of haystack.
// Return the element number of haystack where the (first) matching slice begins,
// or 0 if there are none.
//
    let /*integer*/ res, hdx, ln, lh;
    let /*object*/ ni, hi;
    // This line, and first parameter being object not sequence, is not Euphoria compliant.
    //  (Euphoria gives error "first argument of match() must be a sequence")
    if (atom(needle)) {
        return find(needle,haystack,start);
    }
    if (!case_sensitive) {
        needle = lower(needle);
        haystack = lower(haystack);
    }
    res = start;
    ln = length(needle);
    // This line is also not RDS compliant
    //  (RDS gives error "first argument of match() must be a non-empty sequence")
    if (ln===0) { return 0; }
    if (start<1) { return 0; }
    lh = length(haystack);
    while (1) {
        if (res+ln-1>lh) { return 0; }
        for (let i=1, i$lim=ln; i<=i$lim; i+=1) {
            ni = $subse(needle,i);
            hdx = i+res-1;
            hi = $subse(haystack,hdx);
            if (!equal(ni,hi)) {
                if (integer(ni)) {
                    // scan for ni later on in haystack
                    // eg needle=13131...,
                    //    haystack=1313x31...
                    // with needle[5]=1, scanning fwd two places to haystack[7]=1
                    // gives the earliest point worth re-starting from.
                    // if ni does not occur anywhere later in haystack, then
                    // clearly there will be no match anywhere.
                    for (let j=hdx+1, j$lim=lh+1; j<=j$lim; j+=1) {
                        res += 1;
                        if (j>lh) { return 0; }
                        hi = $subse(haystack,j);
                        if (equal(ni,hi)) { break; }
                    }
                    break;
                } else if (integer(hi)) {
                    // scan for hi earlier on in needle
                    // eg needle=131313x...,
                    //    haystack=1313131...
                    // with haystack[7]=1, scanning back two places to needle[5]=1
                    // gives the earliest point worth re-starting from.
                    // if haystack[7] does not occur anywhere earlier in needle,
                    // then clearly we should restart from haystack[8].
                    for (let j=i-1; j>=0; j-=1) {
                        res += 1;
                        if (j===0) { break; }
                        ni = $subse(needle,j);
                        if (equal(hi,ni)) { break; }
                    }
                    break;
                } else {
                    res += 1;
                    break;
                }
            }
            if (equal(i,ln)) { return res; }
        }
    }
}
/*global*/ function rmatch(/*object*/ needle, /*sequence*/ haystack, /*integer*/ start=length(haystack), /*bool*/ case_sensitive=true) {
    // This line, and first parameter being object not sequence, is not Euphoria compliant.
    //  (Euphoria gives error "first argument of match() must be a sequence")
    if (atom(needle)) {
        return rfind(needle,haystack,start);
    }
    let /*integer*/ ln = length(needle), 
                    lh = length(haystack);
    if ((ln===0) || (start===0) || start>lh || lh+start<1) {
        return 0;
    }
    if (!case_sensitive) {
        needle = lower(needle);
        haystack = lower(haystack);
    }
    if (start<1) {
        start = lh+start;
    }
    if (start+ln-1>lh) {
        start = lh-ln+1;
    }
//28/11/19 (bitbucket issue #27)
//  ln -= 1
    for (let i=start; i>=1; i-=1) {
        for (let j=1, j$lim=ln; j<=j$lim; j+=1) {
            if ($subse(needle,j)!=$subse(haystack,i+j-1)) { break; }
            if (equal(j,ln)) { return i; }
        }
    }
    return 0;
}
/*global*/ function match_all(/*object*/ needle, /*sequence*/ haystack, /*integer*/ start=1, /*bool*/ case_sensitive=true, overlap=false) {
    if (!case_sensitive) {
        needle = lower(needle);
        haystack = lower(haystack);
    }
    if (atom(needle)) {
        return find_all(needle,haystack,start);
    }
    let /*sequence*/ res = ["sequence"];
    while (1) {
        start = match(needle,haystack,start);
        if (start===0) { break; }
        res = append(res,start);
        start += (overlap) ? 1 : length(needle);
    }
    return res;
}

