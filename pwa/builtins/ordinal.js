// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\ordinal.e
// ==================
//
//  A collection of routines for ordinal number handling. (autoinclude)
//
//      ord(integer n) yields "st", "nd", "rd", or "th".
//      ordinal(atom n) yields "first", "second", etc.
//      ordinal(atom n, bool bJustSpell:=true) yields "one", "two", etc.
//

/*global*/ function ord(/*atom*/ n) {
    let /*integer*/ r = remainder(n,10)+1;
    if ((r<=0 || r>4) || (equal(remainder(n,100),r+9))) { r = 1; }
    let /*string*/ res = $subse(["sequence","th","st","nd","rd"],r);
    return res;
}
let /*integer*/ $oinit = false;
let /*sequence*/ $twenties, $decades, $orders, $irregs, $ordinals;
function $inito() {
    $twenties = ["sequence","zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"];
    $decades = ["sequence","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"];
    $orders = ["sequence",["sequence",power(10,15),"quadrillion"],["sequence",power(10,12),"trillion"],["sequence",power(10,9),"billion"],["sequence",power(10,6),"million"],["sequence",power(10,3),"thousand"]];
    [,$irregs,$ordinals] = columnize(["sequence",["sequence","one","first"],["sequence","two","second"],["sequence","three","third"],["sequence","five","fifth"],["sequence","eight","eighth"],["sequence","nine","ninth"],["sequence","twelve","twelfth"]]);
    $oinit = true;
}
function $twenty(/*integer*/ n) {
    return $subse($twenties,mod(n,20)+1);
}
function $decade(/*integer*/ n) {
    return $subse($decades,mod(n,10)-1);
}
function $hundred(/*integer*/ n) {
    if (n<20) {
        return $twenty(n);
    } else if (equal(mod(n,10),0)) {
        return $decade(mod(floor(n/10),10));
    }
    return $conCat($conCat($decade(floor(n/10)), 0X2D), $twenty(mod(n,10)));
}
function $thousand(/*integer*/ n, /*string*/ withand) {
    // (aside: p2js.exw/insert_dollars() 
    //  must not $hundred -> $$hundred this:)
    let /*string*/ sphun = " hundred";
    if (n<100) {
        return $conCat(withand, $hundred(n));
    } else if (equal(mod(n,100),0)) {
        return $conCat($conCat(withand, $twenty(floor(n/100))), sphun);
    }
    return $conCat($conCat($conCat($twenty(floor(n/100)), sphun), " and "), $hundred(mod(n,100)));
}
function $triplet(/*atom*/ n) {
    let /*atom*/ order, high, low;
    let /*string*/ name, res = "";
    for (let i=1, i$lim=length($orders); i<=i$lim; i+=1) {
        [,order,name] = $subse($orders,i);
        high = floor(n/order);
        low = mod(n,order);
        if (high!==0) {
            res = $conCat(res, $conCat($conCat($thousand(high,""), 0X20), name), false);
        }
        n = low;
        if (low===0) { break; }
        if (length(res) && (high!==0)) {
            res = $conCat(res, ", ", false);
        }
    }
    if ((n!==0) || (res==="")) {
        res = $conCat(res, $thousand(floor(n),((res==="") ? "" : "and ")), false);
        n = abs(mod(n,1));
        if (n>1e-6) {
            res = $conCat(res, " point", false);
            //
            // Ah: inherited from rosettacode, I suspect *10+1e-7 
            //  is there to trigger <1e-6 sooner rather than later,
            //  by rounding up to the nearest six decimal places.
            // (This sort of maths never was quite my strong suit.)
            //
            for (let i=1; i<=10; i+=1) {
                let /*integer*/ d = floor(n*10.0000001);
                res = $conCat(res, $conCat(0X20, $subse($twenties,d+1)), false);
                n = n*10-d;
                if (compare(abs(n),1e-6)<0) { break; }
            }
        }
    }
    return res;
}
function $spell(/*atom*/ n) {
    let /*string*/ res = "";
    if (n<0) {
        res = "minus ";
        n = -n;
    }
    res = $conCat(res, $triplet(n), false);
    return res;
}

/*global*/ function ordinal(/*atom*/ n, /*bool*/ bJustSpell=false) {
    if (!$oinit) { $inito(); }
    let /*string*/ s = $spell(n);
    if (!bJustSpell) {     // default: "one" => "first", etc
        let /*integer*/ i = length(s);
        while (i) {
            let /*integer*/ ch = $subse(s,i);
            if ((ch===0X20) || (ch===0X2D)) { break; }
            i -= 1;
        }
        let /*integer*/ k = find($subss(s,i+1,-1),$irregs);
        if (k) {
            s = $conCat($subss(s,1,i), $subse($ordinals,k));
        } else if (equal($subse(s,-1),0X79)) {
            s = $repss(s,-1,-1,"ieth");
        } else {
            s = $conCat(s, "th", false);
        }
    }
    return s;
}

/*global*/ function ordinant(/*atom*/ n) {
    // returns never, [minus] once, twice, or n,nnn times.
    let /*string*/ res = "";
    if (n<0) { res = "minus "; n = -n; }
    if (n===0) { res = $conCat(res, "never", false);
    } else if (n===1) { res = $conCat(res, "once", false);
    } else if (n===2) { res = $conCat(res, "twice", false);
//  else res &= sprintf("%,d times",n)  
    } else { res = $conCat(res, $conCat(ordinal(n,true), " times"), false);
    }
    return res;
}
