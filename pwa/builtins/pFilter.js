// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\pFilter.e
// ==================
//
//  Phix implementation of the filter() function (an autoinclude)
//
//  See docs for details, and contrast with Euphoria's std/sequence.e/filter().
//
//  There is no get_routine_info() in JavaScript, so this was hand-translated for p2js.js
//
/*include C:\Program Files (x86)\Phix\builtins\ptypes.e*/
//
// builtins\ptypes.e
//
//  NB not an autoinclude, but used/included by [x]pGUI.e, mpfr.e, pFilter.e, and structs.e.
//

// used by IupSetAttribute, IupSetGlobal, cdCreateCanvas, mpz_import:
/*global*/ function atom_string(/*object*/ o) {
    return (string(o) || (integer(o) && compare(o,NULL)>=0)) || ((atom(o) && compare(o,NULL)>=0) && (equal(o,floor(o))));
}

/*global*/ function rid_string(/*object*/ o) {
    return string(o) || (integer(o) && compare(o,15)>0);
}

/*global*/ function nullable_string(/*object*/ o) {
    return string(o) || (equal(o,NULL));
}
// Note: psym.e aliases bool to integer, without the true|false aka 0|1 validation
/*global*/ function boolean(/*object*/ o) {
    return integer(o) && ((equal(o,true)) || (equal(o,false)));
}
//DEV/erm, see if we can get by (in xpGUI.e) without this...
//global function get_raw_string_ptr(string s)
//--
//-- Returns a raw string pointer for s, somewhat like allocate_string(s), but using the existing memory.
//-- NOTE: The return is only valid as long as the value passed as the parameter remains in scope.
//--         In particular, callbacks must make a semi-permanent copy somewhere other than locals/temps.
//--
//atom res
//  #ilASM{
//      [32]
//          mov eax,[s]
//          lea edi,[res]
//          shl eax,2
//      [64]
//          mov rax,[s]
//          lea rdi,[res]
//          shl rax,2
//      []
//          call :%pStoreMint
//        }
//  return res
//end function
                                        // type rid_string
                                        // get_routine_info()

/*global*/ function filter(/*sequence*/ s, /*rid_string*/ rs, /*object*/ userdata=["sequence"], /*string*/ rangetype="") {
//
// Select only those elements from a sequence that pass a specified test.
//
    let /*bool*/ bCount = rangetype==="COUNT";
    if (bCount) { [,userdata,rangetype] = userdata; }
    let /*object*/ si;
    let /*sequence*/ res = ((string(s)) ? "" : ["sequence"]);
    let /*integer*/ ires = 0;
    if (string(rs)) {
        // built-in handling
        let /*integer*/ inout = find(rs,["sequence","in","out"]);
        if (inout!==0) {
            inout = inout===1; // in: true, out: false
            if (rangetype==="") {
                // set handling
//              for i=1 to length(s) do
//                  si = s[i]
                for (let si$idx = 1, si$lim = length(s); si$idx <= si$lim; si$idx += 1) { si = $subse(s,si$idx);
                    let /*integer*/ f = find(si,userdata);
                    if (equal((f!==0),inout)) {
                        if (bCount) {
                            ires += 1;
                        } else {
                            res = append(res,si);
                        }
                    }
                }
            } else {
                // inclusive/exclusive lo/hi range handling
                let /*integer*/ rt = find(rangetype,["sequence","[]","(]","[)","()"])-1;
                if (rt===-1) {
                    crash("invalid rangetype");
                }
                // rt is now 0..3, aka 0b00..0b11:  -- exclsve, inclsive
                let /*integer*/ xl = and_bits(rt,0x1),  // 0 for [,  1 for (
//11/11/22:
//                      xh = -and_bits(rt,0b02)/2   -- 0 for ], -1 for )
                                xh = -and_bits(rt,0x2)/2; // 0 for ], -1 for )
                if (!sequence(userdata) || (!equal(length(userdata),2))) {
                    crash("userdata must be a sequence of length 2 for in/out handling");
                }
                let /*object*/ [,lo,hi] = userdata;
//              for i=1 to length(s) do
//                  si = s[i]
                for (let si$idx = 1, si$lim = length(s); si$idx <= si$lim; si$idx += 1) { si = $subse(s,si$idx);
                    let /*integer*/ lc = compare(si,lo), 
                                    hc = compare(si,hi);
                    if (equal((lc>=xl && hc<=xh),inout)) {
                        if (bCount) {
                            ires += 1;
                        } else {
                            res = append(res,si);
                        }
                    }
                }
            }
        } else {
            if (rangetype!=="") { crash("invalid rangetype"); }
//31/10/22:
            if (equal(rs,"notbits")) {
                for (let si$idx = 1, si$lim = length(s); si$idx <= si$lim; si$idx += 1) { si = $subse(s,si$idx);
                    if (!and_bits(si,userdata)) {
                        if (bCount) {
                            ires += 1;
                        } else {
                            res = append(res,si);
                        }
                    }
                }
            } else {
                let /*integer*/ ct = find(rs,["sequence","<","<=","=","!=",">=",">"]);
                if (ct===0) {
                    ct = find(rs,["sequence","lt","le","eq","ne","gt","ge"]);
                    if (ct===0) { //       maybe "=="    
                        if (!equal(rs,"==")) { crash("unrecognised comparison operator"); }
                        ct = 3;
                    }
                }
                let /*integer*/ ne = ct===4;
                ct -= ct>=4;
                let /*sequence*/ ok = $subse(["sequence",["sequence",-1],["sequence",-1,0],["sequence",0],["sequence",0,1],["sequence",1]],ct);
//              for i=1 to length(s) do
//                  si = s[i]
                for (let si$idx = 1, si$lim = length(s); si$idx <= si$lim; si$idx += 1) { si = $subse(s,si$idx);
                    let /*integer*/ c = compare(si,userdata);
                    if (!equal((!equal(find(c,ok),0)),ne)) {
                        if (bCount) {
                            ires += 1;
                        } else {
                            res = append(res,si);
                        }
                    }
                }
            }
        }
    } else {
        // user-defined function handling
        if (rangetype!=="") { crash("invalid rangetype"); }
        let /*integer*/ fn = rs, [,maxp,minp] = get_routine_info(fn);
        if (maxp<1 || minp>3) {
            crash("filter routine must accept 1..3 parameters");
        } else if ((maxp===1) && (!equal(userdata,["sequence"]))) {
            crash("filter routine must accept 2..3 parameters");
        }
        for (let i=1, i$lim=length(s); i<=i$lim; i+=1) {
            si = $subse(s,i);
            let /*bool*/ bAdd;
            if (equal(userdata,["sequence"])) {
                if ((maxp===1) || minp<=1) {
                    bAdd = fn(si);
                } else if (minp===2) {
                    bAdd = fn(si,i);
                } else if (minp===3) {
                    bAdd = fn(si,i,s);
                }
            } else if (minp===3) {
                bAdd = fn(si,i,userdata);
            } else {
                bAdd = fn(si,userdata);
            }
            if (bAdd) {
                if (bCount) {
                    ires += 1;
                } else {
                    res = append(res,si);
                }
            }
        }
    }
    if (bCount) { return ires; }
    return res;
}

/*global*/ function filter_count(/*sequence*/ s, /*rid_string*/ rs, /*object*/ userdata=["sequence"], /*string*/ rangetype="") {
    return filter(s,rs,["sequence",userdata,rangetype],"COUNT");
}
