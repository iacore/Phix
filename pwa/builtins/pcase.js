// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// pcase.e
// =======
//
// plain ASCII version of the more human-readable pcase8.e, see that for comments.
//
/*without debug*/ // keep ex.err clean (overshadowed by same in pdiag.e)
let /*integer*/ $caseinit = 0;
let /*string*/ $toUpper, $toLower;
let /*sequence*/ $str_methods;
const $LOWER = 1, $UPPER = 2, $CAPITALISE = 3, $SENTENCE = 4, $INVERT = 5
function $initcase() {
    $str_methods = ["sequence","LOWER","UPPER","CAPITALISE","SENTENCE","INVERT"];
    let /*integer*/ i32;
    $toUpper = repeat(255,255);
    $toLower = repeat(255,255);
    for (let i=1; i<=254; i+=1) {
        $toUpper = $repe($toUpper,i,i);
        $toLower = $repe($toLower,i,i);
    }
    for (let i=0X41, i$lim=0X5A; i<=i$lim; i+=1) {
        i32 = i+32;
        $toLower = $repe($toLower,i,i32);
        $toUpper = $repe($toUpper,i32,i);
    }
    for (let i=0xC0, i$lim=0xD6; i<=i$lim; i+=1) { // see pcase8.e
        i32 = i+32;
        $toLower = $repe($toLower,i,i32);
        $toUpper = $repe($toUpper,i32,i);
    }
    for (let i=0xD8, i$lim=0xDE; i<=i$lim; i+=1) { // see pcase8.e
        i32 = i+32;
        $toLower = $repe($toLower,i,i32);
        $toUpper = $repe($toUpper,i32,i);
    }
    // several odd-balls, see pcase8.e
    $toLower = $repe($toLower,0x8A,0x9A);
    $toLower = $repe($toLower,0x8C,0x9C);
    $toLower = $repe($toLower,0x9F,0xFF);
    $toUpper = $repe($toUpper,0x9A,0x8A);
    $toUpper = $repe($toUpper,0x9C,0x8C);
    $toUpper = $repe($toUpper,0xFF,0x9F);
    $caseinit = 1;
}

/*global*/ function upper(/*object*/ x) {
    let /*object*/ o;
    let /*integer*/ c;
    if (!$caseinit) { $initcase(); }
    if (sequence(x)) {
        for (let i=1, i$lim=length(x); i<=i$lim; i+=1) {
            o = $subse(x,i);
            if (sequence(o)) {
                // 8/2/23 p2js violation
//              x[i] = upper(o)
                x = $repe(x,i,0);
                o = upper(o);
                x = $repe(x,i,o);
            } else if (integer(o)) {
                c = o;
                if (c>0 && c<=255) {
                    x = $repe(x,i,$subse($toUpper,c));
                }
            }
        }
    } else if (integer(x)) {
        c = x;
        if (c>0 && c<=255) {
            x = $subse($toUpper,c);
        }
    }
    return x;
}

/*global*/ function lower(/*object*/ x) {
    let /*object*/ o;
    let /*integer*/ c;
    if (!$caseinit) { $initcase(); }
    if (sequence(x)) {
        for (let i=1, i$lim=length(x); i<=i$lim; i+=1) {
            o = $subse(x,i);
            if (sequence(o)) {
                // 8/2/23 p2js violation
//              x[i] = lower(o)
                x = $repe(x,i,0);
                o = lower(o);
                x = $repe(x,i,o);
            } else if (integer(o)) {
                c = o;
                if (c>0 && c<=255) {
                    x = $repe(x,i,$subse($toLower,c));
                }
            }
        }
    } else if (integer(x)) {
        c = x;
        if (c>0 && c<=255) {
            x = $subse($toLower,c);
        }
    }
    return x;
}

/*global*/ function isupper(/*integer*/ ch) {
    if (!$caseinit) { $initcase(); }
    return (ch>0 && ch<=255) && (!equal(ch,$subse($toLower,ch)));
}

/*global*/ function islower(/*integer*/ ch) {
    if (!$caseinit) { $initcase(); }
    return (ch>0 && ch<=255) && (!equal(ch,$subse($toUpper,ch)));
}
//DEV doc/auto:
//**
// Convert a text sequence to capitalized words.
//
// Parameters:
//   # ##x## : A text sequence.
//
// Returns:
//   A **sequence**, the Capitalized Version of ##x##
//
// Comments:
// A text sequence is one in which all elements are either characters or
// text sequences. This means that if a non-character is found in the input,
// it is not converted. However this rule only applies to elements on the
// same level, meaning that sub-sequences could be converted if they are
// actually text sequences.
//
//
// Example 1:
// <eucode>
// s = proper("euphoria programming language")
// -- s is "Euphoria Programming Language"
// s = proper("EUPHORIA PROGRAMMING LANGUAGE")
// -- s is "Euphoria Programming Language"
// s = proper({"EUPHORIA PROGRAMMING", "language", "rapid dEPLOYMENT", "sOfTwArE"})
// -- s is {"Euphoria Programming", "Language", "Rapid Deployment", "Software"}
// s = proper({'a', 'b', 'c'})
// -- s is {'A', 'b', c'} -- "Abc"
// s = proper({'a', 'b', 'c', 3.1472})
// -- s is {'a', 'b', c', 3.1472} -- Unchanged because it contains a non-character.
// s = proper({"abc", 3.1472})
// -- s is {"Abc", 3.1472} -- The embedded text sequence is converted.
// </eucode>
//
// See Also:
//     [[:lower]] [[:upper]]

/*
-- replaced below...
--global function proper(sequence x)
---- Converts text to lowercase and makes each word start with an uppercase.
----integer pos
--integer inword = 0                -- Initially not in a word
----integer convert = string(x) -- Initially convert text
----sequence res
--
----    res = x                 -- Work on a copy of the original, in case we need to restore.
--  if string(x) then
--      for i=1 to length(x) do
--          integer ch = x[i]
--          -- Check for upper case
--          integer pos = isupper(ch)
--          if pos=0 then
--              -- Not upper, so check for lower case
--              pos = islower(ch)
--              if pos=0 then
--                  -- Not lower so check for digits
--                  -- n.b. digits have no effect on if its in a word or not.
--                  pos = ch>='0' and ch<='9'
--                  if pos=0 then
--                      -- not digit so check for special word chars
----                        pos = t_specword(ch)
----                        if pos then
--                      if ch='_' then
--                          inword = 1
--                      else
--                          inword = 0
--                      end if
--                  end if
--              else
--                  if inword=0 then
--                      -- start of word, so convert only lower to upper.
----I have no idea what this test is/was:
----                        if pos<=26 then
--                          x[i] = upper(ch) -- Convert to uppercase
----                        end if
--                      inword = 1      -- now we are in a word
--                  end if
--              end if
--          else
--              if inword=1 then
--                  -- Upper, but as we are in a word convert it to lower.
--                  x[i] = lower(ch) -- Convert to lowercase
--              else
--                  inword = 1      -- now we are in a word
--              end if
--          end if
--      end for
--  else            
--      for i=1 to length(x) do
--          object xi = x[i]
--          if sequence(xi) then
--              x[i] = proper(xi) -- recursive conversion
--          end if
--      end for
--  end if
--  return x
--end function
*/

/*global*/ function proper(/*string*/ s, method="CAPITALISE") {
//
// $LOWER:       "this is England. so there" -> "this is england. so there"
// $UPPER:       "this is England. so there" -> "THIS IS ENGLAND. SO THERE"
// $CAPITALISE:  "this is England. so there" -> "This Is England. So There"
// $SENTENCE:    "this is England. so there" -> "This is england. So there"
// $INVERT:      "this is England. so there" -> "THIS IS eNGLAND. SO THERE"
//
// Obviously $LOWER/$UPPER overlap functionally with lower()/upper(), but it 
//  might one day be useful to dynamically specify such options at runtime.
// $SENTENCE is far from perfect, $INVERT has (potential) use in Edita/Edix,
// to correct something just typed in with the wrong caps lock setting.
//
    let /*integer*/ mi = find(upper(method),$str_methods),  // must be one of those!
                    ch,  // a character
                    pc = 0X20; // previous character
    let /*bool*/ eos = true,  // end of sentence flag
                 inQuote = false,  // within double quotes flag
                 islow = false,  // ch is lowercase
                 ishigh = false,  // ch is uppercase
                 lowit = false,  // change it?
                 highit = false; // change it?
    if (!$caseinit) { $initcase(); }
    if (mi===0) { crash("proper(s,\"%s\"): invalid method parameter",["sequence",method]); }
    for (let i=1, i$lim=length(s); i<=i$lim; i+=1) {
        ch = $subse(s,i);
//      islow := (ch>='a' and ch<='z')  lowit = false
//      ishigh := (ch>='A' and ch<='Z') highit = false
        islow = (ch>0 && ch<=255) && (!equal(ch,$subse($toUpper,ch))); lowit = false;
        ishigh = (ch>0 && ch<=255) && (!equal(ch,$subse($toLower,ch))); highit = false;
        switch (mi) {
            case $LOWER: lowit = ishigh;
                break;
            case $UPPER: highit = islow;
                break;
            case $INVERT: lowit = ishigh;
                highit = islow;
                break;
            case $CAPITALISE:
//                      if find(pc," \t\r\n\"\'`") then
                if (find(pc,$conCat(" \r\n\"\'`", 9))) {
                    highit = islow;
                } else {
                    lowit = ishigh;
                }
                break;
            case $SENTENCE:
//                  if find(pc," \t\r\n") then
                if (find(pc,$conCat(" \r\n", 9))) {
                    if (eos) {
                        highit = islow;
                        eos = false;
                    } else {
                        lowit = ishigh;
                    }
                } else {
                    lowit = ishigh;
                }
                if (find(ch,".!?")) {
                    eos = true;
//                  elsif not find(ch," \t\r\n") then
                } else if (!find(ch,$conCat(" \r\n", 9))) {
                    eos = false;
                }
                if (ch===0X22) {
                    ch = 0X20;
                    inQuote = !inQuote;
                    eos = inQuote;
                }
        }
        pc = ch;
        if (lowit) { ch += 32;
            s = $repe(s,i,ch);
        } else if (highit) { ch -= 32;
            s = $repe(s,i,ch);
        }
    }
    return s;
}
