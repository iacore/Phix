// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// pdecodeflags.e
// ==============
//
//  Phix implementation of decode_flags (autoinclude)
//

/*global*/ function decode_flags(/*sequence*/ FlagSet, /*atom*/ v, /*string*/ sep="+") {
//
//  Given a definition such as:
//
//      constant FileFlagSet = {{ FILE_ATTRIBUTE_READONLY,  "R"},
//                              { FILE_ATTRIBUTE_SYSTEM,    "S"},
//                              { FILE_ATTRIBUTE_HIDDEN,    "H"},
//                              { FILE_ATTRIBUTE_DIRECTORY, "D"}}
//  then
//
//      ? decode_flags(FileFlagSet,#17,"")
//
//  yields/displays "RSHD". Just add the obvious "ead" etc and, with the default sep
//  (of "+") the output would instead be "Read+System+Hidden+Directory". (FYI, those
//  "FILE_ATTRIBUTE_XXX" flags used above are defined in arwen\constants.e, should
//  you want to check precisely why I said #17 rather than (eg) #0F)
//
//  This is useful anywhere you have a bitmap field and want to show a human-readable 
//  version. Further examples can be found in demo\arwendemo\filedump.exw
//
//  Obviously each application must define it's own FlagSet(s).
//  The order of FlagSet determines the order things appear in the result.
//  If a description begins with '-', the separator(optional p3) is omitted. 
//  A decription(s) of "" can be used to ignore/suppress specific bit settings.
//  The first entry can be eg {0,"closed"} to specify the "no bits set" meaning.
//  Any bits not recognised are returned as a hex value at the start.
//
    let /*string*/ res = "";
//24/8/23:
    v = and_bitsu(v,v);
    for (let i=1, i$lim=length(FlagSet); i<=i$lim; i+=1) {
        let /*string*/ desc = $subse($subse(FlagSet,i),2);
        let /*atom*/ flag = $subse($subse(FlagSet,i),1);
        if (flag===0) {
            if (i!==1) { crash("9/0"); } // sanity check
            // (I suspect ^ means there is some logic error setting up FlagSet,
            // (else I suppose you could just ignore entries>1 with a flag of 0.)
            if (v===0) {
                res = desc;
                break;
            }
        } else {
//23/8/23:
//          atom fset = and_bits(v,flag)
            flag = and_bitsu(flag,flag);
            let /*atom*/ fset = and_bitsu(v,flag);
//          if fset=flag then                   -- (oops, sign issues with eg #80000000)
//1/10/19:
//          if fset=and_bits(flag,flag) then
//              v -= flag
//23/8/23:
//          if fset!=0 then
            if ((fset!==0) && ((fset===flag) || (equal(length(desc),0)))) {
                v -= fset;
                if ((((!equal(length(res),0)) && (!equal(length(sep),0))) && compare(length(desc),1)>=0) && (!equal($subse(desc,1),0X2D))) {
                    res = $conCat(res, sep, false);
                }
                res = $conCat(res, desc, false);
            }
        }
    }
    if (v!==0) {
        if (sep==="") { sep = "+"; }
        res = sprintf("0x%x%s%s",["sequence",v,sep,res]);
    }
    return res;
}
