// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// pmaths.e
//
//  Phix implementation of abs(), round(), ceil(), sign(), min(), max()
//
// Note: There is no automatic-substitution-with-warning, as yet, of 
//       sq_abs, sq_round, sq_ceil, sq_sign, sq_mod, or sq_trunc.
//       Not that I have any particular objection to such, or even
//       just deleting the ones in psqop.e in favour of enhancing
//       the routines in here, to cope with sequence parameters.
//
//       There are no sq_xx versions of exp, min, max or atan2;
//       while sq_exp could be made, the other 3 c/should not.
//
// This is an auto-include file; there is no need to manually include
//  it, unless you want a namespace.
//
/*without trace*/ //include VM\pTrig.e    -- (not strictly necessary)

/*global*/ function abs(/*atom*/ a) {
    if (a<0) {
        a = -a;
    }
    return a;
}

/*global*/ function sign(/*atom*/ a) {
    if (a>0) {
        a = +1;
    } else if (a<0) {
        a = -1;
    }
    return a;
}
//now mapped to opAndBits in pmain.e:
//global function even(atom a)
//  return and_bits(a,1)=0
//end function
//
//global function odd(atom a)
//  return and_bits(a,1)=1
//end function

//global function evenN(atom a)
//  return and_bits(a,1)=0
//end function
//
//global function oddD(atom a)
//  return and_bits(a,1)=1
//end function

/*global*/ function exp(/*atom*/ a) {
    return power(EULER,a);
}
//bool bUseBankersRounding = false

/*global*/ function round(/*atom*/ a, inverted_precision=1) {
//  if inverted_precision=0 then
//      if a!=true and a!=false then ?9/0 end if
//      bUseBankersRounding = a
//  elsif bUseBankersRounding then
//      --25/5/20 (round to nearest even)
//      integer s = sign(a)
//      a = abs(a)*inverted_precision
//      atom t = floor(a), f = a-t
//      if f=0.5 then
//          a = t+and_bits(t,1)
//      else
//          a = floor(0.5+a)
//      end if
//      a = s*(a/inverted_precision)
//  else
        // (compatible with Euphoria)
    inverted_precision = abs(inverted_precision);
    a = floor(.5+a*inverted_precision)/inverted_precision;
//  end if
    return a;
}

/*global*/ function bankers_rounding(/*atom*/ pence, /*integer*/ precision=1) {
    let /*integer*/ pennies,  // (or nearest 100, etc, but never nearest < 1 )
                    s = sign(pence), whole;
    pence = abs(pence)/precision;
    whole = floor(pence);
    let /*atom*/ fract = pence-whole;
    if (fract===.5) {
        pennies = whole+and_bits(whole,1);
    } else {
        pennies = floor(.5+pence);
    }
    pennies *= s*precision;
    return pennies;
}

/*global*/ function ceil(/*atom*/ o) {
    o = -floor(-o);
    return o;
}

/*global*/ function min(/*object*/ a, b) {
    if (compare(a,b)<0) { return a; } else { return b; }
}

/*global*/ function minsq(/*sequence*/ s, /*bool*/ return_index=false) {
    // (aliased to smallest)
    let /*object*/ res = $subse(s,1);
    let /*integer*/ rdx = 1;
//  for i=2 to length(s) do
    for (let i = 2, si$lim = length(s); i <= si$lim; i += 1) { let si = $subse(s,i);
//      if s[i]<res then
        if (compare(si,res)<0) {
//          res = s[i]
            res = si;
            rdx = i;
        }
    }
    return ((return_index) ? rdx : res);
}
let smallest = minsq;

/*global*/ function max(/*object*/ a, b) {
    if (compare(a,b)>0) { return a; } else { return b; }
}

/*global*/ function maxsq(/*sequence*/ s, /*bool*/ return_index=false) {
    // (aliased to largest)
    let /*object*/ res = $subse(s,1);
    let /*integer*/ rdx = 1;
//  for i=2 to length(s) do
    for (let i = 2, si$lim = length(s); i <= si$lim; i += 1) { let si = $subse(s,i);
//      if s[i]>res then
        if (compare(si,res)>0) {
//          res = s[i]
            res = si;
            rdx = i;
        }
    }
    return ((return_index) ? rdx : res);
}
let largest = maxsq;

/*global*/ function median(/*sequence*/ s) {
    // for even length lists return average of the middle two
    // for odd length lists just return the middle entry
    // s must be sorted on entry.
    let /*atom*/ m = length(s)/2;
    return ((integer(m)) ? ($subse(s,m)+$subse(s,m+1))/2 : $subse(s,ceil(m)));
}

/*global*/ function mod(/*atom*/ x, y) {
    if (equal(sign(x),sign(y))) {
        return remainder(x,y);
    }
    return x-y*floor(x/y);
}

/*global*/ function trunc(/*atom*/ x) {
//  return sign(x)*floor(abs(x))
    if (x<0) {
        return -floor(-x);
    }
    return floor(x);
}

/*global*/ function atan2(/*atom*/ y, x) {
    if (x>0) {
        return arctan(y/x);
    } else if (x<0) {
        if (y<0) {
            return arctan(y/x)-PI;
        } else {
            return arctan(y/x)+PI;
        }
    } else if (y>0) {
        return PI/2;
    } else if (y<0) {
        return -PI/2;
    } else {
        return 0;
    }
//    return 2*arctan((sqrt(power(x,2)+power(y,2))-x)/y)
}

/*global*/ function mulmod(/*atom*/ a, b, modulus) {
    // return (a*b) % modulus, but allow a*b to exceed precision.
    // Note: intended for use when sign(a)=sign(b); no formal statement concerning whether
    //       the results more closely (/theoretically) match mod() or remainder() is made.

    // (a * b) % modulus = (a % modulus) * (b % modulus) % modulus
    a = mod(a,modulus);
    b = mod(b,modulus);
    // fast path
//  if a<=0xFFFFFFF and b<=0xFFFFFFF then   -- 64 bit?? [PL, 7x4=28,*2=56 bits? - 7 or 8 spare]
    if (a<=0xFFFFFF && b<=0xFFFFFF) {       // 32 bit..      6x4=24,*2=48 bits? - 3 or 4 spare...]
        return mod(a*b,modulus);
    }
    // we might encounter overflows (slow path)
    // the number of loops depends on b, therefore try to minimize b
    if (b>a) { [,a,b] = ["sequence",b,a]; }
    // bitwise multiplication
    let /*atom*/ result = 0;
    while (a>0 && b>0) {
        if (odd(b)) {
            result = mod(result+a,modulus);
        }
        a = mod(a*2,modulus);
        b = floor(b/2); // next bit
    }
    return result;
}

/*global*/ function powmod(/*atom*/ base, exponent, modulus) {
    // return base^exponent % modulus, but allow base^exponent to exceed precision.
    // employs the tricks of https://en.wikipedia.org/wiki/Exponentiation_by_squaring
    // Note: see disclaimer in modmul() above regarding mod() vs remainder().
    let /*atom*/ result = 1;
//  if exponent<0 then x = 1/x; exponent *= -1 end if   -- (untested)
    while (exponent>0) {
        if (odd(exponent)) {
            result = mulmod(result,base,modulus);
        }
        base = mulmod(base,base,modulus);
        exponent = floor(exponent/2);
    }
    return result;
}
//?powmod(13789,722341,2345) -- 2029 expected (good)
