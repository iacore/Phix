// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// Pete's Pretty Print. (Phix compatible)
// ===================
// Author Pete Lomax May 2003
// thanks to Juergen Luethje for help and suggestions.
//           Revised August 2003
//           Revised October 2003
//           Revised September 2004
//           Revised June 2010
//
//   04/06/10: Added pp_Q22 option
// Version 2.0.4
//   27/03/09: Updated for auto-include, string handling.
//   12/12/04: added escape char handling to strings (see $escBytes)
// Version 2.0.3
//   07/09/04: pp_IntFmt applies to 32-bit integers not just 31-bit
//      (#80000000..#7FFFFFFF not just #C0000000..#3FFFFFFF)
//Ahem: -#FFFFFFFF..#FFFFFFFF as requested by JL.
//
// Version 2.0.1
//   05/06/04: float format default changed to %g (was %3.2g)
//
//!/**/without debug -- keep ex.err clean (remove to debug!)
//!/**/with debug
//  NB: the "without debug" in pdiag.e overshadows the one here; you may
//      need to "with debug" here to get a listing, or use -nodiag.
//without trace -- (covered by without debug)

//
// Introduction.
// ============
//
//  Prints any object to screen, file, or returns a string.
//  Long sequences are automatically line-wrapped and optionally 
//  displayed in a neat (vertically aligned) nested format.
//
//  Default handling.
//  ================
//  All these settings can be changed:
//   Display to screen (ie file 1, aka stdout).
//   Lines are wrapped at 78 characters.
//   Display is paused every 23 lines.
//   Strings are printed as double-quoted $ascii, eg "abc".
//<   Values in the range #20 to #7F are treated as $ascii.
//    Values in the range #20 to #7D are treated as $ascii.
//   Integers are printed using a "%d" format.
//   Floating point numbers are printed using a "%g" format.
//   Date handling is turned off by default.
//   Sequences are enclosed in curly braces '{' and '}'.
//
//  The default behaviour can be changed permanently using ppOpt,
//  or temporarily using ppEx(object,<option-list>).
//
//  Interface.
//  =========    
//   pp(object)     Output using the current settings.
//                  This is the way this routine is normally used.
//
//   x=ppf(object)  Return a string representation, (with embedded \n if 
//                  needed), rather than display to screen or write to file.
//                  Note there is no trailing \n on the result
//
//   ppOpt(options) Permanently (or until next ppOpt call) change
//                  selected formatting options (see below).
//
//   ppEx(object,options) Temporarily apply specified options while
//                  printing object. Defaults are reset before exit.
//
//   x=ppExf(object,options) Return a string representation using the
//                  specified temporary formatting options.
//
//  Formatting options.
//  ==================
//   Example:
//
//      ppOpt({pp_IntFmt,"%d.00 US$"})
//      ppOpt({pp_FltFmt,"%.2f US$"})
//
//      x=ppf(1) -- returns "1.00 US$"
//
//   Notes:
//    When using this routine to format values which may or may not have a
//    fractional element, both the integer and float formats should be set.
//    The following one line can be used instead of the above:
//
//      x=ppExf(1,{{pp_IntFmt,"%d.00 US$",pp_FltFmt,"%.2f US$"})
//
//   The options are specified as a pair-sequence, selected from:
//
//         Odd element:    Even element:
//          pp_File         0:no output (used by ppf())
//                          1:display to Screen (the default),
//                          n:an open file handle
//          pp_Nest         nest level, eg:
//                          0: output is {1, {2, {3,3}, 2}, 1}
//                          1: output is {1,
//                                        {2, {3,3}, 2},
//                                        1}
//                          See below for more examples.
//          pp_Maxlen       Split lines at column, default 78
//          pp_Indent       Auto-indent amount, default 0
//          pp_Pause        Pause every n lines, default=23.
//                          Specify 0 for no pause
//          pp_StrFmt       0: print strings as eg "abc" (default)
//                         -1:  ditto, but without quotes.
//                         -2:  as 0, but chars number-only like +1                 [DEPRECATED: use pp_IntCh,false instead]
//                         -3:  as -1, ""                                           [ "" (and pp_StrFmt,-1)]
//                          1: as number only, eg {97, 98, 99}                      [DEPRECATED: use pp_StrFmt,3,pp_IntCh,false instead]
//                          3: as number&text, eg {97a, 98b, 99c}
//          pp_IntCh        show ints as eg 65'A', default false (==just 65)
//          pp_IntFmt       Integer format, default "%d"
//                          NB: applies to pp_StrFmt 1 as well.
//          pp_FltFmt       Float format, default "%.10g"
//                          Both pp_IntFmt and pp_FltFmt can contain extra text,
//                          eg "#%08x (integer)", "%04.1 km", or "%.2f US$"
//          pp_Ascii        Min/max $ascii character, default {' ',#7D}
//                          If sequences are passed, they define ranges.
//                          Eg, for ISO 8859-1, use {{#20,#A0},{#7E,#FF}},
//                          since characters 0..31 and 127..159 are system codes.
//                          (Note it is {start1,start2,...},{end1,end2,...})
//          pp_Date         "": no special date handling (Default)
//                          "%04d-%02d-%02d": eg 2003-12-31
//                          "%02d/%02d/%04d": eg 31/12/2003
//                          Sequences of 3 integers, in the form {day,month,year} or
//                          {year,month,day}, with 1<=day<=31, 1<=month<=12, and
//                          1900<=year<=3000 are recognised as dates.
//          pp_Brkt         "{}" (default) outputs '{' at the start of a (nested)
//                          sequence and '}' at the end. Must be two characters.
//          pp_Q22          Show quotes as #22 (default 0, ie \")
//
//   eg ppOpt({pp_StrFmt,0,pp_Nest,2})
//
// More Examples of pp_Nest:
// ========================
//
// obj={1,{2,{3,3},2},1}
// ppOpt({pp_Nest,0})
// pp(obj) gives: 
// 
// {1, {2, {3,3}, 2}, 1}
//
// ppEx(obj,{pp_Nest,1}) gives:
//
// {1,
//  {2, {3,3}, 2},
//  1}
//
// ppEx(obj,{pp_Nest,2}) gives:
//
// {1,
//  {2,
//   {3,3},
//   2},
//  1}
//
// nest may also be a sequence of {indent,nest_level}.
//  In the above examples, note how the 1, {, and 1 display in the 
//  same column. If an indent level is specified, spaces are inserted 
//  in the "{1" to maintain alignment.
//
// ppEx(obj,{pp_Nest,{2,2}}) gives:
//
// { 1,
//   { 2,
//     { 3,3},
//     2},
//   1}
//
// ppEx(obj,{pp_Nest,{3,2}}) gives:
//
// {  1,
//    {  2,
//       {  3,3},
//       2},
//    1}
//
// Naturally, some experimentation may be required to find the 
// indent/nest combination which works best with your data.
//
// Also, specifying a nest of -1 suppresses the trailing \n
//
// Programming notes
// =================
//
//    no spaces in innermost sequences:
//          if atom(cl[i]) and (i=length(cl) or atom(cl[i+1])) then
//              -- as req by Juergen Luethje
//              sep=","
//          else
//              sep=", "
//          end if
//
// If you are interested in how it works, (obviously you need to at 
// least skim the rest), the key to understanding is in the recursion:
//
//  function $prnf(object cl, integer col, integer indent, integer prnt, integer nestlvl)
//          len+=$prnf(cl[i],col+len,col+$nindent,[0|prnt],nestlvl-1)
//
//  Briefly, cl is the object being printed,
//  col & indent are column and indent with a few subtle twists ;-),
//  prnt=0 allows the routine to find out long it would be if printed, so it can make
//   an informed decision whether it fits or if it needs to break the line,
//  and nestlvl is the nest level, decremented as we recurse.
//
//  Otherwise it is pretty trivial - there is more glue round puts() 
//  and to set up the parameters than anything else.
//
//DEV wrong one for newEmit
//!/**/include builtins\pprntf.e -- (not strictly necessary, but saves on opCallOnce/fwd calls/onDeclaration)
let /*integer*/ $ppp_Maxlen = 78; // break lines longer than this
let /*integer*/ $ppp_Indent = 0; // auto-indent all lines this much
let /*object*/ $ppp_Nest = 0; // nest level
let /*integer*/ $ppp_Pause = 0; // pause display after this many lines, 0=never pause
let /*integer*/ $ppp_StrFmt = 0; // 0=text as strings, -1 without quotes,
                            // 3 as numbers [each as per pp_IntCh]
//3/4/21
//integer $ppp_IntCh = true  -- ints as eg 65'A' (false=just 65, (-1 and ' '..'~')=just 'A')
let /*integer*/ $ppp_IntCh = false; // ints as eg 65 (true=65'A', (-1 with ' '..'~')=just 'A')
let /*integer*/ $ppp_Init = 0;
let /*object*/ $ppp_Ascii; //={#20,#7D}  -- low $ascii [ranges]
let /*sequence*/ $ppp_IntFmt; //="%d"     -- integer display format
let /*sequence*/ $ppp_FltFmt; //="%.10g"  -- float display format
let /*sequence*/ $ppp_Date; //=""        -- date handling
let /*sequence*/ $ppp_Br; //="{}"         -- Bracket characters
let /*integer*/ $ppp_Q22 = 0; // Show quotes as #22 (default 0)
let /*sequence*/ $ascii;
let /*integer*/ $ppp_File = 1; // default: display to Screen

//!/**/  string $ppp_result --/*
let /*sequence*/ $ppp_result; // print result if $ppp_File is 0
//!*/

/* Not required for Phix (see psym.e routine syminit)
global constant pp_File     = 1,
                pp_Maxlen   = 2,
                pp_Indent   = 11,
                pp_Pause    = 3,
                pp_StrFmt   = 4,
                pp_IntFmt   = 5,
                pp_FltFmt   = 6,
                pp_Nest     = 7,
                pp_Ascii    = 8,
                pp_Date     = 9,
                pp_Brkt     = 10,
                pp_Q22      = 12,
                pp_IntCh    = 13
*/

//DEV:
//!/**/ string $pline --/*
let /*sequence*/ $pline; // output line, as built by $sput()
//!*/
let /*integer*/ $plen = 0; // used part of $pline; rest is garbage
let /*integer*/ $sline = 0; // counter for screen line
let /*integer*/ $nindent; // indent increment when nesting
function $spurge() {
//
// display/concatenate the output built so far
//
    if ($ppp_File) {
        puts($ppp_File,$subss($pline,1,$plen));
    } else {
        $ppp_result = $conCat($ppp_result, $subss($pline,1,$plen), false);
    }
    $plen = 0;
}
//integer dieonceonly
//      dieonceonly=1

/*
constant M_WAIT_KEY = 26
*/
function $sput(/*object*/ txt) {
//
// bundle "puts(1," calls together for output one line at a time.
//
    let /*integer*/ p = $plen+1;
    if (atom(txt)) {
        $plen += 1;
    } else {
//if dieonceonly then
//----/**/if not string(txt) then ?9/0 end if    --DEV
//dieonceonly=0
//end if
        $plen += length(txt);
    }
    if (compare($plen,length($pline))>0) {
        $pline = $conCat($pline, repeat(0X20,$plen-length($pline)), false);
    }
    $pline = $repss($pline,p,$plen,txt);
    if (equal($subse($pline,$plen),0XA)) {
        $spurge();
        if (($ppp_File===1) && $ppp_Pause) {
            $sline += 1+($plen>$ppp_Maxlen);
            if ($sline>=$ppp_Pause) {
/**/
                if (wait_key()) { } /*    -- Phix
                if machine_func(M_WAIT_KEY,0) then end if   --      -- RDS */ 
                $sline = 0;
            }
        }
    }
}
let /*sequence*/ $escBytes, $escChars;
//constant $escBytes = "\t\n\r\\\"\'",
//       $escChars = "tnr\\\"\'"
let /*sequence*/ $constants;
//constant $constants = {-1.295837195871e307,"NOVALUE"}

//constant maxgraphic = iff(platform()=LINUX?#7E:255)
function $graphic(/*object*/ cl) {
    if (((integer(cl) && compare(cl,1)>=0) && compare(cl,255)<=0) && $subse($ascii,cl)) {
        return 1;
    }
    return 0;
}
/*without warning*/ // suppress short-circuit warning
let /*integer*/ $cl1q = 0; // cl[1] was '"'
let /*integer*/ $cllq = 0; // cl[-1] was '"'
function $prnf(/*object*/ cl, /*integer*/ col, /*integer*/ indent, /*integer*/ prnt, /*integer*/ nestlvl) {
    let /*integer*/ len, iplus1, k, ch;
    let /*integer*/ aschar, asbacktick;
    let /*sequence*/ sep, txt;
    let /*object*/ chint;
    if (sequence(cl)) {
//23/11/19: (I just never want to see {"this",{9,10}} as {"this","\t\n"} ever again, thank you very much!)
//      if $ppp_StrFmt<=0 then
        if (string(cl) && $ppp_StrFmt<=0) {
//put back 26/4/2020:
 /**/ aschar = string(cl); /* -- Phix
            aschar = (length(cl)>0)         */ 
                                                 // RDS Eu:
            asbacktick = true;
            for (let i=1, i$lim=length(cl); i<=i$lim; i+=1) {
                chint = $subse(cl,i);
// 15/3/2010:
//--                if $ppp_StrFmt=0 then
//              if chint<' ' then   -- "\r\n\t" or escape chars "&'
//--                    if chint<' ' or find(chint,$escBytes) then   -- "\r\n\t" or escape chars "&'
//                  if not find(chint,$escBytes) then    -- "\r\n\t" or escape chars "&'
//                      aschar = 0
//                      exit
//                  end if
//                  aschar += 1
//              end if
//              if find(chint,$escBytes) then    -- "\t\n\r\\\"\'"
                k = find(chint,$escBytes);       // "\t\n\r\\\"\'"
                if (k) {
                    aschar += 1;
                    if (k<3) { asbacktick = false; }
                    if ($ppp_Q22 && (equal(chint,0x22))) { // ie '"'
                        // \"blah ==> #22&"blah
                        // blah\"blah ==> blah"&#22&"blah
                        // blah\" ==> blah"&#22
                        if ((i===1) || (equal(i,length(cl)))) {
                            aschar += 4;
                        } else {
                            aschar += 5;
                        }
                    }
                } else if (compare(chint,0X20)<0) {
                    aschar = 0;
                    break;
                } else if (!$graphic(chint)) {
                    aschar = 0;
                    break;
                } else if (equal(chint,0X60)) {
                    asbacktick = false;
                }
            }
            if (aschar) {
//              len = length(cl)+(aschar-1) -- allow for escape chars
                len = length(cl);
                if (!asbacktick) {
                    len += aschar-1;  // allow for escape chars
                }
                if (prnt) {
                    if (aschar>1 && !asbacktick) {
                        for (let i=length(cl); i>=1; i-=1) {
                            ch = $subse(cl,i);
                            if (find(ch,$escBytes)) {  // escape chars
                                if ($ppp_Q22 && (ch===0x22)) { // ie '"'
                                    // \"blah ==> #22&"blah
                                    // blah\"blah ==> blah"&#22&"blah
                                    // blah\" ==> blah"&#22
                                    if (i===1) {
//                                      cl = "#22&\""&cl[2..length(cl)]
                                        cl = $conCat(`#22&"`, $subss(cl,2,length(cl)));
//                                      if $ppp_StrFmt!=-1
//                                      and $ppp_StrFmt!=-3 then
                                        if ($ppp_StrFmt!==-1) {
                                            $cl1q = 1;
                                        }
                                    } else if (equal(i,length(cl))) {
//                                      cl = cl[1..i-1]&"\"&#22"
                                        cl = $conCat($subss(cl,1,i-1), `"&#22`);
//                                      if $ppp_StrFmt!=-1
//                                      and $ppp_StrFmt!=-3 then
                                        if ($ppp_StrFmt!==-1) {
                                            $cllq = 1;
                                        }
                                    } else {
//                                      cl = cl[1..i-1]&"\"&#22&\""&cl[i+1..length(cl)]
                                        cl = $conCat($conCat($subss(cl,1,i-1), `"&#22&"`), $subss(cl,i+1,length(cl)));
                                    }
//                              else
//22/6/19 (-3 is now deprecated, though was not entirely sure what this was meant to be doing anyways...)
//                              elsif $ppp_StrFmt!=-3 then
                                } else {
                                    cl = $repe(cl,i,0X5C);
                                    ch = $subse($escChars,find(ch,$escBytes));
                                    cl = $conCat($conCat($subss(cl,1,i), ch), $subss(cl,i+1,length(cl)));
                                }
                            }
                        }
                    }
//22/6/19:
//                  if $ppp_StrFmt=-1
//                  or $ppp_StrFmt=-3 then
                    if ($ppp_StrFmt===-1) {
                        $sput(cl);
                    } else if (asbacktick) {
                        $sput($conCat($conCat(0X60, cl), 0X60));
                    } else {
                        if ($ppp_Q22 && $cl1q) {
                            $cl1q = 0;
                            if ($cllq) {
                                $sput(cl);
                                $cllq = 0;
                            } else {
                                $sput($conCat(cl, 0X22));
                            }
                        } else if ($ppp_Q22 && $cllq) {
                            $cllq = 0;
                            $sput($conCat(0X22, cl));
                        } else {
                            $sput($conCat($conCat(0X22, cl), 0X22));
                        }
                    }
                }
//              if $ppp_StrFmt!=-1
//              and $ppp_StrFmt!=-3 then
                if ($ppp_StrFmt!==-1) {
                    len += 2;
                }
                return len;
            }
        }
        // date handling added for George Walters 12/10/2003
        if ((((((length($ppp_Date) && (equal(length(cl),3))) && integer($subse(cl,1))) && integer($subse(cl,2))) && integer($subse(cl,3))) && ((((compare($subse(cl,1),1)>=0 && compare($subse(cl,1),31)<=0) && compare($subse(cl,3),1900)>=0) && compare($subse(cl,3),3000)<=0) || (((compare($subse(cl,3),1)>=0 && compare($subse(cl,3),31)<=0) && compare($subse(cl,1),1900)>=0) && compare($subse(cl,1),3000)<=0))) && (compare($subse(cl,2),1)>=0 && compare($subse(cl,2),12)<=0)) {
            txt = sprintf($ppp_Date,cl);
            if (prnt) { $sput($conCat($conCat(0X22, txt), 0X22)); }
            return length(txt)+2;
        }
        len = $nindent;
        if (prnt) {
            txt = repeat(0X20,$nindent);
            txt = $repe(txt,1,$subse($ppp_Br,1));
            $sput(txt);
        }
        if (nestlvl<0) { nestlvl = 0; }
        sep = "";
        for (let i=1, i$lim=length(cl); i<=i$lim; i+=1) {
            if (compare(col+len,$nindent*(($subse($ppp_Nest,2)+1)-nestlvl))>0) {
                if ((i>1 && nestlvl>0) || compare($ppp_Maxlen,(((($prnf($subse(cl,i),col+len,col+$nindent,0,nestlvl-1)+col)+len)+length(sep))+2)+$ppp_Indent)<=0) {
                    if (!prnt) { return $ppp_Maxlen+1; }         // force linebreak
                    if (length(sep)) {
                        $sput(",\n");
                        $sput(repeat(0X20,(indent+$nindent)+$ppp_Indent));
                    }
                    len = $nindent;
                    col = indent;
                    sep = "";
                }
            }
            if (prnt && length(sep)) { $sput(sep); }
            len += length(sep);
            len += $prnf($subse(cl,i),col+len,col+$nindent,prnt,nestlvl-1);
            iplus1 = i+1;
            if (atom($subse(cl,i)) && ((equal(i,length(cl))) || atom($subse(cl,iplus1)))) {
                // as req by Juergen Luethje
                sep = ",";
            } else {
                sep = ", ";
            }
        }
        if (prnt) { $sput($subse($ppp_Br,2)); }
        return len+1;
    }
    if (integer(cl) || ((compare(cl,-0xFFFFFFFF)>=0 && compare(cl,0xFFFFFFFF)<=0) && (equal(cl,floor(cl))))) {
        if (($graphic(cl) && $ppp_IntCh) && (!find(cl,$escBytes) || compare(cl,0X20)>=0)) {
//22/6/19:
//          if $ppp_StrFmt=1
//          or $ppp_StrFmt=-2
//          or $ppp_StrFmt=-3 then
//              txt = sprintf($ppp_IntFmt,cl)
//30/1/18:
//          elsif find(cl,$escBytes) then
            if (find(cl,$escBytes)) {
                // (just `"'\`, aka "\"\'\\", not "\r\n\t\e\0":)
//              txt = sprintf("%d'\\%s'",{cl,cl})
                txt = sprintf(`%d'\\%s'`,["sequence",cl,cl]);
            } else if (($ppp_IntCh===-1) && compare(cl,0X7E)<=0) {
                txt = sprintf(`'%s'`,["sequence",cl]);
            } else {
                txt = sprintf("%d'%s'",["sequence",cl,cl]);
            }
//3/12/18:
//      elsif cl<0 then
        } else if (compare(cl,0)<0 && (!equal($subse($ppp_IntFmt,1),0X25))) {
            // we may want eg -$14, not $-14
            txt = $conCat(0X2D, sprintf($ppp_IntFmt,-cl));
        } else {
            txt = sprintf($ppp_IntFmt,cl);
        }
    } else {
        k = find(cl,$constants);
        if (k) {
            k += 1;
            txt = $subse($constants,k);
//25/11/18:
//      elsif cl<0 then
//      elsif cl<0 and $ppp_FltFmt[2]='.' then
        } else if (compare(cl,0)<0 && (!equal($subse($ppp_FltFmt,1),0X25))) {
            // we may want eg -$14.99, not $-14.99
            txt = $conCat(0X2D, sprintf($ppp_FltFmt,-cl));
        } else {
            txt = sprintf($ppp_FltFmt,cl);
        }
    }
    if (prnt) { $sput(txt); }
    return length(txt);
}
/*with warning*/ function $setAscii() {
    $ascii = repeat(0,255);
    if (!equal(length($ppp_Ascii),2)) { crash("length($ascii) must be 2",{},4); }
    let /*object*/ [,minasc,maxasc] = $ppp_Ascii;
    if (!sequence(minasc)) { minasc = ["sequence",minasc]; }
    if (!sequence(maxasc)) { maxasc = ["sequence",maxasc]; }
    if (!equal(length(minasc),length(maxasc))) { crash("length(minasc)!=length(maxasc)",{},4); }
    if (find(0,minasc) || find(0,maxasc)) { crash("find(0,minasc) or find(0,maxasc)",{},4); }
    for (let i=1, i$lim=length(minasc); i<=i$lim; i+=1) {
        $ascii = $repss($ascii,$subse(minasc,i),$subse(maxasc,i),1);
    }
    for (let i=1, i$lim=length($escBytes); i<=i$lim; i+=1) {
        $ascii = $repe($ascii,$subse($escBytes,i),1);
    }
}
function $pp_Init() {
    $ppp_Nest = 0;
//simplified 24/11/16:
//  $ppp_Ascii = {#20,#FF}
//DEV/SUG
//  if platform()=LINUX then
//      $ppp_Ascii = {{#20,#A0},{#7E,#FF}}
//      $ppp_Ascii = {#20,#7F}
    $ppp_Ascii = ["sequence",0x20,0x7D];
//  end if
    $ppp_IntFmt = "%d";
    $ppp_FltFmt = "%.10g";
    $ppp_Date = "";
    $ppp_Br = "{}";
//  $escBytes = "\t\n\r\\\"\'\e\E"
//  $escBytes = {'\t','\n','\r','\\','\"','\'','\e','\E'}
    $escBytes = ["sequence",9,0XA,0XD,0X5C,0X22,0X27,0X1B,0X45];
    $escChars = "tnr\\\"\'eE";
//DEV you should have to explicitly load this sort of thing with a ppOpt() call...
    $constants = ["sequence",-1.295837195871e307,"NOVALUE"];
    $setAscii();
    $ppp_Init = 1;
}
function $setOpt(/*sequence*/ options) {
    let /*integer*/ f, ip1, flvl = 4;
    let /*object*/ tmp;
    if (!$ppp_Init) { $pp_Init(); }
    if (and_bits(1,length(options))) { crash("length(options) not even",{},flvl); }
    options = deep_copy(options);
    for (let i=1, i$lim=length(options); i<=i$lim; i+=2) {
        f = $subse(options,i);
        ip1 = i+1;
        tmp = $subse(options,ip1);
        if (f===pp_File) {
            options = $repe(options,ip1,$ppp_File);
            $ppp_File = tmp;
        } else if (f===pp_Maxlen) {
            options = $repe(options,ip1,$ppp_Maxlen);
            if (equal(tmp,0)) { tmp = 78; }
            $ppp_Maxlen = tmp;
        } else if (f===pp_Indent) {
            options = $repe(options,ip1,$ppp_Indent);
            $ppp_Indent = tmp;
        } else if (f===pp_Pause) {
            options = $repe(options,ip1,$ppp_Pause);
            $ppp_Pause = tmp;
        } else if (f===pp_StrFmt) {
            options = $repe(options,ip1,$ppp_StrFmt);
            $ppp_StrFmt = tmp;
            if (equal(tmp,-2)) {
                crash("pp_StrFmt,-2 deprecated: use pp_IntCh,false instead",{},flvl);
            } else if (equal(tmp,-3)) {
                crash("pp_StrFmt,-3 deprecated: use pp_StrFmt,-1,pp_IntCh,false instead",{},flvl);
            } else if (equal(tmp,1)) {
                crash("pp_StrFmt,1 behaves as 3: use pp_StrFmt,3,pp_IntCh,false instead",{},flvl);
            }
//             -2:  as 0, but chars number-only like +1                 [DEPRECATED: use pp_IntCh,false instead]
//             -3:  as -1, ""                                           [ "" (and pp_StrFmt,-1)]
//              1: as number only, eg {97, 98, 99}                      [DEPRECATED: use pp_StrFmt,3,pp_IntCh,false instead]
        } else if (f===pp_IntFmt) {
            options = $repe(options,ip1,$ppp_IntFmt);
            $ppp_IntFmt = tmp;
        } else if (f===pp_IntCh) {
            options = $repe(options,ip1,$ppp_IntCh);
            $ppp_IntCh = tmp;
        } else if (f===pp_FltFmt) {
            options = $repe(options,ip1,$ppp_FltFmt);
            $ppp_FltFmt = tmp;
        } else if (f===pp_Nest) {
            options = $repe(options,ip1,$ppp_Nest);
            $ppp_Nest = tmp;
        } else if (f===pp_Ascii) {
            options = $repe(options,ip1,$ppp_Ascii);
            $ppp_Ascii = tmp;
            $setAscii();
        } else if (f===pp_Date) {
            options = $repe(options,ip1,$ppp_Date);
            $ppp_Date = tmp;
        } else if (f===pp_Brkt) {
            options = $repe(options,ip1,$ppp_Br);
            $ppp_Br = tmp;
        } else if (f===pp_Q22) {
            options = $repe(options,ip1,$ppp_Q22);
            $ppp_Q22 = tmp;
        }
    }
    return options;
}

/*global*/ function ppOpt(/*sequence*/ options) {
// Permanently (or until next ppOpt call) change selected formatting options.
// options is a pair-sequence, selected from:
//   Odd element:      Even element:
//      pp_File         0:no output (used by ppf())
//                      1:display to Screen (the default),
//                      n=an open file handle
//      pp_Nest         nest level, eg:
//                      0: output is {1, {2, {3,3}, 2}, 1}
//                      1: output is {1,
//                                    {2, {3,3}, 2},
//                                    1}
//      pp_Maxlen       split lines at column, default 78
//      pp_Indent       Auto-indent amount, default 0
//      pp_Pause        pause every n lines, default=23.
//                      specify 0 for no pause
//      pp_StrFmt       0: print strings as eg "abc" (default)
//                     -1:  ditto, but without quotes.
//                     -2:  as 0, but chars number-only like +1                 [DEPRECATED: use pp_IntCh,false instead]
//                     -3:  as -1, ""                                           [ "" (and pp_StrFmt,-1)]
//                      1: as number only, eg {97, 98, 99}                      [DEPRECATED: use pp_StrFmt,3,pp_IntCh,false instead]
//                      3: as number&text, eg {97a, 98b, 99c}
//      pp_IntCh        show ints as eg 65'A', default false (==just 65)
//      pp_IntFmt       integer format, default "%d"
//                      NB: applies to pp_StrFmt 1 as well.
//      pp_FltFmt       float format, default "%g"
//                      Both pp_IntFmt and pp_FltFmt can contain extra text,
//                      eg "#%08x (integer)", "%04.1 km", or "%.2f US$"
//
//      pp_Ascii        min/max $ascii character, default {' ',#7D}
//                      if sequences are passed, they define ranges.
//                      Eg, for ISO 8859-1, use {{#20,#A0},{#7E,#FF}},
//                      since characters 0..31 and 127..159 are system codes.
//
//      pp_Date         "": no special date handling (Default)
//                      "%04d-%02d-%02d": eg 2003-12-31
//                      "%02d/%02d/%04d": eg 31/12/2003
//                      Sequences of 3 integers, in the form {day,month,year} or
//                      {year,month,day}, with 1<=day<=31, 1<=month<=12, and
//                      1900<=year<=3000 are recognised as dates.
//
//      pp_Brkt         "{}" (default) outputs '{' at the start of a (nested)
//                      sequence and '}' at the end. Must be two characters.
//
//      pp_Q22          Show quotes as #22 (default 0, ie \")
//
//   eg ppOpt({pp_StrFmt,0,pp_Nest,2})
//
    options = $setOpt(options);
}
// internal, so that pp() and ppEx() have same nesting/fatal error level:
function $pp_Ex(/*object*/ o, /*sequence*/ options) {
// pretty print object with selected options (as per ppOpt)
// The previous pretty_print options are restored on exit.
    options = $setOpt(options);
    $pline = "";
    $ppp_result = "";
    if (!sequence($ppp_Nest)) {
        $ppp_Nest = ["sequence",1,$ppp_Nest];
    }
    $nindent = $subse($ppp_Nest,1);
    if ($prnf(o,0,0,1,$subse($ppp_Nest,2))) { }
    if (compare($subse($ppp_Nest,2),0)>=0) {
        $sput("\n");
    } else if ($plen) {
        $spurge();
    }
    options = $setOpt(options); // restore
}

/*global*/ function ppEx(/*object*/ o, /*sequence*/ options) {
// pretty print object with selected options (as per ppOpt)
// The previous pretty_print options are restored on exit.
    $pp_Ex(o,options);
}

/*global*/ function pp(/*object*/ o, /*sequence*/ options=["sequence"]) {
// pretty print
// For options see ppEx, ppOpt, and ppExf
    $pp_Ex(o,options);
}

/*global*/ function ppExf(/*object*/ o, /*sequence*/ options) {
// return object pretty printed, with options (as per ppOpt)
// The previous pretty_print options are restored on exit.
    for (let i=1, i$lim=length(options); i<=i$lim; i+=2) {
        if (equal($subse(options,i),pp_Nest)) {
            ppEx(o,$conCat(options, ["sequence",pp_File,0]));
            return $ppp_result;
        }
    }
    ppEx(o,$conCat(options, ["sequence",pp_File,0,pp_Nest,-1]));
    return $ppp_result;
}

/*global*/ function ppf(/*object*/ o, /*sequence*/ options=["sequence"]) {
// return object pretty printed (with embedded \n), no trailing \n
    return ppExf(o,options);
}
//sequence s 
//s={{{"blue", "red"}, {"cyan", "white"}},
//   {{"blue", "red"}, {"cyan", "white"}}}
//
//-- s={1,{2,{3,3},2},1}
//ppEx(s,{pp_Nest,0})
//puts(1, "---------------------------\n")
//ppEx(s,{pp_Nest,1})
//puts(1, "---------------------------\n")
//ppEx(s,{pp_Nest,2})
//puts(1, "---------------------------\n")
//ppEx(s,{pp_Nest,{2,2}})
//puts(1, "---------------------------\n")
//ppEx(s,{pp_Nest,3})
//if getc(0) then end if
//s={{1, 2, 3, 4}, {1, 2, 4, 3}, {1, 3, 2, 4}, {1, 3, 4, 2}, {1, 4, 2, 3},
// {1, {4, 3}, 2}, {2, 1, 3, 4}, {2, 1, 4, 3}, {2, 3, 1, 4}, {2, 3, 4, 1},
// {{2, 4, 1, 3}, {2, 4, 3, 1}}, {3, 1, 2, 4}, {3, 1, 4, 2}, {3, 2, 1, 4},
// {3, 2, 4, 1}, {3, 4, 1, 2}, {3, 4, 2, 1}, {4, 1, 2, 3}, {4, 1, 3, 2},
// {4, 2, 1, 3}, {4, 2, 3, 1}, {4, 3, 1, 2}, {4, 3, 2, 1}}
//ppEx(s,{pp_Nest,0})
//puts(1, "---------------------------\n")
//ppEx(s,{pp_Nest,1})
//pp("Hello World\n")
//if getc(0) then end if
