// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\pqueue.e
// =================
//
//  Basic implementation of priority and other queues (an autoinclude).
//
// Priority queues (see about half way down for traditional queues/stacks)
// ===============
//
//  A priority queue is kind of fast to-do list, whereby you can add items,
//  as many as you want, in any order, and quickly retrieve the lowest (if 
//  it is a MIN_HEAP) or highest(if it is a MAX_HEAP) element - one or the 
//  other per list only, not both.
//
//  Relatively small lists gain little, however I can attest to seeing this
//  thoroughly trounce an earlier version of a program, that had to process 
//  over 800,000 numbers in a different order to the way they were created, 
//  by a factor of 17.5 (0.8s vs 14s), yet the only real difference was how 
//  those numbers were stored/sorted.
//
//  Also implements standard (FIFO) queues and (LIFO) stacks.
//
// Interface
// =========
//
//  integer pqid = pq_new(integer t=MIN_HEAP) creates a new priority queue.
//              [optional, omit pqid below to use the default common queue]
//              The argument t must be either MIN_HEAP (ie pop 1 before 2)
//              or MAX_HEAP (ie pop 2 before 1). Note the default queue is
//              always a MIN_HEAP (ie pqid of 1 in the calls below).
//
//  pq_size(integer pqid=1) obtains the number of entries currently in the list.
//
//  pq_empty(integer pqid=1) yields true when the list is empty, false otherwise.
//
//  pq_add(sequence item, integer pqid=1) adds an item to a priority queue, where
//                                        item is {object data, object priority}.
//
//  sequence item = pq_pop(integer pqid=1) obtains highest/lowest priority item.
//                           The item returned is {object data, object priority}.
//
//  object data = pq_pop_data(integer pqid=1) as pq_pop but discards priority.
//                          There would be no way to determine what the priority 
//                          was, unless you had buried it somewhere inside data.
//
//  pq_destroy(integer pqid=1, bool justclear=false) removes/frees a queue once
//                          no longer needed. [pqid of 1 is always just cleared]
//
//  Traditionally the priority is an integer, but here it can also be a float, 
//  a string, or even a complex nested sequence.
//
//  Obviously, using the default queue (of 1) can cause problems if it is used 
//  for different things simultaneously, but also obviously is quite handy for 
//  smaller/simpler (quick 'n dirty) programs.
//
// Technical details
// =================
//
// A priority queue is a tree stored in a flat list, as follows
//
//  tree            1
//                2   3
//               4 5 6 7
//
//             -   1   1   2   2   3   3    <-- parent idx (virtual)
//  node       1   2   3   4   5   6   7    <-- this is sequence $pq[pqid]
//            2,3 4,5 6,7  -   -   -   -    <-- children idx (virtual)
//
// The tree root is at index 1, with valid indices 1 through n, and an element 
// at index i having:
//  * children at indices 2i and 2i+1 - absent if > length(), of course.
//  * a parent at index floor(i/2) - except, obviously, for the root at [1].
//
// Shape property: The tree is always fully filled, except for the last row.
//                 The last row is always left-filled, without any gaps.
// Heap property: The key in each node is always >= or <= its childrens keys.
//   (Note there is no guaranteed left/right relation of any child keys.)
//
// Insertion proceeds as follows (see also flat table form below):
//
//               8                       8                  9
//            5     7       ==>       5     9   ==>      5     8
//          3  4  X(=9)             3  4  7            3  4  7
//
// ie we add 9 at X ($pq[$+1]), then swap it with parent (upheap) as needed.
// Note that the 9 is initially placed where it is not because of any relation
// to the 8, 7 or 5, but to satisfy the shape constraint. Likewise both left
// and right children are swapped with their parent identically, and without 
// any consideration of the value in the other sibling (if present).
// Alt: first observe the shape constraint, then enforce the heap constraint.
//
// Removal (of root, the only type of removal supported) proceeds as follows:
//
//               9                       6                 8
//            8     5       ==>       8     5   ==>     6     5
//          3  6                    3                 3 
//
// ie root := 6 (ie $pq[$]), then swap with larger/smaller child (downheap) as needed.
// The downheap of 6 stops early here because it is greater than all of its children.
// Note that shape and heap constraints are satisfied both initially and on completion,
// even though to the casual onlooker the initial 8 and 5, and the final 6 and 5 might 
// at first glance appear to be the wrong way round.
//
// Naturally the code below belays actually planting the 9/6 until the final step.
// Rewriting the above examples in flat table form, with notional _ markers:
//
//          Insertion: 8 5 7 3 4 _          Removal: 9 8 5 3 6
//                 ==> 8 5 _ 3 4 7               ==> _ 8 5 3
//                 ==> _ 5 8 3 4 7               ==> 8 _ 5 3
//                 ==> 9 5 8 3 4 7               ==> 8 6 5 3
//
// It should now be clear that those operations are very low cost, and in fact both
// insertion and removal are O(log2(n)) operations.
//
const $PDATA = 1, $PRIORITY = 2
//global enum MIN_HEAP = -1, MAX_HEAP = +1  -- now in psym.e
let /*bool*/ $pqinit = false;
let /*sequence*/ $pq, $pqtype, $pqcrid;
let /*integer*/ $freelist = 0;
function $pq_compare(/*object*/ priority1, priority2) {
    return compare(priority1,priority2);
}
//constant PQ_COMPARE = routine_id("pq_compare")
function $pq_init() {
    $pq = ["sequence",["sequence"]];
    $pqtype = ["sequence",MIN_HEAP];
//26/9/19:
//  $pqcrid = {-1}
    $pqcrid = ["sequence",$pq_compare];
    $pqinit = true;
}
//global function pq_new(integer t=MIN_HEAP, crid=$pq_compare)
/*global*/ function pq_new(/*integer*/ t=MIN_HEAP, crid=-2) {
    if ((t!==MIN_HEAP) && (t!==MAX_HEAP)) { crash("9/0"); }
    if (crid===-2) { crid = $pq_compare; }
    if (!$pqinit) { $pq_init(); }
    let /*integer*/ pqid;
    if ($freelist===0) {
        $pq = append($pq,["sequence"]);
        $pqtype = append($pqtype,t);
        $pqcrid = append($pqcrid,crid);
        pqid = length($pq);
    } else {
        pqid = $freelist;
        $freelist = $subse($pqtype,$freelist);
        $pq = $repe($pq,pqid,["sequence"]);
        $pqtype = $repe($pqtype,pqid,t);
        $pqcrid = $repe($pqcrid,pqid,crid);
    }
    return pqid;
}
//global procedure pq_destroy(integer pqid=1, bool justclear=false, integer crid=$pq_compare)
/*global*/ function pq_destroy(/*integer*/ pqid=1, /*bool*/ justclear=false, /*integer*/ crid=-2) {
    if (!$pqinit) { $pq_init(); }
    if (!sequence($subse($pq,pqid))) { crash("9/0"); }
    if (crid===-2) { crid = $pq_compare; }
    if ((pqid===1) || justclear) {
        $pq = $repe($pq,pqid,["sequence"]);
        $pqcrid = $repe($pqcrid,pqid,crid);
    } else {
        $pqtype = $repe($pqtype,pqid,$freelist);
        $freelist = pqid;
        $pq = $repe($pq,pqid,0);
    }
}

/*global*/ function pq_size(/*integer*/ pqid=1) {
    if (!$pqinit) { $pq_init(); }
    return length($subse($pq,pqid));
}

/*global*/ function pq_empty(/*integer*/ pqid=1) {
//  if not $pqinit then $pq_init() end if
    return equal(pq_size(pqid),0);
}

/*global*/ function pq_add(/*sequence*/ item, /*integer*/ pqid=1) {
// item is {object data, object priority}
    if (!$pqinit) { $pq_init(); }
    if (!equal(length(item),2)) { crash("9/0"); }
    let /*integer*/ n = length($subse($pq,pqid))+1, 
                    m = floor(n/2), 
                    heap_type = $subse($pqtype,pqid), 
                    crid = $subse($pqcrid,pqid);
//  $pq[pqid] &= 0
//  $pq[pqid] = deep_copy($pq[pqid]) & 0
//15/2/22 (spotted in passing, gotta be better!)
//  sequence pqp = deep_copy($pq[pqid]) & 0
    let /*sequence*/ pqp = $subse($pq,pqid);
    $pq = $repe($pq,pqid,0);
    pqp = $conCat(pqp, 0, false);
//  $pq[pqid] = pqp
//  $pq[pqid] = deep_copy($pq[pqid] & 0)
    // append at end, then up heap
//  while m>0 and call_func(crid,{item[$PRIORITY],$pq[pqid][m][$PRIORITY]})=heap_type do
    while (m>0 && (equal(call_func(crid,["sequence",$subse(item,$PRIORITY),$subse($subse(pqp,m),$PRIORITY)]),heap_type))) {
//      $pq[pqid][n] = $pq[pqid][m]
        pqp = $repe(pqp,n,$subse(pqp,m));
        n = m;
        m = floor(m/2);
    }
//  $pq[pqid][n] = item
    pqp = $repe(pqp,n,item);
    $pq = $repe($pq,pqid,pqp);
}

/*global*/ function pq_pop(/*integer*/ pqid=1) {
//  if not $pqinit then $pq_init() end if     -- (would crash next either way)
    let /*sequence*/ result = $subse($subse($pq,pqid),1);
    let /*integer*/ qn = length($subse($pq,pqid)), 
                    n = 1, 
                    m = 2, 
                    heap_type = $subse($pqtype,pqid), 
                    crid = $subse($pqcrid,pqid);
    while (m<qn) {
        if (compare(m+1,qn)<0 && (equal(call_func(crid,["sequence",$subse($subse($subse($pq,pqid),m+1),$PRIORITY),$subse($subse($subse($pq,pqid),m),$PRIORITY)]),heap_type))) {
            m += 1;
        }
        if (!equal(call_func(crid,["sequence",$subse($subse($subse($pq,pqid),m),$PRIORITY),$subse($subse($subse($pq,pqid),qn),$PRIORITY)]),heap_type)) { break; }
        $pq = $repe($pq,n,$subse($subse($pq,pqid),m),["sequence",pqid]);
        n = m;
        m = m*2;
    }
    $pq = $repe($pq,n,$subse($subse($pq,pqid),qn),["sequence",pqid]);
    $pq = $repe($pq,pqid,$subss($subse($pq,pqid),1,-1-1));
    return result;
}

/*global*/ function pq_pop_data(/*integer*/ pqid=1) {
    return $subse(pq_pop(pqid),$PDATA);
}

/*global*/ function pq_peek(/*integer*/ pqid=1) {
//  if not $pqinit then $pq_init() end if     -- (would crash next either way)
//15/2/22: (erm, not tried...)
    let /*sequence*/ result = $subse($subse($pq,pqid),1);
//  sequence result = deep_copy($pq[pqid][1])
    return result;
}
//
// Traditional queues and stacks
// =============================
//
//  Fairly obviously a queue is exactly like the one in a shop, you do not expect
//  people arriving after you to be served before you, and a stack is exactly like
//  a pile of plates in a kitchen, the ones on the top are regularly removed and
//  replaced, whereas the ones at the bottom could be there for months even years.
//
// Interface
// =========
//
//  integer qid = new_queue(*)              -- create a new FIFO queue
//  integer qid = new_stack()               -- create a new LIFO stack
//  push(integer qid, object item*)         -- add to end/front of queue/stack
//  object item = pop(integer qid*)         -- remove next from queue/stack
//  object item = peep(integer qid*)        -- inspect head of queue/stack
//  pushn(integer qid, sequence items*)     --  push() multiple items
//  sequence items = popn(integer qid, n*)  --  pop() multiple items
//  sequence items = peepn(integer qid, n*) --  peep() multiple items
//  integer res = queue_size(integer qid)   -- return the size of a queue
//  integer res = stack_size(integer qid)   -- return the size of a stack
//  bool res = queue_empty(integer qid)     -- yields true/false
//  bool res = stack_empty(integer qid)     -- yields true/false
//  destroy_queue(integer qid)              -- release a queue for reuse
//  destroy_stack(integer qid)              -- release a stack for reuse
//
//  The * indicates shared routines with a defaulted field which specifies whether 
//  to apply queue or stack behaviour, which you would not usually be expected to 
//  provide, but are not prohibited from so doing: FIFO_QUEUE and LIFO_QUEUE and
//  the default ANY_QUEUE (as all defined in psym.e) can be used when needed.
//  The other (non-starred) routines have no need or use for such a parameter, 
//  and in fact several stack_XXX() are simply aliased to queue_XXX() in psym.e,
//  obviously really only existing to allow/show clearer indication of intent.
//
//enum ANY_QUEUE = 0, FIFO_QUEUE = 1, LIFO_QUEUE = 2    -- as defined in psym.e/p2js.js
let /*bool*/ $q_init = false;
let /*sequence*/ $q, $qtypes;
let /*integer*/ $qfreelist = 0;
//procedure init_q()
//  $q = {}
//  $qtypes = {}
//  $q_init = true
//end procedure

/*global*/ function new_queue(/*integer*/ qtype=FIFO_QUEUE) { // create a new FIFO queue
    assert((qtype===FIFO_QUEUE) || (qtype===LIFO_QUEUE));
//  if not $q_init then init_q() end if
    if (!$q_init) {
        $q = ["sequence"];
        $qtypes = ["sequence"];
        $q_init = true;
    }
    let /*integer*/ qid;
    if ($qfreelist===0) {
        $q = append($q,["sequence"]);
        $qtypes = append($qtypes,qtype);
        qid = length($q);
    } else {
        qid = $qfreelist;
        $qfreelist = $subse($qtypes,$qfreelist);
        $q = $repe($q,qid,["sequence"]);
        $qtypes = $repe($qtypes,qid,qtype);
    }
    return qid;
}

/*global*/ function new_stack(/*integer*/ qtype=LIFO_QUEUE) { // create a new LIFO queue
    return new_queue(qtype);
}

/*global*/ function destroy_queue(/*integer*/ qid) { // [aliased as destroy_stack() in psym.e]
//  if not $q_init then init_q() end if
    if (!sequence($subse($q,qid))) { crash("9/0"); }
    $qtypes = $repe($qtypes,qid,$qfreelist);
    $qfreelist = qid;
    $q = $repe($q,qid,0);
}
let destroy_stack = destroy_queue;

/*global*/ function queue_size(/*integer*/ qid) { // [aliased as stack_size() in psym.e]
//  if not $q_init then init_q() end if
    return length($subse($q,qid));
}
let stack_size = queue_size;

/*global*/ function queue_empty(/*integer*/ qid) { // [aliased as stack_empty() in psym.e]
//  if not $q_init then init_q() end if
    return equal(queue_size(qid),0);
}
let stack_empty = queue_empty;
//[next 3 were aliased in psym.e, but that's not p2js compatible [DEV]]:
// 4/11/22: proper alias handling, that p2js understands, now added
//global procedure destroy_stack(integer qid) destroy_queue(qid) end procedure
//global function stack_empty(integer qid) return queue_empty(qid) end function
//global function stack_size(integer qid) return queue_size(qid) end function

//28/11/22 (remove qtype, since it wasn't used anyway, docs updated)
//global procedure push(integer qid, object item, integer qtype=ANY_QUEUE, bool bSingle=true)
/*global*/ function push(/*integer*/ qid, /*object*/ item, /*bool*/ bSingle=true) {
//  if not $q_init then init_q() end if
    assert(bSingle || sequence(item));
    let /*sequence*/ qq = $subse($q,qid);
    $q = $repe($q,qid,0);
//  if qtype=FIFO_QUEUE
//  or (qtype=ANY_QUEUE and $qtypes[qid]=FIFO_QUEUE) then
    if (bSingle) {
        qq = append(qq,item);
    } else {
        qq = $conCat(qq, item, false);
    }
//  else
//      if bSingle then
//          qq = prepend(qq,item)
//      else
//          qq = deep_copy(item)&qq
//      end if
//  end if
    $q = $repe($q,qid,qq);
}
//global procedure pushn(integer qid, sequence items, integer qtype=ANY_QUEUE)
/*global*/ function pushn(/*integer*/ qid, /*sequence*/ items) {
//  push(qid,items,qtype,false)
    push(qid,items,false);
}
//global function pop(integer qid, n=-1, qtype=ANY_QUEUE, bool bPop=true)
/*global*/ function pop(/*integer*/ qid, n=-1, qtype=ANY_QUEUE, /*bool*/ bPop=true) {
//  if not $q_init then init_q() end if  -- (would crash next either way)
    let /*object*/ result;
    let /*sequence*/ qq = $subse($q,qid);
    let /*bool*/ bDC = bPop; // deep_copy(top)
    if (bPop) {
        let /*integer*/ l = length(qq);
        if ((l===n) || ((n===-1) && (l===1))) {
            $q = $repe($q,qid,["sequence"]);
            bPop = false;
            bDC = false;
        } else {
            $q = $repe($q,qid,0); // (kill refcount)
        }
    }
    if ((qtype===FIFO_QUEUE) || ((qtype===ANY_QUEUE) && (equal($subse($qtypes,qid),FIFO_QUEUE)))) {
        if (n===-1) {
            result = $subse(qq,1);
            if (bPop) { qq = $subss(qq,2,-1); }
        } else {
            result = $subss(qq,1,n);
            if (bPop) { qq = $subss(qq,n+1,-1); }
        }
    } else {
        if (n===-1) {
            result = $subse(qq,-1);
            if (bPop) { qq = $subss(qq,1,-1-1); }
        } else {
            result = $subss(qq,-n,-1);
            if (bPop) { qq = $subss(qq,1,-n-1); }
        }
    }
    if (bPop) {
        $q = $repe($q,qid,qq);
    } else if (bDC) {
        result = deep_copy(result);
    }
    return result;
}

/*global*/ function popn(/*integer*/ qid, n, qtype=ANY_QUEUE) {
    return pop(qid,n,qtype);
}

/*global*/ function peep(/*integer*/ qid, n=-1, qtype=ANY_QUEUE) {
    return pop(qid,n,qtype,false);
}

/*global*/ function peepn(/*integer*/ qid, n, qtype=ANY_QUEUE) {
    return pop(qid,n,qtype,false);
}
