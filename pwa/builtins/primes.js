"use strict";
// auto-generated by pwa/p2js - part of Phix, see http://phix.x10.mx
//
// builtins/$primes.e
// =================
//
let /*sequence*/ $primes;
let /*atom*/ $sieved = 0;
function $init_sieve() {
    $primes = ["sequence",2, 3, 5, 7];
    $sieved = 10;
}
function $add_block() {
    let /*integer*/ N = min(($sieved-1)*$sieved,400000);
    let /*sequence*/ sieve = repeat(1,N); // sieve[i] is really i+$sieved
    for (let i=2, i$lim=length($primes); i<=i$lim; i+=1) { // (evens filtered on output)
        let /*atom*/ p = $subse($primes,i), p2 = p*p;
        if (compare(p2,$sieved+N)>0) { break; }
        if (compare(p2,$sieved+1)<0) {
            p2 += ceil((($sieved+1)-p2)/p)*p;
        }
        p2 -= $sieved;
        if (equal(and_bits(p2,1),0)) { p2 += p; }
//      if sieve[p2] then           -- dang!
        for (let k=p2, k$lim=N; k<=k$lim; k+=p*2) {
            sieve = $repe(sieve,k,0);
        }
//      end if
    }
    for (let i=1, i$lim=N; i<=i$lim; i+=2) {
        if ($subse(sieve,i)) {
            $primes = $conCat($primes, i+$sieved);
        }
    }
    $sieved += N;
}
// replaced with much faster version in pfactors.e:
/*global*/ function $is_prime2(/*atom*/ p) {
    if ($sieved===0) { $init_sieve(); }
    while ($sieved<p) {
        $add_block();
    }
    return compare(binary_search(p,$primes),0)>0;
}

/*global*/ function get_prime(/*integer*/ n) {
    if (n===0) { return 0; }
    if (($sieved===0) || (n===-1)) { $init_sieve(); }
    while (compare(length($primes),n)<0) {
        $add_block();
    }
    return $subse($primes,n);
}

/*global*/ function get_maxprime(/*atom*/ p) {
// returns a suitable maxprime for prime_factors()
    p += 1;
    p = floor(sqrt(p));
    if ($sieved===0) { $init_sieve(); }
    while ($sieved<p) {
        $add_block();
    }
    p = binary_search(p,$primes);
    if (p<0) { p = abs(p)-1; }
    return p;
}

/*global*/ function get_primes(/*integer*/ count=0) {
    if ($sieved===0) { $init_sieve(); }
    while (compare(length($primes),abs(count))<0) {
        $add_block();
    }
    let /*sequence*/ res = $primes;
    if (count<0) {
        res = $subss(res,1,abs(count));
    }
    return res;
}

/*global*/ function get_primes_le(/*integer*/ hi) {
    if ($sieved===0) { $init_sieve(); }
    while (compare($subse($primes,-1),hi)<0) {
        $add_block();
    }
    hi = binary_search(hi,$primes);
    if (hi<0) { hi = abs(hi)-1; }
    let /*sequence*/ res = $subss($primes,1,hi);
    return res;
}
