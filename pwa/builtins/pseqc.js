"use strict";
// auto-generated by pwa/p2js.
//
// pseqc.e
//
// Phix compatibility implementation of OpenEuphoria's builtin
//   insert(), splice(), head(), tail(), remove(), and replace().
//
//  This is an auto-include; there is no need to manually include 
//  this file, unless you need a namespace attached to it.
//
//  When and *if* it becomes clear the Eu builtins are much faster 
//  than this, and it is a measurable issue in anything other than a 
//  pointless benchmark, I will reconsider reimplementing them using 
//  low-level assembly tricks etc to speed things up, but NOT before.
//   (actually, insert/splice/remove/replace are more likely to be
//    front-end tweaks aka syntactic sugar thingies, maybe with a
//    trick or two to avoid requiring the x = {x}.)
//  Besides, if one of these is nearly, but not quite, what you want,
//  it is significantly easier to copy/edit them in this form.
//DEV did I create a proper test set for these?
//  NO: there is a single splice() call in t24slice.exw, nowt else.
//
/*global*/ function insert(/*sequence*/ src, /*object*/ what, /*integer*/ index) {
// insert 1 element
    src = $conCat($conCat($subss(src,1,index-1), 0X30), $subss(src,index,length(src)));
    src = $repe(src,index,what);
    return src;
}
/*global*/ function splice(/*sequence*/ src, /*object*/ what, /*integer*/ index) {
    return $conCat($conCat($subss(src,1,index-1), what), $subss(src,index,length(src)));
}
/*global*/ function head(/*sequence*/ src, /*integer*/ size=1) {
// if size not specified, returns target[1..1]
    if (compare(size,length(src))>=0) { return src; }
    return $subss(src,1,size);
}
/*global*/ function tail(/*sequence*/ src, /*integer*/ size=-1) {
// if size not specified, returns src[2..$]
    let /*integer*/ l = length(src);
    if (compare(size,0)<0) { size += l; }
    if (compare(size,l)>=0) { return src; }
    return $subss(src,l-size+1,l);
}
/*global*/ function pad_head(/*sequence*/ src, /*integer*/ size, /*object*/ ch=0X20) {
// <same as pad(src,size,"HEAD"[,ch])>
    if (compare(size,length(src))<=0) {
        return src;
    }
    return $conCat(repeat(ch,size-length(src)), src);
}
/*global*/ function pad_tail(/*sequence*/ src, /*integer*/ size, /*object*/ ch=0X20) {
// <same as pad(src,size,"TAIL"[,ch])>
    if (compare(size,length(src))<=0) {
        return src;
    }
    return $conCat(src, repeat(ch,size-length(src)));
}
/*global*/ function pad(/*sequence*/ src, /*integer*/ size, /*string*/ method="BOTH", /*object*/ ch=0X20) {
    if (compare(size,length(src))>0) {
        if (method==="BOTH") {
            size = max(0,floor((size-length(src))/2));
        } else {
            size -= length(src);
        }
        let /*string*/ pad = repeat(ch,size);
        if (method==="BOTH") {
            src = $conCat($conCat(pad, src), pad);
        } else if (method==="HEAD") {
            src = $conCat(pad, src);
        } else if (method==="TAIL") {
            src = $conCat(src, pad);
        } else {
            crash("9/0"); // unknown method
        }
    }
    return src;
}
/*global*/ function remove(/*sequence*/ src, /*integer*/ start, /*integer*/ stop=start) {
    src = $repss(src,start,stop,"");
//  src = src[1..start-1] & src[stop+1..length(src)]
    return src;
}
/*global*/ function replace(/*sequence*/ src, /*object*/ replacement, /*integer*/ start, /*integer*/ stop=start) {
    if (atom(replacement) && (stop!==start)) {
        src = $repss(src,start+1,stop,""); stop = start; }
    src = $repss(src,start,stop,replacement);
    return src;
}

