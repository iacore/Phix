// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// pseqc.e
//
// Phix compatibility implementation of OpenEuphoria's builtin
//   insert(), splice(), head(), tail(), remove(), and replace().
//
//  This is an auto-include; there is no need to manually include 
//  this file, unless you need a namespace attached to it.
//
//  When and *if* it becomes clear the Eu builtins are much faster 
//  than this, and it is a measurable issue in anything other than a 
//  pointless benchmark, I will reconsider reimplementing them using 
//  low-level assembly tricks etc to speed things up, but NOT before.
//   (actually, insert/splice/remove/replace are more likely to be
//    front-end tweaks aka syntactic sugar thingies, maybe with a
//    trick or two to avoid requiring the x = {x}.)
//  Besides, if one of these is nearly, but not quite, what you want,
//  it is significantly easier to copy/edit them in this form.
//DEV did I create a proper test set for these?
//  NO: there is a single splice() call in t24slice.exw, nowt else.
//

/*global*/ function insert(/*sequence*/ src, /*object*/ what, /*integer*/ index) {
// insert 1 element
    src = $conCat($conCat($subss(src,1,index-1), 0X30), $subss(src,index,length(src)));
    src = $repe(src,index,what);
    return src;
}

/*global*/ function splice(/*sequence*/ src, /*object*/ what, /*integer*/ index) {
    return $conCat($conCat($subss(src,1,index-1), what), $subss(src,index,length(src)));
}

/*global*/ function head(/*sequence*/ src, /*integer*/ size=1) {
// if size not specified, returns target[1..1]
    if (compare(size,length(src))>=0) { return src; }
    return $subss(src,1,size);
}

/*global*/ function tail(/*sequence*/ src, /*integer*/ size=-1) {
// if size not specified, returns src[2..$]
    let /*integer*/ l = length(src);
    if (size<0) { size += l; }
    if (size>=l) { return src; }
    return $subss(src,(l-size)+1,l);
}

/*global*/ function pad_head(/*string*/ src, /*integer*/ size, ch=0X20) {
// <same as pad(src,size,"HEAD"[,ch])>
    size -= length(src);
    if (size>0) {
        src = $conCat(repeat(ch,size), src);
    }
    return src;
}
//5/2/22
//global function pad_tail(string src, integer size, ch=' ')
/*global*/ function pad_tail(/*sequence*/ src, /*integer*/ size, /*object*/ ch=0X20) {
// <same as pad(src,size,"TAIL"[,ch])> (but a bit more g.p.)
    assert(!string(src) || (integer(ch) && (equal(ch,and_bits(ch,0xFF)))));
    size -= length(src);
    if (size>0) {
        src = $conCat(src, repeat(ch,size));
    }
    return src;
}

/*global*/ function pad(/*string*/ src, /*integer*/ size, /*string*/ method="BOTH", /*integer*/ ch=0X20) {
    size -= length(src);
    if (size>0) {
        if (method==="HEAD") {
            src = $conCat(repeat(ch,size), src);
        } else if (method==="TAIL") {
            src = $conCat(src, repeat(ch,size));
        } else {
            let /*integer*/ half = floor(size/2);
            if (method==="BOTH") {
                src = $conCat($conCat(repeat(ch,half), src), repeat(ch,size-half));
            } else if (method==="BLOTH") {
                src = $conCat($conCat(repeat(ch,size-half), src), repeat(ch,half));
            } else {
                crash("9/0"); // unknown method
            }
        }
    }
    return src;
}

/*global*/ function remove(/*sequence*/ src, /*integer*/ start, /*integer*/ stop=start) {
    src = $repss(src,start,stop,"");
//  src = src[1..start-1] & src[stop+1..length(src)]
    return src;
}

/*global*/ function replace(/*sequence*/ src, /*object*/ replacement, /*integer*/ start, /*integer*/ stop=start) {
    if (atom(replacement) && (stop!==start)) {
        src = $repss(src,start+1,stop,""); stop = start; }
    src = $repss(src,start,stop,replacement);
    return src;
}
