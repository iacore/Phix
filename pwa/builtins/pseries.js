"use strict";
// auto-generated by pwa/p2js - part of Phix, see http://phix.x10.mx
//
//  pseries.e
//  =========
//      Phix implementation of series (auto-include)
//      Stolen from OpenEuphoria's std/sequence.e
//

//**
// checks whether two objects can perform a sequence operation together.
//
// Parameters:
//              # ##a## : one of the objects to test for compatible shape
//              # ##b## : the other object
//
// Returns:
//      An **integer**, 1 if a sequence operation is valid between ##a## and ##b##, else 0.
//
// Example 1:
// <eucode>
// i = $binop_ok({1,2,3},{4,5})
// -- i is 0
//
// i = $binop_ok({1,2,3},4)
// -- i is 1
//
// i = $binop_ok({1,2,3},{4,{5,6},7})
// -- i is 1
// </eucode>
//
// See Also:
//     [[:series]]

//global 
function $binop_ok(/*object*/ a, /*object*/ b) {
    if (atom(a) || atom(b)) {
        return 1;
    }
    if (!equal(length(a),length(b))) {
        return 0;
    }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        if (!$binop_ok($subse(a,i),$subse(b,i))) {
            return 0;
        }
    }
    return 1;
}
//**
// returns a new sequence built as a series from a given object.
//
// Parameters:
//              # ##start## : the initial value from which to start
//              # ##increment## : the value to recursively add to ##start## to get new elements
//              # ##count## :  an integer, the number of items in the returned sequence. The default is 2.
//              # ##operation## :  an integer, the type of operation used to build the series.
//                         Can be either '+' for a linear series or '*' for a geometric series.
//                         The default is '+'.
//
// Returns:
//              An **object**, either 0 on failure or a sequence containing the series.
// 
//
// Comments:
// * The first item in the returned series is always ##start##.
// * A //linear// series is formed by **adding** ##increment## to ##start##.
// * A //geometric// series is formed by **multiplying** ##increment## by ##start##.
// * If ##count## is negative, or if ##start## **##op##** ##increment## is invalid,
// then 0 is returned. Otherwise, a sequence, of length
// ##count+1##, staring with ##start## and whose adjacent elements differ
// by ##increment##, is returned.
//
// Example 1:
// <eucode>
// s = series( 1, 4, 5)
// -- s is {1, 5, 9, 13, 17}
// s = series( 1, 2, 6, '*')
// -- s is {1, 2, 4, 8, 16, 32}
// s = series({1,2,3}, 4, 2)
// -- s is {{1,2,3}, {5,6,7}}
// s = series({1,2,3}, {4,-1,10}, 2)
// -- s is {{1,2,3}, {5,1,13}}
// </eucode>
//
// See Also:
//     [[:repeat_pattern]]

/*global*/ function series(/*object*/ start, /*object*/ increment, /*integer*/ count=2, /*integer*/ op=0X2B) {
    let /*sequence*/ result;
    if (count<0) {
        return 0;
    }
    if (!$binop_ok(start,increment)) {
        return 0;
    }
    if (count===0) { return ["sequence"]; }
    result = repeat(0,count);
    result = $repe(result,1,start);
    switch (op) {
        case 0X2B:
            for (let i=2, i$lim=count; i<=i$lim; i+=1) {
                start = sq_add(start,increment);
                result = $repe(result,i,start);
            }
            break;
        case 0X2A:
            for (let i=2, i$lim=count; i<=i$lim; i+=1) {
                start = sq_mul(start,increment);
                result = $repe(result,i,start);
            }
            break;
        default: 
            return 0;
    }
    return result;
}
