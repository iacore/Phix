"use strict";
// auto-generated by pwa/p2js - part of Phix, see http://phix.x10.mx
//
// psmall.e
// ========
//
//  Phix implementation of smallest() and largest().
//
//  Compatibility Note: This differs from the OpenEuphoria version of smallest() in std\stats.e in (at least) three ways:
//   * The set passed in the first parameter must be a non-empty sequence (compilation or run-time error if passed an atom or {})
//   * It can return non-atoms in the set (if no atoms occur, it will be the first in an alphabetical and case-sensitive ordering)
//   * It can return the index of the lowest entry, rather than the actual value of the lowest entry.
//  This should not, imho, cause sensibly-written code to be incompatible/misbehave. Despite the fact this is an autoinclude,
//  consider explicitly including this with a namespace and using that to qualify any calls, to avoid potential problems with 
//  code written and tested on Phix, should you later try and run it on OpenEuphoria.
//  This routine is very similar to minsq(), except that this has the optional return_index parameter, and by extension (see
//  the docs) min(s), which also has other incompatibilities with OpenEuphoria (non-recursive processing etc).

/*global*/ function smallest(/*sequence*/ set, /*integer*/ return_index=0) {
    let /*object*/ res, tmp;
    if (equal(length(set),0)) { crash("9/0"); }
    if (return_index) {
        res = 1;
    } else {
        res = $subse(set,1);
    }
    for (let i=2, i$lim=length(set); i<=i$lim; i+=1) {
        tmp = $subse(set,i);
        if (return_index) {
            if (compare(tmp,$subse(set,res))<0) {
                res = i;
            }
        } else if (compare(tmp,res)<0) {
            res = tmp;
        }
    }
    return res;
}

/*global*/ function largest(/*sequence*/ set, /*integer*/ return_index=0) {
    let /*object*/ res, tmp;
    if (equal(length(set),0)) { crash("9/0"); }
    if (return_index) {
        res = 1;
    } else {
        res = $subse(set,1);
    }
    for (let i=2, i$lim=length(set); i<=i$lim; i+=1) {
        tmp = $subse(set,i);
        if (return_index) {
            if (compare(tmp,$subse(set,res))>0) {
                res = i;
            }
        } else if (compare(tmp,res)>0) {
            res = tmp;
        }
    }
    return res;
}
