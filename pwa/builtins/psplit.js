// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\psplit.e
//
//  Phix implementation of split(), split_any(), split_by(), and split_path()
//
//  This is an auto-include file; there is no need to manually include it, unless you want a namespace.
//
/*without debug*/
/*global*/ function split(/*sequence*/ source, /*object*/ delimiter=0X20, /*bool*/ no_empty=true, /*integer*/ limit=0) {
    let /*sequence*/ ret = ["sequence"];
    let /*integer*/ start;
    let /*integer*/ pos;
    let /*bool*/ add_empties = !no_empty;
    if (!equal(length(source),0)) {
        if (sequence(delimiter)) {
            // Handle the simple case of split("123", ""), opposite is join({"1","2","3"}, "") -- "123"
            if (equal(length(delimiter),0)) {
                for (let i=1, i$lim=length(source); i<=i$lim; i+=1) {
                    source = $repe(source,i,$subss(source,i,i));
                    limit -= 1;
                    if (limit===0) {
//                      source = append(source[1..i],source[i+1..$])
                        source = $repe(source,i+1,$subss(source,i+1,-1));
                        source = $subss(source,1,i+1);
                        break;
                    }
                }
                return source;
            }
            start = 1;
            while (compare(start,length(source))<=0) {
                pos = match(delimiter,source,start);
                if (pos===0) { break; }
//              if no_empty=0 or pos-1>=start then
                if (add_empties || pos-1>=start) {
                    limit -= 1;
                    if (limit===0) { break; }
                    ret = append(ret,$subss(source,start,pos-1));
                }
                start = pos+length(delimiter);
            }
        } else {
            start = 1;
            while (compare(start,length(source))<=0) {
                pos = find(delimiter,source,start);
                if (pos===0) { break; }
//              if no_empty=0 or pos-1>=start then
                if (add_empties || pos-1>=start) {
                    limit -= 1;
                    if (limit===0) { break; }
                    ret = append(ret,$subss(source,start,pos-1));
                }
                start = pos+1;
            }
        }
//      if no_empty=0 or start<=length(source) then
        if (add_empties || compare(start,length(source))<=0) {
            ret = append(ret,$subss(source,start,-1));
        }
    }
    return ret;
}
//changed 5/12/2020:
//global function split_any(sequence source, object delimiters=", \t|", bool no_empty=false, integer limit=0)
//global function split_any(sequence source, object delimiters=", \t|", bool no_empty=true, integer limit=0)
//global function split_any(sequence source, object delimiters=", \t|")
/*global*/ function split_any(/*sequence*/ source, /*object*/ delimiters=["sequence",0X2C,0X20,0X9,0X7C]) {
    let /*sequence*/ ret = ["sequence"];
    let /*integer*/ start = 1, pos;
//, k
    if (atom(delimiters)) {
        delimiters = ["sequence",delimiters];
    } else if (equal(length(delimiters),0)) {
//      crash("split_any(): delimiter length must be greater than 0")
        crash("9/0"); //DEV
    }
    while (1) {
        pos = find_any(delimiters,source,start);
        if (pos===0) { break; }
//      if no_empty=false or pos-1>=start then
        if (pos-1>=start) {
            ret = append(ret,$subss(source,start,pos-1));
        }
        start = pos+1;
//      limit -= 1
//      if limit=0 then exit end if
    }
//  if no_empty=false or start<=length(source) then
    if (compare(start,length(source))<=0) {
        ret = append(ret,$subss(source,start,-1));
    }
    return ret;
}

/*global*/ function split_by(/*sequence*/ s, /*integer*/ n) {
// Split a sequence into chucks of at most length n each, eg split_by(tagset(9)) => {{1,2,3},{4,5,6},{7,8,9}}.
    let /*sequence*/ res = ["sequence"];
    let /*integer*/ j = 1, k = n;
    while (compare(k,length(s))<0) {
        res = append(res,$subss(s,j,k));
        j += n;
        k += n;
    }
    if (compare(j,length(s))<=0) {
        res = append(res,$subss(s,j,-1));
    }
    return res;
}

/*global*/ function split_path(/*string*/ path, /*bool*/ preservetrailsep=false) {
    let /*sequence*/ res = ["sequence"];
    let /*string*/ chunk;
    let /*integer*/ start = 1, ch;
    // split, preserving any leading separator
    for (let i=2, i$lim=length(path); i<=i$lim; i+=1) {
        ch = $subse(path,i);
        if ((ch===0X5C) || (ch===0X2F)) {
            chunk = $subss(path,start,i-1);
            if (length(chunk)) {
                res = append(res,chunk);
            }
            start = i+1;
        }
    }
    if (compare(start,length(path))<=0) {
        chunk = $subss(path,start,-1);
        res = append(res,chunk);
    } else if (preservetrailsep && compare(length(path),2)>=0) {
        // (Last char must be a separator, otherwise
        //  we would have had to add a final chunk.)
        if (equal(length(res),0)) {
            res = $subss(path,-1,-1);
        } else if (!find($subse($subse(res,-1),-1),`\\/`)) {
            res = $repe(res,-1,append($subse(res,-1),ch));
        }
    }
    return res;
}
