"use strict";
// auto-generated by pwa/p2js.
//
// builtins\psplit.e
//
//  Phix implementation of split(), split_any(), split_by(), and split_path()
//
//  This is an auto-include file; there is no need to manually include it, unless you want a namespace.
//
/*global*/ function split(/*sequence*/ source, /*object*/ delimiter=0X20, /*bool*/ no_empty=true, /*integer*/ limit=0) {
    let /*sequence*/ ret = ["sequence"];
    let /*integer*/ start;
    let /*integer*/ pos;
//integer k
    if (length(source)!==0) {
        if (sequence(delimiter)) {
            // Handle the simple case of split("123", ""), opposite is join({"1","2","3"}, "") -- "123"
            if (length(delimiter)===0) {
                for (let i=1, i$lim=length(source); i<=i$lim; i+=1) {
                    source = $repe(source,i,$subss(source,i,i));
                    limit -= 1;
                    if (limit===0) {
//                      source = append(source[1..i],source[i+1..$])
                        source = $repe(source,i+1,$subss(source,i+1,-1));
                        source = $subss(source,1,i+1);
                        break;
                    }
                }
                return source;
            }
            start = 1;
            while (compare(start,length(source))<=0) {
                pos = match(delimiter,source,start);
                if (pos===0) { break; }
                if ((no_empty===0) || compare(pos-1,start)>=0) {
                    limit -= 1;
                    if (limit===0) { break; }
                    ret = append(ret,$subss(source,start,pos-1));
                }
                start = pos+length(delimiter);
            }
        } else {
            start = 1;
            while (compare(start,length(source))<=0) {
                pos = find(delimiter,source,start);
                if (pos===0) { break; }
                if ((no_empty===0) || compare(pos-1,start)>=0) {
                    limit -= 1;
                    if (limit===0) { break; }
                    ret = append(ret,$subss(source,start,pos-1));
                }
                start = pos+1;
            }
        }
        if ((no_empty===0) || compare(start,length(source))<=0) {
            ret = append(ret,$subss(source,start,-1));
        }
//      k = length(ret)
//      if no_empty then
//          k = 0
//          for i=1 to length(ret) do
//              if length(ret[i])!=0 then
//                  k += 1
//                  if k!=i then
//                      ret[k] = ret[i]
//                  end if
//              end if
//          end for
//      end if
//
//      if k<length(ret) then
//          ret = ret[1..k]
//      end if
    }
    return ret;
}
//changed 5/12/2020:
//global function split_any(sequence source, object delimiters=", \t|", bool no_empty=false, integer limit=0)
//global function split_any(sequence source, object delimiters=", \t|", bool no_empty=true, integer limit=0)
/*global*/ function split_any(/*sequence*/ source, /*object*/ delimiters=", \t|") {
    let /*sequence*/ ret = ["sequence"];
    let /*integer*/ start = 1, pos;
//, k
    if (atom(delimiters)) {
        delimiters = ["sequence",delimiters];
    } else if (length(delimiters)===0) {
//      crash("split_any(): delimiter length must be greater than 0")
        crash("9/0"); //DEV
    }
    while (1) {
        pos = find_any(delimiters,source,start);
        if (pos===0) { break; }
//      if no_empty=false or pos-1>=start then
        if (compare(pos-1,start)>=0) {
            ret = append(ret,$subss(source,start,pos-1));
        }
        start = pos+1;
//      limit -= 1
//      if limit=0 then exit end if
    }
//  if no_empty=false or start<=length(source) then
    if (compare(start,length(source))<=0) {
        ret = append(ret,$subss(source,start,-1));
    }
//  k = length(ret)
//  if no_empty then
//      k = 0
//      for i=1 to length(ret) do
//          if length(ret[i])!=0 then
//              k += 1
//              if k!=i then
//                  ret[k] = ret[i]
//              end if
//          end if
//      end for
//  end if
//
//  if k<length(ret) then
//      ret = ret[1..k]
//  end if
    return ret;
}
/*global*/ function split_by(/*sequence*/ s, /*integer*/ n) {
// Split a sequence into chucks of at most length n each, eg split_by(tagset(9)) => {{1,2,3},{4,5,6},{7,8,9}}.
    let /*sequence*/ res = ["sequence"];
    let /*integer*/ j = 1, k = n;
    while (compare(k,length(s))<0) {
        res = append(res,$subss(s,j,k));
        j += n;
        k += n;
    }
    if (compare(j,length(s))<=0) {
        res = append(res,$subss(s,j,-1));
    }
    return res;
}
/*global*/ function split_path(/*string*/ path, /*bool*/ preservetrailsep=false) {
    let /*sequence*/ res = ["sequence"];
    let /*string*/ chunk;
    let /*integer*/ start = 1, ch;
    // split, preserving any leading separator
    for (let i=2, i$lim=length(path); i<=i$lim; i+=1) {
        ch = $subse(path,i);
        if ((ch===0X5C) || (ch===0X2F)) {
            chunk = $subss(path,start,i-1);
            if (length(chunk)) {
                res = append(res,chunk);
            }
            start = i+1;
        }
    }
    if (compare(start,length(path))<=0) {
        chunk = $subss(path,start,-1);
        res = append(res,chunk);
    } else if (preservetrailsep && compare(length(path),2)>=0) {
        // (Last char must be a separator, otherwise
        //  we would have had to add a final chunk.)
        if (length(res)===0) {
            res = $subss(path,-1,-1);
        } else if (!find($subse($subse(res,-1),-1),`\/`)) {
            res = $repe(res,-1,append($subse(res,-1),ch));
        }
    }
    return res;
}

