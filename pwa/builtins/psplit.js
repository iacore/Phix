// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins\psplit.e
//
//  Phix implementation of split(), split_any(), split_by(), and split_path()
//
//  This is an auto-include file; there is no need to manually include it, unless you want a namespace.
//
/*without debug*/
/*global*/ function split(/*sequence*/ source, /*object*/ delimiter=0X20, /*bool*/ no_empty=true, /*integer*/ limit=0) {
    let /*sequence*/ ret = ["sequence"];
    let /*integer*/ start, pos;
    let /*bool*/ add_empties = !no_empty; // (easier to understand!)
    if (!equal(length(source),0)) {
        if (sequence(delimiter)) {
            // Handle the simple case of split("123", ""), opposite is join({"1","2","3"}, "") -- "123"
            if (equal(length(delimiter),0)) {
                for (let i=1, i$lim=length(source); i<=i$lim; i+=1) {
                    source = $repe(source,i,$subss(source,i,i));
                    limit -= 1;
                    if (limit===0) {
                        source = $repe(source,i+1,$subss(source,i+1,-1));
                        source = $subss(source,1,i+1);
                        break;
                    }
                }
                return source;
            }
            start = 1;
            while (compare(start,length(source))<=0) {
                pos = match(delimiter,source,start);
                if (pos===0) { break; }
                if (add_empties || pos-1>=start) {
                    limit -= 1;
                    if (limit===0) { break; }
                    ret = append(ret,$subss(source,start,pos-1));
                }
                start = pos+length(delimiter);
            }
        } else {
            start = 1;
            while (compare(start,length(source))<=0) {
                pos = find(delimiter,source,start);
                if (pos===0) { break; }
                if (add_empties || pos-1>=start) {
                    limit -= 1;
                    if (limit===0) { break; }
                    ret = append(ret,$subss(source,start,pos-1));
                }
                start = pos+1;
            }
        }
        if (add_empties || compare(start,length(source))<=0) {
            ret = append(ret,$subss(source,start,-1));
        }
    }
    return ret;
}

/*global*/ function split_any(/*sequence*/ source, /*object*/ delimiters=", \t|") {
    let /*sequence*/ ret = ["sequence"];
    let /*integer*/ start = 1;
    if (atom(delimiters)) {
        delimiters = ["sequence",delimiters];
    } else if (equal(length(delimiters),0)) {
        crash("split_any(): delimiter length must be greater than 0");
    }
    while (1) {
        let /*integer*/ pos = find_any(delimiters,source,start);
        if (pos===0) { break; }
        if (pos-1>=start) {
            ret = append(ret,$subss(source,start,pos-1));
        }
        start = pos+1;
    }
    if (compare(start,length(source))<=0) {
        ret = append(ret,$subss(source,start,-1));
    }
    return ret;
}

/*global*/ function split_by(/*sequence*/ s, /*integer*/ n) {
    // Split a sequence into chucks of at most length n each, 
    // eg split_by(tagset(9)) => {{1,2,3},{4,5,6},{7,8,9}}.
    let /*sequence*/ res = ["sequence"];
    let /*integer*/ j = 1, k = n;
    while (compare(k,length(s))<0) {
        res = append(res,$subss(s,j,k));
        j += n;
        k += n;
    }
    if (compare(j,length(s))<=0) {
        res = append(res,$subss(s,j,-1));
    }
    return res;
}

/*global*/ function split_path(/*string*/ path, /*bool*/ preservetrailsep=false) {
    let /*sequence*/ res = ["sequence"];
    let /*string*/ chunk;
    let /*integer*/ start = 1, ch;
    // split, preserving any leading separator
    for (let i=2, i$lim=length(path); i<=i$lim; i+=1) {
        ch = $subse(path,i);
        if ((ch===0X5C) || (ch===0X2F)) {
            chunk = $subss(path,start,i-1);
            if (length(chunk)) {
                res = append(res,chunk);
            }
            start = i+1;
        }
    }
    if (compare(start,length(path))<=0) {
        chunk = $subss(path,start,-1);
        res = append(res,chunk);
    } else if (preservetrailsep && compare(length(path),2)>=0) {
        // (Last char must be a separator, otherwise
        //  we would have had to add a final chunk.)
        if (equal(length(res),0)) {
            res = $subss(path,-1,-1);
        } else if (!find($subse($subse(res,-1),-1),`\\/`)) {
            res = $repe(res,-1,append($subse(res,-1),ch));
        }
    }
    return res;
}
