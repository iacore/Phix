"use strict";
// auto-generated by pwa/p2js.
//
// psqop.e
// =======
//
// The functions in this file implement explicit sequence ops.
//  This file is automatically included when needed, you should only
//  need to manually include it for compatibility with RDS Eu, or you
//  can write code in the following manner:
//      --/**/ sq_add() --/* -- Phix
//              +       --*/ -- RDS Eu
//
//  (Yes, '+' is far easier to type than 'sq_add()', but...
//        '=' is far easier to type than 'equal()', and...
//      the latter is several orders of magnitude more frequent.)
//
// As an example, the legacy sequence-op-based function lower() was:
//
//  global function lower(object x)
//  -- convert atom or sequence to lower case
//      return x + (x >= 'A' and x <= 'Z') * TO_LOWER
//  end function
//
// (Look in pcase.e to see the official Phix version of lower(), btw.)
//
// In Phix you could, if you really wanted, recode the above as:
//
//  global function lower(object x)
//  -- convert atom or sequence to lower case
//  sequence mask
//      -- create 1/0 mask for chars in A..Z/not in A..Z
//      mask = sq_and(sq_ge(x,'A'),sq_le(x,'Z'))
//      -- convert to TO_LOWER/0 array
//      mask = sq_mul(mask,TO_LOWER)
//      return sq_add(x,mask)
//  end function
//
// Agreed, it is visually uglier, but probably easier to understand 
// (rather than looking like integer add etc, you know it might be 
//  doing loads of work) and also //much easier to debug//.
//
// Interestingly, on RDS Eu the following is not significantly any
//  slower (ok, maybe 5%) than the legacy version from wildcard.e:
//
//  global function lower(object x)
//  -- convert atom or sequence to lower case
//  sequence tmp1, tmp2
//      tmp1 = (x >= 'A')
//      tmp2 = (x <= 'Z')
//      tmp1 = (tmp1 and tmp2)
//      tmp1 = (tmp1 * TO_LOWER)
//      tmp1 = (x + tmp1)
//      return tmp1
//  end function
//
// Admittedly, the Phix equivalent:
//
//  global function lower(object x)
//  -- convert atom or sequence to lower case
//  sequence tmp1, tmp2
//      tmp1 = sq_ge(x,'A')
//      tmp2 = sq_le(x,'Z')
//      tmp1 = sq_and(tmp1,tmp2)
//      tmp1 = sq_mul(tmp1,TO_LOWER)
//      tmp1 = sq_add(x,tmp1)
//      return tmp1
//  end function
//
// is about 3.6x slower, however the pcase.e version is 8.4x
// faster than the legacy wildcard.e version (on Phix, that
// is, and about 2.7x faster on RDS Eu). Comparing the routine
// immediately above and builtins/pcase.e, when both are run on
// Phix, the latter is an astonishing 30.5x faster.
//
// The bottom line is, I guess, that Phix supports (implicit)
// sequence ops at a bearable speed loss, but there is usually
// a much faster way in Phix. If, and not before, performance
// of these routines causes real problems in real programs, I
// will reconsider recoding them in assembly.
//
function fatal(/*sequence*/ a, /*sequence*/ b) {
    printf(1,"sequence lengths not the same (%d!=%d)!\n",["sequence",length(a), length(b)]);
    crash("9/0");
}
/* Not required for Phix:
--DEV: why is this global?
--global 
type string(object s)
    if not sequence(s) then return 0 end if
    for i = 1 to length(s) do
        object si = s[i]
        if not integer(si) then return 0 end if
        if si<0 or si>255 then return 0 end if
    end for
    return 1
end type
*/
/*global*/ function sq_cmp(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return compare(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_cmp(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_cmp($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_cmp($subse(a,i),$subse(b,i)));
    }
    return a;
}
//p2js:
//global function sq_eq(object a, object b)
//  if atom(a) then
//      if atom(b) then return a=b end if
//      for i=1 to length(b) do
//          b[i] = sq_eq(a,b[i])
//      end for
//      return b
//  elsif atom(b) then
//      for i=1 to length(a) do
//          a[i] = sq_eq(a[i],b)
//      end for
//      return a
//  end if
//  if length(a)!=length(b) then fatal(a,b) end if
//  for i=1 to length(a) do
//      a[i] = sq_eq(a[i],b[i])
//  end for
//  return a
//end function
/*global*/ function sq_eq(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return equal(a,b); }
        [,a, b] = ["sequence",b, a];
    }
    let /*integer*/ la = length(a);
    let /*sequence*/ res = repeat(0,la);
    if (atom(b)) {
        for (let i=1, i$lim=la; i<=i$lim; i+=1) {
            res = $repe(res,i,sq_eq($subse(a,i),b));
        }
        return res;
    }
    if (la!==length(b)) { fatal(a,b); }
    for (let i=1, i$lim=la; i<=i$lim; i+=1) {
        res = $repe(res,i,sq_eq($subse(a,i),$subse(b,i)));
    }
    return res;
}
/*global*/ function sq_ne(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return !equal(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_ne(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_ne($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_ne($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_lt(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return compare(a,b)<0; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_lt(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_lt($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_lt($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_le(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return compare(a,b)<=0; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_le(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_le($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_le($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_gt(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return compare(a,b)>0; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_gt(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_gt($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_gt($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_ge(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return compare(a,b)>=0; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_ge(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_ge($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_ge($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_int(/*object*/ a) {
    if (atom(a)) { return integer(a); }
    if (string(a)) { return 0; }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
//      a[i] = sq_int(a[i])
        a = $repe(a,i,integer($subse(a,i))); // NB no recursion! (see note below)
    }
    return a;
}
/*global*/ function sq_atom(/*object*/ a) {
    if (atom(a)) { return 1; }
    if (string(a)) { return 0; }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,atom($subse(a,i))); // NB no recursion! (see note below)
    }
    return a;
}
/*global*/ function sq_str(/*object*/ a) {
    if (atom(a)) { return 0; }
    if (string(a)) { return 1; }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
//      a[i] = sq_str(a[i])
        a = $repe(a,i,string($subse(a,i))); // NB no recursion! (see note below)
    }
    return a;
}
/*global*/ function sq_seq(/*object*/ a) {
    if (atom(a)) { return 0; }
    if (string(a)) { return 1; }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sequence($subse(a,i))); // NB no recursion! (see note below)
    }
    return a;
}
// If sq_atom()/sq_seq() used recursion, you would just get a 
// "tree of 1's"/"tree of 0's" of the exact same size/shape.
// [ie sum(sq_atom(x)) would be === length(flatten(x)), and
//  sum(sq_seq(x)) would always be 0, for any and all x]
// It may be that these routines deserve a "nest" parameter
// (possibly defaulted to 1), ditto for sq_int/sq_str.
// OTOH, there are NO known uses of the above routines, anywhere!
// update: recursion removed for sq_int/sq_str, as per docs.
/*global*/ function sq_abs(/*object*/ o) {
    if (atom(o)) {
        return abs(o);
    }
    for (let i=1, i$lim=length(o); i<=i$lim; i+=1) {
        o = $repe(o,i,sq_abs($subse(o,i)));
    }
    return o;
}
/*global*/ function sq_add(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return a+b; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_add(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_add($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_add($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_sub(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return a-b; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_sub(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_sub($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_sub($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_mul(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return a*b; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_mul(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_mul($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_mul($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_div(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return a/b; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_div(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_div($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_div($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_floor_div(/*object*/ a, /*object*/ b) {
// (equivalent to sq_floor(sq_div(a,b)) but much faster.)
    if (atom(a)) {
        if (atom(b)) { return floor(a/b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_floor_div(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_floor_div($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_floor_div($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_rmdr(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return remainder(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_rmdr(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_rmdr($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_rmdr($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_floor(/*object*/ a) {
    if (atom(a)) { return floor(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_floor($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_round(/*object*/ a, /*object*/ inverted_precision=1) {
    let /*integer*/ len, lp;
    let /*object*/ res;
    inverted_precision = sq_abs(inverted_precision);
    if (atom(a)) {
        if (atom(inverted_precision)) {
//25/5/20
//          res = floor(0.5 + (a * inverted_precision )) / inverted_precision
            res = round(a,inverted_precision);
        } else {
            len = length(inverted_precision);
            res = repeat(0,len);
            for (let i=1, i$lim=len; i<=i$lim; i+=1) {
                res = $repe(res,i,sq_round(a,$subse(inverted_precision,i)));
            }
        }
    } else {
        len = length(a);
        res = repeat(0,len);
        if (atom(inverted_precision)) {
            for (let i=1, i$lim=len; i<=i$lim; i+=1) {
                res = $repe(res,i,sq_round($subse(a,i),inverted_precision));
            }
        } else {
            lp = length(inverted_precision);
            if (len!==lp) { crash("sequence lengths not the same (%d!=%d)!\n",["sequence",len, lp]); }
            for (let i=1, i$lim=len; i<=i$lim; i+=1) {
                res = $repe(res,i,sq_round($subse(a,i),$subse(inverted_precision,i)));
            }
        }
    }
    return res;
}
/*global*/ function sq_ceil(/*object*/ o) {
    if (atom(o)) {
        o = -floor(-o);
    } else {
        for (let i=1, i$lim=length(o); i<=i$lim; i+=1) {
            o = $repe(o,i,sq_ceil($subse(o,i)));
        }
    }
    return o;
}
/*global*/ function sq_sign(/*object*/ o) {
    if (atom(o)) {
        if (compare(o,0)>0) {
            o = +1;
        } else if (compare(o,0)<0) {
            o = -1;
        }
    } else {
        for (let i=1, i$lim=length(o); i<=i$lim; i+=1) {
            o = $repe(o,i,sq_sign($subse(o,i)));
        }
    }
    return o;
}
/*global*/ function sq_mod(/*object*/ x, /*object*/ y) {
    let /*integer*/ len, ly;
    let /*object*/ res;
    if (atom(x)) {
        if (atom(y)) {
            if (sign(x)===sign(y)) {
                res = remainder(x,y);
            } else {
                res = x-y*floor(x/y);
            }
        } else {
            len = length(y);
            res = repeat(0,len);
            for (let i=1, i$lim=len; i<=i$lim; i+=1) {
                res = $repe(res,i,sq_mod(x,$subse(y,i)));
            }
        }
    } else {
        len = length(x);
        res = repeat(0,len);
        if (atom(y)) {
            for (let i=1, i$lim=len; i<=i$lim; i+=1) {
                res = $repe(res,i,sq_mod($subse(x,i),y));
            }
        } else {
            ly = length(y);
            if (len!==ly) { crash("sequence lengths not the same (%d!=%d)!\n",["sequence",len, ly]); }
            for (let i=1, i$lim=len; i<=i$lim; i+=1) {
                res = $repe(res,i,sq_mod($subse(x,i),$subse(y,i)));
            }
        }
    }
    return res;
}
/*global*/ function sq_trunc(/*object*/ x) {
    return sq_mul(sq_sign(x),sq_floor(sq_abs(x)));
}
/*global*/ function sq_and(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return a && b; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_and(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_and($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_and($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_or(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return a || b; }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_or(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_or($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_or($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_xor(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return xor(a, b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_xor(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_xor($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_xor($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_rand(/*object*/ a) {
    if (atom(a)) { return rand(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
//      a[i] = sq_rand(a[i])
        let /*object*/ ai = $subse(a,i);
        ai = ((atom(ai)) ? rand(ai) : sq_rand(ai));
        a = $repe(a,i,ai);
    }
    return a;
}
/*global*/ function sq_uminus(/*object*/ a) {
    if (atom(a)) { return -a; }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_uminus($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_not(/*object*/ a) {
    if (atom(a)) { return !a; }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_not($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_and_bits(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return and_bits(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_and_bits(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_and_bits($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_and_bits($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_or_bits(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return or_bits(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_or_bits(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_or_bits($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_or_bits($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_xor_bits(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return xor_bits(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_xor_bits(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_xor_bits($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_xor_bits($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_not_bits(/*object*/ a) {
    if (atom(a)) { return not_bits(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_not_bits($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_cos(/*object*/ a) {
    if (atom(a)) { return cos(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_cos($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_sin(/*object*/ a) {
    if (atom(a)) { return sin(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_sin($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_tan(/*object*/ a) {
    if (atom(a)) { return tan(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_tan($subse(a,i)));
    }
    return a;
}
//1/11/20 (p2js)
//include builtins\misc.e as misc
//include builtins\misc.e
/*global*/ function sq_arccos(/*object*/ a) {
//  if atom(a) then return misc:arccos(a) end if
    if (atom(a)) { return arccos(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_arccos($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_arcsin(/*object*/ a) {
//  if atom(a) then return misc:arcsin(a) end if
    if (atom(a)) { return arcsin(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_arcsin($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_arctan(/*object*/ a) {
    if (atom(a)) { return arctan(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_arctan($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_log(/*object*/ a) {
    if (atom(a)) { return log(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_log($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_log10(/*object*/ a) {
    if (atom(a)) { return log10(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_log10($subse(a,i)));
    }
    return a;
}
// removed 31/3/21 (p2js):
//include builtins\log10.e  -- (temp, for log2)
/*global*/ function sq_log2(/*object*/ a) {
    if (atom(a)) { return log2(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_log2($subse(a,i)));
    }
    return a;
}
/*global*/ function sq_power(/*object*/ a, /*object*/ b) {
    if (atom(a)) {
        if (atom(b)) { return power(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,sq_power(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,sq_power($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_power($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_sqrt(/*object*/ a) {
    if (atom(a)) { return sqrt(a); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,sq_sqrt($subse(a,i)));
    }
    return a;
}
// removed 31/3/21 (p2js):
 /*
--DEV not even sure these return anything different from upper/lower...
-- (ie: this might just be a sad hangover from trying to cope with the one in wildcard.e)
--include builtins\pcase.e as pcase
include builtins\pcase.e
global function sq_upper(object a)
--  if integer(a) then return pcase:upper(a) end if
    if integer(a) then return upper(a) end if
    if atom(a) then return a end if
--  if string(a) then return pcase:upper(a) end if
    if string(a) then return upper(a) end if
    for i=1 to length(a) do
        a[i] = sq_upper(a[i])
    end for
    return a
--DEV tryme:
--  return pcase:upper(a)
end function
global function sq_lower(object a)
--  if integer(a) then return pcase:lower(a) end if
    if integer(a) then return lower(a) end if
    if atom(a) then return a end if
--  if string(a) then return pcase:lower(a) end if
    if string(a) then return lower(a) end if
    for i=1 to length(a) do
        a[i] = sq_lower(a[i])
    end for
    return a
--DEV tryme:
--  return pcase:lower(a)
end function
*/ 
/*global*/ function sq_min(/*object*/ a, b) {
    if (atom(a)) {
        if (atom(b)) { return min(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,min(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,min($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,min($subse(a,i),$subse(b,i)));
    }
    return a;
}
/*global*/ function sq_max(/*object*/ a, b) {
    if (atom(a)) {
        if (atom(b)) { return max(a,b); }
        for (let i=1, i$lim=length(b); i<=i$lim; i+=1) {
            b = $repe(b,i,max(a,$subse(b,i)));
        }
        return b;
    } else if (atom(b)) {
        for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
            a = $repe(a,i,max($subse(a,i),b));
        }
        return a;
    }
    if (!equal(length(a),length(b))) { fatal(a,b); }
    for (let i=1, i$lim=length(a); i<=i$lim; i+=1) {
        a = $repe(a,i,max($subse(a,i),$subse(b,i)));
    }
    return a;
}

