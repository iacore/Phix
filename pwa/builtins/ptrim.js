// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// ptrim.e
//
//  implements trim(), trim_head(), trim_tail()
//  This is automatically included when needed; there should be no need 
//  to manually include this file, unless you want/need a namespace.
//
// Typically these are used to trim whitespace from strings, but you 
//  could also, perhaps, trim unused entries from a table, etc.
//
// Examples
//  ? trim(" abc ")         -- prints "abc"
//  ? trim(`"abc"`)     `   -- prints `"abc"`
//  ? trim(`"abc"`,'"')     -- prints "abc" (not ""abc"" nor `"abc"`, but 3 chars)
//  ? trim(table,{{}})      -- removes s[i]={} entries from start and end (note the extra {})
//  ? trim(table,{{},0})    -- removes s[i]={} or 0 """
//  ? trim(gets(fn))        -- trim returns eof (-1) unaltered.
//
// Note that when working with indexes (passing the optional third parameter something
//      non-zero), especially for trim_head() and trim_tail(), it is almost certainly
//      easier to test that source (first parameter) is a sequence and avoid the call,
//      rather than struggle to correctly interpret the results. Passing an eof (-1)
//      to trim_head() or trim_tail() returns it unaltered, and it is rather doubtful 
//      that subsequently treating that -1 as an index will work out at all well...
//

//global function trim(object source, object what=" \t\r\n", bool return_index=false)
/*global*/ function trim(/*object*/ source, /*object*/ what=["sequence",0X20,0X9,0XD,0XA], /*bool*/ return_index=false) {
    if (sequence(source)) {
        let /*integer*/ lpos = 1, 
                        rpos = length(source);
        if (atom(what)) {
            while (lpos<=rpos && (equal($subse(source,lpos),what))) { lpos += 1; }
            while (rpos>lpos && (equal($subse(source,rpos),what))) { rpos -= 1; }
        } else {
            while (lpos<=rpos && find($subse(source,lpos),what)) { lpos += 1; }
            while (rpos>lpos && find($subse(source,rpos),what)) { rpos -= 1; }
        }
        if (return_index) {
            return ["sequence",lpos,rpos];
        } else if ((lpos!==1) || (!equal(rpos,length(source)))) {
            source = $subss(source,lpos,rpos);
        }
    }
    return source;
}
//global function trim_head(object source, object what=" \t\r\n", bool return_index=false)
/*global*/ function trim_head(/*object*/ source, /*object*/ what=["sequence",0X20,0X9,0XD,0XA], /*bool*/ return_index=false) {
    if (sequence(source)) {
        let /*sequence*/ s = trim(source,what,true);
        let /*integer*/ lpos = $subse(s,1);
        if (return_index) {
            return lpos;
        } else if (lpos!==1) {
            source = $subss(source,lpos,-1);
        }
    }
    return source;
}
//global function trim_tail(object source, object what=" \t\r\n", bool return_index=false)
/*global*/ function trim_tail(/*object*/ source, /*object*/ what=["sequence",0X20,0X9,0XD,0XA], /*bool*/ return_index=false) {
    if (sequence(source)) {
        let /*sequence*/ s = trim(source,what,true);
        let /*integer*/ [,lpos,rpos] = s;
        if (return_index) {
            return rpos;
        } else if (lpos>rpos) {
            source = $subss(source,1,0); // "" or {}
        } else if (compare(rpos,length(source))<0) {
            source = $subss(source,1,rpos);
        }
    }
    return source;
}

/*global*/ function shorten(/*sequence*/ s, /*string*/ what="digits", /*integer*/ ml=20) {
    let /*integer*/ l = length(s), 
//pwa.p2js:
//          c = iff(string(s) and what="digits"?sum(sq_eq(s,',')):0)
                    c = 0;
    if (what==="digits") {
        for (let i=1, i$lim=l; i<=i$lim; i+=1) {
            c += equal($subse(s,i),0X2C);
        }
    }
    let /*string*/ ls = ((length(what)) ? sprintf(" (%,d %s)",["sequence",l-c,what]) : "");
    if (compare(l,ml*2+((string(s)) ? 3+length(ls) : 2))>0) {
        if (string(s)) {
            s = $repss(s,ml+1,-ml-1,"...");
            if (length(ls)) { s = $conCat(s, ls); }
        } else {
//p2js:
//          s[ml+1..-ml-1] = {"..."}
            s = $conCat($conCat($subss(s,1,ml), ["sequence","..."]), $subss(s,-ml,-1));
            if (length(ls)) { s = append(s,ls); }
        }
    }
    return s;
}
