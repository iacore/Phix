"use strict";
// auto-generated by pwa/p2js.
//
// ptrim.e
//
//  implements trim(), trim_head(), trim_tail()
//  This is automatically included when needed; there should be no need 
//  to manually include this file, unless you want/need a namespace.
//
// Typically these are used to trim whitespace from strings, but you 
//  could also, perhaps, trim unused entries from a table, etc.
//
// Examples
//  ? trim(" abc ")         -- prints "abc"
//  ? trim(`"abc"`)     `   -- prints `"abc"`
//  ? trim(`"abc"`,'"')     -- prints "abc" (not ""abc"" nor `"abc"`, but 3 chars)
//  ? trim(table,{{}})      -- removes s[i]={} entries from start and end (note the extra {})
//  ? trim(table,{{},0})    -- removes s[i]={} or 0 """
//  ? trim(gets(fn))        -- trim returns eof (-1) unaltered.
//
// Note that when working with indexes (passing the optional third parameter something
//      non-zero), especially for trim_head() and trim_tail(), it is almost certainly
//      easier to test that source (first parameter) is a sequence and avoid the call,
//      rather than struggle to correctly interpret the results. Passing an eof (-1)
//      to trim_head() or trim_tail() returns it unaltered, and it is rather doubtful 
//      that subsequently treating that -1 as an index will work out at all well...
//
/*global*/ function trim(/*object*/ source, /*object*/ what=" \t\r\n", /*bool*/ return_index=false) {
    if (sequence(source)) {
        let /*integer*/ lpos = 1, 
                        rpos = length(source);
        if (atom(what)) {
            while (compare(lpos,rpos)<=0 && (equal($subse(source,lpos),what))) { lpos += 1; }
            while (compare(rpos,lpos)>0 && (equal($subse(source,rpos),what))) { rpos -= 1; }
        } else {
            while (compare(lpos,rpos)<=0 && find($subse(source,lpos),what)) { lpos += 1; }
            while (compare(rpos,lpos)>0 && find($subse(source,rpos),what)) { rpos -= 1; }
        }
        if (return_index) {
            return ["sequence",lpos, rpos];
        } else if ((lpos!==1) || (rpos!==length(source))) {
            source = $subss(source,lpos,rpos);
        }
    }
    return source;
}
/*global*/ function trim_head(/*object*/ source, /*object*/ what=" \t\r\n", /*bool*/ return_index=false) {
    if (sequence(source)) {
        let /*sequence*/ s = trim(source,what,true);
        let /*integer*/ lpos = $subse(s,1);
        if (return_index) {
            return lpos;
        } else if (lpos!==1) {
            source = $subss(source,lpos,-1);
        }
    }
    return source;
}
/*global*/ function trim_tail(/*object*/ source, /*object*/ what=" \t\r\n", /*bool*/ return_index=false) {
    if (sequence(source)) {
        let /*sequence*/ s = trim(source,what,true);
        let /*integer*/ [,lpos, rpos] = s;
        if (return_index) {
            return rpos;
        } else if (compare(lpos,rpos)>0) {
            source = $subss(source,1,0); // "" or {}
        } else if (compare(rpos,length(source))<0) {
            source = $subss(source,1,rpos);
        }
    }
    return source;
}
/*global*/ function shorten(/*sequence*/ s, /*string*/ what="digits", /*integer*/ ml=20) {
    let /*integer*/ l = length(s), 
                    c = ((string(s) && (what==="digits")) ? sum(sq_eq(s,0X2C)) : 0);
    let /*string*/ ls = ((length(what)) ? sprintf(" (%,d %s)",["sequence",l-c, what]) : "");
    if (compare(l,ml*2+((string(s)) ? 3+length(ls) : 2))>0) {
        if (string(s)) {
            s = $repss(s,ml+1,-ml-1,"...");
            if (length(ls)) { s = $conCat(s, ls); }
        } else {
            s = $repss(s,ml+1,-ml-1,["sequence","..."]);
            if (length(ls)) { s = append(s,ls); }
        }
    }
    return s;
}

