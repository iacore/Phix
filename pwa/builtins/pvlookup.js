// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins/pvlookup.e
//

/*global*/ function vlookup(/*object*/ find_item, /*sequence*/ grid_data, /*integer*/ source_col, target_col, /*object*/ def_value=0) {
    for (let i=1, i$lim=length(grid_data); i<=i$lim; i+=1) {
        let /*object*/ gdi = $subse(grid_data,i);
        if ((sequence(gdi) && compare(source_col,length(gdi))<=0) && equal(find_item,$subse(gdi,source_col))) {
            if (compare(target_col,length(gdi))>0) { break; }
            return $subse(gdi,target_col);
        }
    }
    return def_value;
}
//DEV doc/auto:
//**
// If the supplied item is in the source list, this returns the corresponding
// element from the target list.
// Parameters:
// # ##find_item##: an object that might exist in ##source_list##.
// # ##source_list##: a sequence that might contain ##pITem##.
// # ##target_list##: a sequence from which the corresponding item will be returned.
// # ##def_value##: an object (defaults to zero). This is returned when ##find_item## 
// is not in ##source_list## **and** ##target_list## is not longer than ##source_list##.
//
// Returns:
// an object
// * If ##find_item## is found in ##source_list## then this is the corresponding element
// from ##target_list##
// * If ##find_item## is not in ##source_list## then if ##target_list## is longer than ##source_list##
// then the last item in ##target_list## is returned otherwise ##def_value## is returned.
//
// Examples:
// <eucode>
// $lookup('a', "cat", "dog") --> 'o'
// $lookup('d', "cat", "dogx") --> 'x'
// $lookup('d', "cat", "dog") --> 0
// $lookup('d', "cat", "dog", -1) --> -1
// $lookup("ant", {"ant","bear","cat"}, {"spider","seal","dog","unknown"}) --> "spider"
// $lookup("dog", {"ant","bear","cat"}, {"spider","seal","dog","unknown"}) --> "unknown"
// </eucode>
//
/*global*/ function $lookup(/*object*/ find_item, /*sequence*/ source_list, target_list, /*object*/ def_value=0) {
    let /*integer*/ k = find(find_item,source_list);
    if (k>=1 && compare(k,length(target_list))<=0) {
        def_value = $subse(target_list,k);
    } else if (compare(length(target_list),length(source_list))>0) {
        def_value = $subse(target_list,-1);
    }
    return def_value;
}
//DEV doc/auto/move to a better location...
//**
// Converts a string containing Key/Value pairs into a set of
// sequences, one per K/V pair.
//
// Parameters:
// # ##source## : a text sequence, containing the representation of the key/values.
// # ##pair_delim## : an object containing a list of elements that delimit one
//                   key/value pair from the next. The defaults are semi-colon (;)
//                   and comma (,).
// # ##kv_delim## : an object containing a list of elements that delimit the
//                key from its value. The defaults are colon (:) and equal (=).
// # ##quotes## : an object containing a list of elements that can be used to
//                enclose either keys or values that contain delimiters or
//                whitespace. The defaults are double-quote ("), single-quote (')
//                and back-quote (`)
// # ##whitespace## : an object containing a list of elements that are regarded
//                as whitespace characters. The defaults are space, tab, new-line,
//                and carriage-return.
// # ##haskeys## : an integer containing true or false. The default is true. When
// ##true##, the ##kv_delim## values are used to separate keys from values, but
// when ##false## it is assumed that each 'pair' is actually just a value.
//
// Returns:
//              A **sequence**, of pairs. Each pair is in the form {key, value}.
//
// Comments:
//
// String representations of atoms are not converted, either in the key or value part, but returned as any regular string instead.
//
// If ##haskeys## is ##true##, but a substring only holds what appears to be a value, the key
// is synthesized as ##p[n]##, where ##n## is the number of the pair. See example #2.
//
// By default, pairs can be delimited by either a comma or semi-colon ",;" and
// a key is delimited from its value by either an equal or a colon "=:".
// Whitespace between pairs, and between delimiters is ignored.
//
// If you need to have one of the delimiters in the value data, enclose it in
// quotation marks. You can use any of single, double and back quotes, which
// also means you can quote quotation marks themselves. See example #3.
//
// It is possible that the value data itself is a nested set of pairs. To do
// this enclose the value in parentheses. Nested sets can nested to any level.
// See example #4.
//
// If a sub-list has only data values and not keys, enclose it in either braces
// or square brackets. See example #5.
// If you need to have a bracket as the first character in a data value, prefix
// it with a tilde. Actually a leading tilde will always just be stripped off
// regardless of what it prefixes. See example #6.
//
// Example 1:
// <eucode>
// s = $keyvalues("foo=bar, qwe=1234, asdf='contains space, comma, and equal(=)'")
// -- s is { {"foo", "bar"}, {"qwe", "1234"}, {"asdf", "contains space, comma, and equal(=)"}}
// </eucode>
//
// Example 2:
// <eucode>
// s = $keyvalues("abc fgh=ijk def")
// -- s is { {"p[1]", "abc"}, {"fgh", "ijk"}, {"p[3]", "def"} }
// </eucode>
//
// Example 3:
// <eucode>
// s = $keyvalues("abc=`'quoted'`")
// -- s is { {"abc", "'quoted'"} }
// </eucode>
//
// Example 4:
// <eucode>
// s = $keyvalues("colors=(a=black, b=blue, c=red)")
// -- s is { {"colors", {{"a", "black"}, {"b", "blue"},{"c", "red"}}  } }
// s = $keyvalues("colors=(black=[0,0,0], blue=[0,0,FF], red=[FF,0,0])")
// -- s is { {"colors", {{"black",{"0", "0", "0"}}, {"blue",{"0", "0", "FF"}},{"red", {"FF","0","0"}}}} }
// </eucode>
//
// Example 5:
// <eucode>
// s = $keyvalues("colors=[black, blue, red]")
// -- s is { {"colors", { "black", "blue", "red"}  } }
// </eucode>
//
// Example 6:
// <eucode>
// s = $keyvalues("colors=~[black, blue, red]")
// -- s is { {"colors", "[black, blue, red]"}  } }
// -- The following is another way to do the same.
// s = $keyvalues("colors=`[black, blue, red]`")
// -- s is { {"colors", "[black, blue, red]"}  } }
// </eucode>

/*global*/ function $keyvalues(/*sequence*/ source, /*object*/ pair_delim=";,", kv_delim=":=", quotes="\"'`", whitespace=" \t\n\r", /*integer*/ haskeys=1) {
//sequence lEndBracket -- PL unused??
//sequence lBracketed -- PL (now defined locally)
    source = trim(source);
    if (equal(length(source),0)) { return ["sequence"]; }
    if (atom(pair_delim)) { pair_delim = ["sequence",pair_delim]; }
    if (atom(kv_delim)) { kv_delim = ["sequence",kv_delim]; }
    if (atom(quotes)) { quotes = ["sequence",quotes]; }
    if (atom(whitespace)) { whitespace = ["sequence",whitespace]; }
    let /*sequence*/ all_delim = $conCat($conCat(whitespace, pair_delim), kv_delim), 
                     white_pair = $conCat(whitespace, pair_delim);
//  lEndBracket   = "}])"
    let /*sequence*/ res = ["sequence"];
    let /*integer*/ sdx = 1;
    while (compare(sdx,length(source))<=0) {
        // ignore leading whitespace
        while (compare(sdx,length(source))<=0 && find($subse(source,sdx),whitespace)) {
            sdx += 1;
        }
        // Get key. Ends at any of unquoted whitespace or unquoted delimiter
        let /*string*/ key = "";
        let /*integer*/ ch = 0, quote_ch = 0, bpos, was_kv = false;
        if (haskeys) {
            while (compare(sdx,length(source))<=0) {
                ch = $subse(source,sdx);
                if (!equal(find(ch,quotes),0)) {
                    if (ch===quote_ch) {
                        // End of quoted span
                        quote_ch = 0;
                        ch = -1;
                    } else if (quote_ch===0) {
                        // Start of quoted span
                        quote_ch = ch;
                        ch = -1;
                    }
                } else if ((quote_ch===0) && (!equal(find(ch,all_delim),0))) {
                    break;
                }
                if (ch>0) {
                    key = $conCat(key, ch, false);
                }
                sdx += 1;
            }
            // ignore next whitespace
            if (!equal(find(ch,whitespace),0)) {
                sdx += 1;
                while (compare(sdx,length(source))<=0) {
                    ch = $subse(source,sdx);
                    if (equal(find(ch,whitespace),0)) {
                        break;
                    }
                    sdx += 1;
                }
            }
        } else {
            sdx -= 1;       // Put back the last char.
        }
        let /*sequence*/ val = "";
        if ((!equal(find(ch,kv_delim),0)) || !haskeys) {
            if (!equal(find(ch,kv_delim),0)) {
                was_kv = true;
            }
            // ignore next whitespace
            sdx += 1;
            while (compare(sdx,length(source))<=0) {
                ch = $subse(source,sdx);
                if (equal(find(ch,whitespace),0)) {
                    break;
                }
                sdx += 1;
            }
            // Get value. Ends at any of unquoted whitespace or unquoted delimiter
            quote_ch = 0;
            ch = 0;
            let /*sequence*/ lBracketed = ["sequence"];
            while (compare(sdx,length(source))<=0) {
                ch = $subse(source,sdx);
                bpos = find(ch,"{[(");
                if ((equal(length(lBracketed),0)) && (!equal(find(ch,quotes),0))) {
                    if (ch===quote_ch) {
                        // End of quoted span
                        quote_ch = 0;
                        ch = -1;
                    } else if (quote_ch===0) {
                        // Start of quoted span
                        quote_ch = ch;
                        ch = -1;
                    }
                } else if (bpos) {
                    lBracketed = $conCat(lBracketed, $subse("}])",bpos), false);
                } else if ((!equal(length(lBracketed),0)) && (equal(ch,$subse(lBracketed,-1)))) {
                    lBracketed = $subss(lBracketed,1,-1-1);
                } else if (((equal(length(lBracketed),0)) && (quote_ch===0)) && (!equal(find(ch,white_pair),0))) {
                    break;
                }
                if (ch>0) {
                    val = $conCat(val, ch, false);
                }
                sdx += 1;
            }
            if (!equal(find(ch,whitespace),0)) {
                // ignore next whitespace
                sdx += 1;
                while (compare(sdx,length(source))<=0) {
                    ch = $subse(source,sdx);
                    if (equal(find(ch,whitespace),0)) {
                        break;
                    }
                    sdx += 1;
                }
            }
            if (!equal(find(ch,pair_delim),0)) {
                sdx += 1;
                if (compare(sdx,length(source))<=0) {
                    ch = $subse(source,sdx);
                }
            }
        }
        if (!equal(find(ch,pair_delim),0)) {
            sdx += 1;
        }
        if ((equal(length(val),0)) && (equal(length(key),0))) {
            res = append(res,["sequence"]);
        } else {
            if ((equal(length(val),0)) && !was_kv) {
                val = key;
                key = "";
            }
            if ((equal(length(key),0)) && haskeys) {
                key = sprintf("p[%d]",length(res)+1);
            }
            if (compare(length(val),0)>0) {
                ch = $subse(val,1);
                bpos = find(ch,"{[(");
                if (bpos>0 && (equal($subse(val,-1),$subse("}])",bpos)))) {
                    if (ch===0X28) {
                        val = $keyvalues($subss(val,2,-1-1),pair_delim,kv_delim,quotes,whitespace,haskeys);
                    } else {
                        val = $keyvalues($subss(val,2,-1-1),pair_delim,kv_delim,quotes,whitespace,0);
                    }
                } else if (ch===0X7E) {
                    val = $subss(val,2,-1);
                }
            }
            key = trim(key);
            val = trim(val);
            if (equal(length(key),0)) {
                res = append(res,val);
            } else {
                res = append(res,["sequence",key,val]);
            }
        }
    }
    return res;
}
//**
// Formats a set of arguments in to a string based on a supplied pattern.
//
// Parameters:
//   # ##format_pattern## : A sequence: the pattern string that contains zero or more tokens.
//   # ##arg_list## : An object: Zero or more arguments used in token replacement.
//
// Returns:
// A string **sequence**, the original ##format_pattern## but with tokens replaced by
// corresponding arguments.
//
// Comments:
// The ##format_pattern## string contains text and argument tokens. The resulting string
// is the same as the format string except that each token is replaced by an
// item from the argument list.
//
// A token has the form **##[<Q>]##**, where <Q> is are optional qualifier codes.
//
// The qualifier. ##<Q>## is a set of zero or more codes that modify the default
// way that the argument is used to replace the token. The default replacement
// method is to convert the argument to its shortest string representation and
// use that to replace the token. This may be modified by the following codes,
// which can occur in any order.
// |= Qualifier |= Usage                                              |
// |  N         | ('N' is an integer) The index of the argument to use|
// | {id}       | Uses the argument that begins with "id=" where "id" \\
//                is an identifier name.                              |
// | %envvar%   | Uses the Environment Symbol 'envar' as an argument  |
// |  w         | For string arguments, if capitalizes the first\\
//                letter in each word                                 |
// |  u         | For string arguments, it converts it to upper case. |
// |  l         | For string arguments, it converts it to lower case. |
// |  <         | For numeric arguments, it left justifies it.        |
// |  >         | For string arguments, it right justifies it.        |
// |  c         | Centers the argument.                               |
// |  z         | For numbers, it zero fills the left side.           |
// |  :S        | ('S' is an integer) The maximum size of the\\
//                resulting field. Also, if 'S' begins with '0' the\\
//                field will be zero-filled if the argument is an integer|
// |  .N        | ('N' is an integer) The number of digits after\\
//                 the  decimal point                                 |
// |  +         | For positive numbers, show a leading plus sign      |
// |  (         | For negative numbers, enclose them in parentheses   |
// |  b         | For numbers, causes zero to be all blanks           |
// |  s         | If the resulting field would otherwise be zero\\
//                length, this ensures that at least one space occurs\\
//                between this token's field                          |
// |  t         | After token replacement, the resulting string up to this point is trimmed. |
// |  X         | Outputs integer arguments using hexadecimal digits. |
// |  B         | Outputs integer arguments using binary digits.      |
// |  ?         | The corresponding argument is a set of two strings. This\\
//                uses the first string if the previous token's argument is\\
//                not the value 1 or a zero-length string, otherwise it\\
//                uses the second string.                             |
// |  [         | Does not use any argument. Outputs a left-square-bracket symbol |
// |  ,X        | Insert thousands separators. The <X> is the character\\
//                to use. If this is a dot "." then the decimal point\\
//                is rendered using a comma. Does not apply to zero-filled\\
//                fields.                         \\
//                N.B. if hex or binary output was specified, the \\
//                separators are every 4 digits otherwise they are \\
//                every three digits. |
//
// Clearly, certain combinations of these qualifier codes do not make sense and in
// those situations, the rightmost clashing code is used and the others are ignored.
//
// Any tokens in the format that have no corresponding argument are simply removed
// from the result. Any arguments that are not used in the result are ignored.
//
// Any sequence argument that is not a string will be converted to its
// //pretty// format before being used in token replacement.
//
// If a token is going to be replaced by a zero-length argument, all white space
// following the token until the next non-whitespace character is not copied to
// the result string.
//
// Examples:
// <eucode>
// format("Cannot open file '[]' - code []", {"/usr/temp/work.dat", 32})
// -- "Cannot open file '/usr/temp/work.dat' - code 32"
//
// format("Err-[2], Cannot open file '[1]'", {"/usr/temp/work.dat", 32})
// -- "Err-32, Cannot open file '/usr/temp/work.dat'"
//
// format("[4w] [3z:2] [6] [5l] [2z:2], [1:4]", {2009,4,21,"DAY","MONTH","of"})
// -- "Day 21 of month 04, 2009"
//
// format("The answer is [:6.2]%", {35.22341})
// -- "The answer is  35.22%"
//
// format("The answer is [.6]", {1.2345})
// -- "The answer is 1.234500"
//
// format("The answer is [,,.2]", {1234.56})
// -- "The answer is 1,234.56"
//
// format("The answer is [,..2]", {1234.56})
// -- "The answer is 1.234,56"
//
// format("The answer is [,:.2]", {1234.56})
// -- "The answer is 1:234.56"
//
// format("[] [?]", {5, {"cats", "cat"}})
// -- "5 cats"
//
// format("[] [?]", {1, {"cats", "cat"}})
// -- "1 cat"
//
// format("[<:4]", {"abcdef"})
// -- "abcd"
//
// format("[>:4]", {"abcdef"})
// -- "cdef"
//
// format("[>:8]", {"abcdef"})
// -- "  abcdef"
//
// format("seq is []", {{1.2, 5, "abcdef", {3}}})
// -- `seq is {1.2,5,"abcdef",{3}}`
//
// format("Today is [{day}], the [{date}]", {"date=10/Oct/2012", "day=Wednesday"})
// -- "Today is Wednesday, the 10/Oct/2012"
// </eucode>
//
// See Also:
//   [[:sprintf]]
//

/*global*/ function $text_format(/*sequence*/ format_pattern, /*object*/ arg_list=["sequence"]) {
    let /*sequence*/ result;
    let /*integer*/ in_token;
    let /*integer*/ tch;
    let /*integer*/ i;
    let /*integer*/ tstart;
    let /*integer*/ tend;
    let /*integer*/ cap;
    let /*integer*/ align;
    let /*integer*/ psign;
    let /*integer*/ msign;
    let /*integer*/ zfill;
    let /*integer*/ bwz;
    let /*integer*/ spacer;
    let /*integer*/ alt;
    let /*integer*/ width;
    let /*integer*/ decs;
    let /*integer*/ pos;
    let /*integer*/ argn;
    let /*integer*/ argl;
    let /*integer*/ trimming;
    let /*integer*/ hexout;
    let /*integer*/ binout;
    let /*integer*/ tsep;
    let /*object*/ prevargv;
    let /*object*/ currargv;
    let /*sequence*/ idname;
    let /*object*/ envsym;
    let /*object*/ envvar;
    let /*integer*/ sp;
    let /*sequence*/ argtext;
    let /*object*/ tempv;
    let /*integer*/ dpos;
    let /*integer*/ dist;
    let /*integer*/ bracketed;
    if (atom(arg_list)) {
        arg_list = ["sequence",arg_list];
    }
    result = "";
    in_token = 0;
    i = 0;
    tstart = 0;
    tend = 0;
    argl = 0;
    spacer = 0;
    prevargv = 0;
    while (compare(i,length(format_pattern))<0) {
        i += 1;
        tch = $subse(format_pattern,i);
        if (!in_token) {
            if (tch===0X5B) {
                in_token = 1;
                tstart = i;
                tend = 0;
                cap = 0;
                align = 0;
                psign = 0;
                msign = 0;
                zfill = 0;
                bwz = 0;
                spacer = 0;
                alt = 0;
                width = 0;
                decs = -1;
                argn = 0;
                hexout = 0;
                binout = 0;
                trimming = 0;
                tsep = 0;
                idname = "";
                envvar = "";
                envsym = "";
            } else {
                result = $conCat(result, tch, false);
            }
        } else {
            if (tch===0X5D) {
                in_token = 0;
                tend = i;
            } else if (tch===0X5B) {
                result = $conCat(result, tch, false);
                while (compare(i,length(format_pattern))<0) {
                    i += 1;
                    if (equal($subse(format_pattern,i),0X5D)) {
                        in_token = 0;
                        tstart = 0;
                        tend = 0;
                        break;
                    }
                }
            } else if (((tch===0X77) || (tch===0X75)) || (tch===0X6C)) {
                cap = tch;
            } else if (tch===0X62) {
                bwz = 1;
            } else if (tch===0X73) {
                spacer = 1;
            } else if (tch===0X74) {
                trimming = 1;
            } else if (tch===0X7A) {
                zfill = 1;
            } else if (tch===0X58) {
                hexout = 1;
            } else if (tch===0X42) {
                binout = 1;
            } else if (((tch===0X63) || (tch===0X3C)) || (tch===0X3E)) {
                align = tch;
            } else if (tch===0X2B) {
                psign = 1;
            } else if (tch===0X28) {
                msign = 1;
            } else if (tch===0X3F) {
                alt = 1;
            } else if (tch===0X3A) {
                while (compare(i,length(format_pattern))<0) {
                    i += 1;
                    tch = $subse(format_pattern,i);
                    pos = find(tch,"0123456789");
                    if (pos===0) {
                        i -= 1;
                        break;
                    }
                    width = (width*10+pos)-1;
                    if (width===0) {
                        zfill = 0X30;
                    }
                }
            } else if (tch===0X2E) {
                decs = 0;
                while (compare(i,length(format_pattern))<0) {
                    i += 1;
                    tch = $subse(format_pattern,i);
                    pos = find(tch,"0123456789");
                    if (pos===0) {
                        i -= 1;
                        break;
                    }
                    decs = (decs*10+pos)-1;
                }
            } else if (tch===0X7B) {
                // Use a named argument.
                sp = i+1;
                i = sp;
                while (compare(i,length(format_pattern))<0) {
                    if (equal($subse(format_pattern,i),0X7D)) {
                        break;
                    }
                    if (equal($subse(format_pattern,i),0X5D)) {
                        break;
                    }
                    i += 1;
                }
                idname = $conCat(trim($subss(format_pattern,sp,i-1)), 0X3D);
                if (equal($subse(format_pattern,i),0X5D)) {
                    i -= 1;
                }
                for (let j=1, j$lim=length(arg_list); j<=j$lim; j+=1) {
//                  if begins(idname, arg_list[j]) then
                    if (equal(match(idname,$subse(arg_list,j)),1)) {
                        if (argn===0) {
                            argn = j;
                            break;
                        }
                    }
                    if (equal(j,length(arg_list))) {
                        idname = "";
                        argn = -1;
                    }
                }
            } else if (tch===0X25) {
                // Use the environment symbol
                sp = i+1;
                i = sp;
                while (compare(i,length(format_pattern))<0) {
                    if (equal($subse(format_pattern,i),0X25)) {
                        break;
                    }
                    if (equal($subse(format_pattern,i),0X5D)) {
                        break;
                    }
                    i += 1;
                }
                envsym = trim($subss(format_pattern,sp,i-1));
                if (equal($subse(format_pattern,i),0X5D)) {
                    i -= 1;
                }
                envvar = getenv(envsym);
                argn = -1;
                if (atom(envvar)) {
                    envvar = "";
                }
            } else if (tch>=0X30 && tch<=0X39) {
                if (argn===0) {
                    i -= 1;
                    while (compare(i,length(format_pattern))<0) {
                        i += 1;
                        tch = $subse(format_pattern,i);
                        pos = find(tch,"0123456789");
                        if (pos===0) {
                            i -= 1;
                            break;
                        }
                        argn = (argn*10+pos)-1;
                    }
                }
            } else if (tch===0X2C) {
                if (compare(i,length(format_pattern))<0) {
                    i += 1;
                    tsep = $subse(format_pattern,i);
                }
//          else
                // ignore it
            }
            if (tend>0) {
                // Time to replace the token.
                argtext = "";
                if (argn===0) {
                    argn = argl+1;
                }
                argl = argn;
                if (argn<1 || compare(argn,length(arg_list))>0) {
                    if (compare(length(envvar),0)>0) {
                        argtext = envvar;
                        currargv = envvar;
                    } else {
                        argtext = "";
                        currargv = "";
                    }
                } else {
                    if (string($subse(arg_list,argn))) {
                        if (compare(length(idname),0)>0) {
                            argtext = $subss($subse(arg_list,argn),length(idname)+1,-1);
                        } else {
                            argtext = $subse(arg_list,argn);
                        }
                    } else if (integer($subse(arg_list,argn))) {
                        if ((bwz!==0) && (equal($subse(arg_list,argn),0))) {
                            argtext = "";
                        } else if (binout===1) {
/**/
                            argtext = sprintf("%b",$subse(arg_list,argn)); /*
--/!**!/                    argtext = sq_add(reverse(int_to_bits(arg_list[argn], 32)),'0')              --/!*
                            argtext = stdseq:reverse( convert:int_to_bits(arg_list[argn], 32)) + '0'    */ 
                            for (let ib=1, ib$lim=length(argtext); ib<=ib$lim; ib+=1) {
                                if (equal($subse(argtext,ib),0X31)) {
                                    argtext = $subss(argtext,ib,-1);
                                    break;
                                }
                            }
                        } else if (hexout===0) {
                            argtext = sprintf("%d",$subse(arg_list,argn));
                            if ((zfill!==0) && width>0) {
                                if (compare(length(argtext),0)>0) {
                                    if (equal($subse(argtext,1),0X2D)) {
                                        if (compare(width,length(argtext))>0) {
                                            argtext = $conCat($conCat(0X2D, repeat(0X30,width-length(argtext))), $subss(argtext,2,-1));
                                        }
                                    } else {
                                        if (compare(width,length(argtext))>0) {
                                            argtext = $conCat(repeat(0X30,width-length(argtext)), argtext);
                                        }
                                    }
                                } else {
                                    argtext = $conCat(repeat(0X30,width-length(argtext)), argtext);
                                }
                            }
                            if (compare($subse(arg_list,argn),0)>0) {
                                if (psign) {
                                    if (zfill===0) {
                                        argtext = $conCat(0X2B, argtext);
                                    } else if (equal($subse(argtext,1),0X30)) {
                                        argtext = $repe(argtext,1,0X2B);
                                    }
                                }
                            } else if (compare($subse(arg_list,argn),0)<0) {
                                if (msign) {
                                    if (zfill===0) {
                                        argtext = $conCat($conCat(0X28, $subss(argtext,2,-1)), 0X29);
                                    } else {
                                        if (equal($subse(argtext,2),0X30)) {
                                            argtext = $conCat($conCat(0X28, $subss(argtext,3,-1)), 0X29);
                                        } else {
                                            argtext = $conCat($subss(argtext,2,-1), 0X29);
                                        }
                                    }
                                }
                            }
                        } else {
                            argtext = sprintf("%x",$subse(arg_list,argn));
                            if ((zfill!==0) && width>0) {
                                if (compare(width,length(argtext))>0) {
                                    argtext = $conCat(repeat(0X30,width-length(argtext)), argtext);
                                }
                            }
                        }
                    } else if (atom($subse(arg_list,argn))) {
                        if ((bwz!==0) && (equal($subse(arg_list,argn),0))) {
                            argtext = "";
                        } else {
                            if (hexout) {
                                argtext = sprintf("%x",$subse(arg_list,argn));
                                if ((zfill!==0) && width>0) {
                                    if (compare(width,length(argtext))>0) {
                                        argtext = $conCat(repeat(0X30,width-length(argtext)), argtext);
                                    }
                                }
                            } else {
                                argtext = trim(sprintf("%15.15g",$subse(arg_list,argn)));
                                if ((zfill!==0) && width>0) {
                                    if (compare(length(argtext),0)>0) {
                                        if (compare(width,length(argtext))>0) {
                                            if (equal($subse(argtext,1),0X2D)) {
                                                argtext = $conCat($conCat(0X2D, repeat(0X30,width-length(argtext))), $subss(argtext,2,-1));
                                            } else {
                                                argtext = $conCat(repeat(0X30,width-length(argtext)), argtext);
                                            }
                                        }
                                    } else {
                                        argtext = $conCat(repeat(0X30,width-length(argtext)), argtext);
                                    }
                                }
                                if (compare($subse(arg_list,argn),0)>0) {
                                    if (psign) {
                                        if (zfill===0) {
                                            argtext = $conCat(0X2B, argtext);
                                        } else if (equal($subse(argtext,1),0X30)) {
                                            argtext = $repe(argtext,1,0X2B);
                                        }
                                    }
                                } else if (compare($subse(arg_list,argn),0)<0) {
                                    if (msign) {
                                        if (zfill===0) {
                                            argtext = $conCat($conCat(0X28, $subss(argtext,2,-1)), 0X29);
                                        } else {
                                            if (equal($subse(argtext,2),0X30)) {
                                                argtext = $conCat($conCat(0X28, $subss(argtext,3,-1)), 0X29);
                                            } else {
                                                argtext = $conCat($subss(argtext,2,-1), 0X29);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if ((alt!==0) && (equal(length($subse(arg_list,argn)),2))) {
                            if (atom(prevargv)) {
                                if (!equal(prevargv,1)) {
                                    tempv = $subse($subse(arg_list,argn),1);
                                } else {
                                    tempv = $subse($subse(arg_list,argn),2);
                                }
                            } else {
                                if (equal(length(prevargv),0)) {
                                    tempv = $subse($subse(arg_list,argn),1);
                                } else {
                                    tempv = $subse($subse(arg_list,argn),2);
                                }
                            }
                            if (string(tempv)) {
                                argtext = tempv;
                            } else if (integer(tempv)) {
                                if ((bwz!==0) && (equal(tempv,0))) {
                                    argtext = "";
                                } else {
                                    argtext = sprintf("%d",tempv);
                                }
                            } else if (atom(tempv)) {
                                if ((bwz!==0) && (equal(tempv,0))) {
                                    argtext = "";
                                } else {
                                    argtext = trim(sprintf("%15.15g",tempv));
                                }
                            } else {
/**/
                                argtext = ppf(tempv); /*
                                argtext = pretty_sprint(tempv,
                                                        {2,0,1,1000,"%d","%.15g",32,127,1,0}
                                                       )                                        */ 
                            }
                        } else {
/**/
                            argtext = ppf($subse(arg_list,argn)); /*
                            argtext = pretty_sprint(arg_list[argn],
                                                    {2,0,1,1000,"%d","%.15g",32,127,1,0}
                                                   )                                            */ 
                        }
                    }
                    currargv = $subse(arg_list,argn);
                }
                if (compare(length(argtext),0)>0) {
                    if (cap===0X75) {
                        argtext = upper(argtext);
                    } else if (cap===0X6C) {
                        argtext = lower(argtext);
                    } else if (cap===0X77) {
                        argtext = proper(argtext);
                    } else if (cap===0) {
                        // do nothing
                        cap = cap;
                    } else {
                        crash("logic error: 'cap' mode in format.");
                    }
                    if (atom(currargv)) {
                        if (equal(find(0X65,argtext),0)) {
                            // Only applies to non-scientific notation.
                            if (decs!==-1) {
                                pos = find(0X2E,argtext);
                                if (pos) {
                                    if (decs===0) {
                                        argtext = $subss(argtext,1,pos-1);
                                    } else {
                                        pos = length(argtext)-pos;
                                        if (pos>decs) {
                                            argtext = $subss(argtext,1,(-1-pos)+decs);
                                        } else if (pos<decs) {
                                            argtext = $conCat(argtext, repeat(0X30,decs-pos), false);
                                        }
                                    }
                                } else if (decs>0) {
                                    argtext = $conCat($conCat(argtext, 0X2E), repeat(0X30,decs));
                                }
                            }
                        }
                    }
                    if (align===0) {
                        if (atom(currargv)) {
                            align = 0X3E;
                        } else {
                            align = 0X3C;
                        }
                    }
                    if (atom(currargv)) {
                        if ((tsep!==0) && (zfill===0)) {
                            if (binout || hexout) {
                                dist = 4;
                            } else {
                                dist = 3;
                            }
                            bracketed = equal($subse(argtext,1),0X28);
                            if (bracketed) {
                                argtext = $subss(argtext,2,-1-1);
                            }
                            dpos = find(0X2E,argtext);
                            if (dpos===0) {
                                dpos = length(argtext)+1;
                            } else {
                                if (tsep===0X2E) {
                                    argtext = $repe(argtext,dpos,0X2C);
                                }
                            }
                            while (dpos>dist) {
                                dpos -= dist;
                                if (dpos>1) {
                                    argtext = $conCat($conCat($subss(argtext,1,dpos-1), tsep), $subss(argtext,dpos,-1));
                                }
                            }
                            if (bracketed) {
                                argtext = $conCat($conCat(0X28, argtext), 0X29);
                            }
                        }
                    }
                    if (width<=0) {
                        width = length(argtext);
                    }
                    if (compare(width,length(argtext))<0) {
                        if (align===0X3E) {
                            argtext = $subss(argtext,(-1-width)+1,-1);
                        } else if (align===0X63) {
                            pos = length(argtext)-width;
                            if (equal(remainder(pos,2),0)) {
                                pos = pos/2;
                                argtext = $subss(argtext,pos+1,-1-pos);
                            } else {
                                pos = floor(pos/2);
                                argtext = $subss(argtext,pos+1,(-1-pos)-1);
                            }
                        } else {
                            argtext = $subss(argtext,1,width);
                        }
                    } else if (compare(width,length(argtext))>0) {
                        if (align===0X3E) {
                            argtext = $conCat(repeat(0X20,width-length(argtext)), argtext);
                        } else if (align===0X63) {
                            pos = width-length(argtext);
                            if (equal(remainder(pos,2),0)) {
                                pos = pos/2;
                                argtext = $conCat($conCat(repeat(0X20,pos), argtext), repeat(0X20,pos));
                            } else {
                                pos = floor(pos/2);
                                argtext = $conCat($conCat(repeat(0X20,pos), argtext), repeat(0X20,pos+1));
                            }
                        } else {
                            argtext = $conCat(argtext, repeat(0X20,width-length(argtext)), false);
                        }
                    }
                    result = $conCat(result, argtext, false);
                } else {
                    if (spacer) {
                        result = $conCat(result, 0X20, false);
                    }
                }
                if (trimming) {
                    result = trim(result);
                }
                tend = 0;
                prevargv = currargv;
            }
        }
    }
    return result;
}
//**
// Test whether a sequence is the head of another one.
// 
// Parameters:
//      # ##sub_text## : an object to be looked for
//  # ##full_text## : a sequence, the head of which is being inspected.
//
// Returns:
//              An **integer**, 1 if ##sub_text## begins ##full_text##, else 0.
//
// Example 1:
// <eucode>
// s = begins("abc", "abcdef")
// -- s is 1
// s = begins("bcd", "abcdef")
// -- s is 0
// </eucode>
//
// See Also:
//     [[:ends]], [[:head]]

/*global*/ function begins(/*object*/ sub_text, /*sequence*/ full_text) {
    let /*integer*/ lf = length(full_text);
    if (lf===0) { return false; }
    if (atom(sub_text)) {
        return equal(sub_text,$subse(full_text,1));
    }
    let /*integer*/ ls = length(sub_text);
    return ls<=lf && (equal(sub_text,$subss(full_text,1,ls)));
}
