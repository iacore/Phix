// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// builtins/shift_bits.e
// =====================
//
//  Copied from std/math.e, for compatibility with OpenEuphoria.
//

//**
// See Also:
//   [[:rotate_bits]]

/*global*/ function shift_bits(/*object*/ n, /*integer*/ shift_distance) {
    if (sequence(n)) {
        for (let i=1, i$lim=length(n); i<=i$lim; i+=1) {
            n = $repe(n,i,shift_bits($subse(n,i),shift_distance));
        }
        return n;
    }
    if (shift_distance!==0) {
        if (shift_distance<0) {
            n *= power(2,-shift_distance);
        } else {
            let /*integer*/ lSigned = 0;
            // Check for the sign bit so we don't propagate it.
            if (and_bits(n,0x80000000)) {
                lSigned = 1;
                n = and_bits(n,0x7FFFFFFF);
            }
//PL (nb this change is not apparently rqd to OE...)
//          n /= power(2, shift_distance)
            n = floor(n/power(2,shift_distance));
            if (lSigned && shift_distance<32) {
                // Put back the sign bit now shifted
                n = or_bits(n,power(2,31-shift_distance));
            }
        }
    }
    n = and_bits(n,0xFFFFFFFF);
    return n;
}

/*global*/ function count_bits(/*object*/ n, /*integer*/ nFrames=2) {
    if (sequence(n)) {
        for (let i=1, i$lim=length(n); i<=i$lim; i+=1) {
            n = $repe(n,i,count_bits($subse(n,i),nFrames+1));
        }
        return n;
    }
    let /*integer*/ res = 0;
    if (compare(n,0)<0 || (!integer(n) && (equal($subse(atom_to_float64(n),-1),127)))) { // [+/-]nan/inf
        return -1;
    }
//  if n>0 and n<1 then
//  if n>0 and n!=floor(n) then
    if (!equal(n,floor(n))) {
        if (compare(n,1)>0) {
            res = count_bits(floor(n),nFrames+1);
            n -= floor(n);
        }
        while (!equal(n,0)) {
            while (compare(n,1)<0) {
                n *= 2;
            }
            n -= 1;
            res += 1;
        }
    } else {
//      if n<0 or n!=round(n) then
//          string g = sprintf("%g",n)
//          if not find('.',g) then g &= sprintf("%+g",n-round(n)) end if
//          crash("count_bits(%s): argument must be a non-negative integer",{g},nFrames:=nFrames)
//      end if
//javascript compatibility... (now fixed, but it's a better test anyway)
//      while not integer(n) and n!=0 do
        while (compare(n,((equal(machine_bits(),32)) ? 0x3FFFFFFF : 0x4000000000000000))>0) {
//          res += and_bits(n,1)
            res += odd(n);
            n = floor(n/2);
        }
        while (n) {
// naieve, slower:
//          res += odd(n)
//          n = floor(n/2)
// Kernigans bit counter:
// eg n = 0b10101 && n-1=0b10100 => 0b10100
//    n = 0b10100 && n-1=0b10011 => 0b10000
//    n = 0b10000 && n-1=0b01111 => 0b00000
//          n = and_bits(n,n-1)
            n = and_bits(n, n-1);
            res += 1;
        }
    }
    return res;
}
