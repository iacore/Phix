"use strict";
// auto-generated by pwa/p2js.
//
// substitute.e
//
//  Phix implementation of substitute (auto-include)
//
//global function substitute(string text, string s, string r, integer limit=-1)
/*global*/ function substitute(/*sequence*/ text, s, r, /*integer*/ limit=-1) {
// replace all instances of s in text with r
    let /*integer*/ k = 1, 
                    l = length(s), 
                    startidx = 1;
    let /*sequence*/ chunks = ["sequence"];
    while ((limit===-1) || compare(length(chunks),limit)<0) {
        k = match(s,text,k);
        if (k===0) { break; }
        chunks = append(chunks,$subss(text,startidx,k-1));
        k += l;
        startidx = k;
    }
    if (length(chunks)) {
        chunks = append(chunks,$subss(text,startidx,-1));
        text = $subse(chunks,1);
        for (let i=2, i$lim=length(chunks); i<=i$lim; i+=1) {
            text = $conCat(text, r);
            text = $conCat(text, $subse(chunks,i));
        }
    }
    return text;
}
//global function substitute_all(string text, sequence strings, sequence replacements)
/*global*/ function substitute_all(/*sequence*/ text, strings, replacements) {
    for (let i=1, i$lim=length(strings); i<=i$lim; i+=1) {
        if (string(strings)) {
            if (string(replacements)) {
                // in this case a naive in situ approach is faster:
                let /*integer*/ ch = $subse(strings,i), repch = $subse(replacements,i);
                for (let j=1, j$lim=length(text); j<=j$lim; j+=1) {
                    if ($subse(text,j)===ch) {
                        text = $repe(text,j,repch); }
                }
            } else {
                text = substitute(text,$subss(strings,i,i),$subse(replacements,i));
            }
        } else {
            text = substitute(text,$subse(strings,i),$subse(replacements,i));
        }
    }
    return text;
}

