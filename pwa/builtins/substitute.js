// auto-generated by pwa/p2js, see http://phix.x10.mx
"use strict";
//
// substitute.e
//
//  Phix implementation of substitute[_all] (auto-include)
//
/*global*/ function substitute(/*sequence*/ text, /*object*/ s, r, /*integer*/ limit=-1) {
// replace all instances of s in text with r
    let /*integer*/ k = 1, 
                    l = ((atom(s)) ? 1 : length(s)), 
                    startidx = 1;
    let /*sequence*/ chunks = ["sequence"];
    while ((limit===-1) || compare(length(chunks),limit)<0) {
        k = match(s,text,k);
        if (k===0) { break; }
        chunks = append(chunks,$subss(text,startidx,k-1));
        k += l;
        startidx = k;
    }
    if (length(chunks)) {
        chunks = append(chunks,$subss(text,startidx,-1));
        text = $subse(chunks,1);
        chunks = $repe(chunks,1,0);
        for (let i=2, i$lim=length(chunks); i<=i$lim; i+=1) {
            text = $conCat(text, r);
            text = $conCat(text, $subse(chunks,i));
        }
    }
    return text;
}

/*global*/ function substitute_all(/*sequence*/ text, strings, replacements) {
    for (let i=1, i$lim=length(strings); i<=i$lim; i+=1) {
        if (string(strings)) {
            if (string(replacements)) {
                // in this case a naive in situ approach is faster:
                let /*integer*/ ch = $subse(strings,i), repch = $subse(replacements,i);
                for (let j=1, j$lim=length(text); j<=j$lim; j+=1) {
                    if (equal($subse(text,j),ch)) {
                        text = $repe(text,j,repch); }
                }
            } else {
                text = substitute(text,$subss(strings,i,i),$subse(replacements,i));
            }
        } else {
            text = substitute(text,$subse(strings,i),$subse(replacements,i));
        }
    }
    return text;
}
