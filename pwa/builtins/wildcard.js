"use strict";
// auto-generated by pwa/p2js - part of Phix, see http://phix.x10.mx
// Euphoria 2.4 (Phix compatible)
// wild card matching for strings and file names

/* Not required for Phix:
--include builtins\misc.e   -- constant LINUX
constant LINUX = 3
*/

/**/
      // not strictly necessary, but reduces opCallOnce/fwd calls/onDeclaration
//pwa/p2js: removed...
//!/**/include builtins\pcase.e -- upper/lower()

/* Not required for Phix (see pcase.e):
constant TO_LOWER = 'a' - 'A' 

global
function lower(object x)
-- convert atom or sequence to lower case
    return x + (x >= 'A' and x <= 'Z') * TO_LOWER
end function

global
function upper(object x)
-- convert atom or sequence to upper case
    return x - (x >= 'a' and x <= 'z') * TO_LOWER
end function
*/
function $qmatch(/*sequence*/ p, /*sequence*/ s) {
// find pattern p in string s
// p may have '?' wild cards (but not '*')
    let /*integer*/ k, pj;
    if (!find(0X3F,p)) {
        return match(p,s); // fast
    }
    // must allow for '?' wildcard
    for (let i=1, i$lim=(length(s)-length(p))+1; i<=i$lim; i+=1) {
        k = i;
        for (let j=1, j$lim=length(p); j<=j$lim; j+=1) {
            pj = $subse(p,j);
            if ((pj!==0X3F) && (!equal(pj,$subse(s,k)))) {
                k = 0;
                break;
            }
            k += 1;
        }
        if (k!==0) { return i; }
    }
    return 0;
}
const $END_MARKER = -1;

/*global*/ function wildcard_match(/*sequence*/ pattern, /*sequence*/ str) {
// returns TRUE if string matches pattern
// pattern can include '*' and '?' "wildcard" characters
    let /*integer*/ p, f, t;
    let /*sequence*/ match_string;
    let /*object*/ pch;
    pattern = $conCat(pattern, $END_MARKER);
    str = $conCat(str, $END_MARKER);
    p = 1;
    f = 1;
    while (compare(f,length(str))<=0) {
//      if not find(pattern[p], {str[f], '?'}) then
        pch = $subse(pattern,p);
        if (equal(pch,0X2A) || (!equal(pch,$subse(str,f)) && !equal(pch,0X3F))) {
            if (!equal(pch,0X2A)) {
                return 0;
            }
            while (1) {
                p += 1;
                pch = $subse(pattern,p);
                if (!equal(pch,0X2A)) { break; }
            }
            if (equal(pch,$END_MARKER)) {
                return 1;
            }
            match_string = "";
            while (!equal(pch,0X2A)) {
                match_string = $conCat(match_string, pch);
                if (equal(pch,$END_MARKER)) {
                    break;
                }
                p += 1;
                pch = $subse(pattern,p);
            }
            if (equal(pch,0X2A)) {
                p -= 1;
            }
            t = $qmatch(match_string,$subss(str,f,length(str)));
            if (t===0) {
                return 0;
            }
            f += (t+length(match_string))-2;
        }
        p += 1;
        f += 1;
        if (compare(p,length(pattern))>0) {
            return compare(f,length(str))>0;
        }
    }
    return 0;
}

/*global*/ function wildcard_file(/*sequence*/ pattern, /*sequence*/ filename) {
// Return 1 (TRUE) if filename matches the wild card pattern.
// Similar to DOS wild card matching but better. For example, 
// "*ABC.*" in DOS will match *all* files, where this function will 
// only match when the file name part has "ABC" at the end.
    if (!equal(platform(),LINUX)) {
        pattern = upper(pattern);
        filename = upper(filename);
    }
    if (!find(0X2E,pattern)) {
        pattern = $conCat(pattern, 0X2E);
    }
    if (!find(0X2E,filename)) {
        filename = $conCat(filename, 0X2E);
    }
    return wildcard_match(pattern,filename);
}
